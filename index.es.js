function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var STYLE_KEY$5 = {
  POSITION: 0,
  DISPLAY: 1,
  TOP: 2,
  RIGHT: 3,
  BOTTOM: 4,
  LEFT: 5,
  MARGIN_TOP: 6,
  MARGIN_RIGHT: 7,
  MARGIN_BOTTOM: 8,
  MARGIN_LEFT: 9,
  PADDING_TOP: 10,
  PADDING_RIGHT: 11,
  PADDING_BOTTOM: 12,
  PADDING_LEFT: 13,
  FONT_SIZE: 14,
  FONT_FAMILY: 15,
  COLOR: 16,
  FONT_STYLE: 17,
  FONT_WEIGHT: 18,
  LINE_HEIGHT: 19,
  BACKGROUND_IMAGE: 20,
  BACKGROUND_COLOR: 21,
  BACKGROUND_SIZE: 22,
  BACKGROUND_REPEAT: 23,
  BACKGROUND_POSITION_X: 24,
  BACKGROUND_POSITION_Y: 25,
  BORDER_TOP_WIDTH: 26,
  BORDER_RIGHT_WIDTH: 27,
  BORDER_BOTTOM_WIDTH: 28,
  BORDER_LEFT_WIDTH: 29,
  BORDER_TOP_COLOR: 30,
  BORDER_RIGHT_COLOR: 31,
  BORDER_BOTTOM_COLOR: 32,
  BORDER_LEFT_COLOR: 33,
  BORDER_TOP_STYLE: 34,
  BORDER_RIGHT_STYLE: 35,
  BORDER_BOTTOM_STYLE: 36,
  BORDER_LEFT_STYLE: 37,
  BORDER_TOP_LEFT_RADIUS: 38,
  BORDER_TOP_RIGHT_RADIUS: 39,
  BORDER_BOTTOM_RIGHT_RADIUS: 40,
  BORDER_BOTTOM_LEFT_RADIUS: 41,
  WIDTH: 42,
  HEIGHT: 43,
  FLEX_GROW: 44,
  FLEX_SHRINK: 45,
  FLEX_BASIS: 46,
  FLEX_DIRECTION: 47,
  JUSTIFY_CONTENT: 48,
  ALIGN_ITEMS: 49,
  ALIGN_SELF: 50,
  TEXT_ALIGN: 51,
  TRANSFORM_ORIGIN: 52,
  VISIBILITY: 53,
  OPACITY: 54,
  Z_INDEX: 55,
  TRANSFORM: 56,
  TRANSLATE_X: 57,
  TRANSLATE_Y: 58,
  TRANSLATE_Z: 59,
  SCALE_X: 60,
  SCALE_Y: 61,
  SCALE_Z: 62,
  SKEW_X: 63,
  SKEW_Y: 64,
  ROTATE_X: 65,
  ROTATE_Y: 66,
  ROTATE_Z: 67,
  ROTATE_3D: 68,
  PERSPECTIVE: 69,
  PERSPECTIVE_ORIGIN: 70,
  FILTER: 71,
  BOX_SHADOW: 72,
  POINTER_EVENTS: 73,
  OVERFLOW: 74,
  MIX_BLEND_MODE: 75,
  BACKGROUND_CLIP: 76,
  WHITE_SPACE: 77,
  TEXT_OVERFLOW: 78,
  LETTER_SPACING: 79,
  LINE_CLAMP: 80,
  ORDER: 81,
  FLEX_WRAP: 82,
  ALIGN_CONTENT: 83,
  TEXT_STROKE_WIDTH: 84,
  TEXT_STROKE_COLOR: 85,
  TEXT_STROKE_OVER: 86,
  // GEOM
  FILL: 87,
  STROKE: 88,
  STROKE_WIDTH: 89,
  STROKE_DASHARRAY: 90,
  STROKE_DASHARRAY_STR: 91,
  STROKE_LINECAP: 92,
  STROKE_LINEJOIN: 93,
  STROKE_MITERLIMIT: 94,
  FILL_RULE: 95,
  // 无此样式，仅cache或特殊情况需要
  MATRIX: 96,
  BORDER_TOP: 97,
  BORDER_RIGHT: 98,
  BORDER_BOTTOM: 99,
  BORDER_LEFT: 100,
  TRANSLATE_PATH: 101
};
var STYLE2LOWER_MAP = {};

function style2Lower(s) {
  STYLE2LOWER_MAP[s] = STYLE2LOWER_MAP[s] || s.toLowerCase().replace(/_([a-z])/g, function ($0, $1) {
    return $1.toUpperCase();
  });
  return STYLE2LOWER_MAP[s];
}

var STYLE2UPPER_MAP = {};

function style2Upper$2(s) {
  STYLE2UPPER_MAP[s] = STYLE2UPPER_MAP[s] || s.replace(/([a-z\d_])([A-Z])/g, function ($0, $1, $2) {
    return $1 + '_' + $2;
  }).toUpperCase();
  return STYLE2UPPER_MAP[s];
}

var STYLE_R_KEY = {};
var STYLE_RV_KEY$2 = {};
var STYLE_V_KEY = {};
Object.keys(STYLE_KEY$5).forEach(function (k) {
  var k2 = STYLE_KEY$5[k];
  STYLE_R_KEY[k2] = k;
  var l = style2Lower(k);
  STYLE_RV_KEY$2[k2] = l;
  STYLE_V_KEY[l] = k2;
}); // Root的update过程使用

var UPDATE_KEY = {
  UPDATE_NODE: 0,
  UPDATE_STYLE: 1,
  UPDATE_FOCUS: 2,
  UPDATE_MEASURE: 3,
  UPDATE_COMPONENT: 4,
  UPDATE_OVERWRITE: 5,
  UPDATE_KEYS: 6,
  UPDATE_LIST: 7,
  UPDATE_CONFIG: 8,
  UPDATE_ADD_DOM: 9,
  UPDATE_REMOVE_DOM: 10
}; // animation计算每帧使用

var KEY_FRAME_KEY = {
  FRAME_STYLE: 0,
  FRAME_TIME: 1,
  FRAME_EASING: 2,
  FRAME_TRANSITION: 3
}; // 节点使用

var NODE_KEY = {
  NODE_DOM_PARENT: 0,
  NODE_OPACITY: 1,
  NODE_MATRIX: 2,
  NODE_MATRIX_EVENT: 3,
  NODE_CACHE: 4,
  NODE_CACHE_TOTAL: 5,
  NODE_CACHE_FILTER: 6,
  NODE_CACHE_MASK: 7,
  NODE_CACHE_OVERFLOW: 8,
  NODE_STRUCT: 9,
  NODE_TAG_NAME: 10,
  NODE_CURRENT_STYLE: 11,
  NODE_CURRENT_PROPS: 12,
  NODE_COMPUTED_STYLE: 13,
  NODE_CACHE_STYLE: 14,
  NODE_CACHE_PROPS: 15,
  NODE_LIMIT_CACHE: 16,
  NODE_IS_MASK: 17,
  NODE_IS_INLINE: 18,
  NODE_HAS_CONTENT: 19,
  NODE_REFRESH_LV: 20,
  NODE_IS_DESTROYED: 21,
  NODE_STYLE: 22,
  NODE_UPDATE_HASH: 23,
  NODE_UNIQUE_UPDATE_ID: 24,
  NODE_DEFS_CACHE: 25,
  NODE_PERSPECTIVE_MATRIX: 26,
  NODE_VIRTUAL_DOM: 27
}; // struct用

var STRUCT_KEY = {
  STRUCT_NODE: 0,
  STRUCT_INDEX: 1,
  STRUCT_CHILD_INDEX: 2,
  STRUCT_LV: 3,
  STRUCT_NUM: 4,
  STRUCT_TOTAL: 5,
  STRUCT_HAS_MASK: 6
};
var enums = {
  STYLE_KEY: STYLE_KEY$5,
  // 大写常量为k，数字为值
  STYLE_R_KEY: STYLE_R_KEY,
  // 数字为k，大写常量为值
  STYLE_RV_KEY: STYLE_RV_KEY$2,
  // 数字为k，小写为值
  STYLE_V_KEY: STYLE_V_KEY,
  // 小写为k，数字为值
  style2Lower: style2Lower,
  style2Upper: style2Upper$2,
  UPDATE_KEY: UPDATE_KEY,
  KEY_FRAME_KEY: KEY_FRAME_KEY,
  NODE_KEY: NODE_KEY,
  STRUCT_KEY: STRUCT_KEY
};

var _enums$STRUCT_KEY$3 = enums.STRUCT_KEY,
    STRUCT_NODE$2 = _enums$STRUCT_KEY$3.STRUCT_NODE,
    STRUCT_INDEX$2 = _enums$STRUCT_KEY$3.STRUCT_INDEX,
    STRUCT_CHILD_INDEX$1 = _enums$STRUCT_KEY$3.STRUCT_CHILD_INDEX,
    STRUCT_LV$2 = _enums$STRUCT_KEY$3.STRUCT_LV,
    _enums$NODE_KEY$a = enums.NODE_KEY,
    NODE_IS_DESTROYED$2 = _enums$NODE_KEY$a.NODE_IS_DESTROYED,
    NODE_STRUCT$4 = _enums$NODE_KEY$a.NODE_STRUCT;

var Node = /*#__PURE__*/function () {
  function Node() {
    _classCallCheck(this, Node);

    this.__x = 0;
    this.__y = 0;
    this.__ox = 0; // relative造成的偏移量

    this.__oy = 0;
    this.__width = 0;
    this.__height = 0;
    this.__baseLine = 0;
    this.__config = {}; // 默认undefined
    // this.__prev = undefined;
    // this.__next = undefined;
    // this.__parent = undefined;
    // this.__domParent = undefined;
    // this.__root = undefined;
    // this.__host = undefined;
  }

  _createClass(Node, [{
    key: "__structure",
    value: function __structure(i, lv, j) {
      var _this$__config$NODE_S;

      return this.__config[NODE_STRUCT$4] = (_this$__config$NODE_S = {}, _defineProperty(_this$__config$NODE_S, STRUCT_NODE$2, this), _defineProperty(_this$__config$NODE_S, STRUCT_INDEX$2, i), _defineProperty(_this$__config$NODE_S, STRUCT_CHILD_INDEX$1, j), _defineProperty(_this$__config$NODE_S, STRUCT_LV$2, lv), _this$__config$NODE_S);
    }
  }, {
    key: "__modifyStruct",
    value: function __modifyStruct(root) {
      var struct = this.__config[NODE_STRUCT$4];
      return [struct, 0];
    }
  }, {
    key: "__offsetX",
    value: function __offsetX(diff, isLayout) {
      if (isLayout) {
        this.__x += diff;
      } else {
        this.__ox += diff;
      }

      this.__sx += diff;
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff, isLayout) {
      if (isLayout) {
        this.__y += diff;
      } else {
        this.__oy += diff;
      }

      this.__sy += diff;
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      this.__config[NODE_IS_DESTROYED$2] = true;
    }
  }, {
    key: "x",
    get: function get() {
      return this.__x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.__y;
    }
  }, {
    key: "ox",
    get: function get() {
      return this.__ox;
    }
  }, {
    key: "oy",
    get: function get() {
      return this.__oy;
    }
  }, {
    key: "sx",
    get: function get() {
      return this.x + this.ox;
    }
  }, {
    key: "sy",
    get: function get() {
      return this.y + this.oy;
    }
  }, {
    key: "width",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "height",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "outerWidth",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "outerHeight",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "prev",
    get: function get() {
      return this.__prev;
    }
  }, {
    key: "next",
    get: function get() {
      return this.__next;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.__parent;
    }
  }, {
    key: "domParent",
    get: function get() {
      return this.__domParent;
    } // canvas/svg根节点

  }, {
    key: "root",
    get: function get() {
      return this.__root;
    } // component根节点

  }, {
    key: "host",
    get: function get() {
      return this.__host;
    } // 考虑高阶组件在内的component根节点

  }, {
    key: "hostRoot",
    get: function get() {
      return this.__hostRoot;
    }
  }, {
    key: "baseLine",
    get: function get() {
      return this.__baseLine;
    }
  }, {
    key: "virtualDom",
    get: function get() {
      return this.__virtualDom;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.__config[NODE_IS_DESTROYED$2];
    }
  }]);

  return Node;
}();

var mode = {
  CANVAS: 0,
  SVG: 1,
  WEBGL: 2
};

var o$4 = {
  AUTO: 0,
  PX: 1,
  PERCENT: 2,
  NUMBER: 3,
  INHERIT: 4,
  DEG: 5,
  STRING: 6,
  RGBA: 7,
  REM: 8,
  EM: 9,
  VW: 10,
  VH: 11,

  /**
   * 通用的格式化计算数值单位的方法，百分比/像素/REM/VW/auto和纯数字
   * @param v value
   * @returns 格式化好的[number, unit]
   */
  calUnit: function calUnit(v) {
    var n = parseFloat(v) || 0;

    if (/%$/.test(v)) {
      return [n, o$4.PERCENT];
    } else if (/px$/i.test(v)) {
      return [n, o$4.PX];
    } else if (/deg$/i.test(v)) {
      return [n, o$4.DEG];
    } else if (/rem$/i.test(v)) {
      return [n, o$4.REM];
    } else if (/vw$/i.test(v)) {
      return [n, o$4.VW];
    } else if (/vh$/i.test(v)) {
      return [n, o$4.VH];
    } else if (/em$/i.test(v)) {
      return [n, o$4.EM];
    } else if (/vw$/i.test(v)) {
      return [n, o$4.VW];
    } else if (/vh$/i.test(v)) {
      return [n, o$4.VH];
    }

    return [n, o$4.NUMBER];
  }
};

var o$3 = {
  info: {
    arial: {
      lhr: 1.14990234375,
      // 默认line-height ratio，(67+1854+434)/2048
      // car: 1.1171875, // content-area ratio，(1854+434)/2048
      blr: 0.9052734375,
      // base-line ratio，1854/2048
      // mdr: 0.64599609375, // middle ratio，(1854-1062/2)/2048
      lgr: 0.03271484375,
      // line-gap ratio，67/2048，默认0
      // 个别字符误差，初次之外误差还有根据经验得的比例系数，https://github.com/karasjs/karas/issues/145
      padding: {
        1: 1,
        f: 0.9
      }
    },
    verdana: {
      lhr: 1.21533203125,
      // (0+2059+430)/2048
      blr: 1.00537109375 // 2059/2048

    },
    tahoma: {
      lhr: 1.20703125,
      // (0+2049+423)/2048
      blr: 1.00048828125,
      // 2049/2048
      padding: {
        S: 1,
        T: 1,
        Z: 1,
        c: 1,
        f: 0.7,
        i: 1,
        l: 1,
        t: 0.9
      }
    },
    georgia: {
      lhr: 1.13623046875,
      // (0+1878+449)/2048
      blr: 0.9169921875 // 1878/2048

    },
    'courier new': {
      lhr: 1.1328125,
      // (0+1705+615)/2048
      blr: 0.83251953125 // 1705/2048

    },
    'pingfang sc': {
      lhr: 1.4,
      // (0+1060+340)/1000
      blr: 1.06,
      // 1060/1000
      padding: {
        f: 0.5
      }
    },
    simsun: {
      lhr: 1.4,
      // (0+1060+340)/1000
      blr: 1.06,
      padding: {
        f: 0.5
      }
    }
  },
  support: function support(fontFamily) {
    return this.info.hasOwnProperty(fontFamily);
  },
  register: function register(name, info) {
    var _ref = info || {},
        _ref$emSquare = _ref.emSquare,
        emSquare = _ref$emSquare === void 0 ? 2048 : _ref$emSquare,
        _ref$ascent = _ref.ascent,
        ascent = _ref$ascent === void 0 ? 1854 : _ref$ascent,
        _ref$descent = _ref.descent,
        descent = _ref$descent === void 0 ? 434 : _ref$descent,
        _ref$lineGap = _ref.lineGap,
        lineGap = _ref$lineGap === void 0 ? 67 : _ref$lineGap,
        _ref$padding = _ref.padding,
        padding = _ref$padding === void 0 ? {} : _ref$padding;

    this.info[name.toLowerCase()] = {
      lhr: (ascent + descent + lineGap) / emSquare,
      blr: ascent / emSquare,
      padding: padding
    };
  },
  addPadding: function addPadding(name, padding) {
    Object.assign(this.info[name.toLowerCase()].padding, padding);
  }
};
o$3.info['宋体'] = o$3.info.simsun;

var reg = {
  position: /(([-+]?[\d.]+[pxremvwh%]*)|(left|top|right|bottom|center)){1,2}/ig,
  // tfo: /((-?[\d.]+(px|%)?)|(left|top|right|bottom|center)){1,2}/ig,
  gradient: /\b(\w+)-?gradient\((.+)\)/i,
  img: /(?:\burl\((['"]?)(.*?)\1\))|(?:\b((data:)))/i
};

// 生成4*4单位矩阵
function identity$1() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
} // 矩阵a*b，固定两个matrix都是长度16


function multiply$2(a, b) {
  if (isE$3(a)) {
    return b;
  }

  if (isE$3(b)) {
    return a;
  }

  var c = [];

  for (var i = 0; i < 4; i++) {
    var a0 = a[i];
    var a1 = a[i + 4];
    var a2 = a[i + 8];
    var a3 = a[i + 12];
    c[i] = a0 * b[0] + a1 * b[1] + a2 * b[2] + a3 * b[3];
    c[i + 4] = a0 * b[4] + a1 * b[5] + a2 * b[6] + a3 * b[7];
    c[i + 8] = a0 * b[8] + a1 * b[9] + a2 * b[10] + a3 * b[11];
    c[i + 12] = a0 * b[12] + a1 * b[13] + a2 * b[14] + a3 * b[15];
  }

  return c;
}

function calPoint$2(point, m) {
  var _point = _slicedToArray(point, 4),
      x = _point[0],
      y = _point[1],
      z = _point[2],
      w = _point[3];

  if (w === undefined) {
    w = 1;
  }

  if (m && !isE$3(m)) {
    if (m.length === 16) {
      z = z || 0;

      var _m = _slicedToArray(m, 16),
          a1 = _m[0],
          b1 = _m[1],
          c1 = _m[2],
          d1 = _m[3],
          a2 = _m[4],
          b2 = _m[5],
          c2 = _m[6],
          d2 = _m[7],
          a3 = _m[8],
          b3 = _m[9],
          c3 = _m[10],
          d3 = _m[11],
          a4 = _m[12],
          b4 = _m[13],
          c4 = _m[14],
          d4 = _m[15];

      w *= x * d1 + y * d2 + z * d3 + d4;
      return [x * a1 + y * a2 + z * a3 + a4, x * b1 + y * b2 + z * b3 + b4, x * c1 + y * c2 + z * c3 + c4, w];
    } // 6位类型


    var _m2 = _slicedToArray(m, 6),
        a = _m2[0],
        b = _m2[1],
        c = _m2[2],
        d = _m2[3],
        e = _m2[4],
        f = _m2[5];

    return [a * x + c * y + e, b * x + d * y + f];
  }

  return [x, y, z, w];
}
/**
 * 初等行变换求3*3特定css的matrix方阵，一维6长度
 * https://blog.csdn.net/iloveas2014/article/details/82930946
 * @param m
 * @returns {number[]|*}
 */


function inverse$1(m) {
  if (m.length === 16) {
    return inverse4(m);
  }

  var _m3 = _slicedToArray(m, 6),
      a = _m3[0],
      b = _m3[1],
      c = _m3[2],
      d = _m3[3],
      e = _m3[4],
      f = _m3[5];

  if (a === 1 && b === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
    return m;
  }

  var divisor = a * d - b * c;

  if (divisor === 0) {
    return m;
  }

  return [d / divisor, -b / divisor, -c / divisor, a / divisor, (c * f - d * e) / divisor, (b * e - a * f) / divisor];
} // 16位或者6位单位矩阵判断，空也认为是


function isE$3(m) {
  if (!m) {
    return true;
  }

  if (m.length === 16) {
    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
  }

  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
}
/**
 * 求任意4*4矩阵的逆矩阵，行列式为 0 则返回单位矩阵兜底
 * 格式：matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)
 * 参见: https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d()
 * 对应：
 * [
 *   a1,a2,a3,a4,
 *   b1,b2,b3,b4,
 *   c1,c2,c3,c4,
 *   d1,d2,d3,d4,
 * ]
 *
 * 根据公式 A* = |A|A^-1 来计算
 * A* 表示矩阵 A 的伴随矩阵，A^-1 表示矩阵 A 的逆矩阵，|A| 表示行列式的值
 *
 * @returns {number[]}
 */


function inverse4(s) {
  var inv = [];
  inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
  inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
  inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
  inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
  inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
  inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
  inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
  inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
  inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
  inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
  inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
  inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
  inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
  inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
  inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
  inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
  var det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];

  if (det === 0) {
    return identity$1();
  }

  det = 1 / det;
  var d = [];

  for (var i = 0; i < 16; i++) {
    d[i] = inv[i] * det;
  }

  return d;
} // 将4*4的16长度矩阵转成css/canvas的6位标准使用，忽略transform3d


function m2m6(m) {
  return [m[0], m[1], m[4], m[5], m[12], m[13]];
}

function point2d$1(point) {
  var w = point[3];

  if (w && w !== 1) {
    point = point.slice(0, 2);
    point[0] /= w;
    point[1] /= w;
  }

  return point;
}

var mx = {
  identity: identity$1,
  multiply: multiply$2,
  calPoint: calPoint$2,
  point2d: point2d$1,
  inverse: inverse$1,
  isE: isE$3,
  m2m6: m2m6
};

// 向量点乘积
function dotProduct(x1, y1, x2, y2) {
  return x1 * x2 + y1 * y2;
} // 向量叉乘积


function crossProduct$1(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}

var vector = {
  dotProduct: dotProduct,
  crossProduct: crossProduct$1
};

var H$1 = 4 * (Math.sqrt(2) - 1) / 3;
var crossProduct = vector.crossProduct;
var calPoint$1 = mx.calPoint,
    isE$2 = mx.isE;
var _enums$STYLE_KEY$p = enums.STYLE_KEY,
    WIDTH$8 = _enums$STYLE_KEY$p.WIDTH,
    HEIGHT$8 = _enums$STYLE_KEY$p.HEIGHT,
    TRANSFORM_ORIGIN$5 = _enums$STYLE_KEY$p.TRANSFORM_ORIGIN;
/**
 * 圆弧拟合公式，根据角度求得3阶贝塞尔控制点比例长度，一般<=90，超过拆分
 * @param deg
 * @returns {number}
 */

function h(deg) {
  deg *= 0.5;
  return 4 * ((1 - Math.cos(deg)) / Math.sin(deg)) / 3;
}
/**
 * 判断点是否在多边形内
 * @param x 点坐标
 * @param y
 * @param vertexes 多边形顶点坐标
 * @returns {boolean}
 */


function pointInPolygon(x, y, vertexes) {
  // 先取最大最小值得一个外围矩形，在外边可快速判断false
  var _vertexes$ = _slicedToArray(vertexes[0], 2),
      xmax = _vertexes$[0],
      ymax = _vertexes$[1];

  var _vertexes$2 = _slicedToArray(vertexes[0], 2),
      xmin = _vertexes$2[0],
      ymin = _vertexes$2[1];

  var len = vertexes.length;

  for (var i = 1; i < len; i++) {
    var _vertexes$i = _slicedToArray(vertexes[i], 2),
        _x = _vertexes$i[0],
        _y = _vertexes$i[1];

    xmax = Math.max(xmax, _x);
    ymax = Math.max(ymax, _y);
    xmin = Math.min(xmin, _x);
    ymin = Math.min(ymin, _y);
  }

  if (x < xmin || y < ymin || x > xmax || y > ymax) {
    return false;
  } // 所有向量积均为非负数说明在多边形内或边上


  for (var _i = 0, _len = vertexes.length; _i < _len; _i++) {
    var _vertexes$_i = _slicedToArray(vertexes[_i], 2),
        x1 = _vertexes$_i[0],
        y1 = _vertexes$_i[1];

    var _vertexes = _slicedToArray(vertexes[(_i + 1) % _len], 2),
        x2 = _vertexes[0],
        y2 = _vertexes[1];

    if (crossProduct(x2 - x1, y2 - y1, x - x1, y - y1) < 0) {
      return false;
    }
  }

  return true;
} // 判断点是否在一个4边形内，比如事件发生是否在节点上


function pointInQuadrilateral(x, y, x1, y1, x2, y2, x4, y4, x3, y3, matrix) {
  if (matrix && !isE$2(matrix)) {
    var w1, w2, w3, w4;

    var _calPoint = calPoint$1([x1, y1], matrix);

    var _calPoint2 = _slicedToArray(_calPoint, 4);

    x1 = _calPoint2[0];
    y1 = _calPoint2[1];
    w1 = _calPoint2[3];

    var _calPoint3 = calPoint$1([x2, y2], matrix);

    var _calPoint4 = _slicedToArray(_calPoint3, 4);

    x2 = _calPoint4[0];
    y2 = _calPoint4[1];
    w2 = _calPoint4[3];

    var _calPoint5 = calPoint$1([x3, y3], matrix);

    var _calPoint6 = _slicedToArray(_calPoint5, 4);

    x3 = _calPoint6[0];
    y3 = _calPoint6[1];
    w3 = _calPoint6[3];

    var _calPoint7 = calPoint$1([x4, y4], matrix);

    var _calPoint8 = _slicedToArray(_calPoint7, 4);

    x4 = _calPoint8[0];
    y4 = _calPoint8[1];
    w4 = _calPoint8[3];

    if (w1 && w1 !== 1) {
      x1 /= w1;
      y1 /= w1;
    }

    if (w2 && w2 !== 1) {
      x2 /= w2;
      y2 /= w2;
    }

    if (w3 && w3 !== 1) {
      x3 /= w3;
      y3 /= w3;
    }

    if (w4 && w4 !== 1) {
      x4 /= w4;
      y4 /= w4;
    }

    return pointInPolygon(x, y, [[x1, y1], [x2, y2], [x4, y4], [x3, y3]]);
  } else {
    return x >= x1 && y >= y1 && x <= x4 && y <= y4;
  }
}
/**
 * 余弦定理3边长求夹角
 * @param a
 * @param b
 * @param c
 */


function angleBySide(a, b, c) {
  var theta = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
  return Math.acos(theta);
}
/**
 * 余弦定理2边长和夹角求3边
 * @param alpha 弧度
 * @param a
 * @param b
 */


function sideByAngle(alpha, a, b) {
  var cos = Math.cos(alpha);
  return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * cos);
}
/**
 * 两点距离
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 */


function pointsDistance(x1, y1, x2, y2) {
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
}
/**
 * 三角形内心
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @param x3
 * @param y3
 */


function triangleIncentre(x1, y1, x2, y2, x3, y3) {
  var a = pointsDistance(x2, y2, x3, y3);
  var b = pointsDistance(x1, y1, x3, y3);
  var c = pointsDistance(x1, y1, x2, y2);
  return [(a * x1 + b * x2 + c * x3) / (a + b + c), (a * y1 + b * y2 + c * y3) / (a + b + c)];
}
/**
 * 椭圆圆心和长短轴生成4个端点和控制点
 */


function ellipsePoints(x, y, a) {
  var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a;
  var ox = a * H$1;
  var oy = b === a ? ox : b * H$1;
  return [[x - a, y], [x - a, y - oy, x - ox, y - b, x, y - b], [x + ox, y - b, x + a, y - oy, x + a, y], [x + a, y + oy, x + ox, y + b, x, y + b], [x - ox, y + b, x - a, y + oy, x - a, y]];
}
/**
 * 扇形圆心和半径起始角度生成4个端点和控制点
 * 分为4个象限进行拟合，0、1、2、3
 */


function sectorPoints$1(x, y, r, begin, end) {
  if (begin > end) {
    var _ref = [end, begin];
    begin = _ref[0];
    end = _ref[1];
  }

  if (begin === end) {
    return [];
  }

  var list = [];
  var b = Math.floor(begin / 90);
  var e = Math.floor(end / 90); // 同象限直接算

  if (b === e || e - b === 1 && end % 90 === 0) {
    var h2 = h(d2r$2(Math.abs(begin - end)));
    var d = h2 * r;
    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var alpha = Math.atan(d / r);

    if (b < 90) {
      // 第1个交点
      var rx = Math.sin(d2r$2(begin)) * r;
      var ry = Math.cos(d2r$2(begin)) * r;
      var p1 = [x + rx, y - ry]; // 第1个控制点

      var deg = alpha + d2r$2(begin);
      rx = Math.sin(deg) * c;
      ry = Math.cos(deg) * c;
      var p2 = [x + rx, y - ry]; // 第2个交点

      rx = Math.sin(d2r$2(end)) * r;
      ry = Math.cos(d2r$2(end)) * r;
      var p4 = [x + rx, y - ry]; // 第2个控制点

      deg = d2r$2(end) - alpha;
      rx = Math.sin(deg) * c;
      ry = Math.cos(deg) * c;
      var p3 = [x + rx, y - ry];
      list.push(p1);
      list.push(p2.concat(p3).concat(p4));
    } else if (b < 180) {
      // 第1个交点
      var _rx = Math.cos(d2r$2(begin - 90)) * r;

      var _ry = Math.sin(d2r$2(begin - 90)) * r;

      var _p = [x + _rx, y + _ry]; // 第1个控制点

      var _deg = alpha + d2r$2(begin - 90);

      _rx = Math.cos(_deg) * c;
      _ry = Math.sin(_deg) * c;
      var _p2 = [x + _rx, y + _ry]; // 第2个交点

      _rx = Math.cos(d2r$2(end - 90)) * r;
      _ry = Math.sin(d2r$2(end - 90)) * r;
      var _p3 = [x + _rx, y + _ry]; // 第2个控制点

      _deg = d2r$2(end - 90) - alpha;
      _rx = Math.cos(_deg) * c;
      _ry = Math.sin(_deg) * c;
      var _p4 = [x + _rx, y + _ry];
      list.push(_p);
      list.push(_p2.concat(_p4).concat(_p3));
    } else if (b < 270) {
      // 第1个交点
      var _rx2 = Math.sin(d2r$2(begin - 180)) * r;

      var _ry2 = Math.cos(d2r$2(begin - 180)) * r;

      var _p5 = [x - _rx2, y + _ry2]; // 第1个控制点

      var _deg2 = alpha + d2r$2(begin - 180);

      _rx2 = Math.sin(_deg2) * c;
      _ry2 = Math.cos(_deg2) * c;
      var _p6 = [x - _rx2, y + _ry2]; // 第2个交点

      _rx2 = Math.sin(d2r$2(end - 180)) * r;
      _ry2 = Math.cos(d2r$2(end - 180)) * r;
      var _p7 = [x - _rx2, y + _ry2]; // 第2个控制点

      _deg2 = d2r$2(end - 180) - alpha;
      _rx2 = Math.sin(_deg2) * c;
      _ry2 = Math.cos(_deg2) * c;
      var _p8 = [x - _rx2, y + _ry2];
      list.push(_p5);
      list.push(_p6.concat(_p8).concat(_p7));
    } else {
      // 第1个交点
      var _rx3 = Math.cos(d2r$2(begin - 270)) * r;

      var _ry3 = Math.sin(d2r$2(begin - 270)) * r;

      var _p9 = [x - _rx3, y + _ry3]; // 第1个控制点

      var _deg3 = alpha + d2r$2(begin - 270);

      _rx3 = Math.cos(_deg3) * c;
      _ry3 = Math.sin(_deg3) * c;
      var _p10 = [x - _rx3, y + _ry3]; // 第2个交点

      _rx3 = Math.cos(d2r$2(end - 270)) * r;
      _ry3 = Math.sin(d2r$2(end - 270)) * r;
      var _p11 = [x - _rx3, y + _ry3]; // 第2个控制点

      _deg3 = d2r$2(end - 270) - alpha;
      _rx3 = Math.cos(_deg3) * c;
      _ry3 = Math.sin(_deg3) * c;
      var _p12 = [x - _rx3, y + _ry3];
      list.push(_p9);
      list.push(_p10.concat(_p12).concat(_p11));
    }
  } // 跨象限循环算
  else {
    var i = b;
    var temp = [];

    for (; i <= e; i++) {
      if (i === 0) {
        var res = sectorPoints$1(x, y, r, begin, 90);
        temp.push(res);
      } else if (i === 1) {
        // 防止90~90这种情况，但如果begin和end都是90时又要显示
        if (b === i || end > 90) {
          var _res = sectorPoints$1(x, y, r, begin < 90 ? 90 : begin, end > 180 ? 180 : end);

          temp.push(_res);
        }
      } else if (i === 2) {
        // 防止180~180这种情况，但如果begin和end都是90时又要显示
        if (b === i || end > 180) {
          var _res2 = sectorPoints$1(x, y, r, begin < 180 ? 180 : begin, end > 270 ? 270 : end);

          temp.push(_res2);
        }
      } else if (i === 3) {
        // 防止180~180这种情况，但如果begin和end都是90时又要显示
        if (b === i || end > 270) {
          var _res3 = sectorPoints$1(x, y, r, begin < 270 ? 270 : begin, end);

          temp.push(_res3);
        }
      }
    } // 去掉重复的首尾扇弧点


    list = temp[0];

    for (var _i2 = 1, len = temp.length; _i2 < len; _i2++) {
      list.push(temp[_i2][1]);
    }
  }

  return list;
}
/**
 * 获取2个矩形重叠区域，如不重叠返回null
 * @param a
 * @param b
 */


function getRectsIntersection(a, b) {
  if (!isRectsOverlap(a, b)) {
    return null;
  }

  var _a = _slicedToArray(a, 4),
      ax1 = _a[0],
      ay1 = _a[1],
      ax4 = _a[2],
      ay4 = _a[3];

  var _b = _slicedToArray(b, 4),
      bx1 = _b[0],
      by1 = _b[1],
      bx4 = _b[2],
      by4 = _b[3];

  return [Math.max(ax1, bx1), Math.max(ay1, by1), Math.min(ax4, bx4), Math.min(ay4, by4)];
}
/**
 * 2个矩形是否重叠
 * @param a
 * @param b
 */


function isRectsOverlap(a, b) {
  var _a2 = _slicedToArray(a, 4),
      ax1 = _a2[0],
      ay1 = _a2[1],
      ax4 = _a2[2],
      ay4 = _a2[3];

  var _b2 = _slicedToArray(b, 4),
      bx1 = _b2[0],
      by1 = _b2[1],
      bx4 = _b2[2],
      by4 = _b2[3];

  if (ax1 >= bx4 || ay1 >= by4 || bx1 >= ax4 || by1 >= ay4) {
    return false;
  }

  return true;
}
/**
 * 2个矩形是否包含，a包含b
 * @param a
 * @param b
 */


function isRectsInside(a, b) {
  var _a3 = _slicedToArray(a, 4),
      ax1 = _a3[0],
      ay1 = _a3[1],
      ax4 = _a3[2],
      ay4 = _a3[3];

  var _b3 = _slicedToArray(b, 4),
      bx1 = _b3[0],
      by1 = _b3[1],
      bx4 = _b3[2],
      by4 = _b3[3];

  if (ax1 <= bx1 && ay1 <= by1 && ax4 >= bx4 && ay4 >= by4) {
    return true;
  }

  return false;
}

function calCoordsInNode(px, py, node) {
  var _node$matrix = node.matrix,
      matrix = _node$matrix === void 0 ? [1, 0, 0, 1, 0, 0] : _node$matrix,
      _node$computedStyle = node.computedStyle,
      computedStyle = _node$computedStyle === void 0 ? {} : _node$computedStyle;
  var width = computedStyle[WIDTH$8],
      height = computedStyle[HEIGHT$8],
      _computedStyle$TRANSF = computedStyle[TRANSFORM_ORIGIN$5];
  _computedStyle$TRANSF = _computedStyle$TRANSF === void 0 ? [width * 0.5, height * 0.5] : _computedStyle$TRANSF;

  var _computedStyle$TRANSF2 = _slicedToArray(_computedStyle$TRANSF, 2),
      ox = _computedStyle$TRANSF2[0],
      oy = _computedStyle$TRANSF2[1];

  var _calPoint9 = calPoint$1([px * width - ox, py * height - oy], matrix);

  var _calPoint10 = _slicedToArray(_calPoint9, 2);

  px = _calPoint10[0];
  py = _calPoint10[1];
  return [px + ox, py + oy];
}

function calPercentInNode(x, y, node) {
  var _node$computedStyle2 = node.computedStyle,
      width = _node$computedStyle2[WIDTH$8],
      height = _node$computedStyle2[HEIGHT$8],
      _node$computedStyle2$ = _slicedToArray(_node$computedStyle2[TRANSFORM_ORIGIN$5], 2),
      ox = _node$computedStyle2$[0],
      oy = _node$computedStyle2$[1]; // 先求无旋转时右下角相对于原点的角度ds


  var ds = Math.atan((height - oy) / (width - ox));

  var _calCoordsInNode = calCoordsInNode(1, 1, node),
      _calCoordsInNode2 = _slicedToArray(_calCoordsInNode, 2),
      x1 = _calCoordsInNode2[0],
      y1 = _calCoordsInNode2[1];

  var d1;
  var deg; // 根据旋转后的坐标，分4个象限，求旋转后的右下角相对于原点的角度d1，得出偏移角度deg，分顺逆时针[-180, 180]

  if (x1 >= ox && y1 >= oy) {
    if (ox === x1) {
      d1 = -Math.atan(Infinity);
    } else {
      d1 = Math.atan((y1 - oy) / (x1 - ox));
    }

    deg = d1 - ds;
  } else if (x1 >= ox && y1 < oy) {
    if (ox === x1) {
      d1 = -Math.atan(Infinity);
    } else {
      d1 = Math.atan((oy - y1) / (x1 - ox));
    }

    deg = d1 + ds;
  } else if (x1 < ox && y1 >= oy) {
    d1 = Math.atan((y1 - oy) / (ox - x1));
    deg = d1 - ds;
  } else if (x1 < ox && y1 < oy) {
    d1 = Math.atan((y1 - oy) / (x1 - ox));

    if (ds >= d1) {
      deg = d1 + Math.PI - ds;
    } else {
      deg = Math.PI - d1 + ds;
      deg = -deg;
    }
  } else {
    deg = 0;
  } // 目标点到原点的边长不会变


  var dt = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2)); // 分4个象限，先求目标点到原点的角度d2，再偏移deg后求得原始坐标

  var d2;

  if (x >= ox && y >= oy) {
    if (ox === x) {
      d2 = -Math.atan(Infinity);
    } else {
      d2 = Math.atan((y - oy) / (x - ox));
    }
  } else if (x >= ox && y < oy) {
    if (ox === x) {
      d2 = -Math.atan(Infinity);
    } else {
      d2 = -Math.atan((y - oy) / (ox - x));
    }
  } else if (x < ox && y >= oy) {
    d2 = Math.PI - Math.atan((y - oy) / (ox - x));
  } else {
    d2 = Math.atan((y - oy) / (x - ox)) - Math.PI;
  }

  d2 -= deg;

  if (d2 > Math.PI) {
    d2 -= Math.PI;
    return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
  }

  if (d2 > Math.PI * 0.5) {
    d2 = Math.PI - d2;
    return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
  }

  if (d2 >= 0) {
    return [(ox + dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
  }

  if (d2 >= -Math.PI * 0.5) {
    d2 = -d2;
    return [(ox + dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
  }

  if (d2 >= -Math.PI) {
    d2 = Math.PI + d2;
    return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
  }

  d2 = -Math.PI - d2;
  return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
}

function d2r$2(n) {
  return n * Math.PI / 180;
}

function r2d(n) {
  return n * 180 / Math.PI;
}
/**
 * 二阶贝塞尔曲线范围框
 * @param x0
 * @param y0
 * @param x1
 * @param y1
 * @param x2
 * @param y2
 * @returns {number[]}
 * https://www.iquilezles.org/www/articles/bezierbbox/bezierbbox.htm
 */


function bboxBezier2(x0, y0, x1, y1, x2, y2) {
  var minX = Math.min(x0, x2);
  var minY = Math.min(y0, y2);
  var maxX = Math.max(x0, x2);
  var maxY = Math.max(y0, y2); // 控制点位于边界内部时，边界就是范围框，否则计算导数获取极值

  if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY) {
    var tx = (x0 - x1) / (x0 - 2 * x1 + x2);
    var ty = (y0 - y1) / (y0 - 2 * y1 + y2);
    var sx = 1 - tx;
    var sy = 1 - ty;
    var qx = sx * sx * x0 + 2 * sx * tx * x1 + tx * tx * x2;
    var qy = sy * sy * y0 + 2 * sy * ty * y1 + ty * ty * y2;
    minX = Math.min(minX, qx);
    minY = Math.min(minY, qy);
    maxX = Math.min(maxX, qx);
    maxY = Math.min(maxY, qy);
  }

  return [minX, minY, maxX, maxY];
}
/**
 * 同上三阶的
 */


function bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3) {
  var minX = Math.min(x0, x3);
  var minY = Math.min(y0, y3);
  var maxX = Math.max(x0, x3);
  var maxY = Math.max(y0, y3);

  if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY || x2 < minX || y2 < minY || x2 > maxX || y2 > maxY) {
    var cx = -x0 + x1;
    var cy = -y0 + y1;
    var bx = x0 - 2 * x1 + x2;
    var by = y0 - 2 * y1 + y2;
    var ax = -x0 + 3 * x1 - 3 * x2 + x3;
    var ay = -y0 + 3 * y1 - 3 * y2 + y3;
    var hx = bx * bx - ax * cx;
    var hy = by * by - ay * cy;

    if (hx > 0) {
      hx = Math.sqrt(hx);
      var t = (-bx - hx) / ax;

      if (t > 0 && t < 1) {
        var s = 1 - t;
        var q = s * s * s * x0 + 3 * s * s * t * x1 + 3 * s * t * t * x2 + t * t * t * x3;
        minX = Math.min(minX, q);
        maxX = Math.max(maxX, q);
      }

      t = (-bx + hx) / ax;

      if (t > 0 && t < 1) {
        var _s = 1 - t;

        var _q = _s * _s * _s * x0 + 3 * _s * _s * t * x1 + 3 * _s * t * t * x2 + t * t * t * x3;

        minX = Math.min(minX, _q);
        maxX = Math.max(maxX, _q);
      }
    }

    if (hy > 0) {
      hy = Math.sqrt(hy);

      var _t = (-by - hy) / ay;

      if (_t > 0 && _t < 1) {
        var _s2 = 1 - _t;

        var _q2 = _s2 * _s2 * _s2 * y0 + 3 * _s2 * _s2 * _t * y1 + 3 * _s2 * _t * _t * y2 + _t * _t * _t * y3;

        minY = Math.min(minY, _q2);
        maxY = Math.max(maxY, _q2);
      }

      _t = (-by + hy) / ay;

      if (_t > 0 && _t < 1) {
        var _s3 = 1 - _t;

        var _q3 = _s3 * _s3 * _s3 * y0 + 3 * _s3 * _s3 * _t * y1 + 3 * _s3 * _t * _t * y2 + _t * _t * _t * y3;

        minY = Math.min(minY, _q3);
        maxY = Math.max(maxY, _q3);
      }
    }
  }

  return [minX, minY, maxX, maxY];
}

function bboxBezier(x0, y0, x1, y1, x2, y2, x3, y3) {
  if (arguments.length === 4) {
    return [x0, y0, x1, y1];
  }

  if (arguments.length === 6) {
    return bboxBezier2(x0, y0, x1, y1, x2, y2);
  }

  if (arguments.length === 8) {
    return bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3);
  }
}
/**
 * 范数 or 模
 */


function norm(v) {
  var order = v.length;
  var sum = v.reduce(function (a, b) {
    return Math.pow(a, order) + Math.pow(b, order);
  });
  return Math.pow(sum, 1 / order);
}

function simpson38(derivativeFunc, l, r) {
  var f = derivativeFunc;
  var middleL = (2 * l + r) / 3;
  var middleR = (l + 2 * r) / 3;
  return (f(l) + 3 * f(middleL) + 3 * f(middleR) + f(r)) * (r - l) / 8;
}
/**
 * bezier 曲线的长度
 * @param derivativeFunc 微分函数
 * @param l 左点
 * @param r 右点
 * @param eps 精度
 * @return {*} number
 */


function adaptiveSimpson38(derivativeFunc, l, r) {
  var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
  var f = derivativeFunc;
  var mid = (l + r) / 2;
  var st = simpson38(f, l, r);
  var sl = simpson38(f, l, mid);
  var sr = simpson38(f, mid, r);
  var ans = sl + sr - st;

  if (Math.abs(ans) <= 15 * eps) {
    return sl + sr + ans / 15;
  }

  return adaptiveSimpson38(f, l, mid, eps / 2) + adaptiveSimpson38(f, mid, r, eps / 2);
}
/**
 * bezier 曲线的长度
 * @param points 曲线的起止点 和 控制点
 * @param order 阶次， 2 和 3
 * @param startT 计算长度的起点，满足 0 <= startT <= endT <= 1
 * @param endT 计算长度的终点
 * @return {*} number
 */


function bezierLength(points, order) {
  var startT = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var endT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  var derivativeFunc = function derivativeFunc(t) {
    return norm(at(t, points, order));
  };

  return adaptiveSimpson38(derivativeFunc, startT, endT);
}
/**
 * 3 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
 */


function at3(t, points) {
  var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var _points = _slicedToArray(points, 4),
      p0 = _points[0],
      p1 = _points[1],
      p2 = _points[2],
      p3 = _points[3];

  var _p13 = _slicedToArray(p0, 2),
      x0 = _p13[0],
      y0 = _p13[1];

  var _p14 = _slicedToArray(p1, 2),
      x1 = _p14[0],
      y1 = _p14[1];

  var _p15 = _slicedToArray(p2, 2),
      x2 = _p15[0],
      y2 = _p15[1];

  var _p16 = _slicedToArray(p3, 2),
      x3 = _p16[0],
      y3 = _p16[1];

  var x = 0;
  var y = 0;

  if (order === 0) {
    x = Math.pow(1 - t, 3) * x0 + 3 * t * Math.pow(1 - t, 2) * x1 + 3 * (1 - t) * Math.pow(t, 2) * x2 + Math.pow(t, 3) * x3;
    y = Math.pow(1 - t, 3) * y0 + 3 * t * Math.pow(1 - t, 2) * y1 + 3 * (1 - t) * Math.pow(t, 2) * y2 + Math.pow(t, 3) * y3;
  } else if (order === 1) {
    x = 3 * ((1 - t) * (1 - t) * (x1 - x0) + 2 * (1 - t) * t * (x2 - x1) + t * t * (x3 - x2));
    y = 3 * ((1 - t) * (1 - t) * (y1 - y0) + 2 * (1 - t) * t * (y2 - y1) + t * t * (y3 - y2));
  } else if (order === 2) {
    x = 6 * (x2 - 2 * x1 + x0) * (1 - t) + 6 * (x3 - 2 * x2 + x1) * t;
    y = 6 * (y2 - 2 * y1 + y0) * (1 - t) + 6 * (y3 - 2 * y2 + y1) * t;
  } else if (order === 3) {
    x = 6 * (x3 - 3 * x2 + 3 * x1 - x0);
    y = 6 * (y3 - 3 * y2 + 3 * y1 - y0);
  } else {
    // 3阶导数就是常数了，大于3阶的都是0
    x = 0;
    y = 0;
  }

  return [x, y];
}
/**
 * 2 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
 */


function at2(t, points) {
  var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  var _points2 = _slicedToArray(points, 3),
      p0 = _points2[0],
      p1 = _points2[1],
      p2 = _points2[2];

  var _p17 = _slicedToArray(p0, 2),
      x0 = _p17[0],
      y0 = _p17[1];

  var _p18 = _slicedToArray(p1, 2),
      x1 = _p18[0],
      y1 = _p18[1];

  var _p19 = _slicedToArray(p2, 2),
      x2 = _p19[0],
      y2 = _p19[1];

  var x = 0;
  var y = 0;

  if (order === 0) {
    x = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
    y = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
  } else if (order === 1) {
    x = 2 * (1 - t) * (x1 - x0) + 2 * t * (x2 - x1);
    y = 2 * (1 - t) * (y1 - y0) + 2 * t * (y2 - y1);
  } else if (order === 2) {
    x = 2 * (x2 - 2 * x1 + x0);
    y = 2 * (y2 - 2 * y1 + y0);
  } else {
    x = 0;
    y = 0;
  }

  return [x, y];
}

function at(t, points, bezierOrder) {
  var derivativeOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  if (bezierOrder === 2) {
    return at2(t, points, derivativeOrder);
  } else if (bezierOrder === 3) {
    return at3(t, points, derivativeOrder);
  }
}

function pointAtBezier(points, order, percent, maxIteration, eps) {
  var length = bezierLength(points, order, 0, 1);
  return pointAtBezierWithLength(points, order, length, percent, maxIteration, eps);
}

function pointAtBezierWithLength(points, order, length) {
  var percent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var maxIteration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;
  var eps = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.001;

  var derivativeFunc = function derivativeFunc(t) {
    return norm(at(t, points, order));
  };

  var targetLen = length * percent;
  var approachLen = length;
  var approachT = percent;
  var preApproachT = approachT;

  for (var i = 0; i < maxIteration; i++) {
    approachLen = simpson38(derivativeFunc, 0, approachT);
    var d = approachLen - targetLen;

    if (Math.abs(d) < eps) {
      break;
    } // Newton 法


    var derivative1 = norm(at(approachT, points, order, 1)); // 1 阶导数

    var derivative2 = norm(at(approachT, points, order, 2)); // 2 阶导数

    var numerator = d * derivative1;
    var denominator = d * derivative2 + derivative1 * derivative1;
    approachT = approachT - numerator / denominator;

    if (Math.abs(approachT - preApproachT) < eps) {
      break;
    } else {
      preApproachT = approachT;
    }
  }

  return at(approachT, points, order, 0);
}

function sliceBezier(points, t) {
  var _points3 = _slicedToArray(points, 4),
      _points3$ = _slicedToArray(_points3[0], 2),
      x1 = _points3$[0],
      y1 = _points3$[1],
      _points3$2 = _slicedToArray(_points3[1], 2),
      x2 = _points3$2[0],
      y2 = _points3$2[1],
      _points3$3 = _slicedToArray(_points3[2], 2),
      x3 = _points3$3[0],
      y3 = _points3$3[1],
      p4 = _points3[3];

  var x12 = (x2 - x1) * t + x1;
  var y12 = (y2 - y1) * t + y1;
  var x23 = (x3 - x2) * t + x2;
  var y23 = (y3 - y2) * t + y2;
  var x123 = (x23 - x12) * t + x12;
  var y123 = (y23 - y12) * t + y12;

  if (points.length === 4) {
    var _p20 = _slicedToArray(p4, 2),
        x4 = _p20[0],
        y4 = _p20[1];

    var x34 = (x4 - x3) * t + x3;
    var y34 = (y4 - y3) * t + y3;
    var x234 = (x34 - x23) * t + x23;
    var y234 = (y34 - y23) * t + y23;
    var x1234 = (x234 - x123) * t + x123;
    var y1234 = (y234 - y123) * t + y123;
    return [[x1, y1], [x12, y12], [x123, y123], [x1234, y1234]];
  } else if (points.length === 3) {
    return [[x1, y1], [x12, y12], [x123, y123]];
  }
}

function sliceBezier2Both(points) {
  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  start = Math.max(start, 0);
  end = Math.min(end, 1);

  if (start === 0 && end === 1) {
    return points;
  }

  if (end < 1) {
    points = sliceBezier(points, end);
  }

  if (start > 0) {
    if (end < 1) {
      start = start / end;
    }

    points = sliceBezier(points.reverse(), 1 - start).reverse();
  }

  return points;
}

function pointOnCircle(x, y, r, deg) {
  if (deg >= 270) {
    deg -= 270;
    deg = d2r$2(deg);
    return [x - Math.cos(deg) * r, y - Math.sin(deg) * r];
  } else if (deg >= 180) {
    deg -= 180;
    deg = d2r$2(deg);
    return [x - Math.sin(deg) * r, y + Math.cos(deg) * r];
  } else if (deg >= 90) {
    deg -= 90;
    deg = d2r$2(deg);
    return [x + Math.cos(deg) * r, y + Math.sin(deg) * r];
  } else {
    deg = d2r$2(deg);
    return [x + Math.sin(deg) * r, y - Math.cos(deg) * r];
  }
}

var geom$1 = {
  pointInPolygon: pointInPolygon,
  pointInQuadrilateral: pointInQuadrilateral,
  d2r: d2r$2,
  r2d: r2d,
  // 贝塞尔曲线模拟1/4圆弧比例
  H: H$1,
  // <90任意角度贝塞尔曲线拟合圆弧的比例公式
  h: h,
  angleBySide: angleBySide,
  sideByAngle: sideByAngle,
  pointsDistance: pointsDistance,
  triangleIncentre: triangleIncentre,
  ellipsePoints: ellipsePoints,
  sectorPoints: sectorPoints$1,
  getRectsIntersection: getRectsIntersection,
  isRectsOverlap: isRectsOverlap,
  isRectsInside: isRectsInside,
  calCoordsInNode: calCoordsInNode,
  calPercentInNode: calPercentInNode,
  bboxBezier: bboxBezier,
  bezierLength: bezierLength,
  pointAtBezier: pointAtBezier,
  pointAtBezierWithLength: pointAtBezierWithLength,
  sliceBezier: sliceBezier,
  sliceBezier2Both: sliceBezier2Both,
  pointOnCircle: pointOnCircle
};

/**
 * @typedef {Object} gradientStatement
 * @property {Array<number>} color - 颜色rgba，0～255，如 [0, 255, 0, 255]
 * @property {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
 */

/**
 * 获取渐变图像像素数组
 * @param {number} originX - 渐变中心x坐标（相对图片左上角(0,0)的值，可在图片外，下同）
 * @param {number} originY - 渐变中心y坐标
 * @param {number} width - 图片宽度
 * @param {number} height - 图片高度
 * @param {Array<stop>} stop - 渐变声明列表
 * @param data - canvas的imgData.data
 * @returns {Array<number>} 图像像素数组，每4个元素（rgba）构成一个像素点
 * @example
     // 矩形宽度为200*200，此时坐标为0～199，渐变中心为中点时，应传入99.5，可消除零点问题
     // 若渐变中心在某一整数轴上，就会引入零点问题，此时零点取y轴正半轴的色值，要消除这个问题，可以对渐变中心增加一个偏移量，使其不为整数
     let w = 200;
     let h = 200;
     let ctx = document.getElementById('example').getContext('2d');
     let imgData = ctx.getImageData(0,0, w, h);
     let data = getConicGradientImage(99.5, 99.5, w, h, [{
       color: [0,0,0,255],
       angle: 0,
     } ,{
       color: [255,0,0,255],
       angle: 2 * Math.PI,
     }]);
     for (let i = 0; i < imgData.data.length; i++) {
       imgData.data[i] = data[i];
     }
     ctx.putImageData(imgData, 0, 0);
 */
function getConicGradientImage(originX, originY, width, height, stop, data) {
  if (stop.length < 2) {
    throw new Error('Conic gradient should recieve at least 2 gradient statements (start line and end line).');
  }

  width = Math.floor(width);
  height = Math.floor(height);
  /**
   * 根据坐标获取角度
   * @param {number} x - x坐标，左上角为原点
   * @param {number} y - y坐标，左上角为原点
   * @returns {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
   */

  var getAngle = function getAngle(x, y) {
    // 此函数注释内的x、y轴基于 (originX, originY)
    // 计算相对 (originX, originY) 的坐标(dx, dy)
    var dx = x - originX;
    var dy = originY - y; // 在y轴上

    if (dx === 0) {
      return dy < 0 ? // y轴负半轴，
      1 * Math.PI : // y轴正半轴，因此，(originX, originY) 的angle视作0
      0;
    } // 在x轴上


    if (dy === 0) {
      return dx < 0 ? // x轴负半轴
      1.5 * Math.PI : // x轴正半轴
      0.5 * Math.PI;
    }

    var atan = Math.atan(dy / dx);
    /**
     *  2   |  1
     * -----|-----
     *  3   |  4
     */
    // 第一象限，atan > 0
    // 第四象限，atan < 0

    if (dx > 0) {
      return 0.5 * Math.PI - atan;
    } // 第二象限，atan < 0
    // 第三象限，atan > 0


    if (dx < 0) {
      return 1.5 * Math.PI - atan;
    }
  };

  var increasingList = stop.map(function (item) {
    return {
      color: item[0],
      angle: item[1] * Math.PI * 2
    };
  });

  for (var y = 0; y < height; y++) {
    var _loop = function _loop(x) {
      // step 1. 找到当前点坐标相对 (originX, originY) 的角度
      var angle = getAngle(x, y); // step 2. 找到当前点坐标对应的渐变区间

      var j = void 0;

      for (j = 0; j < increasingList.length && increasingList[j].angle <= angle; j++) {}

      var start = increasingList[j - 1];
      var end = increasingList[j];

      if (!(start && end)) {
        // step 2-1. 不在渐变区间里
        return "continue";
      } // step 3. 计算色值并填充


      var factor = (angle - start.angle) / (end.angle - start.angle);
      var color = end.color.map(function (v, idx) {
        return factor * (v - start.color[idx]) + start.color[idx];
      });
      var i = (x + y * width) * 4;
      data[i] = color[0];
      data[i + 1] = color[1];
      data[i + 2] = color[2];
      data[i + 3] = Math.min(255, color[3] * 255);
    };

    for (var x = 0; x < width; x++) {
      var _ret = _loop(x);

      if (_ret === "continue") continue;
    }
  }

  return data;
}

var gradient$1 = {
  getConicGradientImage: getConicGradientImage
};

function canvasPolygon$7(ctx, list) {
  var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (!list || !list.length) {
    return;
  }

  var start = 0;

  for (var i = 0, len = list.length; i < len; i++) {
    var item = list[i];

    if (Array.isArray(item)) {
      start = i;
      break;
    }
  }

  ctx.moveTo(list[start][0] + dx, list[start][1] + dy);

  for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
    var _item = list[_i];

    if (!Array.isArray(_item)) {
      continue;
    }

    if (_item.length === 2) {
      ctx.lineTo(_item[0] + dx, _item[1] + dy);
    } else if (_item.length === 4) {
      ctx.quadraticCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy);
    } else if (_item.length === 6) {
      ctx.bezierCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy, _item[4] + dx, _item[5] + dy);
    }
  }
}

function svgPolygon$7(list) {
  if (!list || !list.length) {
    return '';
  }

  var start = 0;

  for (var i = 0, len = list.length; i < len; i++) {
    var item = list[i];

    if (Array.isArray(item)) {
      start = i;
      break;
    }
  }

  var s = 'M' + list[start][0] + ',' + list[start][1];

  for (var _i2 = start + 1, _len2 = list.length; _i2 < _len2; _i2++) {
    var _item2 = list[_i2];

    if (!Array.isArray(_item2)) {
      continue;
    }

    if (_item2.length === 2) {
      s += 'L' + _item2[0] + ',' + _item2[1];
    } else if (_item2.length === 4) {
      s += 'Q' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3];
    } else if (_item2.length === 6) {
      s += 'C' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3] + ' ' + _item2[4] + ',' + _item2[5];
    }
  }

  return s;
}

function canvasLine(ctx, x1, y1, x2, y2, controlA, controlB, num) {
  var dx = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
  var dy = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
  ctx.moveTo(x1 + dx, y1 + dy);

  if (num === 3) {
    ctx.bezierCurveTo(controlA[0] + dx, controlA[1] + dy, controlB[0] + dx, controlB[1], x2 + dx, y2 + dy);
    return 2;
  } else if (num === 2) {
    ctx.quadraticCurveTo(controlB[0] + dx, controlB[1] + dy, x2 + dx, y2 + dy);
    return 2;
  } else if (num === 1) {
    ctx.quadraticCurveTo(controlA[0] + dx, controlA[1] + dy, x2 + dx, y2 + dy);
    return 2;
  } else {
    ctx.lineTo(x2 + dx, y2 + dy);
    return 1;
  }
}

function svgLine(x1, y1, x2, y2, controlA, controlB, num) {
  if (num === 3) {
    return 'M' + x1 + ',' + y1 + 'C' + controlA[0] + ',' + controlA[1] + ' ' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
  } else if (num === 2) {
    return 'M' + x1 + ',' + y1 + 'Q' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
  } else if (num === 1) {
    return 'M' + x1 + ',' + y1 + 'Q' + controlA[0] + ',' + controlA[1] + ' ' + x2 + ',' + y2;
  } else {
    return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;
  }
}

function canvasFilter(filter) {
  var s = '';
  filter.forEach(function (item) {
    var _item3 = _slicedToArray(item, 2),
        k = _item3[0],
        v = _item3[1];

    if (k === 'blur') {
      s += "blur(".concat(v, "px)");
    } else if (k === 'hue-rotate') {
      s += "hue-rotate(".concat(v, "deg)");
    } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast') {
      s += "".concat(k, "(").concat(v, "%)");
    }
  });
  return s;
}

var painter = {
  canvasPolygon: canvasPolygon$7,
  svgPolygon: svgPolygon$7,
  canvasLine: canvasLine,
  svgLine: svgLine,
  canvasFilter: canvasFilter,
  svgFilter: canvasFilter
};

var H = geom$1.H;
var PX$b = o$4.PX,
    PERCENT$c = o$4.PERCENT,
    REM$g = o$4.REM,
    VW$g = o$4.VW,
    VH$g = o$4.VH;
var canvasPolygon$6 = painter.canvasPolygon,
    svgPolygon$6 = painter.svgPolygon;
var _enums$STYLE_KEY$o = enums.STYLE_KEY,
    BORDER_LEFT_WIDTH$8 = _enums$STYLE_KEY$o.BORDER_LEFT_WIDTH,
    BORDER_TOP_WIDTH$6 = _enums$STYLE_KEY$o.BORDER_TOP_WIDTH,
    BORDER_BOTTOM_WIDTH$6 = _enums$STYLE_KEY$o.BORDER_BOTTOM_WIDTH,
    PADDING_LEFT$7 = _enums$STYLE_KEY$o.PADDING_LEFT,
    PADDING_BOTTOM$5 = _enums$STYLE_KEY$o.PADDING_BOTTOM,
    PADDING_TOP$5 = _enums$STYLE_KEY$o.PADDING_TOP,
    BORDER_TOP_LEFT_RADIUS$2 = _enums$STYLE_KEY$o.BORDER_TOP_LEFT_RADIUS,
    BORDER_TOP_RIGHT_RADIUS$2 = _enums$STYLE_KEY$o.BORDER_TOP_RIGHT_RADIUS,
    BORDER_BOTTOM_LEFT_RADIUS$2 = _enums$STYLE_KEY$o.BORDER_BOTTOM_LEFT_RADIUS,
    BORDER_BOTTOM_RIGHT_RADIUS$2 = _enums$STYLE_KEY$o.BORDER_BOTTOM_RIGHT_RADIUS,
    FONT_SIZE$h = _enums$STYLE_KEY$o.FONT_SIZE;
/* 获取合适的虚线实体空白宽度ps/pd和数量n
 * 总长total，start边长bs，end边长be，内容长w，
 * 实体长范围[smin,smax]，空白长范围[dmin,dmax]
 */

function calFitDashed(total, bs, be, w, smin, smax, dmin, dmax) {
  var n = 1;
  var ps = 1;
  var pd = 1; // 从最大实体空白长开始尝试

  outer: for (var i = smax; i >= smin; i--) {
    for (var j = dmax; j >= dmin; j--) {
      // 已知实体空白长度，n实体和n-1空白组成total，计算获取n数量
      var per = i + j;
      var num = Math.floor((total + j) / per);
      var k = j; // 可能除不尽，此时扩展空白长

      if (num * per < j + total) {
        var free = total - num * i;
        k = free / (num - 1);

        if (k > dmax) {
          continue;
        }
      }

      per = i + k; // bs比实体大才有效，因为小的话必定和第一个实体完整相连

      if (bs > 1 && bs > i) {
        var mo = bs % per;

        if (mo > i) {
          continue;
        }

        if (be > 1) {
          var _mo = (bs + w) % per;

          if (_mo > i) {
            continue;
          }
        }
      }

      if (be > 1) {
        var _mo2 = (bs + w) % per;

        if (_mo2 > i) {
          continue;
        }
      }

      if (num > 0) {
        n = num;
        ps = i;
        pd = k;
      }

      break outer;
    }
  }

  return {
    n: n,
    ps: ps,
    pd: pd
  };
} // dashed时n个实线和n-1虚线默认以3:1宽度组成，dotted则是n和n以1:1组成


function calDashed(style, m1, m2, m3, m4, bw) {
  var total = m4 - m1;
  var w = m3 - m2;
  var bs = m2 - m1;
  var be = m4 - m3;

  if (style === 'dotted') {
    return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
  } else {
    var _calFitDashed = calFitDashed(total, bs, be, w, bw, bw * 3, Math.max(1, bw * 0.25), bw * 2),
        n = _calFitDashed.n,
        ps = _calFitDashed.ps,
        pd = _calFitDashed.pd;

    if (n === 1) {
      return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
    } // 降级为dotted


    return {
      n: n,
      ps: ps,
      pd: pd
    };
  }
} // 获取边框分割为几块的坐标，虚线分割为若干四边形、三边型、五边形
// 三边形重复内外边交点形成四边形，五边形进行切割形成2个四边形
// direction为上右下左0123


function calPoints(borderWidth, borderStyle, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, direction, beginRadius, endRadius) {
  var points = [];

  if (['dashed', 'dotted'].indexOf(borderStyle) > -1) {
    // 寻找一个合适的虚线线段长度和之间空白边距长度
    var _ref = direction === 0 || direction === 2 ? calDashed(borderStyle, x1, x2, x3, x4, borderWidth) : calDashed(borderStyle, y1, y2, y3, y4, borderWidth),
        n = _ref.n,
        ps = _ref.ps,
        pd = _ref.pd;

    if (n > 1) {
      for (var i = 0; i < n; i++) {
        // 最后一个可能没有到底，延长之
        var isLast = i === n - 1;
        var main1 = void 0;
        var main2 = void 0;
        var cross1 = void 0;
        var cross2 = void 0;

        if (direction === 0 || direction === 2) {
          main1 = i ? x1 + ps * i + pd * i : x1;
        } else {
          main1 = i ? y1 + ps * i + pd * i : y1;
        }

        main2 = main1 + ps;

        if (direction === 0) {
          // 整个和borderLeft重叠
          if (main2 <= x2) {
            if (isLast) {
              points.push([[x1, y1], [x4, y1], [x3, y2], [x2, y2]]);
            } else {
              cross1 = y1 + (main1 - x1) * Math.tan(deg1);
              cross2 = y1 + (main2 - x1) * Math.tan(deg1);
              points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
            }
          } // 整个和borderRight重叠
          else if (main1 >= x3) {
            cross1 = y1 + (x4 - main1) * Math.tan(deg2);
            cross2 = y1 + (x4 - main2) * Math.tan(deg2);

            if (isLast) {
              points.push([[main1, y1], [x4, y1], [x4, y1], [main1, cross1]]);
            } else {
              points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
            }
          } // 不被整个重叠的情况再细分
          else {
            // 上部分和borderLeft重叠
            if (main1 < x2) {
              cross1 = y1 + (main1 - x1) * Math.tan(deg1);
              points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross1]]);

              if (isLast) {
                points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                points.push([[x3, y1], [x4, y1], [x4, y1], [x2, y2]]);
              } else {
                // 下部分和borderRight重叠
                if (main2 > x3) {
                  cross2 = y1 + (x4 - main2) * Math.tan(deg2);
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                  points.push([[x3, y1], [main2, y1], [main2, cross2], [x3, y2]]);
                } // 下部独立
                else {
                  points.push([[x2, y1], [main2, y1], [main2, y2], [x2, y2]]);
                }
              }
            } // 下部分和borderRight重叠
            else if (main2 > x3) {
              cross1 = y1 + (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

              if (main1 < x2) {
                cross2 = y1 + (main1 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross2]]);
                points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

                if (isLast) {
                  points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                } else {
                  points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                }
              } // 上部独立
              else {
                points.push([[main1, y1], [x3, y1], [x3, y2], [main1, y2]]);

                if (isLast) {
                  points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                } else {
                  points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                }
              }
            } // 完全独立
            else {
              if (isLast) {
                points.push([[main1, y1], [x4, y1], [x3, y2], [main1, y2]]);
              } else {
                points.push([[main1, y1], [main2, y1], [main2, y2], [main1, y2]]);
              }
            }
          }
        } else if (direction === 1) {
          // 整个和borderTop重叠
          if (main2 <= y2) {
            if (isLast) {
              points.push([[x3, y2], [x4, y1], [x4, y4], [x3, y3]]);
            } else {
              cross1 = x4 - (main1 - y1) * Math.tan(deg1);
              cross2 = x4 - (main2 - y1) * Math.tan(deg1);
              points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
            }
          } // 整个和borderBottom重叠
          else if (main1 >= y3) {
            cross1 = x3 + (main1 - y3) * Math.tan(deg2);
            cross2 = x3 + (main2 - y3) * Math.tan(deg2);

            if (isLast) {
              points.push([[cross1, main1], [x4, main1], [x4, y4], [x4, y4]]);
            } else {
              points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
            }
          } // 不被整个重叠的情况再细分
          else {
            // 上部分和borderTop重叠
            if (main1 < y2) {
              cross1 = x3 + (y2 - main1) * Math.tan(deg1);
              points.push([[cross1, main1], [x4, main1], [x4, y2], [x3, y2]]);

              if (isLast) {
                points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
              } else {
                // 下部分和borderBottom重叠
                if (main2 > y3) {
                  cross2 = x3 + (main2 - y3) * Math.tan(deg2);
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                  points.push([[x3, y3], [x4, y3], [x4, main2], [cross2, main2]]);
                } // 下部独立
                else {
                  points.push([[x3, y2], [x4, y2], [x4, main2], [x3, main2]]);
                }
              }
            } // 下部分和borderBottom重叠
            else if (main2 > y3) {
              cross1 = x3 + (main2 - y3) * Math.tan(deg2); // 上部分和borderTop重叠

              if (main1 < y2) {
                cross2 = x3 + (y2 - main1) * Math.tan(deg1);
                points.push([[cross2, main1], [x4, main1], [x4, y2], [x3, y2]]);
                points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

                if (isLast) {
                  points.push([[x3, y3], [x4, y3], [x4, x4], [x4, x4]]);
                } else {
                  points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                }
              } // 上部独立
              else {
                points.push([[x3, main1], [x4, main1], [x4, y3], [x3, y3]]);

                if (isLast) {
                  points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                } else {
                  points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                }
              }
            } // 完全独立
            else {
              if (isLast) {
                points.push([[x3, main1], [x4, main1], [x4, y4], [x3, y3]]);
              } else {
                points.push([[x3, main1], [x4, main1], [x4, main2], [x3, main2]]);
              }
            }
          }
        } else if (direction === 2) {
          // 整个和borderLeft重叠
          if (main2 <= x2) {
            if (isLast) {
              points.push([[x1, y4], [x2, y3], [x3, y3], [x4, y4]]);
            } else {
              cross1 = y4 - (main1 - x1) * Math.tan(deg1);
              cross2 = y4 - (main2 - x1) * Math.tan(deg1);
              points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
            }
          } // 整个和borderRight重叠
          else if (main1 >= x3) {
            cross1 = y4 - (x4 - main1) * Math.tan(deg2);
            cross2 = y4 - (x4 - main2) * Math.tan(deg2);

            if (isLast) {
              points.push([[main1, cross1], [x4, y4], [x4, y4], [main1, y4]]);
            } else {
              points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
            }
          } // 不被整个重叠的情况再细分
          else {
            // 上部分和borderLeft重叠
            if (main1 < x2) {
              cross1 = y4 - (main1 - x1) * Math.tan(deg1);
              points.push([[main1, cross1], [x2, y3], [x2, y4], [main1, y4]]);

              if (isLast) {
                points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
              } else {
                // 下部分和borderRight重叠
                if (main2 > x3) {
                  cross2 = y4 - (main2 - x3) * Math.tan(deg2);
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                  points.push([[x3, y3], [main2, cross2], [main2, y4], [x3, y4]]);
                } // 下部独立
                else {
                  points.push([[x2, y3], [main2, y3], [main2, y4], [x2, y4]]);
                }
              }
            } // 下部分和borderRight重叠
            else if (main2 > x3) {
              cross1 = y4 - (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

              if (main1 < x2) {
                cross2 = y4 - (main1 - x3) * Math.tan(deg1);
                points.push([[main1, cross2], [x2, y3], [x2, y4], [main1, y4]]);
                points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

                if (isLast) {
                  points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                } else {
                  points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                }
              } // 上部独立
              else {
                points.push([[main1, y3], [x3, y3], [x3, y4], [main1, y4]]);

                if (isLast) {
                  points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                } else {
                  points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                }
              }
            } // 完全独立
            else {
              if (isLast) {
                points.push([[main1, y3], [x3, y3], [x4, y4], [main1, y4]]);
              } else {
                points.push([[main1, y3], [main2, y3], [main2, y4], [main1, y4]]);
              }
            }
          }
        } else if (direction === 3) {
          // 整个和borderTop重叠
          if (main2 <= y2) {
            if (isLast) {
              points.push([[x1, y1], [x2, y2], [x2, y3], [x1, y4]]);
            } else {
              cross1 = x1 + (main1 - y1) * Math.tan(deg1);
              cross2 = x1 + (main2 - y1) * Math.tan(deg1);
              points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
            }
          } // 整个和borderBottom重叠
          else if (main1 >= y3) {
            cross1 = x1 + (y4 - main1) * Math.tan(deg2);
            cross2 = x1 + (y4 - main2) * Math.tan(deg2);

            if (isLast) {
              points.push([[x1, main1], [cross1, main1], [x1, y4], [x1, y4]]);
            } else {
              points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
            }
          } // 不被整个重叠的情况再细分
          else {
            // 上部分和borderTop重叠
            if (main1 < y2) {
              cross1 = x1 + (main1 - y1) * Math.tan(deg1);
              points.push([[x1, main1], [cross1, main1], [x2, y2], [x1, y2]]);

              if (isLast) {
                points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
              } else {
                // 下部分和borderBottom重叠
                if (main2 > y3) {
                  cross2 = x1 + (y4 - main2) * Math.tan(deg2);
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                  points.push([[x1, y3], [x2, y3], [cross2, main2], [x1, main2]]);
                } // 下部独立
                else {
                  points.push([[x1, y2], [x2, y2], [x2, main2], [x1, main2]]);
                }
              }
            } // 下部分和borderBottom重叠
            else if (main2 > y3) {
              cross1 = x1 + (y4 - main2) * Math.tan(deg2); // 上部分和borderTop重叠

              if (main1 < y2) {
                cross2 = x1 + (main1 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross2, main1], [x2, y2], [x1, y1]]);
                points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

                if (isLast) {
                  points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                } else {
                  points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                }
              } // 上部独立
              else {
                points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y3]]);

                if (isLast) {
                  points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                } else {
                  points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                }
              }
            } // 完全独立
            else {
              if (isLast) {
                points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y4]]);
              } else {
                points.push([[x1, main1], [x2, main1], [x2, main2], [x1, main2]]);
              }
            }
          }
        }
      }

      if (direction === 0) {
        return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
      } else if (direction === 1) {
        return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
      } else if (direction === 2) {
        return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
      } else if (direction === 3) {
        return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
      }
    }
  } // 兜底返回实线


  if (direction === 0) {
    if (x2 > x1) {
      points.push([[x1, y1], [x2, y1], [x2, y2], [x1, y1]]);
    }

    points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

    if (x4 > x3) {
      points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
    }

    return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
  } else if (direction === 1) {
    if (y2 > y1) {
      points.push([[x4, y1], [x4, y1], [x4, y2], [x3, y2]]);
    }

    points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

    if (y4 > y3) {
      points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
    }

    return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
  } else if (direction === 2) {
    if (x2 > x1) {
      points.push([[x1, y4], [x2, y3], [x2, y4], [x1, y4]]);
    }

    points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

    if (x4 > x3) {
      points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
    }

    return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
  } else if (direction === 3) {
    if (y2 > y1) {
      points.push([[x1, y1], [x1, y1], [x2, y2], [x1, y2]]);
    }

    points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

    if (y4 > y3) {
      points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
    }

    return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
  }
}

function calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
  var _beginRadius = _slicedToArray(beginRadius, 2),
      brx = _beginRadius[0],
      bry = _beginRadius[1];

  var _endRadius = _slicedToArray(endRadius, 2),
      erx = _endRadius[0],
      ery = _endRadius[1]; // 一条边的两侧圆角均为0时无效


  if ((!brx || !bry) && (!erx || !ery)) {
    return pointsList;
  } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


  var oxl = x2 + brx - (x2 - x1);
  var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
  // 也有可能左右圆角相接，跨越的只分为左右2份
  // 最终左圆角内的存入begin，右圆角内的存入end，中间center

  var beginList = [];
  var centerList = [];
  var endList = [];

  for (var i = 0, len = pointsList.length; i < len; i++) {
    var points = pointsList[i]; // 全在左圆角

    if (points[1][0] < oxl) {
      beginList.push(points);
    } // 全在右圆角
    else if (points[0][0] > oxr) {
      endList.push(points);
    } // 跨越左右圆角
    else if (points[1][0] > oxr && points[0][0] < oxl) {
      var ya = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;
      var yb = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
      beginList.push([points[0], [oxl, y1], [oxl, ya], points[3]]);

      if (oxl < oxr) {
        if (oxl > x2 && oxr < x3) {
          centerList.push([[oxl, y1], [oxr, y1], [oxr, y2], [oxl, y2]]);
        } else if (oxl > x2) {
          centerList.push([[oxl, y1], [x3, y1], [x3, y2], [oxl, y2]]);
          centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
        } else if (oxr < x3) {
          centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
          centerList.push([[x2, y1], [oxr, y1], [oxr, y2], [x2, y2]]);
        } else {
          centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
          centerList.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
          centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
        }
      }

      endList.push([[oxr, y1], points[1], points[2], [oxr, yb]]);
    } // 跨越右圆角
    else if (points[1][0] > oxr) {
      var y = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
      centerList.push([points[0], [oxr, y1], [oxr, y], points[3]]);
      endList.push([[oxr, y1], points[1], points[2], [oxr, y]]);
    } // 跨越左圆角
    else if (points[0][0] < oxl) {
      var _y = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;

      beginList.push([points[0], [oxl, y1], [oxl, _y], points[3]]);
      centerList.push([[oxl, y1], points[1], points[2], [oxl, _y]]);
    } else {
      centerList.push(points);
    }
  }

  var beginLength = beginList.length;

  if (beginLength) {
    // 边宽可能大于圆角尺寸，边的里面无需圆弧化
    var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

    var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
    var rx1 = brx;
    var ry1 = bry;
    var sx1 = ry1 / rx1;
    var oyl = y1 + bry;
    var rx2 = brx - (x2 - x1);
    var ry2 = bry - (y2 - y1);
    var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

    var xa, _ya, xb, _yb;

    var ca = calBezierTopLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

    var _ca$ = _slicedToArray(ca[0], 2);

    xa = _ca$[0];
    _ya = _ca$[1];
    var cb;

    if (needInner) {
      cb = calBezierTopLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

      var _cb$ = _slicedToArray(cb[0], 2);

      xb = _cb$[0];
      _yb = _cb$[1];
    }

    beginList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === 0) {
        controls1 = ca;

        if (needInner) {
          controls2 = cb;
        }
      } else {
        controls1 = calBezierTopLeft(points[0], points[1], oxl, oyl, sx1, ry1);

        if (needInner) {
          controls2 = calBezierTopLeft(points[3], points[2], oxl, oyl, sx2, ry2);
        }
      }

      for (var _i = 0, _len = controls1.length; _i < _len; _i++) {
        limit(controls1[_i], xa, _ya, 0);
      }

      points[0] = controls1[0];
      points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);

      if (needInner) {
        for (var _i2 = 0, _len2 = controls2.length; _i2 < _len2; _i2++) {
          limit(controls2[_i2], xb, _yb, 0);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[3];
          points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
        }
      }
    });
  }

  var endLength = endList.length;

  if (endLength) {
    // 边宽可能大于圆角尺寸，边的里面无需圆弧化
    var _needInner = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


    var _crossDeg = Math.atan((x4 - x3) / (y2 - y1));

    var _rx = erx;
    var _ry = ery;

    var _sx = _ry / _rx;

    var oyr = y1 + ery;

    var _rx2 = erx - (x4 - x3);

    var _ry2 = ery - (y2 - y1);

    var _sx2 = _ry2 / _rx2; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


    var _xa, _ya2, _xb, _yb2;

    var _ca = calBezierTopRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx, _ry, true, Math.tan(_crossDeg) * _ry);

    var _ca2 = _slicedToArray(_ca[_ca.length - 1], 2);

    _xa = _ca2[0];
    _ya2 = _ca2[1];

    var _cb;

    if (_needInner) {
      _cb = calBezierTopRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx2, _ry2, true, Math.tan(_crossDeg) * _ry2);

      var _cb2 = _slicedToArray(_cb[_cb.length - 1], 2);

      _xb = _cb2[0];
      _yb2 = _cb2[1];
    }

    endList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === endLength - 1) {
        controls1 = _ca;

        if (_needInner) {
          controls2 = _cb;
        }
      } else {
        controls1 = calBezierTopRight(points[0], points[1], oxr, oyr, _sx, _ry);

        if (_needInner) {
          controls2 = calBezierTopRight(points[3], points[2], oxr, oyr, _sx2, _ry2);
        }
      }

      for (var _i3 = 0, _len3 = controls1.length; _i3 < _len3; _i3++) {
        limit(controls1[_i3], _xa, _ya2, 1);
      }

      points[0] = controls1[0];
      points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);

      if (_needInner) {
        for (var _i4 = 0, _len4 = controls2.length; _i4 < _len4; _i4++) {
          limit(controls2[_i4], _xb, _yb2, 1);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[3];
          points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
        }
      }
    });
  }

  return beginList.concat(centerList).concat(endList);
}

function calBezierTopLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p = _slicedToArray(p1, 2),
      p1x = _p[0],
      p1y = _p[1];

  var _p2 = _slicedToArray(p2, 2),
      p2x = _p2[0],
      p2y = _p2[1];

  var dx1 = -p1x + ox;
  var dsx1 = dx1 * sx;
  var dx2 = -p2x + ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx2 = ox - Math.sin(deg2) * r / sx;
  var cpy2 = oy - Math.cos(deg2) * r;
  var deg1;
  var cpx1;
  var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

  if (isStart) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg1 = Math.PI * 0.5 - alpha;
    cpx1 = ox - Math.cos(alpha) * r / sx;
    cpy1 = oy - Math.sin(alpha) * r;
  } else {
    deg1 = Math.atan(dsx1 / (oy - p1y));
    cpx1 = ox - Math.sin(deg1) * r / sx;
    cpy1 = oy - Math.cos(deg1) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 - degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox - cdx1 / sx;
  var cy1 = oy - cdy1;
  var degTg2 = deg2 + degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox - cdx2 / sx;
  var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(p1x, p1y, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(p2x, p2y, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
}

function calBezierTopRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p3 = _slicedToArray(p1, 2),
      p1x = _p3[0],
      p1y = _p3[1];

  var _p4 = _slicedToArray(p2, 2),
      p2x = _p4[0],
      p2y = _p4[1];

  var dx1 = p1x - ox;
  var dsx1 = dx1 * sx;
  var dx2 = p2x - ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg1 = Math.atan(dsx1 / (oy - p1y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx1 = ox + Math.sin(deg1) * r / sx;
  var cpy1 = oy - Math.cos(deg1) * r;
  var deg2;
  var cpx2;
  var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

  if (isEnd) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg2 = Math.PI * 0.5 - alpha;
    cpx2 = ox + Math.cos(alpha) * r / sx;
    cpy2 = oy - Math.sin(alpha) * r;
  } else {
    deg2 = Math.atan(dsx2 / (oy - p2y));
    cpx2 = ox + Math.sin(deg2) * r / sx;
    cpy2 = oy - Math.cos(deg2) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 + degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox + cdx1 / sx;
  var cy1 = oy - cdy1;
  var degTg2 = deg2 - degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox + cdx2 / sx;
  var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
}

function calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
  var _beginRadius2 = _slicedToArray(beginRadius, 2),
      brx = _beginRadius2[0],
      bry = _beginRadius2[1];

  var _endRadius2 = _slicedToArray(endRadius, 2),
      erx = _endRadius2[0],
      ery = _endRadius2[1]; // 一条边的两侧圆角均为0时无效


  if ((!brx || !bry) && (!erx || !ery)) {
    return pointsList;
  } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


  var oyt = y2 + bry - (y2 - y1);
  var oyb = y3 - ery + (y4 - y3);
  var beginList = [];
  var centerList = [];
  var endList = []; // 同borderTop拆分

  for (var i = 0, len = pointsList.length; i < len; i++) {
    var points = pointsList[i]; // 全在上圆角

    if (points[2][1] < oyt) {
      beginList.push(points);
    } // 全在下圆角
    else if (points[1][1] > oyb) {
      endList.push(points);
    } // 跨越上下圆角
    else if (points[2][1] > oyb && points[1][1] < oyt) {
      var xa = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;
      var xb = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
      beginList.push([points[0], points[1], [x4, oyt], [xa, oyt]]);

      if (oyt < oyb) {
        if (oyb < y3 && oyt > y2) {
          centerList.push([[x3, oyt], [x4, oyt], [x4, oyb], [x3, oyb]]);
        } else if (oyt > y2) {
          centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
          centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
        } else if (oyb < y3) {
          centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
          centerList.push([[x3, y2], [x4, y2], [x4, oyb], [x3, oyb]]);
        } else {
          centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
          centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
          centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
        }
      }

      endList.push([[xb, oyb], [x4, oyb], points[2], points[3]]);
    } // 跨越下圆角
    else if (points[2][1] > oyb) {
      var x = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
      centerList.push([points[0], points[1], [x4, oyb], [x, oyb]]);
      endList.push([[x, oyb], [x4, oyb], points[2], points[3]]);
    } // 跨越上圆角
    else if (points[1][1] < oyt) {
      var _x = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;

      beginList.push([points[0], points[1], [x4, oyt], [_x, oyt]]);
      centerList.push([[_x, oyt], [x4, oyt], points[2], points[3]]);
    } else {
      centerList.push(points);
    }
  }

  var beginLength = beginList.length;

  if (beginLength) {
    var needInner = bry > y2 - y1 && borderWidth < brx;
    var crossDeg = Math.atan((x4 - x3) / (y2 - y1));
    var rx1 = brx;
    var ry1 = bry;
    var sx1 = ry1 / rx1;
    var oxt = x4 - brx;
    var rx2 = brx - (x4 - x3);
    var ry2 = bry - (y2 - y1);
    var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

    var _xa2, ya, _xb2, yb;

    var ca = calBezierRightTop(beginList[0][1], beginList[0][2], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

    var _ca3 = _slicedToArray(ca[ca.length - 1], 2);

    _xa2 = _ca3[0];
    ya = _ca3[1];
    var cb;

    if (needInner) {
      cb = calBezierRightTop(beginList[0][0], beginList[0][3], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

      var _cb3 = _slicedToArray(cb[cb.length - 1], 2);

      _xb2 = _cb3[0];
      yb = _cb3[1];
    }

    beginList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === 0) {
        controls1 = ca;

        if (needInner) {
          controls2 = cb;
        }
      } else {
        controls1 = calBezierRightTop(points[1], points[2], oxt, oyt, sx1, ry1);

        if (needInner) {
          controls2 = calBezierRightTop(points[0], points[3], oxt, oyt, sx2, ry2);
        }
      }

      for (var _i5 = 0, _len5 = controls1.length; _i5 < _len5; _i5++) {
        limit(controls1[_i5], _xa2, ya, 2);
      }

      if (needInner) {
        for (var _i6 = 0, _len6 = controls2.length; _i6 < _len6; _i6++) {
          limit(controls2[_i6], _xb2, yb, 2);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[0];
          points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
        }
      } else {
        points[2] = points[3];
        points[3] = points[0];
      }

      points[0] = controls1[3];
      points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
    });
  }

  var endLength = endList.length;

  if (endLength) {
    var _needInner2 = ery > y4 - y3 && borderWidth < erx;

    var _crossDeg2 = Math.atan((x4 - x3) / (y4 - y3));

    var _rx3 = erx;
    var _ry3 = ery;

    var _sx3 = _ry3 / _rx3;

    var oxb = x4 - erx;

    var _rx4 = erx - (x4 - x3);

    var _ry4 = ery - (y4 - y3);

    var _sx4 = _ry4 / _rx4; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


    var _xa3, _ya3, _xb3, _yb3;

    var _ca4 = calBezierRightBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx3, _ry3, true, Math.tan(_crossDeg2) * _ry3);

    var _ca4$ = _slicedToArray(_ca4[0], 2);

    _xa3 = _ca4$[0];
    _ya3 = _ca4$[1];

    var _cb4;

    if (_needInner2) {
      _cb4 = calBezierRightBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx4, _ry4, true, Math.tan(_crossDeg2) * _ry4);

      var _cb4$ = _slicedToArray(_cb4[0], 2);

      _xb3 = _cb4$[0];
      _yb3 = _cb4$[1];
    }

    endList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === endLength - 1) {
        controls1 = _ca4;

        if (_needInner2) {
          controls2 = _cb4;
        }
      } else {
        controls1 = calBezierRightBottom(points[1], points[2], oxb, oyb, _sx3, _ry3);

        if (_needInner2) {
          controls2 = calBezierRightBottom(points[0], points[3], oxb, oyb, _sx4, _ry4);
        }
      }

      for (var _i7 = 0, _len7 = controls1.length; _i7 < _len7; _i7++) {
        limit(controls1[_i7], _xa3, _ya3, 3);
      }

      if (_needInner2) {
        for (var _i8 = 0, _len8 = controls2.length; _i8 < _len8; _i8++) {
          limit(controls2[_i8], _xb3, _yb3, 3);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[0];
          points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
        }
      } else {
        points[2] = points[3];
        points[3] = points[0];
      }

      points[0] = controls1[3];
      points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
    });
  }

  return beginList.concat(centerList).concat(endList);
}

function calBezierRightTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p5 = _slicedToArray(p1, 2),
      p1x = _p5[0],
      p1y = _p5[1];

  var _p6 = _slicedToArray(p2, 2),
      p2x = _p6[0],
      p2y = _p6[1];

  var dx1 = p1x - ox;
  var dsx1 = dx1 * sx;
  var dx2 = p2x - ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx2 = ox + Math.sin(deg2) * r / sx;
  var cpy2 = oy - Math.cos(deg2) * r;
  var deg1;
  var cpx1;
  var cpy1;

  if (isStart) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg1 = Math.PI * 0.5 - alpha;
    cpx1 = ox + Math.cos(alpha) * r / sx;
    cpy1 = oy - Math.sin(alpha) * r;
  } else {
    deg1 = Math.atan(dsx1 / (oy - p1y));
    cpx1 = ox + Math.sin(deg1) * r / sx;
    cpy1 = oy - Math.cos(deg1) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 + degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox + cdx1 / sx;
  var cy1 = oy - cdy1;
  var degTg2 = deg2 - degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox + cdx2 / sx;
  var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
}

function calBezierRightBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p7 = _slicedToArray(p1, 2),
      p1x = _p7[0],
      p1y = _p7[1];

  var _p8 = _slicedToArray(p2, 2),
      p2x = _p8[0],
      p2y = _p8[1];

  var dx1 = p1x - ox;
  var dsx1 = dx1 * sx;
  var dx2 = p2x - ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx1 = ox + Math.sin(deg1) * r / sx;
  var cpy1 = oy + Math.cos(deg1) * r;
  var deg2;
  var cpx2;
  var cpy2;

  if (isEnd) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg2 = Math.PI * 0.5 - alpha;
    cpx2 = ox + Math.cos(alpha) * r / sx;
    cpy2 = oy + Math.sin(alpha) * r;
  } else {
    deg2 = Math.atan(dsx2 / (p2y - oy));
    cpx2 = ox + Math.sin(deg2) * r / sx;
    cpy2 = oy + Math.cos(deg2) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 - degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox + cdx1 / sx;
  var cy1 = oy + cdy1;
  var degTg2 = deg2 + degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox + cdx2 / sx;
  var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
}

function calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
  var _beginRadius3 = _slicedToArray(beginRadius, 2),
      brx = _beginRadius3[0],
      bry = _beginRadius3[1];

  var _endRadius3 = _slicedToArray(endRadius, 2),
      erx = _endRadius3[0],
      ery = _endRadius3[1]; // 一条边的两侧圆角均为0时无效


  if ((!brx || !bry) && (!erx || !ery)) {
    return pointsList;
  } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


  var oxl = x2 + brx - (x2 - x1);
  var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
  // 也有可能左右圆角相接，跨越的只分为左右2份
  // 最终左圆角内的存入begin，右圆角内的存入end，中间center

  var beginList = [];
  var centerList = [];
  var endList = [];

  for (var i = 0, len = pointsList.length; i < len; i++) {
    var points = pointsList[i]; // 全在左圆角

    if (points[2][0] < oxl) {
      beginList.push(points);
    } // 全在右圆角
    else if (points[3][0] > oxr) {
      endList.push(points);
    } // 跨越左右圆角
    else if (points[2][0] > oxr && points[3][0] < oxl) {
      var ya = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y2;
      var yb = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
      beginList.push([points[0], [oxl, ya], [oxl, y4], points[3]]);

      if (oxl < oxr) {
        if (oxl > x2 && oxr < x3) {
          centerList.push([[oxl, y3], [oxr, y3], [oxr, y4], [oxl, y4]]);
        } else if (oxl > x2) {
          centerList.push([[oxl, y3], [x3, y3], [x3, y4], [oxl, y4]]);
          centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
        } else if (oxr < x3) {
          centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
          centerList.push([[x2, y3], [oxr, y3], [oxr, y4], [x2, y4]]);
        } else {
          centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
          centerList.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
          centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
        }
      }

      endList.push([[oxr, yb], points[1], points[2], [oxr, y4]]);
    } // 跨越右圆角
    else if (points[2][0] > oxr) {
      var y = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
      centerList.push([points[0], [oxr, y], [oxr, y4], points[3]]);
      endList.push([[oxr, y], points[1], points[2], [oxr, y4]]);
    } // 跨越左圆角
    else if (points[3][0] < oxl) {
      var _y2 = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y3;

      beginList.push([points[0], [oxl, _y2], [oxl, y4], points[3]]);
      centerList.push([[oxl, _y2], points[1], points[2], [oxl, y4]]);
    } else {
      centerList.push(points);
    }
  }

  var beginLength = beginList.length;

  if (beginLength) {
    // 边宽可能大于圆角尺寸，边的里面无需圆弧化
    var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

    var crossDeg = Math.atan((x2 - x1) / (y4 - y3));
    var rx1 = brx;
    var ry1 = bry;
    var sx1 = ry1 / rx1;
    var oyl = y4 - bry;
    var rx2 = brx - (x2 - x1);
    var ry2 = bry - (y4 - y3);
    var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

    var xa, _ya4, xb, _yb4;

    var ca = calBezierBottomLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

    var _ca$2 = _slicedToArray(ca[0], 2);

    xa = _ca$2[0];
    _ya4 = _ca$2[1];
    var cb;

    if (needInner) {
      cb = calBezierBottomLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

      var _cb$2 = _slicedToArray(cb[0], 2);

      xb = _cb$2[0];
      _yb4 = _cb$2[1];
    }

    beginList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === 0) {
        controls1 = ca;

        if (needInner) {
          controls2 = cb;
        }
      } else {
        controls1 = calBezierBottomLeft(points[3], points[2], oxl, oyl, sx1, ry1);

        if (needInner) {
          controls2 = calBezierBottomLeft(points[0], points[1], oxl, oyl, sx2, ry2);
        }
      }

      for (var _i9 = 0, _len9 = controls1.length; _i9 < _len9; _i9++) {
        limit(controls1[_i9], xa, _ya4, 4);
      }

      if (needInner) {
        for (var _i10 = 0, _len10 = controls2.length; _i10 < _len10; _i10++) {
          limit(controls2[_i10], xb, _yb4, 4);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[3];
          points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
        }
      } else {
        points[2] = points[1];
        points[3] = points[0];
      }

      points[0] = controls1[0];
      points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
    });
  }

  var endLength = endList.length;

  if (endLength) {
    // 边宽可能大于圆角尺寸，边的里面无需圆弧化
    var _needInner3 = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


    var _crossDeg3 = Math.atan((x4 - x3) / (y4 - y3));

    var _rx5 = erx;
    var _ry5 = ery;

    var _sx5 = _ry5 / _rx5;

    var oyr = y4 - ery;

    var _rx6 = erx - (x4 - x3);

    var _ry6 = ery - (y4 - y3);

    var _sx6 = _ry6 / _rx6; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


    var _xa4, _ya5, _xb4, _yb5;

    var _ca5 = calBezierBottomRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx5, _ry5, true, Math.tan(_crossDeg3) * _ry5);

    var _ca6 = _slicedToArray(_ca5[_ca5.length - 1], 2);

    _xa4 = _ca6[0];
    _ya5 = _ca6[1];

    var _cb5;

    if (_needInner3) {
      _cb5 = calBezierBottomRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx6, _ry6, true, Math.tan(_crossDeg3) * _ry6);

      var _cb6 = _slicedToArray(_cb5[_cb5.length - 1], 2);

      _xb4 = _cb6[0];
      _yb5 = _cb6[1];
    }

    endList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === endLength - 1) {
        controls1 = _ca5;

        if (_needInner3) {
          controls2 = _cb5;
        }
      } else {
        controls1 = calBezierBottomRight(points[3], points[2], oxr, oyr, _sx5, _ry5);

        if (_needInner3) {
          controls2 = calBezierBottomRight(points[0], points[1], oxr, oyr, _sx6, _ry6);
        }
      }

      for (var _i11 = 0, _len11 = controls1.length; _i11 < _len11; _i11++) {
        limit(controls1[_i11], _xa4, _ya5, 5);
      }

      if (_needInner3) {
        for (var _i12 = 0, _len12 = controls2.length; _i12 < _len12; _i12++) {
          limit(controls2[_i12], _xb4, _yb5, 5);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[3];
          points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
        }
      } else {
        points[2] = points[1];
        points[3] = points[0];
      }

      points[0] = controls1[0];
      points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
    });
  }

  return beginList.concat(centerList).concat(endList);
}

function calBezierBottomLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p9 = _slicedToArray(p1, 2),
      p1x = _p9[0],
      p1y = _p9[1];

  var _p10 = _slicedToArray(p2, 2),
      p2x = _p10[0],
      p2y = _p10[1];

  var dx1 = -p1x + ox;
  var dsx1 = dx1 * sx;
  var dx2 = -p2x + ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg2 = Math.atan(dsx2 / (p2y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx2 = ox - Math.sin(deg2) * r / sx;
  var cpy2 = oy + Math.cos(deg2) * r;
  var deg1;
  var cpx1;
  var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

  if (isStart) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg1 = Math.PI * 0.5 - alpha;
    cpx1 = ox - Math.cos(alpha) * r / sx;
    cpy1 = oy + Math.sin(alpha) * r;
  } else {
    deg1 = Math.atan(dsx1 / (p1y - oy));
    cpx1 = ox - Math.sin(deg1) * r / sx;
    cpy1 = oy + Math.cos(deg1) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 - degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox - cdx1 / sx;
  var cy1 = oy + cdy1;
  var degTg2 = deg2 + degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox - cdx2 / sx;
  var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
}

function calBezierBottomRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p11 = _slicedToArray(p1, 2),
      p1x = _p11[0],
      p1y = _p11[1];

  var _p12 = _slicedToArray(p2, 2),
      p2x = _p12[0],
      p2y = _p12[1];

  var dx1 = p1x - ox;
  var dsx1 = dx1 * sx;
  var dx2 = p2x - ox;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx1 = ox + Math.sin(deg1) * r / sx;
  var cpy1 = oy + Math.cos(deg1) * r;
  var deg2;
  var cpx2;
  var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

  if (isEnd) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg2 = Math.PI * 0.5 - alpha;
    cpx2 = ox + Math.cos(alpha) * r / sx;
    cpy2 = oy + Math.sin(alpha) * r;
  } else {
    deg2 = Math.atan(dsx2 / (p2y - oy));
    cpx2 = ox + Math.sin(deg2) * r / sx;
    cpy2 = oy + Math.cos(deg2) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 + degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox + cdx1 / sx;
  var cy1 = oy + cdy1;
  var degTg2 = deg2 - degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox + cdx2 / sx;
  var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
}

function calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
  var _beginRadius4 = _slicedToArray(beginRadius, 2),
      brx = _beginRadius4[0],
      bry = _beginRadius4[1];

  var _endRadius4 = _slicedToArray(endRadius, 2),
      erx = _endRadius4[0],
      ery = _endRadius4[1]; // 一条边的两侧圆角均为0时无效


  if ((!brx || !bry) && (!erx || !ery)) {
    return pointsList;
  } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


  var oyt = y2 + bry - (y2 - y1);
  var oyb = y3 - ery + (y4 - y3);
  var beginList = [];
  var centerList = [];
  var endList = []; // 同borderTop拆分

  for (var i = 0, len = pointsList.length; i < len; i++) {
    var points = pointsList[i]; // 全在上圆角

    if (points[3][1] < oyt) {
      beginList.push(points);
    } // 全在下圆角
    else if (points[0][1] > oyb) {
      endList.push(points);
    } // 跨越上下圆角
    else if (points[3][1] > oyb && points[0][1] < oyt) {
      var xa = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;
      var xb = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
      beginList.push([points[0], points[1], [xa, oyt], [x1, oyt]]);

      if (oyt < oyb) {
        if (oyb < y3 && oyt > y2) {
          centerList.push([[x1, oyt], [x2, oyt], [x2, oyb], [x1, oyb]]);
        } else if (oyt > y2) {
          centerList.push([[x1, oyt], [x2, oyt], [x2, y3], [x1, y3]]);
          centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
        } else if (oyb < y3) {
          centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
          centerList.push([[x1, y2], [x2, y2], [x2, oyb], [x1, oyb]]);
        } else {
          centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
          centerList.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
          centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
        }
      }

      endList.push([[x1, oyb], [xb, oyb], points[2], points[3]]);
    } // 跨越下圆角
    else if (points[3][1] > oyb) {
      var x = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
      centerList.push([points[0], points[1], [x, oyb], [x1, oyb]]);
      endList.push([[x1, oyb], [x, oyb], points[2], points[3]]);
    } // 跨越上圆角
    else if (points[1][1] < oyt) {
      var _x2 = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;

      beginList.push([points[0], points[1], [_x2, oyt], [x1, oyt]]);
      centerList.push([[x1, oyt], [_x2, oyt], points[2], points[3]]);
    } else {
      centerList.push(points);
    }
  }

  var beginLength = beginList.length;

  if (beginLength) {
    var needInner = bry > y2 - y1 && borderWidth < brx;
    var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
    var rx1 = brx;
    var ry1 = bry;
    var sx1 = ry1 / rx1;
    var oxt = x1 + brx;
    var rx2 = brx - (x2 - x1);
    var ry2 = bry - (y2 - y1);
    var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

    var _xa5, ya, _xb5, yb;

    var ca = calBezierLeftTop(beginList[0][0], beginList[0][3], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

    var _ca7 = _slicedToArray(ca[ca.length - 1], 2);

    _xa5 = _ca7[0];
    ya = _ca7[1];
    var cb;

    if (needInner) {
      cb = calBezierLeftTop(beginList[0][1], beginList[0][2], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

      var _cb7 = _slicedToArray(cb[cb.length - 1], 2);

      _xb5 = _cb7[0];
      yb = _cb7[1];
    }

    beginList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === 0) {
        controls1 = ca;

        if (needInner) {
          controls2 = cb;
        }
      } else {
        controls1 = calBezierLeftTop(points[0], points[3], oxt, oyt, sx1, ry1);

        if (needInner) {
          controls2 = calBezierLeftTop(points[1], points[2], oxt, oyt, sx2, ry2);
        }
      }

      for (var _i13 = 0, _len13 = controls1.length; _i13 < _len13; _i13++) {
        limit(controls1[_i13], _xa5, ya, 6);
      }

      if (needInner) {
        for (var _i14 = 0, _len14 = controls2.length; _i14 < _len14; _i14++) {
          limit(controls2[_i14], _xb5, yb, 6);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[0];
          points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
        }
      } else {
        points[3] = points[1];
      }

      points[0] = controls1[3];
      points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
    });
  }

  var endLength = endList.length;

  if (endLength) {
    var _needInner4 = ery > y4 - y3 && borderWidth < erx;

    var _crossDeg4 = Math.atan((x2 - x1) / (y4 - y3));

    var _rx7 = erx;
    var _ry7 = ery;

    var _sx7 = _ry7 / _rx7;

    var oxb = x1 + erx;

    var _rx8 = erx - (x2 - x1);

    var _ry8 = ery - (y4 - y3);

    var _sx8 = _ry8 / _rx8; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


    var _xa6, _ya6, _xb6, _yb6;

    var _ca8 = calBezierLeftBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx7, _ry7, true, Math.tan(_crossDeg4) * _ry7);

    var _ca8$ = _slicedToArray(_ca8[0], 2);

    _xa6 = _ca8$[0];
    _ya6 = _ca8$[1];

    var _cb8;

    if (_needInner4) {
      _cb8 = calBezierLeftBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx8, _ry8, true, Math.tan(_crossDeg4) * _ry8);

      var _cb8$ = _slicedToArray(_cb8[0], 2);

      _xb6 = _cb8$[0];
      _yb6 = _cb8$[1];
    }

    endList.forEach(function (points, i) {
      var controls1;
      var controls2;

      if (i === endLength - 1) {
        controls1 = _ca8;

        if (_needInner4) {
          controls2 = _cb8;
        }
      } else {
        controls1 = calBezierLeftBottom(points[0], points[3], oxb, oyb, _sx7, _ry7);

        if (_needInner4) {
          controls2 = calBezierLeftBottom(points[1], points[2], oxb, oyb, _sx8, _ry8);
        }
      }

      for (var _i15 = 0, _len15 = controls1.length; _i15 < _len15; _i15++) {
        limit(controls1[_i15], _xa6, _ya6, 7);
      }

      if (_needInner4) {
        for (var _i16 = 0, _len16 = controls2.length; _i16 < _len16; _i16++) {
          limit(controls2[_i16], _xb6, _yb6, 7);
        }

        if (controls2.length === 1) {
          points[2] = controls2[0];
          points.pop();
        } else {
          points[2] = controls2[0];
          points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
        }
      } else {
        points[3] = points[1];
      }

      points[0] = controls1[3];
      points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
    });
  }

  return beginList.concat(centerList).concat(endList);
}

function calBezierLeftTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p13 = _slicedToArray(p1, 2),
      p1x = _p13[0],
      p1y = _p13[1];

  var _p14 = _slicedToArray(p2, 2),
      p2x = _p14[0],
      p2y = _p14[1];

  var dx1 = ox - p1x;
  var dsx1 = dx1 * sx;
  var dx2 = ox - p2x;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx2 = ox - Math.sin(deg2) * r / sx;
  var cpy2 = oy - Math.cos(deg2) * r;
  var deg1;
  var cpx1;
  var cpy1;

  if (isStart) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg1 = Math.PI * 0.5 - alpha;
    cpx1 = ox - Math.cos(alpha) * r / sx;
    cpy1 = oy - Math.sin(alpha) * r;
  } else {
    deg1 = Math.atan(dsx1 / (oy - p1y));
    cpx1 = ox - Math.sin(deg1) * r / sx;
    cpy1 = oy - Math.cos(deg1) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 + degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox - cdx1 / sx;
  var cy1 = oy - cdy1;
  var degTg2 = deg2 - degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox - cdx2 / sx;
  var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
}

function calBezierLeftBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
  // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
  var _p15 = _slicedToArray(p1, 2),
      p1x = _p15[0],
      p1y = _p15[1];

  var _p16 = _slicedToArray(p2, 2),
      p2x = _p16[0],
      p2y = _p16[1];

  var dx1 = ox - p1x;
  var dsx1 = dx1 * sx;
  var dx2 = ox - p2x;
  var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

  var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

  var cpx1 = ox - Math.sin(deg1) * r / sx;
  var cpy1 = oy + Math.cos(deg1) * r;
  var deg2;
  var cpx2;
  var cpy2;

  if (isEnd) {
    // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
    var crossDsx = crossDx * sx;
    var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

    var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
    var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
    var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

    deg2 = Math.PI * 0.5 - alpha;
    cpx2 = ox - Math.cos(alpha) * r / sx;
    cpy2 = oy + Math.sin(alpha) * r;
  } else {
    deg2 = Math.atan(dsx2 / (p2y - oy));
    cpx2 = ox - Math.sin(deg2) * r / sx;
    cpy2 = oy + Math.cos(deg2) * r;
  } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
  // 使得交点相同角度相同无法计算，直接返回1个点即可


  if (deg1 === deg2) {
    return [[cpx1, cpy1]];
  } // 根据夹角求贝塞尔拟合圆弧长度


  var h = geom$1.h(Math.abs(deg1 - deg2));
  var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
  // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
  // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

  var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
  var degTg = Math.atan(d / r);
  var degTg1 = deg1 - degTg;
  var cdx1 = Math.sin(degTg1) * c;
  var cdy1 = Math.cos(degTg1) * c;
  var cx1 = ox - cdx1 / sx;
  var cy1 = oy + cdy1;
  var degTg2 = deg2 + degTg;
  var cdx2 = Math.sin(degTg2) * c;
  var cdy2 = Math.cos(degTg2) * c;
  var cx2 = ox - cdx2 / sx;
  var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0FF';
  // window.ctx.beginPath();
  // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#00F';
  // window.ctx.beginPath();
  // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.fillStyle = '#0F0';
  // window.ctx.beginPath();
  // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
  // window.ctx.fill();
  // window.ctx.closePath();

  return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
}
/**
 * 简单计算椭圆的圆化坐标控制点，视作重合位置，外面判断backgroundClip并调整坐标
 * @param x 起始x
 * @param y 起始y
 * @param w 宽
 * @param h 高
 * @param btlr borderTopLeftRadius
 * @param btrr borderTopRightRadius
 * @param bbrr borderBottomRightRadius
 * @param bblr borderBottomLeftRadius
 * @returns {[]} 多边形的顶点和曲线控制点
 */


function calRadius(x, y, w, h, btlr, btrr, bbrr, bblr) {
  var need;

  var _btlr = _slicedToArray(btlr, 2),
      btlx = _btlr[0],
      btly = _btlr[1];

  var _btrr = _slicedToArray(btrr, 2),
      btrx = _btrr[0],
      btry = _btrr[1];

  var _bbrr = _slicedToArray(bbrr, 2),
      bbrx = _bbrr[0],
      bbry = _bbrr[1];

  var _bblr = _slicedToArray(bblr, 2),
      bblx = _bblr[0],
      bbly = _bblr[1];

  btlx = Math.max(btlx, 0);
  btly = Math.max(btly, 0);
  btrx = Math.max(btrx, 0);
  btry = Math.max(btry, 0);
  bbrx = Math.max(bbrx, 0);
  bbry = Math.max(bbry, 0);
  bblx = Math.max(bblx, 0);
  bbly = Math.max(bbly, 0); // 圆角必须x/y都>0才有效，否则视为不绘制

  if (btlx > 0 && btly > 0 || btrx > 0 && btry > 0 || bbrx > 0 && bbry > 0 || bblx > 0 && bbly > 0) {
    need = true;
  }

  if (need) {
    var list = [];

    if (btlx > 0 && btly > 0) {
      list.push([x, y + btly]);
      list.push([x, y + btly * (1 - H), x + btlx * (1 - H), y, x + btlx, y]);
    } else {
      list.push([x, y]);
    }

    if (btrx > 0 && btry > 0) {
      list.push([x + w - btrx, y]);
      list.push([x + w - btrx * (1 - H), y, x + w, y + btry * (1 - H), x + w, y + btry]);
    } else {
      list.push([x + w, y]);
    }

    if (bbrx > 0 && bbry > 0) {
      list.push([x + w, y + h - bbry]);
      list.push([x + w, y + h - bbry * (1 - H), x + w - bbrx * (1 - H), y + h, x + w - bbrx, y + h]);
    } else {
      list.push([x + w, y + h]);
    }

    if (bblx > 0 && bbly > 0) {
      list.push([x + bblx, y + h]);
      list.push([x + bblx * (1 - H), y + h, x, y + h - bbly * (1 - H), x, y + h - bbly]);
    } else {
      list.push([x, y + h]);
    }

    return list;
  }
}

function limit(points, x, y, direction) {
  if (direction === 0) {
    points[0] = Math.max(points[0], x);
    points[1] = Math.min(points[1], y);
  } else if (direction === 1) {
    points[0] = Math.min(points[0], x);
    points[1] = Math.min(points[1], y);
  } else if (direction === 2) {
    points[0] = Math.max(points[0], x);
    points[1] = Math.max(points[1], y);
  } else if (direction === 3) {
    points[0] = Math.max(points[0], x);
    points[1] = Math.min(points[1], y);
  } else if (direction === 4) {
    points[0] = Math.max(points[0], x);
    points[1] = Math.max(points[1], y);
  } else if (direction === 5) {
    points[0] = Math.min(points[0], x);
    points[1] = Math.max(points[1], y);
  } else if (direction === 6) {
    points[0] = Math.min(points[0], x);
    points[1] = Math.max(points[1], y);
  } else if (direction === 7) {
    points[0] = Math.min(points[0], x);
    points[1] = Math.min(points[1], y);
  }
}

var BR_KS = [BORDER_TOP_LEFT_RADIUS$2, BORDER_TOP_RIGHT_RADIUS$2, BORDER_BOTTOM_RIGHT_RADIUS$2, BORDER_BOTTOM_LEFT_RADIUS$2];

function calBorderRadius(w, h, currentStyle, computedStyle, root) {
  var noRadius = true;
  BR_KS.forEach(function (k) {
    computedStyle[k] = currentStyle[k].map(function (item, i) {
      if (item[0] > 0) {
        noRadius = false;
      } else {
        return 0;
      }

      if (item[1] === PX$b) {
        return Math.max(0, item[0]);
      } else if (item[1] === PERCENT$c) {
        return Math.max(0, item[0] * (i ? h : w) * 0.01);
      } else if (item[1] === REM$g) {
        return Math.max(0, item[0] * root.computedStyle[FONT_SIZE$h]);
      } else if (item[1] === VW$g) {
        return Math.max(0, item[0] * root.width * 0.01);
      } else if (item[1] === VH$g) {
        return Math.max(0, item[0] * root.height * 0.01);
      }

      return 0;
    });
  }); // 优化提前跳出

  if (noRadius) {
    return;
  } // radius限制，相交的2个之和不能超过边长，如果2个都超过中点取中点，只有1个超过取交点，这包含了单个不能超过总长的逻辑


  BR_KS.forEach(function (k, i) {
    var j = i % 2 === 0 ? 0 : 1;
    var target = j ? h : w;
    var prev = computedStyle[k];
    var next = computedStyle[BR_KS[(i + 1) % 4]]; // 相加超过边长则是相交

    if (prev[j] + next[j] > target) {
      var half = target * 0.5; // 都超过一半中点取中点

      if (prev[j] >= half && next[j] >= half) {
        prev[j] = next[j] = half;
      } // 仅1个超过中点，因相交用总长减去另一方即可
      else if (prev[j] > half) {
        prev[j] = target - next[j];
      } else if (next[j] > half) {
        next[j] = target - prev[j];
      }
    }
  });
}

function calBorderRadiusInline(contentBoxList, currentStyle, computedStyle) {
  var first, last;

  if (contentBoxList.length) {
    first = contentBoxList[0];
    last = contentBoxList[contentBoxList.length - 1];
  } // 先看first的左侧


  var w = first ? first.outerWidth : 0,
      h = first ? first.outerHeight : 0;
  w += computedStyle[BORDER_LEFT_WIDTH$8] + computedStyle[PADDING_LEFT$7];
  h += computedStyle[BORDER_TOP_WIDTH$6] + computedStyle[BORDER_BOTTOM_WIDTH$6] + computedStyle[PADDING_TOP$5] + computedStyle[PADDING_BOTTOM$5];
  [BORDER_TOP_LEFT_RADIUS$2, BORDER_BOTTOM_LEFT_RADIUS$2].forEach(function (k) {
    computedStyle[k] = currentStyle[k].map(function (item, i) {
      var v;

      if (item[1] === PX$b) {
        v = Math.max(0, item[0]);
        v = Math.min(i ? h : w, v);
      } else {
        v = Math.max(0, item[0] * (i ? h : w) * 0.01);
        v = Math.min(i ? h : w, v);
      }

      return v;
    });
  }); // 再看end的右侧

  w = last ? last.outerWidth : 0;
  h = last ? last.outerHeight : 0;
  [BORDER_TOP_RIGHT_RADIUS$2, BORDER_BOTTOM_RIGHT_RADIUS$2].forEach(function (k) {
    computedStyle[k] = currentStyle[k].map(function (item, i) {
      var v;

      if (item[1] === PX$b) {
        v = Math.max(0, item[0]);
        v = Math.min(i ? h : w, v);
      } else {
        v = Math.max(0, item[0] * (i ? h : w) * 0.01);
        v = Math.min(i ? h : w, v);
      }

      return v;
    });
  });
}

function renderBorder(xom, renderMode, ctx, points, color, dx, dy) {
  if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
    ctx.beginPath();

    if (ctx.fillStyle !== color) {
      ctx.fillStyle = color;
    }

    points.forEach(function (point) {
      canvasPolygon$6(ctx, point, dx, dy);
    });
    ctx.fill();
    ctx.closePath();
  } else if (renderMode === mode.SVG) {
    var s = '';
    points.forEach(function (point) {
      s += svgPolygon$6(point);
    });
    xom.virtualDom.bb.push({
      type: 'item',
      tagName: 'path',
      props: [['d', s], ['fill', color]]
    });
  }
}

var border = {
  calPoints: calPoints,
  calRadius: calRadius,
  calBorderRadius: calBorderRadius,
  calBorderRadiusInline: calBorderRadiusInline,
  renderBorder: renderBorder
};

// 类型为引用防止json仿造
var TYPE_VD$4 = {
  _: 1
};
var TYPE_GM$4 = {
  _: 2
};
var TYPE_CP$4 = {
  _: 3
};
var $$type = {
  TYPE_VD: TYPE_VD$4,
  TYPE_GM: TYPE_GM$4,
  TYPE_CP: TYPE_CP$4
};

var toString = {}.toString;

function isType(type) {
  return function (obj) {
    return toString.call(obj) === '[object ' + type + ']';
  };
}

var isObject$2 = isType('Object');
var isString$1 = isType('String');
var isFunction$8 = isType('Function');
var isNumber$1 = isType('Number');
var isBoolean = isType('Boolean');
var isDate = isType('Date');
var hasOwn = {}.hasOwnProperty;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call(Object);

function isNil$f(v) {
  return v === undefined || v === null;
}

function _joinSourceArray(arr) {
  var res = '';

  for (var i = 0, len = arr.length; i < len; i++) {
    var item = arr[i];

    if (Array.isArray(item)) {
      res += _joinSourceArray(item);
    } else {
      res += stringify(item);
    }
  }

  return res;
}

function stringify(s) {
  if (isNil$f(s)) {
    return '';
  }

  return s.toString();
}

function encodeHtml(s, prop) {
  if (prop) {
    return s.replace(/"/g, '&quot;');
  }

  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/ /g, '&nbsp;');
} // 根元素专用


function joinVirtualDom(vd) {
  var s = '<defs>';
  vd.defs.forEach(function (item) {
    s += joinDef$1(item);
  });
  s += '</defs><g>';
  vd.bb.forEach(function (item) {
    s += joinVd$1(item);
  });
  s += '</g><g';

  if (vd.conClip) {
    s += ' clip-path="' + vd.conClip + '"';
  }

  s += '>';
  (vd.children || []).forEach(function (item) {
    if (item.isMask) {
      return;
    }

    s += joinVd$1(item);
  });
  s += '</g>';
  return s;
} // 普通元素


function joinVd$1(vd) {
  if (vd.type === 'item' || vd.type === 'img') {
    var s = '';
    (vd.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });

    if (vd.tagName === 'text') {
      return '<text' + s + '>' + vd.content + '</text>';
    }

    return '<' + vd.tagName + s + '/>';
  } else if (vd.type === 'text') {
    var _s = ""; // text有许多lineBox

    (vd.children || []).forEach(function (item) {
      _s += joinVd$1(item);
    });
    return '<g>' + _s + '</g>';
  } else if (vd.type === 'dom' || vd.type === 'geom') {
    var _s2 = '<g>';
    vd.bb.forEach(function (item) {
      _s2 += joinVd$1(item);
    });
    _s2 += '</g><g';

    if (vd.conClip) {
      _s2 += ' clip-path="' + vd.conClip + '"';
    }

    _s2 += '>';
    (vd.children || []).forEach(function (item) {
      if (item.isMask) {
        return;
      }

      _s2 += joinVd$1(item);
    });
    _s2 += '</g>';
    var opacity = vd.opacity,
        transform = vd.transform,
        visibility = vd.visibility,
        mask = vd.mask,
        overflow = vd.overflow,
        filter = vd.filter,
        mixBlendMode = vd.mixBlendMode;
    return '<g' + (opacity !== 1 && opacity !== undefined ? ' opacity="' + opacity + '"' : '') + (transform ? ' transform="' + transform + '"' : '') + ' visibility="' + visibility + '"' + (mask ? ' mask="' + mask + '"' : '') + (overflow ? ' clip-path="' + overflow + '"' : '') // + (filter ? (' filter="' + filter + '"') : '')
    + (filter || mixBlendMode ? ' style="' : '') + (filter ? 'filter:' + filter + ';' : '') + (mixBlendMode ? 'mix-blend-mode:' + mixBlendMode + ';' : '') + (filter || mixBlendMode ? '"' : '') + '>' + _s2 + '</g>';
  }
}

function joinDef$1(def) {
  var s = '<' + def.tagName + ' id="' + def.uuid + '"';

  if (def.tagName === 'mask' || def.tagName === 'clipPath') ; else if (def.tagName === 'filter') ; else {
    s += ' gradientUnits="userSpaceOnUse"';
  }

  (def.props || []).forEach(function (item) {
    s += ' ' + item[0] + '="' + item[1] + '"';
  });
  s += '>';
  (def.children || []).forEach(function (item) {
    s += joinItem(item);
  });
  s += '</' + def.tagName + '>';
  return s;
}

function joinItem(item) {
  var s = '<' + item.tagName;
  (item.props || []).forEach(function (item) {
    s += ' ' + item[0] + '="' + item[1] + '"';
  });
  s += '></' + item.tagName + '>';
  return s;
}

function rgba2int$3(color) {
  if (Array.isArray(color)) {
    return color;
  }

  var res = [];

  if (!color || color === 'transparent') {
    res = [0, 0, 0, 0];
  } else if (color.charAt(0) === '#') {
    color = color.slice(1);

    if (color.length === 3) {
      res.push(parseInt(color.charAt(0) + color.charAt(0), 16));
      res.push(parseInt(color.charAt(1) + color.charAt(1), 16));
      res.push(parseInt(color.charAt(2) + color.charAt(2), 16));
      res[3] = 1;
    } else if (color.length === 6) {
      res.push(parseInt(color.slice(0, 2), 16));
      res.push(parseInt(color.slice(2, 4), 16));
      res.push(parseInt(color.slice(4), 16));
      res[3] = 1;
    } else if (color.length === 8) {
      res.push(parseInt(color.slice(0, 2), 16));
      res.push(parseInt(color.slice(2, 4), 16));
      res.push(parseInt(color.slice(4, 6), 16));
      res.push(parseInt(color.slice(6), 16) / 255);
    } else {
      res[0] = res[1] = res[2] = 0;
      res[3] = 1;
    }
  } else {
    var c = color.match(/rgba?\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);

    if (c) {
      res = [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];

      if (!isNil$f(c[4])) {
        res[3] = parseFloat(c[4]);
      } else {
        res[3] = 1;
      }
    } else {
      res = [0, 0, 0, 0];
    }
  }

  return res;
}

function int2rgba$3(color) {
  if (Array.isArray(color)) {
    if (color.length === 4) {
      color = color.map(function (c, i) {
        return i === 3 ? c : Math.floor(Math.max(0, c));
      });
      return 'rgba(' + joinArr$3(color, ',') + ')';
    } else if (color.length === 3) {
      color = color.map(function (c) {
        return Math.floor(c);
      });
      return 'rgba(' + joinArr$3(color, ',') + ',1)';
    }
  }

  return color || 'rgba(0,0,0,0)';
}

function int2invert(color) {
  if (Array.isArray(color)) {
    color = color.slice(0);
    color[0] = 255 - color[0];
    color[1] = 255 - color[1];
    color[2] = 255 - color[2];

    if (color.length === 4) {
      return 'rgba(' + joinArr$3(color, ',') + ')';
    } else if (color.length === 3) {
      return 'rgba(' + joinArr$3(color, ',') + ',1)';
    }
  }

  return 'rgba(0,0,0,0)';
}

function arr2hash(arr) {
  var hash = {};

  for (var i = 0, len = arr.length; i < len; i++) {
    var item = arr[i];

    if (Array.isArray(item)) {
      hash[item[0]] = item[1];
    } else {
      for (var list = Object.keys(item), j = list.length - 1; j >= 0; j--) {
        var k = list[j];
        hash[k] = item[k];
      }
    }
  }

  return hash;
}

function hash2arr(hash) {
  if (Array.isArray(hash)) {
    return hash;
  }

  var arr = [];

  for (var list = Object.keys(hash), i = 0, len = list.length; i < len; i++) {
    var k = list[i];
    arr.push([k, hash[k]]);
  }

  return arr;
}

function clone$4(obj) {
  if (isNil$f(obj) || _typeof(obj) !== 'object') {
    return obj;
  } // parse递归会出现内部先返回解析好的json，外部parse不能clone


  if (obj.$$type === $$type.TYPE_VD || obj.$$type === $$type.TYPE_GM || obj.$$type === $$type.TYPE_CP) {
    return obj;
  }

  if (util.isDate(obj)) {
    return new Date(obj);
  }

  if (!isPlainObject(obj) && !Array.isArray(obj)) {
    return obj;
  }

  var n = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach(function (i) {
    n[i] = clone$4(obj[i]);
  });
  return n;
}
/**
 * 简化的arr对比，arr中只有arr和其它类型，其它类型对比值或引用，arr递归
 * @param a
 * @param b
 * @returns {boolean}
 */


function equalArr$2(a, b) {
  if (!a || !b) {
    return a === b;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0, len = a.length; i < len; i++) {
    var ai = a[i];
    var bi = b[i];
    var isArrayA = Array.isArray(ai);
    var isArrayB = Array.isArray(bi);

    if (isArrayA && isArrayB) {
      if (!equalArr$2(ai, bi)) {
        return false;
      }
    } else if (isArrayA || isArrayB) {
      return false;
    } else if (ai !== bi) {
      return false;
    }
  }

  return true;
}
/**
 * 深度对比对象
 * @param a
 * @param b
 * @returns {boolean}
 */


function equal(a, b) {
  if (a === b) {
    return true;
  }

  if (isObject$2(a) && isObject$2(b)) {
    var hash = {};

    for (var i = 0, arr = Object.keys(a), len = arr.length; i < len; i++) {
      var k = arr[i];

      if (!b.hasOwnProperty(k) || !equal(a[k], b[k])) {
        return false;
      }

      hash[k] = true;
    } // a没有b有则false


    for (var _i = 0, _arr = Object.keys(b), _len = _arr.length; _i < _len; _i++) {
      var _k = _arr[_i];

      if (!hash.hasOwnProperty(_k)) {
        return false;
      }
    }
  } else if (isDate(a) && isDate(b)) {
    return a.getTime() === b.getTime();
  } else if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
      if (!equal(a[_i2], b[_i2])) {
        return false;
      }
    }
  } else {
    return a === b;
  }

  return true;
}

function extend$2(target, source, keys) {
  if (source === null || _typeof(source) !== 'object') {
    return target;
  }

  if (!keys) {
    keys = Object.keys(source);
  }

  var i = 0;
  var len = keys.length;

  while (i < len) {
    var k = keys[i];
    target[k] = source[k];
    i++;
  }

  return target;
}

function joinArr$3(arr, split) {
  var s = arr.length ? arr[0] : '';

  for (var i = 1, len = arr.length; i < len; i++) {
    s += split + arr[i];
  }

  return s;
}

function extendAnimate(ovd, nvd) {
  var list = nvd.__animationList = ovd.animationList.splice(0);
  list.forEach(function (item) {
    item.__setTarget(nvd); // 事件队列的缘故，可能动画本帧刚执行过，然后再继承，就会缺失，需再次赋值一遍；也有可能停留最后


    if (item.assigning || item.finished && item.__stayEnd()) {
      item.assignCurrentStyle();
    }
  }); // 帧动画继承

  nvd.__frameAnimateList = ovd.__frameAnimateList.splice(0);
}

function transformBbox(bbox, matrix) {
  var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (matrix && !mx.isE(matrix)) {
    var _bbox = bbox,
        _bbox2 = _slicedToArray(_bbox, 4),
        x1 = _bbox2[0],
        y1 = _bbox2[1],
        x2 = _bbox2[2],
        y2 = _bbox2[3]; // 可能因filter的原因扩展范围


    if (dx) {
      x1 -= dx;
      x2 += dx;
    }

    if (dy) {
      y1 -= dy;
      y2 += dy;
    }

    var list = [x2, y1, x1, y2, x2, y2];
    var w;

    var _mx$calPoint = mx.calPoint([x1, y1], matrix);

    var _mx$calPoint2 = _slicedToArray(_mx$calPoint, 4);

    x1 = _mx$calPoint2[0];
    y1 = _mx$calPoint2[1];
    w = _mx$calPoint2[3];

    if (w && w !== 1) {
      x1 /= w;
      y1 /= w;
    }

    var xa = x1,
        ya = y1,
        xb = x1,
        yb = y1;

    for (var i = 0; i < 6; i += 2) {
      var x = list[i],
          y = list[i + 1];

      var _mx$calPoint3 = mx.calPoint([x, y], matrix);

      var _mx$calPoint4 = _slicedToArray(_mx$calPoint3, 4);

      x = _mx$calPoint4[0];
      y = _mx$calPoint4[1];
      w = _mx$calPoint4[3];

      if (w && w !== 1) {
        x /= w;
        y /= w;
      }

      xa = Math.min(xa, x);
      xb = Math.max(xb, x);
      ya = Math.min(ya, y);
      yb = Math.max(yb, y);
    }

    bbox = [xa, ya, xb, yb];
  } else if (dx || dy) {
    bbox = bbox.slice(0);
    bbox[0] -= dx;
    bbox[1] -= dy;
    bbox[2] += dx;
    bbox[3] += dy;
  }

  return bbox;
}

function isPlainObject(obj) {
  if (!obj || toString.call(obj) !== '[object Object]') {
    return false;
  }

  var proto = Object.getPrototypeOf(obj);

  if (!proto) {
    return true;
  }

  var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
}

function assignMatrix(t, v) {
  t[0] = v[0];
  t[1] = v[1];
  t[2] = v[2];
  t[3] = v[3];
  t[4] = v[4];
  t[5] = v[5];
  t[6] = v[6];
  t[7] = v[7];
  t[8] = v[8];
  t[9] = v[9];
  t[10] = v[10];
  t[11] = v[11];
  t[12] = v[12];
  t[13] = v[13];
  t[14] = v[14];
  t[15] = v[15];
  return t;
}

var util = {
  isObject: isObject$2,
  isString: isString$1,
  isFunction: isFunction$8,
  isNumber: isNumber$1,
  isBoolean: isBoolean,
  isDate: isDate,
  isNil: isNil$f,
  isPrimitive: function isPrimitive(v) {
    return util.isNil(v) || util.isBoolean(v) || util.isString(v) || util.isNumber(v);
  },
  // css中常用undefined/null表示auto本身
  isAuto: function isAuto(v) {
    return isNil$f(v) || v === 'auto';
  },
  isPlainObject: isPlainObject,
  stringify: stringify,
  joinSourceArray: function joinSourceArray(arr) {
    return _joinSourceArray(arr);
  },
  encodeHtml: encodeHtml,
  joinVirtualDom: joinVirtualDom,
  joinVd: joinVd$1,
  joinDef: joinDef$1,
  rgba2int: rgba2int$3,
  int2rgba: int2rgba$3,
  int2invert: int2invert,
  arr2hash: arr2hash,
  hash2arr: hash2arr,
  clone: clone$4,
  equalArr: equalArr$2,
  equal: equal,
  extend: extend$2,
  joinArr: joinArr$3,
  extendAnimate: extendAnimate,
  transformBbox: transformBbox,
  assignMatrix: assignMatrix
};

var debug = {
  flag: false
};

var textCache = {
  list: [],
  // 每次渲染前的更新后，等待测量的文字对象列表
  data: {},
  // Text中存入的特殊等待测量的信息，字体+字号+粗细为key
  charWidth: {},
  // key的文字宽度hash
  padding: {},
  // key的文字宽度偏移，少量字体的少量文字有
  ELLIPSIS: '…'
};

var ca = {
  alpha: true,
  antialias: true,
  premultipliedAlpha: true,
  preserveDrawingBuffer: true // depth: true,
  // stencil: true,

};

var calPoint = mx.calPoint;
/**
 * 初始化 shader
 * @param gl GL context
 * @param vshader vertex shader (string)
 * @param fshader fragment shader (string)
 * @return program, if the program object was created and successfully made current
 */

function initShaders(gl, vshader, fshader) {
  var program = createProgram(gl, vshader, fshader);

  if (!program) {
    throw new Error('Failed to create program');
  } // 要开启透明度，用以绘制透明的图形


  gl.enable(gl.BLEND);
  gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  return program;
}
/**
 * Create the linked program object
 * @param gl GL context
 * @param vshader a vertex shader program (string)
 * @param fshader a fragment shader program (string)
 * @return created program object, or null if the creation has failed
 */


function createProgram(gl, vshader, fshader) {
  // Create shader object
  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

  if (!vertexShader || !fragmentShader) {
    return null;
  } // Create a program object


  var program = gl.createProgram();

  if (!program) {
    return null;
  }

  program.vertexShader = vertexShader;
  program.fragmentShader = fragmentShader; // Attach the shader objects

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader); // Link the program object

  gl.linkProgram(program); // Check the result of linking

  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (!linked) {
    var error = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
    throw new Error('Failed to link program: ' + error);
  }

  return program;
}
/**
 * Create a shader object
 * @param gl GL context
 * @param type the type of the shader object to be created
 * @param source shader program (string)
 * @return created shader object, or null if the creation has failed.
 */


function loadShader(gl, type, source) {
  // Create shader object
  var shader = gl.createShader(type);

  if (shader == null) {
    throw new Error('unable to create shader');
  } // Set the shader program


  gl.shaderSource(shader, source); // Compile the shader

  gl.compileShader(shader); // Check the result of compilation

  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (!compiled) {
    var error = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error('Failed to compile shader: ' + error);
  }

  return shader;
}

function convertCoords2Gl(_ref, cx, cy, revertY) {
  var _ref2 = _slicedToArray(_ref, 4),
      x = _ref2[0],
      y = _ref2[1],
      z = _ref2[2],
      w = _ref2[3];

  if (z === undefined) {
    z = 0;
  }

  if (w === undefined) {
    w = 1;
  }

  if (w && w !== 1) {
    x /= w;
    y /= w;
    z /= w;
  }

  if (x === cx) {
    x = 0;
  } else {
    x = (x - cx) / cx;
  }

  if (y === cy) {
    y = 0;
  } else {
    y = (y - cy) / cy;

    if (revertY) {
      y = -y;
    }
  }

  return [x * w, y * w, z * w, w];
}

function createTexture(gl, tex, n, width, height) {
  var texture = gl.createTexture();
  bindTexture(gl, texture, n); // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, -1);

  gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); // 传入高宽时是绑定fbo，且tex一定为null

  if (width && height) {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);
  } // 普通将canvas对象作为纹理
  else {
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
  }

  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  return texture;
}

function bindTexture(gl, texture, n) {
  gl.activeTexture(gl['TEXTURE' + n]);
  gl.bindTexture(gl.TEXTURE_2D, texture);
}
/**
 * texCache集满纹理上传占用最多可用纹理单元后，进行批量顺序绘制
 * 将所有dom的矩形顶点（经过transform变换后的）、贴图坐标、透明度存入3个buffer中，
 * 然后相同纹理单元的形成一批，设置uniform的纹理单元号进行绘制，如此循环
 * @param gl
 * @param list
 * @param hash
 * @param cx
 * @param cy
 * @param revertY
 */


function drawTextureCache(gl, list, hash, cx, cy, revertY) {
  var vtPoint = [],
      vtTex = [],
      vtOpacity = [];
  var lastChannel; // 上一个dom的单元号

  var record = [0]; // [num, channel]每一批的数量和单元号记录

  var stack = [record]; // 所有批的数据记录集合

  list.forEach(function (item, i) {
    var _item = _slicedToArray(item, 5),
        cache = _item[0],
        opacity = _item[1],
        matrix = _item[2],
        dx = _item[3],
        dy = _item[4];

    if (i) {
      var channel = hash[cache.page.uuid]; // 和上一个单元号不同时，生成新的批次记录

      if (lastChannel !== channel) {
        lastChannel = channel;
        record = [0, lastChannel];
        stack.push(record);
      }
    } else {
      lastChannel = hash[cache.page.uuid];
      record[1] = lastChannel;
    }

    var x = cache.x,
        y = cache.y,
        width = cache.width,
        height = cache.height,
        page = cache.page,
        bbox = cache.bbox; // 计算顶点坐标和纹理坐标，转换[0,1]对应关系

    var bx = bbox[0],
        by = bbox[1];
    var xa = bx + (dx || 0),
        ya = by + height + (dy || 0);
    var xb = bx + width + (dx || 0),
        yb = by + (dy || 0);

    var _calPoint = calPoint([xa, ya], matrix),
        _calPoint2 = _slicedToArray(_calPoint, 4),
        x1 = _calPoint2[0],
        y1 = _calPoint2[1],
        w1 = _calPoint2[3];

    var _calPoint3 = calPoint([xb, ya], matrix),
        _calPoint4 = _slicedToArray(_calPoint3, 4),
        x2 = _calPoint4[0],
        y2 = _calPoint4[1],
        w2 = _calPoint4[3];

    var _calPoint5 = calPoint([xb, yb], matrix),
        _calPoint6 = _slicedToArray(_calPoint5, 4),
        x3 = _calPoint6[0],
        y3 = _calPoint6[1],
        w3 = _calPoint6[3];

    var _calPoint7 = calPoint([xa, yb], matrix),
        _calPoint8 = _slicedToArray(_calPoint7, 4),
        x4 = _calPoint8[0],
        y4 = _calPoint8[1],
        w4 = _calPoint8[3];

    var _convertCoords2Gl = convertCoords2Gl([x1, y1, 0, w1], cx, cy, revertY);

    var _convertCoords2Gl2 = _slicedToArray(_convertCoords2Gl, 2);

    x1 = _convertCoords2Gl2[0];
    y1 = _convertCoords2Gl2[1];

    var _convertCoords2Gl3 = convertCoords2Gl([x2, y2, 0, w2], cx, cy, revertY);

    var _convertCoords2Gl4 = _slicedToArray(_convertCoords2Gl3, 2);

    x2 = _convertCoords2Gl4[0];
    y2 = _convertCoords2Gl4[1];

    var _convertCoords2Gl5 = convertCoords2Gl([x3, y3, 0, w3], cx, cy, revertY);

    var _convertCoords2Gl6 = _slicedToArray(_convertCoords2Gl5, 2);

    x3 = _convertCoords2Gl6[0];
    y3 = _convertCoords2Gl6[1];

    var _convertCoords2Gl7 = convertCoords2Gl([x4, y4, 0, w4], cx, cy, revertY);

    var _convertCoords2Gl8 = _slicedToArray(_convertCoords2Gl7, 2);

    x4 = _convertCoords2Gl8[0];
    y4 = _convertCoords2Gl8[1];
    vtPoint.push(x1, y1, 0, w1, x4, y4, 0, w4, x2, y2, 0, w2, x4, y4, 0, w4, x2, y2, 0, w2, x3, y3, 0, w3);
    var tx1 = x / page.width,
        ty1 = (y + height) / page.height;
    var tx2 = (x + width) / page.width,
        ty2 = y / page.height;
    vtTex.push(tx1, ty1, tx1, ty2, tx2, ty1, tx1, ty2, tx2, ty1, tx2, ty2);
    vtOpacity.push(opacity, opacity, opacity, opacity, opacity, opacity);
    record[0]++;
  }); // 顶点buffer

  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtPoint), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(gl.program, 'a_position');
  gl.vertexAttribPointer(a_position, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer

  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtTex), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // opacity buffer

  var opacityBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtOpacity), gl.STATIC_DRAW);
  var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
  gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_opacity); // 纹理单元

  var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
  var count = 0; // 循环按批次渲染

  stack.forEach(function (record) {
    var _record = _slicedToArray(record, 2),
        num = _record[0],
        channel = _record[1];

    gl.uniform1i(u_texture, channel);
    num *= 6;
    gl.drawArrays(gl.TRIANGLES, count, num);
    count += num;
  });
  gl.deleteBuffer(pointBuffer);
  gl.deleteBuffer(texBuffer);
  gl.deleteBuffer(opacityBuffer);
  gl.disableVertexAttribArray(a_position);
  gl.disableVertexAttribArray(a_texCoords);
  gl.disableVertexAttribArray(a_opacity);
}
/**
 * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
 * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核扩大3倍性能慢
 * x/y方向分开执行，加速性能，计算次数由d*d变为d+d，d为卷积核大小
 * spread由d和sigma计算得出，d由sigma计算得出，sigma即css的blur()参数
 * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
 * i和j为total和filter的纹理单元，3次执行（x/y合起来算1次）需互换单元，来回执行源和结果
 * 由total变为filter时cache会各方向上扩展spread的大小到width/height
 * 因此第一次绘制时坐标非1，后面则固定1
 * @param gl
 * @param program
 * @param frameBuffer
 * @param texCache
 * @param tex1 初次绘制目标纹理
 * @param tex2 初次绘制源纹理
 * @param i 初次绘制目标纹理单元
 * @param j 初次绘制源纹理单元
 * @param width
 * @param height
 * @param cx
 * @param cy
 * @param spread
 * @param d
 * @param sigma
 */


function drawBlur(gl, program, frameBuffer, texCache, tex1, tex2, i, j, width, height, cx, cy, spread, d, sigma) {
  // 第一次将total绘制到blur上，此时尺寸存在spread差值，因此不加模糊防止坐标计算问题，仅作为扩展纹理尺寸
  var _convertCoords2Gl9 = convertCoords2Gl([spread, height - spread], cx, cy),
      _convertCoords2Gl10 = _slicedToArray(_convertCoords2Gl9, 2),
      x1 = _convertCoords2Gl10[0],
      y2 = _convertCoords2Gl10[1];

  var _convertCoords2Gl11 = convertCoords2Gl([width - spread, spread], cx, cy),
      _convertCoords2Gl12 = _slicedToArray(_convertCoords2Gl11, 2),
      x2 = _convertCoords2Gl12[0],
      y1 = _convertCoords2Gl12[1]; // 顶点buffer


  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(program, 'a_position');
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer

  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // direction全0，即无模糊，此时只是进行扩展尺寸操作，还没到模糊所以传0

  var u_direction = gl.getUniformLocation(program, 'u_direction');
  gl.uniform2f(u_direction, 0, 0); // 纹理单元

  var u_texture = gl.getUniformLocation(program, 'u_texture');
  gl.uniform1i(u_texture, j);
  gl.drawArrays(gl.TRIANGLES, 0, 6); // fbo绑定切换纹理对象和单元索引，同时注意不能向源纹理绘制，因为源是cacheTotal，需要重新生成一个，y方向再来一次

  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  /**
   * 反复执行共3次，坐标等均不变，只是切换fbo绑定对象和纹理单元
   * 注意max和ratio的设置，当是100尺寸的正方形时，传给direction的始终为1
   * 当正方形<100时，direction相应地要扩大相对于100的倍数，反之则缩小，如此为了取相邻点坐标时是+-1
   * 当非正方形时，长轴一端为基准值不变，短的要二次扩大比例倍数
   */

  var max = 100 / Math.max(width, height);
  var ratio = width / height;
  var recycle = []; // 3次过程中新生成的中间纹理需要回收

  for (var k = 0; k < 3; k++) {
    var tex3 = createTexture(gl, null, j, width, height);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex3, 0);

    if (width >= height) {
      gl.uniform2f(u_direction, max, 0);
    } else {
      gl.uniform2f(u_direction, max * ratio, 0);
    }

    gl.uniform1i(u_texture, i);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    recycle.push(tex1);
    var tex4 = createTexture(gl, null, i, width, height);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex4, 0);

    if (width >= height) {
      gl.uniform2f(u_direction, 0, max * ratio);
    } else {
      gl.uniform2f(u_direction, 0, max);
    }

    gl.uniform1i(u_texture, j);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    tex1 = tex4;
    recycle.push(tex3);
  } // 回收


  gl.deleteBuffer(pointBuffer);
  gl.deleteBuffer(texBuffer);
  gl.disableVertexAttribArray(a_position);
  gl.disableVertexAttribArray(a_texCoords);
  recycle.forEach(function (item) {
    return gl.deleteTexture(item);
  });
  return tex1;
}

function drawCm(gl, program, i, m) {
  // 顶点buffer
  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(program, 'a_position');
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer

  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // 纹理单元

  var u_texture = gl.getUniformLocation(program, 'u_texture');
  gl.uniform1i(u_texture, i); // matrix

  var u_m = gl.getUniformLocation(program, 'u_m');
  gl.uniform1fv(u_m, new Float32Array(m));
  gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

  gl.deleteBuffer(pointBuffer);
  gl.deleteBuffer(texBuffer);
  gl.disableVertexAttribArray(a_position);
  gl.disableVertexAttribArray(a_texCoords);
}
/**
 * 根据total/filter生成overflow
 * @param gl
 * @param i 输入纹理单元
 * @param dx 二者偏移值
 * @param dy
 * @param width 最终大小
 * @param height
 * @param w 输入纹理大小
 * @param h
 */


function drawOverflow(gl, i, dx, dy, width, height, w, h) {
  // 顶点buffer
  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(gl.programOverflow, 'a_position');
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer，原本大小width/height，使用其中的w/h

  var x1 = dx / w,
      y1 = dy / h,
      x2 = (width + dx) / w,
      y2 = (height + dy) / h;
  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(gl.programOverflow, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // 纹理单元

  var u_texture = gl.getUniformLocation(gl.programOverflow, 'u_texture');
  gl.uniform1i(u_texture, i);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.deleteBuffer(pointBuffer);
}

function drawMask(gl, i, j, program) {
  // 顶点buffer
  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(program, 'a_position');
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer

  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // 纹理单元

  var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
  gl.uniform1i(u_texture1, j);
  var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
  gl.uniform1i(u_texture2, i);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.deleteBuffer(pointBuffer);
  gl.deleteBuffer(texBuffer);
  gl.disableVertexAttribArray(a_position);
  gl.disableVertexAttribArray(a_texCoords);
}

function drawMbm(gl, program, i, j, W, H) {
  // 顶点buffer
  var pointBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  var a_position = gl.getAttribLocation(program, 'a_position');
  gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_position); // 纹理buffer

  var texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
  var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
  gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(a_texCoords); // 纹理单元

  var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
  gl.uniform1i(u_texture1, i);
  var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
  gl.uniform1i(u_texture2, j);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.deleteBuffer(pointBuffer);
  gl.deleteBuffer(texBuffer);
  gl.disableVertexAttribArray(a_position);
  gl.disableVertexAttribArray(a_texCoords);
}

var webgl = {
  initShaders: initShaders,
  createTexture: createTexture,
  bindTexture: bindTexture,
  drawTextureCache: drawTextureCache,
  drawBlur: drawBlur,
  drawOverflow: drawOverflow,
  drawMask: drawMask,
  drawMbm: drawMbm,
  drawCm: drawCm
};

var SPF = 1000 / 60;
var CANVAS$1 = {};
var WEBGL$1 = {};
var CANVAS_LIST = [];
var WEBGL_LIST = [];
var SUPPORT_OFFSCREEN_CANVAS = typeof OffscreenCanvas === 'function' && util.isFunction(OffscreenCanvas.prototype.getContext);
var defaultFontFamilyData;

function cache(key, width, height, hash, message) {
  var o;

  if (!key) {
    var target = hash === CANVAS$1 ? CANVAS_LIST : WEBGL_LIST;

    if (target.length) {
      o = target.pop();
    } else {
      o = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
    }
  } else if (!hash[key]) {
    o = hash[key] = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
  } else {
    o = hash[key];
  }

  o.width = width;
  o.height = height;

  if (debug.flag) {
    o.style.width = width + 'px';
    o.style.height = height + 'px';
    o.setAttribute('type', hash === CANVAS$1 ? 'canvas' : 'webgl');

    if (key) {
      o.setAttribute('key', key);
    }

    if (message) {
      o.setAttribute('message', message);
    }

    document.body.appendChild(o);
  }

  var ctx;

  if (hash === CANVAS$1) {
    ctx = o.getContext('2d');
  } else {
    ctx = o.getContext('webgl', ca) || o.getContext('experimental-webgl', ca);
  }

  return {
    canvas: o,
    ctx: ctx,
    draw: function draw() {// 空函数，仅对小程序提供hook特殊处理，flush缓冲
    },
    enabled: true,
    available: true,
    release: function release() {
      if (!key && this.available) {
        if (hash === CANVAS$1) {
          CANVAS_LIST.push(this.canvas);
        } else {
          WEBGL_LIST.push(this.canvas);
        }
      }

      this.available = false;
    }
  };
}

function cacheCanvas(key, width, height, message) {
  return cache(key, width, height, CANVAS$1, message);
}

function cacheWebgl(key, width, height, message) {
  return cache(key, width, height, WEBGL$1, message);
}

var IMG = {};
var INIT = 0;
var LOADING = 1;
var LOADED = 2;
var FONT = {};
var COMPONENT = {};
var inject = {
  measureText: function measureText() {
    var list = textCache.list,
        data = textCache.data;
    var html = '';
    var keys = [];
    var lengths = [];
    var chars = [];
    Object.keys(data).forEach(function (key) {
      var _data$key = data[key],
          ff = _data$key.ff,
          fs = _data$key.fs,
          fw = _data$key.fw,
          s = _data$key.s;

      if (s) {
        keys.push(key);
        lengths.push(s.length);
        var inline = "position:absolute;font-family:".concat(ff, ";font-size:").concat(fs, "px;font-weight:").concat(fw);

        for (var i = 0, len = s.length; i < len; i++) {
          var _char = s.charAt(i);

          chars.push(_char);
          html += "<span style=\"".concat(inline, "\">").concat(_char.replace(/</, '&lt;').replace(' ', '&nbsp;'), "</span>");
        }

        data[key].s = '';
      }
    });

    if (!html) {
      return;
    }

    var div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '99999px';
    div.style.top = '-99999px';
    div.style.visibility = 'hidden';
    document.body.appendChild(div);
    div.innerHTML = html;
    var cns = div.childNodes;
    var charWidth = textCache.charWidth;
    var count = 0,
        index = 0,
        key;

    for (var i = 0, len = cns.length; i < len; i++) {
      var node = cns[i];

      if (count === 0) {
        key = keys[index];
      }

      if (++count === lengths[index]) {
        index++;
        count = 0;
      }

      var _char2 = chars[i]; // clientWidth只返回ceil整数，精度必须用getComputedStyle

      var css = window.getComputedStyle(node, null);
      charWidth[key][_char2] = parseFloat(css.width);
    }

    list.forEach(function (text) {
      return text.__measureCb();
    });
    textCache.list = [];
    textCache.data = {};

    if (!debug.flag) {
      document.body.removeChild(div);
    }
  },
  measureTextSync: function measureTextSync(key, ff, fs, fw, _char3) {
    var inline = "position:absolute;font-family:".concat(ff, ";font-size:").concat(fs, "px;font-weight:").concat(fw);
    var html = "<span style=\"".concat(inline, "\">").concat(_char3, "</span><span style=\"").concat(inline, "\">").concat(_char3).concat(_char3, "</span>");
    var div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '99999px';
    div.style.top = '-99999px';
    div.style.visibility = 'hidden';
    document.body.appendChild(div);
    div.innerHTML = html;
    var cns = div.childNodes;
    var w1 = parseFloat(window.getComputedStyle(cns[0], null).width);
    var w2 = parseFloat(window.getComputedStyle(cns[1], null).width);
    return w1 * 2 - w2;
  },
  IMG: IMG,
  INIT: INIT,
  LOADED: LOADED,
  LOADING: LOADING,
  measureImg: function measureImg(url, cb) {
    if (Array.isArray(url)) {
      if (!url.length) {
        return cb();
      }

      var count = 0;
      var len = url.length;
      var list = [];
      url.forEach(function (item, i) {
        inject.measureImg(item, function (cache) {
          list[i] = cache;

          if (++count === len) {
            cb(list);
          }
        });
      });
      return;
    } else if (!url || !util.isString(url)) {
      inject.error('Measure img invalid: ' + url);
      cb && cb({
        state: LOADED,
        success: false,
        url: url
      });
      return;
    }

    var cache = IMG[url] = IMG[url] || {
      state: INIT,
      task: []
    };

    if (cache.state === LOADED) {
      cb && cb(cache);
    } else if (cache.state === LOADING) {
      cb && cache.task.push(cb);
    } else {
      cache.state = LOADING;
      cb && cache.task.push(cb);
      var img = new Image();

      img.onload = function () {
        cache.state = LOADED;
        cache.success = true;
        cache.width = img.width;
        cache.height = img.height;
        cache.source = img;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
      };

      img.onerror = function (e) {
        cache.state = LOADED;
        cache.success = false;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
      };

      if (url.substr(0, 5) !== 'data:') {
        var host = /^(?:\w+:)?\/\/([^/:]+)/.exec(url);

        if (host) {
          if (location.hostname !== host[1]) {
            img.crossOrigin = 'anonymous';
          }
        }
      }

      img.src = url;

      if (debug.flag) {
        document.body.appendChild(img);
      }
    }
  },
  warn: function warn(s) {
    console.warn(s);
  },
  error: function error(s) {
    console.error(s);
  },
  requestAnimationFrame: function (_requestAnimationFrame) {
    function requestAnimationFrame(_x) {
      return _requestAnimationFrame.apply(this, arguments);
    }

    requestAnimationFrame.toString = function () {
      return _requestAnimationFrame.toString();
    };

    return requestAnimationFrame;
  }(function (cb) {
    if (!cb) {
      return;
    }

    var res;

    if (typeof requestAnimationFrame !== 'undefined') {
      inject.requestAnimationFrame = requestAnimationFrame.bind(window);
      res = requestAnimationFrame(cb);
    } else {
      res = setTimeout(cb, SPF);

      inject.requestAnimationFrame = function (cb) {
        return setTimeout(cb, SPF);
      };
    }

    return res;
  }),
  cancelAnimationFrame: function (_cancelAnimationFrame) {
    function cancelAnimationFrame(_x2) {
      return _cancelAnimationFrame.apply(this, arguments);
    }

    cancelAnimationFrame.toString = function () {
      return _cancelAnimationFrame.toString();
    };

    return cancelAnimationFrame;
  }(function (id) {
    var res;

    if (typeof cancelAnimationFrame !== 'undefined') {
      inject.cancelAnimationFrame = cancelAnimationFrame.bind(window);
      res = cancelAnimationFrame(id);
    } else {
      res = clearTimeout(id);

      inject.cancelAnimationFrame = function (id) {
        return clearTimeout(id);
      };
    }

    return res;
  }),
  now: function now() {
    if (typeof performance !== 'undefined') {
      inject.now = function () {
        return Math.floor(performance.now());
      };

      return Math.floor(performance.now());
    }

    inject.now = Date.now.bind(Date);
    return Date.now();
  },
  hasCacheCanvas: function hasCacheCanvas(key) {
    return key && CANVAS$1.hasOwnProperty(key);
  },
  getCacheCanvas: function getCacheCanvas(width, height, key, message) {
    return cacheCanvas(key, width, height, message);
  },
  releaseCacheCanvas: function releaseCacheCanvas(o) {
    CANVAS_LIST.push(o);
  },
  delCacheCanvas: function delCacheCanvas(key) {
    key && delete CANVAS$1[key];
  },
  hasCacheWebgl: function hasCacheWebgl(key) {
    return key && WEBGL$1.hasOwnProperty(key);
  },
  getCacheWebgl: function getCacheWebgl(width, height, key, message) {
    return cacheWebgl(key, width, height, message);
  },
  releaseCacheWebgl: function releaseCacheWebgl(o) {
    WEBGL_LIST.push(o);
  },
  delCacheWebgl: function delCacheWebgl(key) {
    key && delete WEBGL$1[key];
  },
  isDom: function isDom(o) {
    if (o) {
      if (util.isString(o)) {
        return true;
      }

      if (typeof window !== 'undefined' && window.Element && o instanceof window.Element) {
        return true;
      }

      if (typeof window !== 'undefined' && window.OffscreenCanvas && o instanceof window.OffscreenCanvas) {
        return true;
      } // worker


      if (typeof self !== 'undefined' && self.OffscreenCanvas && o instanceof self.OffscreenCanvas) {
        return true;
      }

      if (util.isFunction(o.getElementsByTagName)) {
        return true;
      }
    }

    return false;
  },
  isWebGLTexture: function isWebGLTexture(o) {
    if (o && typeof WebGLTexture !== 'undefined') {
      return o instanceof WebGLTexture;
    }
  },
  checkSupportFontFamily: function checkSupportFontFamily(ff) {
    ff = ff.toLowerCase(); // 强制arial兜底

    if (ff === 'arial') {
      return true;
    }

    if (!o$3.info.hasOwnProperty(ff)) {
      return false;
    }

    if (o$3.info[ff].hasOwnProperty('checked')) {
      return o$3.info[ff].checked;
    }

    var canvas = inject.getCacheCanvas(16, 16, '__$$CHECK_SUPPORT_FONT_FAMILY$$__');
    var context = canvas.ctx;
    context.textAlign = 'center';
    context.fillStyle = '#000';
    context.textBaseline = 'middle';

    if (!defaultFontFamilyData) {
      context.clearRect(0, 0, 16, 16);
      context.font = '16px arial';
      context.fillText('a', 8, 8);
      canvas.draw();
      defaultFontFamilyData = context.getImageData(0, 0, 16, 16).data;
    }

    context.clearRect(0, 0, 16, 16);
    context.font = '16px ' + ff;
    context.fillText('a', 8, 8);
    canvas.draw();
    var data = context.getImageData(0, 0, 16, 16).data;

    for (var i = 0, len = data.length; i < len; i++) {
      if (defaultFontFamilyData[i] !== data[i]) {
        return o$3.info[ff].checked = true;
      }
    }

    return o$3.info[ff].checked = false;
  },
  loadFont: function loadFont(url, cb) {
    if (Array.isArray(url)) {
      if (!url.length) {
        return cb();
      }

      var count = 0;
      var len = url.length;
      var list = [];
      url.forEach(function (item, i) {
        inject.loadFont(item, function (cache) {
          list[i] = cache;

          if (++count === len) {
            cb(list);
          }
        });
      });
      return;
    } else if (!url || !util.isString(url)) {
      inject.error('Load font invalid: ' + url);
      cb && cb({
        state: LOADED,
        success: false,
        url: url
      });
      return;
    }

    var cache = FONT[url] = FONT[url] || {
      state: INIT,
      task: []
    };

    if (cache.state === LOADED) {
      cb && cb(cache);
    } else if (cache.state === LOADING) {
      cb && cache.task.push(cb);
    } else {
      cache.state = LOADING;
      cb && cache.task.push(cb);
      var f = new FontFace(url, "url(".concat(url, ")"));
      f.load().then(function () {
        cache.state = LOADED;
        cache.success = true;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
      })["catch"](function () {
        cache.state = LOADED;
        cache.success = false;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
      });
    }
  },
  loadComponent: function loadComponent(url, cb) {
    if (Array.isArray(url)) {
      if (!url.length) {
        return cb();
      }

      var count = 0;
      var len = url.length;
      var list = [];
      url.forEach(function (item, i) {
        inject.loadComponent(item, function (cache) {
          list[i] = cache;

          if (++count === len) {
            cb(list);
          }
        });
      });
      return;
    } else if (!url || !util.isString(url)) {
      inject.error('Load component invalid: ' + url);
      cb && cb({
        state: LOADED,
        success: false,
        url: url
      });
      return;
    }

    var cache = COMPONENT[url] = COMPONENT[url] || {
      state: INIT,
      task: []
    };

    if (cache.state === LOADED) {
      cb && cb(cache);
    } else if (cache.state === LOADING) {
      cb && cache.task.push(cb);
    } else {
      cache.state = LOADING;
      cb && cache.task.push(cb);
      var script = document.createElement('script');
      script.src = url;
      script.async = true;

      script.onload = function () {
        cache.state = LOADED;
        cache.success = true;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
        document.head.removeChild(script);
      };

      script.onerror = function () {
        cache.state = LOADED;
        cache.success = false;
        cache.url = url;
        var list = cache.task.splice(0);
        list.forEach(function (cb) {
          return cb(cache);
        });
        document.head.removeChild(script);
      };

      document.head.appendChild(script);
    }
  }
};

var rgba2int$2 = util.rgba2int,
    isNil$e = util.isNil;
var PX$a = o$4.PX,
    PERCENT$b = o$4.PERCENT,
    DEG$2 = o$4.DEG,
    NUMBER$5 = o$4.NUMBER,
    REM$f = o$4.REM,
    VW$f = o$4.VW,
    VH$f = o$4.VH,
    calUnit$2 = o$4.calUnit;
var d2r$1 = geom$1.d2r;
var canvasPolygon$5 = painter.canvasPolygon,
    svgPolygon$5 = painter.svgPolygon;
var FONT_SIZE$g = enums.STYLE_KEY.FONT_SIZE,
    NODE_DEFS_CACHE$6 = enums.NODE_KEY.NODE_DEFS_CACHE;

function getLinearDeg(v) {
  var deg = 180;

  if (v === 'to top') {
    deg = 0;
  } else if (v === 'to top right') {
    deg = 45;
  } else if (v === 'to right') {
    deg = 90;
  } else if (v === 'to bottom right') {
    deg = 135;
  } else if (v === 'to bottom') ; else if (v === 'to bottom left') {
    deg = 225;
  } else if (v === 'to left') {
    deg = 270;
  } else if (v === 'to top left') {
    deg = 315;
  } // 数字角度，没有的话取默认角度
  else {
    var match = /([-+]?[\d.]+)deg/.exec(v);

    if (match) {
      deg = parseFloat(match[1]);
    }
  }

  return deg % 360;
}

function getRadialPosition(data) {
  if (/^[-+]?[\d.]/.test(data)) {
    var v = calUnit$2(data);

    if ([NUMBER$5, DEG$2].indexOf(v[1]) > -1) {
      v[1] = PX$a;
    }

    return v;
  } else {
    return [{
      top: 0,
      left: 0,
      center: 50,
      right: 100,
      bottom: 100
    }[data] || 50, PERCENT$b];
  }
} // 获取color-stop区间范围，去除无用值


function getColorStop(v, length, root) {
  var list = [];
  var firstColor = v[0][0]; // 先把已经声明距离的换算成[0,1]以数组形式存入，未声明的原样存入

  for (var i = 0, len = v.length; i < len; i++) {
    var item = v[i]; // 考虑是否声明了位置

    if (item.length > 1) {
      var p = item[1];

      if (p[1] === PERCENT$b) {
        list.push([item[0], p[0] * 0.01]);
      } else if (p[1] === REM$f) {
        list.push([item[0], p[0] * root.computedStyle[FONT_SIZE$g] / length]);
      } else if (p[1] === VW$f) {
        list.push([item[0], p[0] * root.width / length]);
      } else if (p[1] === VH$f) {
        list.push([item[0], p[0] * root.height / length]);
      } else {
        list.push([item[0], p[0] / length]);
      }
    } else {
      list.push([item[0]]);
    }
  }

  if (list.length === 1) {
    list.push(util.clone(list[0]));
  } // 首尾不声明默认为[0, 1]


  if (list[0].length === 1) {
    list[0].push(0);
  }

  if (list.length > 1) {
    var _i = list.length - 1;

    if (list[_i].length === 1) {
      list[_i].push(1);
    }
  } // 找到未声明位置的，需区间计算，找到连续的未声明的，前后的区间平分


  var start = list[0][1];

  for (var _i2 = 1, _len = list.length; _i2 < _len - 1; _i2++) {
    var _item = list[_i2];

    if (_item.length > 1) {
      start = _item[1];
    } else {
      var j = _i2 + 1;
      var end = list[list.length - 1][1];

      for (; j < _len - 1; j++) {
        var _item2 = list[j];

        if (_item2.length > 1) {
          end = _item2[1];
          break;
        }
      }

      var num = j - _i2 + 1;
      var per = (end - start) / num;

      for (var k = _i2; k < j; k++) {
        var _item3 = list[k];

        _item3.push(start + per * (k + 1 - _i2));
      }

      _i2 = j;
    }
  } // 每个不能小于前面的，canvas/svg不能兼容这种情况，需处理


  for (var _i3 = 1, _len2 = list.length; _i3 < _len2; _i3++) {
    var _item4 = list[_i3];
    var prev = list[_i3 - 1];

    if (_item4[1] < prev[1]) {
      _item4[1] = prev[1];
    }
  } // 0之前的和1之后的要过滤掉


  for (var _i4 = 0, _len3 = list.length; _i4 < _len3; _i4++) {
    var _item5 = list[_i4];

    if (_item5[1] > 1) {
      list.splice(_i4);
      var _prev = list[_i4 - 1];

      if (_prev && _prev[1] < 1) {
        var dr = _item5[0][0] - _prev[0][0];
        var dg = _item5[0][1] - _prev[0][1];
        var db = _item5[0][2] - _prev[0][2];
        var da = _item5[0][3] - _prev[0][3];

        var _p = (1 - _prev[1]) / (_item5[1] - _prev[1]);

        list.push([[_item5[0][0] + dr * _p, _item5[0][1] + dg * _p, _item5[0][2] + db * _p, _item5[0][3] + da * _p], 1]);
      }

      break;
    }
  }

  for (var _i5 = list.length - 1; _i5 >= 0; _i5--) {
    var _item6 = list[_i5];

    if (_item6[1] < 0) {
      list.splice(0, _i5 + 1);
      var next = list[_i5];

      if (next && next[1] > 0) {
        var _dr = next[0][0] - _item6[0][0];

        var _dg = next[0][1] - _item6[0][1];

        var _db = next[0][2] - _item6[0][2];

        var _da = next[0][3] - _item6[0][3];

        var _p2 = -_item6[1] / (next[1] - _item6[1]);

        list.unshift([[_item6[0][0] + _dr * _p2, _item6[0][1] + _dg * _p2, _item6[0][2] + _db * _p2, _item6[0][3] + _da * _p2], 0]);
      }

      break;
    }
  } // 可能存在超限情况，如在使用px单位超过len或<len时，canvas会报错超过[0,1]区间，需手动换算至区间内


  list.forEach(function (item) {
    // item[0] = int2rgba(item[0]);
    if (item[1] < 0) {
      item[1] = 0;
    } else if (item[1] > 1) {
      item[1] = 1;
    }
  }); // 都超限时，第一个颜色兜底

  if (!list.length) {
    list.push([firstColor, 0]);
  }

  return list;
} // 根据角度和圆心获取渐变的4个点坐标


function calLinearCoords(deg, length, cx, cy) {
  var x0;
  var y0;
  var x1;
  var y1;

  if (deg >= 270) {
    var r = d2r$1(360 - deg);
    x0 = cx + Math.sin(r) * length;
    y0 = cy + Math.cos(r) * length;
    x1 = cx - Math.sin(r) * length;
    y1 = cy - Math.cos(r) * length;
  } else if (deg >= 180) {
    var _r = d2r$1(deg - 180);

    x0 = cx + Math.sin(_r) * length;
    y0 = cy - Math.cos(_r) * length;
    x1 = cx - Math.sin(_r) * length;
    y1 = cy + Math.cos(_r) * length;
  } else if (deg >= 90) {
    var _r2 = d2r$1(180 - deg);

    x0 = cx - Math.sin(_r2) * length;
    y0 = cy - Math.cos(_r2) * length;
    x1 = cx + Math.sin(_r2) * length;
    y1 = cy + Math.cos(_r2) * length;
  } else {
    var _r3 = d2r$1(deg);

    x0 = cx - Math.sin(_r3) * length;
    y0 = cy + Math.cos(_r3) * length;
    x1 = cx + Math.sin(_r3) * length;
    y1 = cy - Math.cos(_r3) * length;
  }

  return [x0, y0, x1, y1];
}

function calCircleCentre(position, x1, y1, iw, ih, root) {
  var cx, cy;
  var positionX = position[0],
      positionY = position[1];

  if (positionX[1] === PERCENT$b) {
    cx = x1 + positionX[0] * iw * 0.01;
  } else if (positionX[1] === REM$f) {
    cx = x1 + positionX[0] * root.computedStyle[FONT_SIZE$g];
  } else if (positionX[1] === VW$f) {
    cx = x1 + positionX[0] * root.width * 0.01;
  } else if (positionX[1] === VH$f) {
    cx = x1 + positionX[0] * root.height * 0.01;
  } else {
    cx = x1 + positionX[0];
  }

  if (positionY[1] === PERCENT$b) {
    cy = y1 + positionY[0] * ih * 0.01;
  } else if (positionY[1] === REM$f) {
    cy = y1 + positionY[0] * root.computedStyle[FONT_SIZE$g];
  } else if (positionY[1] === VW$f) {
    cy = y1 + positionY[0] * root.width * 0.01;
  } else if (positionY[1] === VH$f) {
    cy = y1 + positionY[0] * root.height * 0.01;
  } else {
    cy = y1 + positionY[0];
  }

  return [cx, cy];
} // 获取径向渐变圆心半径


function calRadialRadius(shape, size, position, iw, ih, x1, y1, x2, y2, root) {
  var cx,
      cy,
      xl,
      yl,
      r,
      d = 0; // 扩展的from to ratio格式，圆心、长轴坐标、短轴缩放比

  if (Array.isArray(size)) {
    cx = x1 + size[0] * iw;
    cy = y1 + size[1] * ih;

    if (size[4] <= 0) {
      r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
    } else {
      xl = Math.sqrt(Math.pow((size[2] - size[0]) * iw, 2) + Math.pow((size[3] - size[1]) * ih, 2));
      yl = xl * size[4];
      r = Math.max(xl, yl); // 看旋转

      if (size[2] >= size[0]) {
        if (size[3] >= size[1]) {
          d = Math.asin((size[3] - size[1]) * ih / xl);
        } else {
          d = -Math.asin((size[1] - size[3]) * ih / xl);
        }
      } else {
        if (size[3] >= size[1]) {
          d = d2r$1(180) - Math.asin((size[3] - size[1]) * ih / xl);
        } else {
          d = Math.asin((size[1] - size[3]) * ih / xl) - d2r$1(180);
        }
      }
    }
  } else {
    // 默认椭圆a是水平轴，b是垂直轴
    var _calCircleCentre = calCircleCentre(position, x1, y1, iw, ih, root);

    var _calCircleCentre2 = _slicedToArray(_calCircleCentre, 2);

    cx = _calCircleCentre2[0];
    cy = _calCircleCentre2[1];
    var ratio = 1;

    if (size === 'closest-corner' && shape === 'circle') {
      if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
        r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
      } else {
        if (cx < x1 + iw * 0.5) {
          xl = cx - x1;
        } else {
          xl = x2 - cx;
        }

        if (cy < y1 + ih * 0.5) {
          yl = cy - y1;
        } else {
          yl = y2 - cy;
        }

        r = Math.sqrt(Math.pow(xl, 2) + Math.pow(yl, 2));
      }
    } else if (size === 'closest-side' || size === 'closest-corner') {
      // 在边外特殊情况只有end颜色填充
      if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
        r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
      } else {
        var _ratio = 1;

        if (cx < x1 + iw * 0.5) {
          xl = cx - x1;
        } else {
          xl = x2 - cx;
        }

        if (cy < y1 + ih * 0.5) {
          yl = cy - y1;
        } else {
          yl = y2 - cy;
        }

        r = Math.min(xl, yl); // css的角和边有对应关系，即边扩展倍数，计算为固定值

        if (size === 'closest-corner') {
          _ratio = Math.sqrt(2);
        }

        xl *= _ratio;
        yl *= _ratio;
        r *= _ratio;
      }
    } else {
      if (cx <= x1) {
        xl = x1 - cx + iw;
      } else if (cx >= x2) {
        xl = cx - x2 + iw;
      } else if (cx < x1 + iw * 0.5) {
        xl = x2 - cx;
      } else {
        xl = cx - x1;
      }

      if (cy <= y1) {
        yl = y1 - cy + ih;
      } else if (cy >= y2) {
        yl = cy - y2 + ih;
      } else if (cy < y1 + ih * 0.5) {
        yl = y2 - cy;
      } else {
        yl = cy - y1;
      }

      r = Math.max(xl, yl);

      if (size !== 'farthest-side') {
        ratio = Math.sqrt(2);
      }

      xl *= ratio;
      yl *= ratio;
      r *= ratio;
    }
  }

  if (shape === 'circle') {
    xl = yl = r;
  }

  return [cx, cy, r, xl, yl, d];
}

function parseGradient(s) {
  var gradient = reg.gradient.exec(s);

  if (gradient) {
    var o = {
      k: gradient[1]
    };

    if (o.k === 'linear') {
      var deg = /([-+]?[\d.]+deg)|(to\s+[toprighbml]+)/i.exec(gradient[2]);

      if (deg) {
        o.d = getLinearDeg(deg[0].toLowerCase());
      } // 扩展支持从a点到b点相对坐标，而不是css角度，sketch等ui软件中用此格式
      else {
        var points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)/.exec(gradient[2]);

        if (points) {
          o.d = [parseFloat(points[1]), parseFloat(points[2]), parseFloat(points[3]), parseFloat(points[4])];
        } else {
          o.d = 180;
        }
      }
    } else if (o.k === 'radial') {
      o.s = gradient[2].indexOf('circle') > -1 ? 'circle' : 'ellipse';
      var size = /(closest|farthest)-(side|corner)/i.exec(gradient[2]);

      if (size) {
        o.z = size[0].toLowerCase();
      } // 扩展支持从a点到b点相对坐标，而不是size，sketch等ui软件中用此格式
      else {
        var _points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)(?:\s+([\d.]+))?/.exec(gradient[2]);

        if (_points) {
          o.z = [parseFloat(_points[1]), parseFloat(_points[2]), parseFloat(_points[3]), parseFloat(_points[4])];

          if (!isNil$e(_points[5])) {
            o.z.push(parseFloat(_points[5]));
          } else {
            o.z.push(1);
          }
        } else {
          o.z = 'farthest-corner';
        }
      }

      var position = /at\s+((?:[-+]?[\d.]+[pxremvwh%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwh%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

      if (position) {
        var x = getRadialPosition(position[1]);
        var y = position[2] ? getRadialPosition(position[2]) : x;
        o.p = [x, y];
      } else {
        o.p = [[50, PERCENT$b], [50, PERCENT$b]];
      }
    } else if (o.k === 'conic') {
      var _deg = /([-+]?[\d.]+deg)/i.exec(gradient[2]);

      if (_deg) {
        o.d = parseFloat(_deg[0]) % 360;
      } else {
        o.d = 0;
      }

      var _position = /at\s+((?:[-+]?[\d.]+[pxremvwh%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwh%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

      if (_position) {
        var _x = getRadialPosition(_position[1]);

        var _y = _position[2] ? getRadialPosition(_position[2]) : _x;

        o.p = [_x, _y];
      } else {
        o.p = [[50, PERCENT$b], [50, PERCENT$b]];
      }
    }

    var v = gradient[2].match(/([-+]?[\d.]+[pxremvwh%]+)?\s*((#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))\s*([-+]?[\d.]+[pxremvwh%]+)?/ig) || [];
    o.v = v.map(function (item) {
      var color = /((?:#[0-9a-f]{3,8})|(?:rgba?\s*\(.+?\)))/i.exec(item);
      var arr = [rgba2int$2(color[1])];
      var percent = /[-+]?[\d.]+[pxremvwh%]+/.exec(item);

      if (percent) {
        var _v = calUnit$2(percent[0]);

        if ([NUMBER$5, DEG$2].indexOf(_v[1]) > -1) {
          _v[1] = PX$a;
        }

        arr[1] = _v;
      }

      return arr;
    });
    return o;
  }
}

function getLinear(v, d, ox, oy, cx, cy, w, h, root) {
  // d为数组是2个坐标点，数字是css标准角度
  var x1, y1, x2, y2, stop;

  if (Array.isArray(d)) {
    x1 = ox + d[0] * w;
    y1 = oy + d[1] * h;
    x2 = ox + d[2] * w;
    y2 = oy + d[3] * h;
    var total = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    stop = getColorStop(v, total);
  } else {
    while (d >= 360) {
      d -= 360;
    }

    while (d < 0) {
      d += 360;
    } // 根据角度求直线上2点，设置半径为长宽最大值，这样一定在矩形外，看做一个向量A


    var len = Math.max(w, h);
    var coords = calLinearCoords(d, len, cx, cy);
    len *= 2; // start和4个顶点的向量在A上的投影长度

    var l1 = vector.dotProduct(ox - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
    var l2 = vector.dotProduct(ox + w - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
    var l3 = vector.dotProduct(ox + w - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
    var l4 = vector.dotProduct(ox - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len; // 最小和最大值为0~100%

    var min = l1,
        max = l1;
    min = Math.min(min, Math.min(l2, Math.min(l3, l4)));
    max = Math.max(max, Math.max(l2, Math.max(l3, l4))); // 求得0和100%的长度和坐标

    var _total = max - min;

    var r1 = min / len;
    var dx = coords[2] - coords[0];
    var dy = coords[3] - coords[1];
    x1 = coords[0] + dx * r1;
    y1 = coords[1] + dy * r1;
    x2 = coords[2] - dx * r1;
    y2 = coords[3] - dy * r1;
    stop = getColorStop(v, _total, root);
  }

  return {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2,
    stop: stop
  };
}

function getRadial(v, shape, size, position, x1, y1, x2, y2, root) {
  var w = x2 - x1;
  var h = y2 - y1;

  var _calRadialRadius = calRadialRadius(shape, size, position, w, h, x1, y1, x2, y2, root),
      _calRadialRadius2 = _slicedToArray(_calRadialRadius, 6),
      cx = _calRadialRadius2[0],
      cy = _calRadialRadius2[1],
      r = _calRadialRadius2[2],
      xl = _calRadialRadius2[3],
      yl = _calRadialRadius2[4],
      d = _calRadialRadius2[5]; // 圆形取最小值，椭圆根据最小圆进行transform，椭圆其中一边轴和r一样，另一边则大小缩放可能


  var matrix,
      scx = 1,
      scy = 1;

  if (xl !== yl || d) {
    matrix = [1, 0, 0, 1, 0, 0];

    if (d) {
      var sin = Math.sin(d);
      var cos = Math.cos(d);
      matrix = [cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }

    if (xl !== r) {
      scx = xl / r;
      var m = [scx, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      matrix = mx.multiply(matrix, m);
    }

    if (yl !== r) {
      scy = yl / r;
      var _m = [1, 0, 0, 0, 0, scy, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      matrix = mx.multiply(matrix, _m);
    }
  }

  var stop = getColorStop(v, r, root);
  return {
    cx: cx,
    cy: cy,
    r: r,
    stop: stop,
    scx: scx,
    scy: scy,
    matrix: matrix,
    d: d
  };
}

function getConic(v, d, p, x1, y1, x2, y2, ratio, root) {
  var _calConicRadius = calConicRadius(v, d, p, x1, y1, x2, y2, root),
      _calConicRadius2 = _slicedToArray(_calConicRadius, 4),
      cx = _calConicRadius2[0],
      cy = _calConicRadius2[1],
      r = _calConicRadius2[2],
      deg = _calConicRadius2[3];

  var stop = getColorStop(v, 1, root);
  r <<= 1; // 锥形半径*2，这样分割画圆时保证一定会填满原有矩形

  r *= ratio; // 矢量图形比较特殊，有可能超限，传入个倍数扩大半径

  return {
    cx: cx,
    cy: cy,
    w: x2 - x1,
    h: y2 - y1,
    r: r,
    deg: deg,
    stop: stop
  };
}

function calConicRadius(v, deg, position, x1, y1, x2, y2, root) {
  var iw = x2 - x1;
  var ih = y2 - y1;

  var _calCircleCentre3 = calCircleCentre(position, x1, y1, iw, ih, root),
      _calCircleCentre4 = _slicedToArray(_calCircleCentre3, 2),
      cx = _calCircleCentre4[0],
      cy = _calCircleCentre4[1];

  var r, a, b;

  if (cx >= x1 + iw * 0.5) {
    a = cx - x1;
  } else {
    a = x2 - cx;
  }

  if (cy >= y1 + ih * 0.5) {
    b = cy - y1;
  } else {
    b = y2 - cy;
  }

  r = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
  return [cx, cy, r, deg];
}

function renderConic(xom, renderMode, ctx, res, x, y, w, h, btlr, btrr, bbrr, bblr, isInline) {
  // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间
  var list = border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

  if (!list) {
    list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
  }

  if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
    var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
    var imgData = offscreen.ctx.getImageData(0, 0, w, h);
    gradient$1.getConicGradientImage(res.cx - x, res.cy - y, res.w, res.h, res.stop, imgData.data);
    offscreen.ctx.putImageData(imgData, 0, 0);
    ctx.save();
    ctx.beginPath();
    canvasPolygon$5(ctx, list);
    ctx.clip();
    ctx.closePath();
    ctx.drawImage(offscreen.canvas, x, y);
    ctx.restore();
    offscreen.ctx.clearRect(0, 0, w, h);
  } else if (renderMode === mode.SVG) {
    if (isInline) {
      var v = {
        tagName: 'symbol',
        props: [],
        children: []
      };

      xom.__config[NODE_DEFS_CACHE$6].push(v);

      res.forEach(function (item) {
        v.children.push({
          type: 'item',
          tagName: 'path',
          props: [['d', svgPolygon$5(item[0])], ['fill', item[1]]]
        });
      });
      return ctx.add(v);
    } else {
      var _v2 = {
        tagName: 'clipPath',
        children: [{
          tagName: 'path',
          props: [['d', svgPolygon$5(list)]]
        }]
      };

      xom.__config[NODE_DEFS_CACHE$6].push(_v2);

      var clip = ctx.add(_v2);
      res.forEach(function (item) {
        xom.virtualDom.bb.push({
          type: 'item',
          tagName: 'path',
          props: [['d', svgPolygon$5(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
        });
      });
    }
  }
}

var gradient = {
  parseGradient: parseGradient,
  getLinear: getLinear,
  getRadial: getRadial,
  getConic: getConic,
  renderConic: renderConic
};

var DOM = {
  position: 'static',
  display: 'block',
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto',
  marginTop: 0,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  fontSize: 'inherit',
  fontFamily: 'inherit',
  color: 'inherit',
  fontStyle: 'inherit',
  fontWeight: 'inherit',
  lineHeight: 'inherit',
  backgroundImage: null,
  backgroundColor: 'transparent',
  backgroundSize: 'auto',
  backgroundRepeat: 'repeat',
  backgroundPositionX: 0,
  backgroundPositionY: 0,
  backgroundClip: 'borderBox',
  borderTopWidth: 0,
  borderRightWidth: 0,
  borderBottomWidth: 0,
  borderLeftWidth: 0,
  borderTopColor: '#000',
  borderRightColor: '#000',
  borderBottomColor: '#000',
  borderLeftColor: '#000',
  borderTopStyle: 'solid',
  borderRightStyle: 'solid',
  borderBottomStyle: 'solid',
  borderLeftStyle: 'solid',
  borderTopLeftRadius: 0,
  borderTopRightRadius: 0,
  borderBottomRightRadius: 0,
  borderBottomLeftRadius: 0,
  width: 'auto',
  height: 'auto',
  flexGrow: 0,
  flexShrink: 1,
  flexBasis: 'auto',
  flexDirection: 'row',
  flexWrap: 'nowrap',
  order: 0,
  justifyContent: 'flexStart',
  alignItems: 'stretch',
  alignSelf: 'auto',
  alignContent: 'stretch',
  textAlign: 'inherit',
  letterSpacing: 'inherit',
  transformOrigin: 'center',
  visibility: 'inherit',
  opacity: 1,
  zIndex: 0,
  transform: null,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  skewX: 0,
  skewY: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  rotate3d: '0, 0, 0, 0',
  perspective: 0,
  perspectiveOrigin: 'center',
  filter: null,
  boxShadow: null,
  pointerEvents: 'inherit',
  overflow: 'visible',
  mixBlendMode: 'normal',
  whiteSpace: 'inherit',
  textOverflow: 'clip',
  lineClamp: 0,
  textStrokeWidth: 'inherit',
  textStrokeColor: 'inherit',
  textStrokeOver: 'inherit'
};
var GEOM$4 = {
  fill: 'transparent',
  stroke: '#000',
  strokeWidth: 1,
  strokeDasharray: '',
  strokeLinecap: 'butt',
  strokeLinejoin: 'miter',
  strokeMiterlimit: 4,
  fillRule: 'nonzero'
};
var DOM_ENTRY_SET = [];
var DOM_KEY_SET = [];
Object.keys(DOM).forEach(function (k) {
  DOM_KEY_SET.push(k);
  var v = DOM[k];
  DOM_ENTRY_SET.push({
    k: k,
    v: v
  });
});
var GEOM_ENTRY_SET = [];
var GEOM_KEY_SET$2 = [];
Object.keys(GEOM$4).forEach(function (k) {
  GEOM_KEY_SET$2.push(k);
  var v = GEOM$4[k];
  GEOM_ENTRY_SET.push({
    k: k,
    v: v
  });
});
var INHERIT$5 = {
  fontFamily: 'arial',
  fontSize: 16,
  fontWeight: 400,
  fontStyle: 'normal',
  color: '#000',
  textAlign: 'left',
  visibility: 'visible',
  pointerEvents: 'auto',
  textStrokeColor: '#000',
  textStrokeWidth: 1,
  textStrokeOver: 'none'
};
var INHERIT_KEY_SET = [];
Object.keys(INHERIT$5).forEach(function (k) {
  INHERIT_KEY_SET.push(k);
});
var reset = {
  DOM: DOM,
  GEOM: GEOM$4,
  isValid: function isValid(i) {
    return DOM.hasOwnProperty(i) || GEOM$4.hasOwnProperty(i);
  },
  DOM_KEY_SET: DOM_KEY_SET,
  GEOM_KEY_SET: GEOM_KEY_SET$2,
  DOM_ENTRY_SET: DOM_ENTRY_SET,
  GEOM_ENTRY_SET: GEOM_ENTRY_SET,
  INHERIT: INHERIT$5,
  INHERIT_KEY_SET: INHERIT_KEY_SET
};

var isNil$d = util.isNil;

function parseFlex(style, grow, shrink, basis) {
  if (isNil$d(style.flexGrow)) {
    style.flexGrow = grow || 0;
  }

  if (isNil$d(style.flexShrink)) {
    style.flexShrink = shrink || 0;
  }

  if (isNil$d(style.flexBasis)) {
    style.flexBasis = basis || 0;
  }
}

function parseMarginPadding(style, key, list) {
  var temp = style[key];

  if (!isNil$d(temp)) {
    var match = temp.toString().match(/([-+]?[\d.]+[pxremvwh%]*)|(auto)/ig);

    if (match) {
      if (match.length === 1) {
        match[3] = match[2] = match[1] = match[0];
      } else if (match.length === 2) {
        match[2] = match[0];
        match[3] = match[1];
      } else if (match.length === 3) {
        match[3] = match[1];
      }

      list.forEach(function (k, i) {
        if (isNil$d(style[k])) {
          style[k] = match[i];
        }
      });
    }
  }
}

function parseOneBorder(style, k) {
  var v = style[k];

  if (isNil$d(v)) {
    return;
  } // 后面会统一格式化处理


  if (isNil$d(style[k + 'Width'])) {
    var w = /\b[\d.]+[pxremvwh%]*\b/i.exec(v);
    style[k + 'Width'] = w ? w[0] : 0;
  }

  if (isNil$d(style[k + 'Style'])) {
    var s = /\b(solid|dashed|dotted)\b/i.exec(v);
    style[k + 'Style'] = s ? s[1] : 'solid';
  }

  if (isNil$d(style[k + 'Color'])) {
    var c = /#[0-9a-f]{3,8}/i.exec(v);

    if (c && [4, 7, 9].indexOf(c[0].length) > -1) {
      style[k + 'Color'] = c[0];
    } else if (/\btransparent\b/i.test(v)) {
      style[k + 'Color'] = 'transparent';
    } else {
      c = /rgba?\s*\(.+\)/i.exec(v);
      style[k + 'Color'] = c ? c[0] : 'transparent';
    }
  }
}

var abbr$1 = {
  margin: ['marginTop', 'marginRight', 'marginBottom', 'marginLeft'],
  padding: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
  border: ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'],
  borderTop: ['borderTopWidth', 'borderTopStyle', 'borderTopColor'],
  borderRight: ['borderRightWidth', 'borderRightStyle', 'borderRightColor'],
  borderBottom: ['borderBottomWidth', 'borderBottomStyle', 'borderBottomColor'],
  borderLeft: ['borderLeftWidth', 'borderLeftStyle', 'borderLeftColor'],
  borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
  borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
  borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
  borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
  background: ['backgroundColor', 'backgroundImage', 'backgroundRepeat', 'backgroundPosition'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  flex: ['flexGrow', 'flexShrink', 'flexBasis'],
  translate: ['translateX', 'translateY'],
  translate3d: ['translateX', 'translateY', 'translateY'],
  scale: ['scaleX', 'scaleY'],
  scale3d: ['scaleX', 'scaleY', 'scaleZ'],
  rotate: ['rotateZ'],
  skew: ['skewX', 'skewY'],
  textStroke: ['textStrokeWidth', 'textStrokeColor', 'textStrokeOver'],
  toFull: function toFull(style, k) {
    var _this = this;

    var v = style[k];

    if (k === 'background') {
      // bg缩写多个时有color则必须是最后一个
      if (Array.isArray(v)) {
        var length = v.length;

        if (isNil$d(style.backgroundColor)) {
          var bgc = /^\s*((transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))/i.exec(v[length - 1]);

          if (bgc) {
            style.backgroundColor = bgc[0];
            v = v.slice(0, length - 1);
          }
        }

        var bgi = [];
        var bgr = [];
        var bgp = [];
        v.forEach(function (item) {
          if (isNil$d(style.backgroundImage)) {
            var gd = reg.gradient.exec(item);

            if (gd) {
              bgi.push(gd[0]);
              item = item.replace(gd[0], '');
            } else {
              var img = reg.img.exec(v);

              if (img) {
                bgi.push(img[0]);
                item = item.replace(img[0], '');
              }
            }
          }

          if (isNil$d(style.backgroundRepeat)) {
            var repeat = /(no-?)?repeat(-?[xy])?/i.exec(item);

            if (repeat) {
              bgr.push(repeat[0].toLowerCase());
            }
          }

          if (isNil$d(style.backgroundPosition)) {
            var position = item.match(reg.position);

            if (position) {
              bgp.push(position.join(' '));
            }
          }
        });

        if (bgi.length) {
          style.backgroundImage = bgi;
        }

        if (bgr.length) {
          style.backgroundRepeat = bgr;
        }

        if (bgp.length) {
          style.backgroundPosition = bgp;
          this.toFull(style, 'backgroundPosition');
        }
      } else {
        if (isNil$d(style.backgroundImage)) {
          var gd = reg.gradient.exec(v);

          if (gd) {
            style.backgroundImage = gd[0];
            v = v.replace(gd[0], '');
          } else {
            var img = reg.img.exec(v);

            if (img) {
              style.backgroundImage = img[0];
              v = v.replace(img[0], '');
            }
          }
        }

        if (isNil$d(style.backgroundRepeat)) {
          var repeat = /(no-?)?repeat(-?[xy])?/i.exec(v);

          if (repeat) {
            style.backgroundRepeat = repeat[0].toLowerCase();
          }
        }

        if (isNil$d(style.backgroundColor)) {
          var _bgc = /^(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

          if (_bgc) {
            style.backgroundColor = _bgc[0];
            v = v.replace(_bgc[0], '');
          }
        }

        if (isNil$d(style.backgroundPosition)) {
          var position = v.match(reg.position);

          if (position) {
            style.backgroundPosition = position.join(' ');
            this.toFull(style, 'backgroundPosition');
          }
        }
      }
    } else if (k === 'flex') {
      if (v === 'none') {
        parseFlex(style, 0, 0, 'auto');
      } else if (v === 'auto') {
        parseFlex(style, 1, 1, 'auto');
      } else if (/^[\d.]+\s+[\d.]+\s+(auto|none|content)/.test(v)) {
        var arr = v.split(/\s+/);
        parseFlex(style, parseFloat(arr[0]), parseFloat(arr[1]), arr[2]);
      } else if (/^[\d.]+\s+[\d.]+\s+[\d.]+[pxremvwh%]*/.test(v)) {
        var _arr = v.split(/\s+/);

        parseFlex(style, parseFloat(_arr[0]), parseFloat(_arr[1]), _arr[2]);
      } else if (/^[\d.]+\s+[\d.]+$/.test(v)) {
        var _arr2 = v.split(/\s+/);

        parseFlex(style, parseFloat(_arr2[0]), parseFloat(_arr2[1]), 0);
      } else if (/^[\d.]+\s+[\d.]+[pxremvwh%]+/.test(v)) {
        var _arr3 = v.split(/\s+/);

        parseFlex(style, parseFloat(_arr3[0]), 1, _arr3[1]);
      } else if (/^[\d.]+$/.test(v)) {
        parseFlex(style, parseFloat(v), 1, 0);
      } else if (/^[\d.]+[pxremvwh%]+/i.test(v)) {
        parseFlex(style, 1, 1, v);
      } else {
        parseFlex(style, 0, 1, 'auto');
      }
    } else if (k === 'flexFlow') {
      v = v.toString().split(/\s+/);

      if (v.length) {
        if (isNil$d(style.flexDirection)) ;

        style.flexDirection = v[0];

        if (v.length > 1) {
          style.flexWrap = v[1];
        }
      }
    } else if (k === 'borderRadius') {
      // borderRadius缩写很特殊，/分隔x/y，然后上右下左4个
      v = v.toString().split('/');

      if (v.length === 1) {
        v[1] = v[0];
      }

      for (var i = 0; i < 2; i++) {
        var item = v[i].toString().split(/\s+/);

        if (item.length === 0) {
          v[i] = [0, 0, 0, 0];
        } else if (item.length === 1) {
          v[i] = [item[0], item[0], item[0], item[0]];
        } else if (item.length === 2) {
          v[i] = [item[0], item[1], item[0], item[1]];
        } else if (item.length === 3) {
          v[i] = [item[0], item[1], item[2], item[1]];
        } else {
          v[i] = item.slice(0, 4);
        }
      }

      this[k].forEach(function (k, i) {
        if (isNil$d(style[k])) {
          style[k] = v[0][i] + ' ' + v[1][i];
        }
      });
    } else if (k === 'backgroundPosition') {
      if (!Array.isArray(v)) {
        v = [v];
      }

      var isEmpty = this[k].map(function (k2) {
        return isNil$d(style[k2]);
      });
      v.forEach(function (v2) {
        v2 = v2.toString().split(/\s+/);

        if (v2.length === 1) {
          v2[1] = '50%';
        }

        _this[k].forEach(function (k2, i) {
          if (isEmpty[i]) {
            style[k2] = style[k2] || [];
            style[k2].push(v2[i]);
          }
        });
      });
    } else if (['translate', 'scale', 'skew'].indexOf(k) > -1) {
      var _arr4 = v.toString().split(/\s*,\s*/);

      if (_arr4.length === 1) {
        _arr4[1] = _arr4[0];
      }

      this[k].forEach(function (k, i) {
        if (isNil$d(style[k])) {
          style[k] = _arr4[i];
        }
      });
    } else if (['translate3d', 'scale3d'].indexOf(k) > -1) {
      var _arr5 = v.toString().split(/\s*,\s*/);

      if (_arr5.length === 1) {
        _arr5[2] = _arr5[1] = _arr5[0];
      } else if (_arr5.length === 2) {
        _arr5[2] = k === 'scale3d' ? 1 : 0;
      }

      this[k].forEach(function (k, i) {
        if (isNil$d(style[k])) {
          style[k] = _arr5[i];
        }
      });
    } else if (k === 'margin' || k === 'padding') {
      parseMarginPadding(style, k, this[k]);
    } else if (/^border((Top)|(Right)|(Bottom)|(Left))$/.test(k)) {
      parseOneBorder(style, k);
    } else if (k === 'textStroke') {
      var w = /(?:^|\s)([-+]?[\d.]+[pxremvwh%]*)/.exec(v);

      if (w) {
        style.textStrokeWidth = w[1];
      }

      var c = /(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

      if (c) {
        style.textStrokeColor = c[0];
      }

      if (/\bfill\b/i.test(v)) {
        style.textStrokeOver = 'fill';
      } else {
        style.textStrokeOver = 'none';
      }
    } else if (this[k]) {
      this[k].forEach(function (k) {
        if (isNil$d(style[k])) {
          style[k] = v;
        }
      });
    }

    return style;
  }
};

var STYLE_KEY$4 = enums.STYLE_KEY;
var KEY_COLOR = [[STYLE_KEY$4.BACKGROUND_COLOR], [STYLE_KEY$4.BORDER_BOTTOM_COLOR], [STYLE_KEY$4.BORDER_LEFT_COLOR], [STYLE_KEY$4.BORDER_RIGHT_COLOR], [STYLE_KEY$4.BORDER_TOP_COLOR], [STYLE_KEY$4.COLOR], [STYLE_KEY$4.TEXT_STROKE_COLOR]];
var KEY_LENGTH = [[STYLE_KEY$4.FONT_SIZE], [STYLE_KEY$4.BORDER_BOTTOM_WIDTH], [STYLE_KEY$4.BORDER_LEFT_WIDTH], [STYLE_KEY$4.BORDER_RIGHT_WIDTH], [STYLE_KEY$4.BORDER_TOP_WIDTH], [STYLE_KEY$4.LEFT], [STYLE_KEY$4.TOP], [STYLE_KEY$4.RIGHT], [STYLE_KEY$4.BOTTOM], [STYLE_KEY$4.FLEX_BASIS], [STYLE_KEY$4.WIDTH], [STYLE_KEY$4.HEIGHT], [STYLE_KEY$4.LINE_HEIGHT], [STYLE_KEY$4.MARGIN_BOTTOM], [STYLE_KEY$4.MARGIN_LEFT], [STYLE_KEY$4.MARGIN_TOP], [STYLE_KEY$4.MARGIN_RIGHT], [STYLE_KEY$4.PADDING_TOP], [STYLE_KEY$4.PADDING_RIGHT], [STYLE_KEY$4.PADDING_BOTTOM], [STYLE_KEY$4.PADDING_LEFT], [STYLE_KEY$4.STROKE_WIDTH], [STYLE_KEY$4.STROKE_MITERLIMIT], [STYLE_KEY$4.LETTER_SPACING], [STYLE_KEY$4.PERSPECTIVE], [STYLE_KEY$4.TEXT_STROKE_WIDTH]];
var KEY_GRADIENT = [[STYLE_KEY$4.BACKGROUND_IMAGE], [STYLE_KEY$4.FILL], [STYLE_KEY$4.STROKE]];
var KEY_RADIUS = [[STYLE_KEY$4.BORDER_TOP_LEFT_RADIUS], [STYLE_KEY$4.BORDER_TOP_RIGHT_RADIUS], [STYLE_KEY$4.BORDER_BOTTOM_RIGHT_RADIUS], [STYLE_KEY$4.BORDER_BOTTOM_LEFT_RADIUS]];
var COLOR_HASH$2 = {};
KEY_COLOR.forEach(function (k) {
  COLOR_HASH$2[k] = true;
});
var LENGTH_HASH$2 = {};
KEY_LENGTH.forEach(function (k) {
  LENGTH_HASH$2[k] = true;
});
var RADIUS_HASH$2 = {};
KEY_RADIUS.forEach(function (k) {
  RADIUS_HASH$2[k] = true;
});
var GRADIENT_HASH$2 = {};
KEY_GRADIENT.forEach(function (k) {
  GRADIENT_HASH$2[k] = true;
});
var GRADIENT_TYPE$2 = {
  linear: true,
  radial: true,
  conic: true
};
var KEY_EXPAND = [[STYLE_KEY$4.TRANSLATE_X], [STYLE_KEY$4.TRANSLATE_Y], [STYLE_KEY$4.TRANSLATE_Z], [STYLE_KEY$4.SKEW_X], [STYLE_KEY$4.SKEW_Y], [STYLE_KEY$4.SCALE_X], [STYLE_KEY$4.SCALE_Y], [STYLE_KEY$4.SCALE_Z], [STYLE_KEY$4.ROTATE_X], [STYLE_KEY$4.ROTATE_Y], [STYLE_KEY$4.ROTATE_Z]];
var EXPAND_HASH$2 = {};
KEY_EXPAND.forEach(function (k) {
  EXPAND_HASH$2[k] = true;
});
var key = {
  KEY_COLOR: KEY_COLOR,
  KEY_EXPAND: KEY_EXPAND,
  KEY_GRADIENT: KEY_GRADIENT,
  KEY_LENGTH: KEY_LENGTH,
  KEY_RADIUS: KEY_RADIUS,
  COLOR_HASH: COLOR_HASH$2,
  EXPAND_HASH: EXPAND_HASH$2,
  GRADIENT_HASH: GRADIENT_HASH$2,
  LENGTH_HASH: LENGTH_HASH$2,
  RADIUS_HASH: RADIUS_HASH$2,
  GRADIENT_TYPE: GRADIENT_TYPE$2
};

var _REPAINT, _MEASURE;
var RESET_DOM = reset.DOM,
    RESET_GEOM = reset.GEOM;
var INHERIT$4 = o$4.INHERIT;
var STYLE_KEY$3 = enums.STYLE_KEY;
var GEOM$3 = {};
var GEOM_KEY_SET$1 = [];

var IGNORE = _defineProperty({}, STYLE_KEY$3.POINTER_EVENTS, true);

var REPAINT$3 = (_REPAINT = {}, _defineProperty(_REPAINT, STYLE_KEY$3.TRANSFORM, true), _defineProperty(_REPAINT, STYLE_KEY$3.TRANSLATE_X, true), _defineProperty(_REPAINT, STYLE_KEY$3.TRANSLATE_Y, true), _defineProperty(_REPAINT, STYLE_KEY$3.SKEW_X, true), _defineProperty(_REPAINT, STYLE_KEY$3.SKEW_Y, true), _defineProperty(_REPAINT, STYLE_KEY$3.SCALE_X, true), _defineProperty(_REPAINT, STYLE_KEY$3.SCALE_Y, true), _defineProperty(_REPAINT, STYLE_KEY$3.ROTATE_Z, true), _defineProperty(_REPAINT, STYLE_KEY$3.COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.FONT_STYLE, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE_WIDTH, true), _defineProperty(_REPAINT, STYLE_KEY$3.FILL, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE_DASHARRAY, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE_LINECAP, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE_LINEJOIN, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE_MITERLIMIT, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_IMAGE, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_POSITION_X, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_POSITION_Y, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_REPEAT, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_SIZE, true), _defineProperty(_REPAINT, STYLE_KEY$3.STROKE, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_BOTTOM_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_LEFT_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_RIGHT_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_TOP_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_TOP_LEFT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_TOP_RIGHT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_BOTTOM_RIGHT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$3.BORDER_BOTTOM_LEFT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$3.VISIBILITY, true), _defineProperty(_REPAINT, STYLE_KEY$3.OPACITY, true), _defineProperty(_REPAINT, STYLE_KEY$3.Z_INDEX, true), _defineProperty(_REPAINT, STYLE_KEY$3.FILTER, true), _defineProperty(_REPAINT, STYLE_KEY$3.BOX_SHADOW, true), _defineProperty(_REPAINT, STYLE_KEY$3.OVERFLOW, true), _defineProperty(_REPAINT, STYLE_KEY$3.BACKGROUND_CLIP, true), _defineProperty(_REPAINT, STYLE_KEY$3.TEXT_STROKE_WIDTH, true), _defineProperty(_REPAINT, STYLE_KEY$3.TEXT_STROKE_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$3.TEXT_STROKE_OVER, true), _REPAINT);
var MEASURE = (_MEASURE = {}, _defineProperty(_MEASURE, STYLE_KEY$3.FONT_SIZE, true), _defineProperty(_MEASURE, STYLE_KEY$3.FONT_WEIGHT, true), _defineProperty(_MEASURE, STYLE_KEY$3.FONT_FAMILY, true), _MEASURE);
var o$2 = {
  GEOM: GEOM$3,
  GEOM_KEY_SET: GEOM_KEY_SET$1,
  IGNORE: IGNORE,
  REPAINT: REPAINT$3,
  MEASURE: MEASURE,
  addGeom: function addGeom(tagName, ks, cb) {
    if (Array.isArray(ks)) {
      ks.forEach(function (k) {
        o$2.addGeom(tagName, k, cb);
      });
    } else if (ks) {
      if (!GEOM$3.hasOwnProperty(ks)) {
        GEOM_KEY_SET$1.push(ks);
      }

      var hash = GEOM$3[ks] = GEOM$3[ks] || {};
      hash[tagName] = cb || true;
    }
  }
};

o$2.isIgnore = function (k) {
  return IGNORE.hasOwnProperty(k);
};

function isGeom$3(tagName, k) {
  return GEOM$3.hasOwnProperty(k) && GEOM$3[k].hasOwnProperty(tagName);
}

o$2.isGeom = isGeom$3;

o$2.isRepaint = function (k) {
  return REPAINT$3.hasOwnProperty(k) || isGeom$3(k);
};

o$2.isMeasure = function (k) {
  return MEASURE.hasOwnProperty(k);
};

o$2.isValid = function (tagName, k) {
  if (!k) {
    return false;
  }

  if (RESET_DOM.hasOwnProperty(k)) {
    return true;
  } // geom的fill等矢量才有的样式


  if (tagName.charAt(0) === '$' && RESET_GEOM.hasOwnProperty(k)) {
    return true;
  }

  if (GEOM$3.hasOwnProperty(k)) {
    return GEOM$3[k].hasOwnProperty(tagName);
  }

  if (k === 'translatePath') {
    return true;
  }

  return false;
};

var MEASURE_KEY_SET$1 = o$2.MEASURE_KEY_SET = Object.keys(MEASURE).map(function (i) {
  return parseInt(i);
});
var len = MEASURE_KEY_SET$1.length;

o$2.isMeasureInherit = function (target) {
  if (target) {
    for (var i = 0; i < len; i++) {
      var k = MEASURE_KEY_SET$1[i];

      if (target.hasOwnProperty(k) && target[k][1] === INHERIT$4) {
        return true;
      }
    }
  }

  return false;
};

o$2.measureInheritList = function (target) {
  var list = [];

  for (var i = 0; i < len; i++) {
    var k = MEASURE_KEY_SET$1[i];

    if (target.hasOwnProperty(k) && target[k][1] === INHERIT$4) {
      list.push(k);
    }
  }

  return list;
};

o$2.addGeom('$line', ['x1', 'y1', 'x2', 'y2', 'controlA', 'controlB', 'start', 'end']);
o$2.addGeom('$circle', ['r']);
o$2.addGeom('$ellipse', ['rx', 'ry']);
o$2.addGeom('$rect', ['rx', 'ry']);
o$2.addGeom('$sector', ['begin', 'end', 'edge', 'closure']);
o$2.addGeom('$polyline', ['points', 'controls', 'start', 'end']);
o$2.addGeom('$polygon', ['points', 'controls', 'start', 'end']);

var _VALUE, _ARRAY_, _ARRAY_0_;
var STYLE_KEY$2 = enums.STYLE_KEY,
    STYLE_RV_KEY$1 = enums.STYLE_RV_KEY,
    style2Upper$1 = enums.style2Upper,
    _enums$STYLE_KEY$n = enums.STYLE_KEY,
    POSITION$5 = _enums$STYLE_KEY$n.POSITION,
    WIDTH$7 = _enums$STYLE_KEY$n.WIDTH,
    HEIGHT$7 = _enums$STYLE_KEY$n.HEIGHT,
    TRANSLATE_X$4 = _enums$STYLE_KEY$n.TRANSLATE_X,
    TRANSLATE_Y$4 = _enums$STYLE_KEY$n.TRANSLATE_Y,
    TRANSLATE_Z$4 = _enums$STYLE_KEY$n.TRANSLATE_Z,
    SCALE_X$3 = _enums$STYLE_KEY$n.SCALE_X,
    SCALE_Y$3 = _enums$STYLE_KEY$n.SCALE_Y,
    SCALE_Z$2 = _enums$STYLE_KEY$n.SCALE_Z,
    SKEW_X$2 = _enums$STYLE_KEY$n.SKEW_X,
    SKEW_Y$2 = _enums$STYLE_KEY$n.SKEW_Y,
    ROTATE_X$2 = _enums$STYLE_KEY$n.ROTATE_X,
    ROTATE_Y$2 = _enums$STYLE_KEY$n.ROTATE_Y,
    ROTATE_Z$2 = _enums$STYLE_KEY$n.ROTATE_Z,
    ROTATE_3D$3 = _enums$STYLE_KEY$n.ROTATE_3D,
    PERSPECTIVE$5 = _enums$STYLE_KEY$n.PERSPECTIVE,
    PERSPECTIVE_ORIGIN$4 = _enums$STYLE_KEY$n.PERSPECTIVE_ORIGIN,
    TRANSFORM$4 = _enums$STYLE_KEY$n.TRANSFORM,
    TRANSFORM_ORIGIN$4 = _enums$STYLE_KEY$n.TRANSFORM_ORIGIN,
    BACKGROUND_IMAGE$2 = _enums$STYLE_KEY$n.BACKGROUND_IMAGE,
    BACKGROUND_COLOR$2 = _enums$STYLE_KEY$n.BACKGROUND_COLOR,
    BACKGROUND_POSITION_X$3 = _enums$STYLE_KEY$n.BACKGROUND_POSITION_X,
    BACKGROUND_POSITION_Y$3 = _enums$STYLE_KEY$n.BACKGROUND_POSITION_Y,
    BACKGROUND_SIZE$2 = _enums$STYLE_KEY$n.BACKGROUND_SIZE,
    OPACITY$5 = _enums$STYLE_KEY$n.OPACITY,
    Z_INDEX$4 = _enums$STYLE_KEY$n.Z_INDEX,
    COLOR$5 = _enums$STYLE_KEY$n.COLOR,
    FONT_SIZE$f = _enums$STYLE_KEY$n.FONT_SIZE,
    FONT_FAMILY$4 = _enums$STYLE_KEY$n.FONT_FAMILY,
    FONT_WEIGHT$4 = _enums$STYLE_KEY$n.FONT_WEIGHT,
    FONT_STYLE$4 = _enums$STYLE_KEY$n.FONT_STYLE,
    LINE_HEIGHT$4 = _enums$STYLE_KEY$n.LINE_HEIGHT,
    TEXT_ALIGN$2 = _enums$STYLE_KEY$n.TEXT_ALIGN,
    FILTER$6 = _enums$STYLE_KEY$n.FILTER,
    VISIBILITY$7 = _enums$STYLE_KEY$n.VISIBILITY,
    BOX_SHADOW$9 = _enums$STYLE_KEY$n.BOX_SHADOW,
    POINTER_EVENTS$2 = _enums$STYLE_KEY$n.POINTER_EVENTS,
    FILL$2 = _enums$STYLE_KEY$n.FILL,
    STROKE$1 = _enums$STYLE_KEY$n.STROKE,
    STROKE_WIDTH$7 = _enums$STYLE_KEY$n.STROKE_WIDTH,
    STROKE_DASHARRAY$1 = _enums$STYLE_KEY$n.STROKE_DASHARRAY,
    BORDER_TOP_WIDTH$5 = _enums$STYLE_KEY$n.BORDER_TOP_WIDTH,
    BORDER_RIGHT_WIDTH$6 = _enums$STYLE_KEY$n.BORDER_RIGHT_WIDTH,
    BORDER_BOTTOM_WIDTH$5 = _enums$STYLE_KEY$n.BORDER_BOTTOM_WIDTH,
    BORDER_LEFT_WIDTH$7 = _enums$STYLE_KEY$n.BORDER_LEFT_WIDTH,
    DISPLAY$a = _enums$STYLE_KEY$n.DISPLAY,
    FLEX_DIRECTION$2 = _enums$STYLE_KEY$n.FLEX_DIRECTION,
    FLEX_GROW$1 = _enums$STYLE_KEY$n.FLEX_GROW,
    FLEX_SHRINK$1 = _enums$STYLE_KEY$n.FLEX_SHRINK,
    FLEX_BASIS$4 = _enums$STYLE_KEY$n.FLEX_BASIS,
    JUSTIFY_CONTENT$1 = _enums$STYLE_KEY$n.JUSTIFY_CONTENT,
    ALIGN_SELF$1 = _enums$STYLE_KEY$n.ALIGN_SELF,
    ALIGN_ITEMS$1 = _enums$STYLE_KEY$n.ALIGN_ITEMS,
    MATRIX$3 = _enums$STYLE_KEY$n.MATRIX,
    LETTER_SPACING$2 = _enums$STYLE_KEY$n.LETTER_SPACING,
    BACKGROUND_CLIP$2 = _enums$STYLE_KEY$n.BACKGROUND_CLIP,
    WHITE_SPACE$2 = _enums$STYLE_KEY$n.WHITE_SPACE,
    TEXT_OVERFLOW$2 = _enums$STYLE_KEY$n.TEXT_OVERFLOW,
    LINE_CLAMP$1 = _enums$STYLE_KEY$n.LINE_CLAMP,
    ORDER$1 = _enums$STYLE_KEY$n.ORDER,
    FLEX_WRAP$1 = _enums$STYLE_KEY$n.FLEX_WRAP,
    ALIGN_CONTENT$1 = _enums$STYLE_KEY$n.ALIGN_CONTENT,
    TRANSLATE_PATH$1 = _enums$STYLE_KEY$n.TRANSLATE_PATH,
    TEXT_STROKE_COLOR$4 = _enums$STYLE_KEY$n.TEXT_STROKE_COLOR,
    TEXT_STROKE_WIDTH$3 = _enums$STYLE_KEY$n.TEXT_STROKE_WIDTH,
    TEXT_STROKE_OVER$3 = _enums$STYLE_KEY$n.TEXT_STROKE_OVER;
var AUTO$8 = o$4.AUTO,
    PX$9 = o$4.PX,
    PERCENT$a = o$4.PERCENT,
    NUMBER$4 = o$4.NUMBER,
    INHERIT$3 = o$4.INHERIT,
    DEG$1 = o$4.DEG,
    RGBA$2 = o$4.RGBA,
    STRING$2 = o$4.STRING,
    REM$e = o$4.REM,
    VW$e = o$4.VW,
    VH$e = o$4.VH,
    calUnit$1 = o$4.calUnit;
var isNil$c = util.isNil,
    rgba2int$1 = util.rgba2int,
    equalArr$1 = util.equalArr;
var MEASURE_KEY_SET = o$2.MEASURE_KEY_SET,
    isGeom$2 = o$2.isGeom,
    GEOM$2 = o$2.GEOM,
    GEOM_KEY_SET = o$2.GEOM_KEY_SET;
var COLOR_HASH$1 = key.COLOR_HASH,
    LENGTH_HASH$1 = key.LENGTH_HASH,
    RADIUS_HASH$1 = key.RADIUS_HASH,
    GRADIENT_HASH$1 = key.GRADIENT_HASH,
    EXPAND_HASH$1 = key.EXPAND_HASH,
    GRADIENT_TYPE$1 = key.GRADIENT_TYPE;
var TRANSFORM_HASH = {
  translateX: TRANSLATE_X$4,
  translateY: TRANSLATE_Y$4,
  translateZ: TRANSLATE_Z$4,
  scaleX: SCALE_X$3,
  scaleY: SCALE_Y$3,
  scaleZ: SCALE_Z$2,
  skewX: SKEW_X$2,
  skewY: SKEW_Y$2,
  rotateX: ROTATE_X$2,
  rotateY: ROTATE_Y$2,
  rotateZ: ROTATE_Z$2,
  rotate: ROTATE_Z$2
};

function compatibleTransform(k, arr) {
  if (k === SCALE_X$3 || k === SCALE_Y$3 || k === SCALE_Z$2) {
    arr[1] = NUMBER$4;
  } else if (k === TRANSLATE_X$4 || k === TRANSLATE_Y$4 || k === TRANSLATE_Z$4) {
    if (arr[1] === NUMBER$4) {
      arr[1] = PX$9;
    }
  } else if (k === PERSPECTIVE$5) {
    if ([NUMBER$4, PERCENT$a, DEG$1].indexOf(arr[1]) > -1) {
      arr[1] = PX$9;
    }
  } else {
    if (arr[1] === NUMBER$4) {
      arr[1] = DEG$1;
    }
  }
}
/**
 * 将传入的手写style标准化，并且用reset默认值覆盖其中为空的
 * @param style 手写的style样式
 * @param reset 默认样式，可选
 * @returns Object 标准化的枚举数组结构样式
 */


function normalize$1(style) {
  var reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  if (!util.isObject(style)) {
    return {};
  }

  var res = {}; // style只有单层无需深度clone

  style = util.extend({}, style); // 缩写提前处理，因为reset里没有缩写

  var temp = style.border;

  if (temp) {
    abbr$1.toFull(style, 'border');
  }

  ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'].forEach(function (k) {
    abbr$1.toFull(style, k);
  });
  temp = style.borderWidth;

  if (temp) {
    abbr$1.toFull(style, 'borderWidth');
  }

  temp = style.borderColor;

  if (temp) {
    abbr$1.toFull(style, 'borderColor');
  }

  temp = style.borderStyle;

  if (temp) {
    abbr$1.toFull(style, 'borderStyle');
  }

  temp = style.borderRadius;

  if (temp) {
    abbr$1.toFull(style, 'borderRadius');
  }

  temp = style.background; // 处理渐变背景缩写

  if (temp) {
    abbr$1.toFull(style, 'background');
  } // 背景位置


  temp = style.backgroundPosition;

  if (!isNil$c(temp)) {
    abbr$1.toFull(style, 'backgroundPosition');
  } // flex


  temp = style.flex;

  if (temp) {
    abbr$1.toFull(style, 'flex');
  } // flex-flow


  temp = style.flexFlow;

  if (temp) {
    abbr$1.toFull(style, 'flexFlow');
  }

  temp = style.margin;

  if (!isNil$c(temp)) {
    abbr$1.toFull(style, 'margin');
  }

  temp = style.padding;

  if (!isNil$c(temp)) {
    abbr$1.toFull(style, 'padding');
  }

  temp = style.textStroke;

  if (temp) {
    abbr$1.toFull(style, 'textStroke');
  } // 扩展css，将transform几个值拆分为独立的css为动画准备，同时不能使用transform


  ['translate', 'scale', 'skew', 'translate3d', 'scale3d', 'rotate'].forEach(function (k) {
    temp = style[k];

    if (!isNil$c(temp)) {
      abbr$1.toFull(style, k);
    }
  }); // 扩展的不能和transform混用，给出警告

  ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate3d'].forEach(function (k) {
    var v = style[k];

    if (!isNil$c(v) && style.transform) {
      inject.warn("Can not use expand style \"".concat(k, "\" with transform"));
    }
  }); // 默认reset，根据传入不同，当style为空时覆盖

  reset.forEach(function (item) {
    var k = item.k,
        v = item.v;

    if (isNil$c(style[k])) {
      style[k] = v;
    }
  }); // 背景图

  temp = style.backgroundImage;

  if (temp !== undefined) {
    if (!temp) {
      res[BACKGROUND_IMAGE$2] = [null];
    } else if (Array.isArray(temp)) {
      res[BACKGROUND_IMAGE$2] = temp.map(function (item) {
        if (!item) {
          return null;
        }

        if (reg.gradient.test(item)) {
          return gradient.parseGradient(item);
        }

        if (reg.img.test(item)) {
          return reg.img.exec(item)[2];
        }

        return null;
      });
    } // 区分是渐变色还是图
    else if (reg.gradient.test(temp)) {
      res[BACKGROUND_IMAGE$2] = [gradient.parseGradient(temp)];
    } else if (reg.img.test(temp)) {
      res[BACKGROUND_IMAGE$2] = [reg.img.exec(temp)[2]];
    } else {
      res[BACKGROUND_IMAGE$2] = [null];
    }
  }

  temp = style.backgroundColor;

  if (temp) {
    // 先赋值默认透明，后续操作有合法值覆盖
    var bgc = /^#[0-9a-f]{3,8}/i.exec(temp);

    if (bgc && [4, 7, 9].indexOf(bgc[0].length) > -1) {
      res[BACKGROUND_COLOR$2] = [rgba2int$1(bgc[0]), RGBA$2];
    } else {
      bgc = /rgba?\s*\(.+\)/i.exec(temp);
      res[BACKGROUND_COLOR$2] = [rgba2int$1(bgc ? bgc[0] : [0, 0, 0, 0]), RGBA$2];
    }
  }

  ['backgroundPositionX', 'backgroundPositionY'].forEach(function (k, i) {
    temp = style[k];

    if (!isNil$c(temp)) {
      k = i ? BACKGROUND_POSITION_Y$3 : BACKGROUND_POSITION_X$3;

      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[k] = temp.map(function (item) {
        if (/^[-+]?[\d.]/.test(item)) {
          var v = calUnit$1(item);

          if ([NUMBER$4, DEG$1].indexOf(v[1]) > -1) {
            v[1] = PX$9;
          }

          return v;
        } else {
          return [{
            top: 0,
            left: 0,
            center: 50,
            right: 100,
            bottom: 100
          }[item] || 0, PERCENT$a];
        }
      });
    }
  }); // 背景尺寸

  temp = style.backgroundSize;

  if (temp) {
    if (!Array.isArray(temp)) {
      temp = [temp];
    }

    res[BACKGROUND_SIZE$2] = temp.map(function (item) {
      if (!item) {
        return [[0, AUTO$8], [0, AUTO$8]];
      }

      var match = item.toString().match(/\b(?:([-+]?[\d.]+[pxremvwh%]*)|(contain|cover|auto))/ig);

      if (match) {
        if (match.length === 1) {
          if (match[0] === 'contain' || match[0] === 'cover') {
            match[1] = match[0];
          } else {
            match[1] = 'auto';
          }
        }

        var v = [];

        for (var i = 0; i < 2; i++) {
          var _item = match[i];

          if (/^[-+]?[\d.]/.test(_item)) {
            var n = calUnit$1(_item);

            if ([NUMBER$4, DEG$1].indexOf(n[1]) > -1) {
              n[1] = PX$9;
            }

            v.push(n);
          } else if (_item === 'contain' || _item === 'cover') {
            v.push([_item, STRING$2]);
          } else {
            v.push([0, AUTO$8]);
          }
        }

        return v;
      } else {
        return [[0, AUTO$8], [0, AUTO$8]];
      }
    });
  } // border-color


  ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
    k = 'border' + k + 'Color';
    var v = style[k];

    if (!isNil$c(v)) {
      res[STYLE_KEY$2[style2Upper$1(k)]] = [rgba2int$1(v), RGBA$2];
    }
  }); // border-radius

  ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].forEach(function (k) {
    k = 'border' + k + 'Radius';
    var v = style[k];

    if (!isNil$c(v)) {
      var arr = v.toString().split(/\s+/);

      if (arr.length === 1) {
        arr[1] = arr[0];
      }

      for (var i = 0; i < 2; i++) {
        var item = arr[i];

        if (/^[-+]?[\d.]/.test(item)) {
          var n = calUnit$1(item);

          if ([NUMBER$4, DEG$1].indexOf(n[1]) > -1) {
            n[1] = PX$9;
          }

          if (n[0] < 0) {
            n[0] = 0;
          }

          arr[i] = n;
        } else {
          arr[i] = [0, PX$9];
        }
      }

      res[STYLE_KEY$2[style2Upper$1(k)]] = arr;
    }
  });
  temp = style.transform;

  if (temp) {
    var transform = res[TRANSFORM$4] = [];
    var match = (temp || '').toString().match(/\w+\(.+?\)/g);

    if (match) {
      match.forEach(function (item) {
        var i = item.indexOf('(');
        var k = item.slice(0, i);
        var v = item.slice(i + 1, item.length - 1);

        if (k === 'matrix') {
          var arr = v.toString().split(/\s*,\s*/);
          arr = arr.map(function (item) {
            return parseFloat(item);
          });

          if (arr.length > 6) {
            arr = arr.slice(0, 6);
          }

          if (arr.length === 6) {
            transform.push([MATRIX$3, [arr[0], arr[1], 0, 0, arr[2], arr[3], 0, 0, 0, 0, 1, 0, arr[4], arr[5], 0, 1]]);
          }
        } else if (k === 'matrix3d') {
          var _arr = v.toString().split(/\s*,\s*/);

          _arr = _arr.map(function (item) {
            return parseFloat(item);
          });

          if (_arr.length > 16) {
            _arr = _arr.slice(0, 16);
          }

          if (_arr.length === 16) {
            transform.push([MATRIX$3, _arr]);
          }
        } else if (k === 'perspective') {
          var _arr2 = calUnit$1(v);

          if (_arr2[0] < 0) {
            _arr2[0] = 0;
          }

          compatibleTransform(PERSPECTIVE$5, _arr2);
          transform.push([PERSPECTIVE$5, _arr2]);
        } else if (k === 'rotate3d') {
          var _arr3 = v.toString().split(/\s*,\s*/);

          if (_arr3.length === 4) {
            var deg = calUnit$1(_arr3[3]);
            compatibleTransform(ROTATE_3D$3, deg);
            _arr3[0] = parseFloat(_arr3[0]);
            _arr3[1] = parseFloat(_arr3[1]);
            _arr3[2] = parseFloat(_arr3[2]);
            _arr3[3] = deg;
            transform.push([ROTATE_3D$3, _arr3]);
          }
        } else if (TRANSFORM_HASH.hasOwnProperty(k)) {
          var k2 = TRANSFORM_HASH[k];

          var _arr4 = calUnit$1(v);

          compatibleTransform(k2, _arr4);
          transform.push([k2, _arr4]);
        } else if ({
          translate: true,
          scale: true,
          skew: true
        }.hasOwnProperty(k)) {
          var _arr5 = v.toString().split(/\s*,\s*/);

          if (_arr5.length === 1) {
            _arr5[1] = k === 'scale' ? _arr5[0] : [0];
          }

          if (_arr5.length === 2) {
            var k1 = STYLE_KEY$2[style2Upper$1(k + 'X')];
            var _k = STYLE_KEY$2[style2Upper$1(k + 'Y')];
            var arr1 = calUnit$1(_arr5[0]);
            var arr2 = calUnit$1(_arr5[1]);
            compatibleTransform(k1, arr1);
            compatibleTransform(_k, arr2);
            transform.push([k1, arr1]);
            transform.push([_k, arr2]);
          }
        } else if ({
          translate3d: true,
          scale3d: true
        }.hasOwnProperty(k)) {
          var _arr6 = v.toString().split(/\s*,\s*/);

          if (_arr6.length === 1) {
            _arr6[1] = k === 'scale3d' ? [1] : [0];
            _arr6[2] = k === 'scale3d' ? [1] : [0];
          } else if (_arr6.length === 2) {
            _arr6[2] = k === 'scale3d' ? [1] : [0];
          }

          if (_arr6.length === 3) {
            var _k2 = STYLE_KEY$2[style2Upper$1(k + 'X')];
            var _k3 = STYLE_KEY$2[style2Upper$1(k + 'Y')];
            var k3 = STYLE_KEY$2[style2Upper$1(k + 'Z')];

            var _arr7 = calUnit$1(_arr6[0]);

            var _arr8 = calUnit$1(_arr6[1]);

            var arr3 = calUnit$1(_arr6[2]);
            compatibleTransform(_k2, _arr7);
            compatibleTransform(_k3, _arr8);
            compatibleTransform(k3, arr3);
            transform.push([_k2, _arr7]);
            transform.push([_k3, _arr8]);
            transform.push([k3, arr3]);
          }
        }
      });
    }
  }

  temp = style.perspective;

  if (!isNil$c(temp)) {
    var arr = calUnit$1(temp);

    if (arr[0] < 0) {
      arr[0] = 0;
    }

    compatibleTransform(PERSPECTIVE$5, arr);
    res[PERSPECTIVE$5] = arr;
  }

  ['perspectiveOrigin', 'transformOrigin'].forEach(function (k) {
    temp = style[k];

    if (!isNil$c(temp)) {
      var _arr9 = res[STYLE_KEY$2[style2Upper$1(k)]] = [];

      var _match = temp.toString().match(reg.position);

      if (_match) {
        if (_match.length === 1) {
          _match[1] = _match[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = _match[i];

          if (/^[-+]?[\d.]/.test(item)) {
            var n = calUnit$1(item);

            if ([NUMBER$4, DEG$1].indexOf(n[1]) > -1) {
              n[1] = PX$9;
            }

            _arr9.push(n);
          } else {
            _arr9.push([{
              top: 0,
              left: 0,
              center: 50,
              right: 100,
              bottom: 100
            }[item], PERCENT$a]); // 不规范的写法变默认值50%


            if (isNil$c(_arr9[i][0])) {
              _arr9[i][0] = 50;
            }
          }
        }
      } else {
        _arr9.push([50, PERCENT$a]);

        _arr9.push([50, PERCENT$a]);
      }
    }
  });
  ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate'].forEach(function (k) {
    var v = style[k];

    if (isNil$c(v)) {
      return;
    }

    var k2 = TRANSFORM_HASH[k];
    var n = calUnit$1(v); // 没有单位或默认值处理单位

    compatibleTransform(k2, n);
    res[k2] = n;
  });
  temp = style.rotate3d;

  if (temp) {
    var _arr10 = temp.toString().split(/\s*,\s*/);

    if (_arr10.length === 4) {
      var deg = calUnit$1(_arr10[3]);
      compatibleTransform(ROTATE_3D$3, deg);
      _arr10[0] = parseFloat(_arr10[0]);
      _arr10[1] = parseFloat(_arr10[1]);
      _arr10[2] = parseFloat(_arr10[2]);
      _arr10[3] = deg;
      res[ROTATE_3D$3] = _arr10;
    }
  }

  temp = style.opacity;

  if (!isNil$c(temp)) {
    temp = parseFloat(temp);

    if (!isNaN(temp)) {
      temp = Math.max(temp, 0);
      temp = Math.min(temp, 1);
      res[OPACITY$5] = temp;
    } else {
      res[OPACITY$5] = 1;
    }
  }

  temp = style.zIndex;

  if (!isNil$c(temp)) {
    res[Z_INDEX$4] = parseInt(temp) || 0;
  } // 转化不同单位值为对象标准化，不写单位的变成number单位转化为px


  ['marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'top', 'right', 'bottom', 'left', 'width', 'height'].forEach(function (k) {
    var v = style[k];

    if (isNil$c(v)) {
      return;
    }

    if (v === 'auto') {
      v = [0, AUTO$8];
    } else {
      v = calUnit$1(v); // 无单位视为px

      if ([NUMBER$4, DEG$1].indexOf(v[1]) > -1) {
        v[1] = PX$9;
      }
    }

    var k2 = STYLE_KEY$2[style2Upper$1(k)];
    res[k2] = v; // 限制padding/border为正数

    if ({
      paddingTop: true,
      paddingRight: true,
      paddingBottom: true,
      paddingLeft: true,
      borderTopWidth: true,
      borderRightWidth: true,
      borderBottomWidth: true,
      borderLeftWidth: true,
      width: true,
      height: true
    }.hasOwnProperty(k) && v[0] < 0) {
      v[0] = 0;
    }
  });
  temp = style.flexBasis;

  if (!isNil$c(temp)) {
    if (temp === 'content') {
      res[FLEX_BASIS$4] = [temp, STRING$2];
    } else if (/^[\d.]/.test(temp)) {
      var v = res[FLEX_BASIS$4] = calUnit$1(temp);
      v[0] = Math.max(v[0], 0); // 无单位视为px

      if ([NUMBER$4, DEG$1].indexOf(v[1]) > -1) {
        v[1] = PX$9;
      }
    } else {
      res[FLEX_BASIS$4] = [0, AUTO$8];
    }
  }

  temp = style.order;

  if (!isNil$c(temp)) {
    res[ORDER$1] = parseInt(temp) || 0;
  }

  temp = style.color;

  if (!isNil$c(temp)) {
    if (temp === 'inherit') {
      res[COLOR$5] = [[], INHERIT$3];
    } else {
      res[COLOR$5] = [rgba2int$1(temp), RGBA$2];
    }
  }

  temp = style.textStrokeColor;

  if (!isNil$c(temp)) {
    if (temp === 'inherit') {
      res[TEXT_STROKE_COLOR$4] = [[], INHERIT$3];
    } else {
      res[TEXT_STROKE_COLOR$4] = [rgba2int$1(temp), RGBA$2];
    }
  }

  temp = style.fontSize;

  if (temp || temp === 0) {
    if (temp === 'inherit') {
      res[FONT_SIZE$f] = [0, INHERIT$3];
    } else {
      var _v = calUnit$1(temp); // fontSize不能为负数，否则为继承


      if (_v < 0) {
        res[FONT_SIZE$f] = [0, INHERIT$3];
      } else {
        if ([NUMBER$4, DEG$1].indexOf(_v[1]) > -1) {
          _v[1] = PX$9;
        }

        res[FONT_SIZE$f] = _v;
      }
    }
  }

  temp = style.textStrokeWidth;

  if (!isNil$c(temp)) {
    if (temp === 'inherit') {
      res[TEXT_STROKE_WIDTH$3] = [0, INHERIT$3];
    } else {
      var _v2 = calUnit$1(temp); // textStrokeWidth不能为负数，否则为继承


      if (_v2 < 0) {
        res[TEXT_STROKE_WIDTH$3] = [0, INHERIT$3];
      } else {
        if ([NUMBER$4, DEG$1, PERCENT$a].indexOf(_v2[1]) > -1) {
          _v2[1] = PX$9;
        }

        res[TEXT_STROKE_WIDTH$3] = _v2;
      }
    }
  }

  temp = style.textStrokeOver;

  if (!isNil$c(temp)) {
    if (temp === 'inherit') {
      res[TEXT_STROKE_OVER$3] = [0, INHERIT$3];
    } else {
      var _v3 = temp.toString();

      if (_v3 !== 'none' && _v3 !== 'fill') {
        _v3 = 'none';
      }

      res[TEXT_STROKE_OVER$3] = [_v3, STRING$2];
    }
  }

  temp = style.fontWeight;

  if (!isNil$c(temp)) {
    if (temp === 'bold') {
      res[FONT_WEIGHT$4] = [700, NUMBER$4];
    } else if (temp === 'normal') {
      res[FONT_WEIGHT$4] = [400, NUMBER$4];
    } else if (temp === 'lighter') {
      res[FONT_WEIGHT$4] = [200, NUMBER$4];
    } else if (temp === 'inherit') {
      res[FONT_WEIGHT$4] = [0, INHERIT$3];
    } else {
      res[FONT_WEIGHT$4] = [Math.max(0, parseInt(temp)) || 400, NUMBER$4];
    }
  }

  temp = style.fontStyle;

  if (temp) {
    if (temp === 'inherit') {
      res[FONT_STYLE$4] = [0, INHERIT$3];
    } else {
      res[FONT_STYLE$4] = [temp, STRING$2];
    }
  }

  temp = style.fontFamily;

  if (temp) {
    if (temp === 'inherit') {
      res[FONT_FAMILY$4] = [0, INHERIT$3];
    } else {
      // 统一文字声明格式
      res[FONT_FAMILY$4] = [temp.toString().toLowerCase().replace(/['"]/, '').replace(/\s*,\s*/g, ','), STRING$2];
    }
  }

  temp = style.textAlign;

  if (temp) {
    if (temp === 'inherit') {
      res[TEXT_ALIGN$2] = [0, INHERIT$3];
    } else {
      res[TEXT_ALIGN$2] = [temp, STRING$2];
    }
  }

  temp = style.lineHeight;

  if (temp !== undefined) {
    if (temp === 'inherit') {
      res[LINE_HEIGHT$4] = [0, INHERIT$3];
    } else if (temp === 'normal') {
      res[LINE_HEIGHT$4] = [0, AUTO$8];
    } // lineHeight默认数字，想要px必须强制带单位
    else if (/^[\d.]+/i.test(temp)) {
      var _v4 = calUnit$1(temp);

      if ([DEG$1].indexOf(_v4[1]) > -1) {
        _v4[1] = NUMBER$4;
      }

      res[LINE_HEIGHT$4] = _v4;
    } else {
      var n = Math.max(0, parseFloat(temp)) || 'normal'; // 非法数字

      if (n === 'normal') {
        res[LINE_HEIGHT$4] = [null, AUTO$8];
      } else {
        res[LINE_HEIGHT$4] = [n, NUMBER$4];
      }
    }
  }

  temp = style.letterSpacing;

  if (temp !== undefined) {
    if (temp === 'inherit') {
      res[LETTER_SPACING$2] = [0, INHERIT$3];
    } else if (temp === 'normal') {
      res[LETTER_SPACING$2] = [0, PX$9];
    } else if (/^[-+]?[\d.]/.test(temp)) {
      var _v5 = calUnit$1(temp);

      if ([NUMBER$4, DEG$1].indexOf(_v5[1]) > -1) {
        _v5[1] = PX$9;
      }

      res[LETTER_SPACING$2] = _v5;
    } else {
      res[LETTER_SPACING$2] = [parseFloat(temp) || 0, PX$9];
    }
  }

  temp = style.whiteSpace;

  if (temp) {
    if (temp === 'inherit') {
      res[WHITE_SPACE$2] = [0, INHERIT$3];
    } else {
      res[WHITE_SPACE$2] = [temp, STRING$2];
    }
  }

  temp = style.lineClamp;

  if (temp !== undefined) {
    temp = parseInt(temp) || 0;
    res[LINE_CLAMP$1] = Math.max(0, temp);
  } // fill和stroke为渐变时特殊处理，fillRule无需处理字符串


  temp = style.fill;

  if (temp !== undefined) {
    if (!temp) {
      res[FILL$2] = ['none'];
    } else if (Array.isArray(temp)) {
      if (temp.length) {
        res[FILL$2] = temp.map(function (item) {
          if (!item) {
            return 'none';
          } else if (reg.gradient.test(item)) {
            return gradient.parseGradient(item);
          } else {
            return rgba2int$1(item);
          }
        });
      } else {
        res[FILL$2] = ['none'];
      }
    } else if (reg.gradient.test(temp)) {
      res[FILL$2] = [gradient.parseGradient(temp)];
    } else {
      res[FILL$2] = [rgba2int$1(temp)];
    }
  }

  temp = style.stroke;

  if (temp !== undefined) {
    if (!temp) {
      res[STROKE$1] = ['none'];
    } else if (Array.isArray(temp)) {
      if (temp.length) {
        res[STROKE$1] = temp.map(function (item) {
          if (!item) {
            return 'none';
          } else if (reg.gradient.test(item)) {
            return gradient.parseGradient(item);
          } else {
            return rgba2int$1(item);
          }
        });
      } else {
        res[STROKE$1] = ['none'];
      }
    } else if (reg.gradient.test(temp)) {
      res[STROKE$1] = [gradient.parseGradient(temp)];
    } else {
      res[STROKE$1] = [rgba2int$1(temp)];
    }
  }

  temp = style.strokeWidth;

  if (!isNil$c(temp)) {
    if (!Array.isArray(temp)) {
      temp = [temp];
    }

    res[STROKE_WIDTH$7] = temp.map(function (item) {
      var v = calUnit$1(item);

      if ([NUMBER$4, DEG$1].indexOf(v[1]) > -1) {
        v[1] = PX$9;
      }

      v[0] = Math.max(v[0], 0);
      return v;
    });
  }

  temp = style.strokeDasharray;

  if (!isNil$c(temp)) {
    if (Array.isArray(temp)) {
      res[STROKE_DASHARRAY$1] = temp.map(function (item) {
        var match = item.toString().match(/[\d.]+/g);

        if (match) {
          match = match.map(function (item) {
            return parseFloat(item);
          });

          if (match.length % 2 === 1) {
            match.push(match[match.length - 1]);
          }

          return match;
        }

        return [];
      });
    } else {
      var _match2 = temp.toString().match(/[\d.]+/g);

      if (_match2) {
        _match2 = _match2.map(function (item) {
          return parseFloat(item);
        });

        if (_match2.length % 2 === 1) {
          _match2.push(_match2[_match2.length - 1]);
        }

        res[STROKE_DASHARRAY$1] = [_match2];
      } else {
        res[STROKE_DASHARRAY$1] = [[]];
      }
    }
  }

  temp = style.filter;

  if (temp !== undefined) {
    var _match3 = (temp || '').toString().match(/\b[\w-]+\s*\(\s*[-+]?[\d.]+\s*[pxremvwhdg%]*\s*\)\s*/ig);

    var f = null;

    if (_match3) {
      f = [];

      _match3.forEach(function (item) {
        var m2 = /([\w-]+)\s*\(\s*([-+]?[\d.]+\s*[pxremvwhdg%]*)\s*\)\s*/i.exec(item);

        if (m2) {
          var k = m2[1].toLowerCase(),
              _v6 = calUnit$1(m2[2]);

          if (k === 'blur') {
            if (_v6[0] <= 0 || [DEG$1, PERCENT$a].indexOf(_v6[1]) > -1) {
              return;
            }

            if (_v6[1] === NUMBER$4) {
              _v6[1] = PX$9;
            }

            f.push([k, _v6]);
          } else if (k === 'hue-rotate') {
            if ([NUMBER$4, DEG$1].indexOf(_v6[1]) === -1) {
              return;
            }

            _v6[1] = DEG$1;
            f.push([k, _v6]);
          } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast') {
            if ([NUMBER$4, PERCENT$a].indexOf(_v6[1]) === -1) {
              return;
            }

            _v6[0] = Math.max(_v6[0], 0);
            _v6[1] = PERCENT$a;
            f.push([k, _v6]);
          }
        }
      });
    }

    res[FILTER$6] = f;
  }

  temp = style.visibility;

  if (temp) {
    if (temp === 'inherit') {
      res[VISIBILITY$7] = [0, INHERIT$3];
    } else {
      res[VISIBILITY$7] = [temp, STRING$2];
    }
  }

  temp = style.pointerEvents;

  if (temp) {
    if (temp === 'inherit') {
      res[POINTER_EVENTS$2] = [0, INHERIT$3];
    } else {
      res[POINTER_EVENTS$2] = [temp, STRING$2];
    }
  }

  temp = style.boxShadow;

  if (temp !== undefined) {
    var bs = null;

    var _match4 = (temp || '').match(/([-+]?[\d.]+[pxremvwh%]*)\s*([-+]?[\d.]+[pxremvwh%]*)\s*([-+]?[\d.]+[pxremvwh%]*\s*)?([-+]?[\d.]+[pxremvwh%]*\s*)?(((transparent)|(#[0-9a-f]{3,8})|(rgba?\(.+?\)))\s*)?(inset|outset)?\s*,?/ig);

    if (_match4) {
      _match4.forEach(function (item) {
        var boxShadow = /([-+]?[\d.]+[pxremvwh%]*)\s*([-+]?[\d.]+[pxremvwh%]*)\s*([-+]?[\d.]+[pxremvwh%]*\s*)?([-+]?[\d.]+[pxremvwh%]*\s*)?(?:((?:transparent)|(?:#[0-9a-f]{3,8})|(?:rgba?\(.+\)))\s*)?(inset|outset)?/i.exec(item);

        if (boxShadow) {
          bs = bs || [];
          var _res = []; // v,h,blur,spread,color,inset

          for (var i = 0; i < 4; i++) {
            var _v7 = calUnit$1(boxShadow[i + 1]);

            if ([NUMBER$4, DEG$1].indexOf(_v7[1]) > -1) {
              _v7[1] = PX$9;
            } // x/y可以负，blur和spread不行


            if (i > 1 && _v7[0] < 0) {
              _v7 = 0;
            }

            _res.push(_v7);
          }

          _res.push(rgba2int$1(boxShadow[5]));

          _res.push(boxShadow[6] || 'outset');

          bs.push(_res);
        }
      });
    }

    res[BOX_SHADOW$9] = bs;
  } // 直接赋值的string类型


  ['position', 'display', 'flexDirection', 'flexWrap', 'justifyContent', 'alignItems', 'alignSelf', 'alignContent', 'overflow', 'mixBlendMode', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'backgroundClip', 'textOverflow'].forEach(function (k) {
    if (style.hasOwnProperty(k)) {
      res[STYLE_KEY$2[style2Upper$1(k)]] = style[k];
    }
  }); // 直接赋值的number类型

  ['flexGrow', 'flexShrink'].forEach(function (k) {
    if (style.hasOwnProperty(k)) {
      res[STYLE_KEY$2[style2Upper$1(k)]] = Math.max(parseFloat(style[k]) || 0, 0);
    }
  });
  temp = style.zIndex;

  if (!isNil$c(temp)) {
    res[Z_INDEX$4] = parseFloat(temp) || 0;
  } // 这些支持多个的用数组表示


  ['backgroundRepeat', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'fillRule'].forEach(function (k) {
    if (style.hasOwnProperty(k)) {
      var _v8 = style[k];
      res[STYLE_KEY$2[style2Upper$1(k)]] = Array.isArray(_v8) ? _v8 : [_v8];
    }
  });
  GEOM_KEY_SET.forEach(function (k) {
    if (style.hasOwnProperty(k)) {
      res[k] = style[k];
    }
  });
  return res;
}
/**
 * 第一次和REFLOW等级下，刷新前首先执行，生成computedStyle
 * 影响文字测量的只有字体和大小和重量，需要提前处理
 * 继承相关的计算
 * @param node 对象节点
 * @param isRoot 是否是根节点，无继承需使用默认值
 */


function computeMeasure(node, isRoot) {
  var currentStyle = node.currentStyle,
      computedStyle = node.computedStyle,
      domParent = node.domParent;
  var parentComputedStyle = !isRoot && domParent.computedStyle;
  MEASURE_KEY_SET.forEach(function (k) {
    var v = currentStyle[k]; // ff特殊处理

    if (k === FONT_FAMILY$4) {
      if (v[1] === INHERIT$3) {
        computedStyle[k] = getFontFamily(isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k]);
      } else {
        computedStyle[k] = getFontFamily(v[0]);
      }
    } else if (v[1] === INHERIT$3) {
      computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k];
    } // 只有fontSize会有%
    else if (v[1] === PERCENT$a) {
      computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k] * v[0] * 0.01;
    } else if (v[1] === REM$e) {
      computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : node.root.computedStyle[FONT_SIZE$f] * v[0];
    } else if (v[1] === VW$e) {
      computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : node.root.width * 0.01 * v[0];
    } else if (v[1] === VH$e) {
      computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : node.root.height * 0.01 * v[0];
    } else {
      computedStyle[k] = v[0];
    }
  });
}
/**
 * 每次布局前需要计算的reflow相关的computedStyle
 * @param node 对象节点
 * @param isHost 是否是根节点或组件节点这种局部根节点，无继承需使用默认值
 */


function computeReflow(node, isHost) {
  var currentStyle = node.currentStyle,
      computedStyle = node.computedStyle,
      parent = node.domParent,
      root = node.root;
  var rem = root.computedStyle[FONT_SIZE$f];
  var isRoot = !parent;
  var parentComputedStyle = parent && parent.computedStyle;
  [BORDER_TOP_WIDTH$5, BORDER_RIGHT_WIDTH$6, BORDER_BOTTOM_WIDTH$5, BORDER_LEFT_WIDTH$7].forEach(function (k) {
    // border-width不支持百分比
    var item = currentStyle[k];

    if (item[1] === PX$9) {
      computedStyle[k] = item[0];
    } else if (item[1] === REM$e) {
      computedStyle[k] = item[0] * rem;
    } else if (item[1] === VW$e) {
      computedStyle[k] = item[0] * root.width * 0.01;
    } else if (item[1] === VH$e) {
      computedStyle[k] = item[0] * root.height * 0.01;
    } else {
      computedStyle[k] = 0;
    }
  });
  [POSITION$5, DISPLAY$a, FLEX_DIRECTION$2, JUSTIFY_CONTENT$1, ALIGN_ITEMS$1, ALIGN_SELF$1, FLEX_GROW$1, FLEX_SHRINK$1, LINE_CLAMP$1, ORDER$1, FLEX_WRAP$1, ALIGN_CONTENT$1].forEach(function (k) {
    computedStyle[k] = currentStyle[k];
  });
  var textAlign = currentStyle[TEXT_ALIGN$2];

  if (textAlign[1] === INHERIT$3) {
    computedStyle[TEXT_ALIGN$2] = isRoot ? 'left' : parentComputedStyle[TEXT_ALIGN$2];
  } else {
    computedStyle[TEXT_ALIGN$2] = textAlign[0];
  }

  var fontSize = computedStyle[FONT_SIZE$f];
  var lineHeight = currentStyle[LINE_HEIGHT$4]; // lineHeight继承很特殊，数字和normal不同于普通单位

  if (lineHeight[1] === INHERIT$3) {
    if (isRoot) {
      computedStyle[LINE_HEIGHT$4] = calNormalLineHeight(computedStyle);
    } else {
      var p = parent;
      var ph;

      while (p) {
        ph = p.currentStyle[LINE_HEIGHT$4];

        if (ph[1] !== INHERIT$3) {
          break;
        }

        p = p.domParent;
      } // 到root还是inherit或normal，或者中途遇到了normal，使用normal


      if ([AUTO$8, INHERIT$3].indexOf(ph[1]) > -1) {
        computedStyle[LINE_HEIGHT$4] = calNormalLineHeight(computedStyle);
      } // 数字继承
      else if (ph[1] === NUMBER$4) {
        computedStyle[LINE_HEIGHT$4] = Math.max(ph[0], 0) * fontSize;
      } // 单位继承
      else {
        computedStyle[LINE_HEIGHT$4] = parentComputedStyle[LINE_HEIGHT$4];
      }
    }
  } // 防止为0
  else if (lineHeight[1] === PX$9) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0], 0) || calNormalLineHeight(computedStyle);
  } else if (lineHeight[1] === PERCENT$a) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0] * fontSize * 0.01, 0) || calNormalLineHeight(computedStyle);
  } else if (lineHeight[1] === REM$e) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0] * rem, 0) || calNormalLineHeight(computedStyle);
  } else if (lineHeight[1] === VW$e) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0] * root.width * 0.01, 0) || calNormalLineHeight(computedStyle);
  } else if (lineHeight[1] === VH$e) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0] * root.height * 0.01, 0) || calNormalLineHeight(computedStyle);
  } else if (lineHeight[1] === NUMBER$4) {
    computedStyle[LINE_HEIGHT$4] = Math.max(lineHeight[0], 0) * fontSize || calNormalLineHeight(computedStyle);
  } // normal或auto
  else {
    computedStyle[LINE_HEIGHT$4] = calNormalLineHeight(computedStyle);
  }

  var letterSpacing = currentStyle[LETTER_SPACING$2];

  if (letterSpacing[1] === INHERIT$3) {
    computedStyle[LETTER_SPACING$2] = isRoot ? 0 : parentComputedStyle[LETTER_SPACING$2];
  } else if (letterSpacing[1] === PERCENT$a) {
    computedStyle[LETTER_SPACING$2] = fontSize * 0.01 * letterSpacing[0];
  } else if (letterSpacing[1] === REM$e) {
    computedStyle[LETTER_SPACING$2] = rem * letterSpacing[0];
  } else if (letterSpacing[1] === VW$e) {
    computedStyle[LETTER_SPACING$2] = root.width * 0.01 * letterSpacing[0];
  } else if (letterSpacing[1] === VH$e) {
    computedStyle[LETTER_SPACING$2] = root.height * 0.01 * letterSpacing[0];
  } else {
    computedStyle[LETTER_SPACING$2] = letterSpacing[0];
  } //whiteSpace


  var whiteSpace = currentStyle[WHITE_SPACE$2];

  if (whiteSpace[1] === INHERIT$3) {
    computedStyle[WHITE_SPACE$2] = isRoot ? 'normal' : parentComputedStyle[WHITE_SPACE$2];
  } else {
    computedStyle[WHITE_SPACE$2] = whiteSpace[0];
  }
}

function setFontStyle(style) {
  var fontSize = style[FONT_SIZE$f];
  return (style[FONT_STYLE$4] || 'normal') + ' ' + (style[FONT_WEIGHT$4] || '400') + ' ' + fontSize + 'px/' + fontSize + 'px ' + (style[FONT_FAMILY$4] || 'arial');
}

function getFontFamily(str) {
  var ff = str.split(',');
  var f = 'arial';

  for (var i = 0, len = ff.length; i < len; i++) {
    if (o$3.support(ff[i])) {
      f = ff[i];
      break;
    }
  }

  return f;
}

function getBaseLine(style) {
  var fontSize = style[FONT_SIZE$f];
  var ff = getFontFamily(style[FONT_FAMILY$4]);
  var normal = fontSize * (o$3.info[ff] || o$3.info.arial).lhr;
  return (style[LINE_HEIGHT$4] - normal) * 0.5 + fontSize * (o$3.info[ff] || o$3.info.arial).blr;
}

function calNormalLineHeight(style) {
  var ff = getFontFamily(style[FONT_FAMILY$4]);
  return style[FONT_SIZE$f] * (o$3.info[ff] || o$3.info.arial).lhr;
}

function calRelativePercent(n, parent, k) {
  n *= 0.01;

  while (parent) {
    var style = parent.currentStyle[k];

    if (style[1] === AUTO$8) {
      if (k === WIDTH$7) {
        parent = parent.domParent;
      } else {
        break;
      }
    } else if (style[1] === PX$9) {
      return n * style[0];
    } else if (style[1] === PERCENT$a) {
      n *= style[0] * 0.01;
      parent = parent.domParent;
    } else if (style[1] === REM$e) {
      return n * style[0] * parent.root.computedStyle[FONT_SIZE$f];
    } else if (style[1] === VW$e) {
      return n * style[0] * parent.root.width * 0.01;
    } else if (style[1] === VH$e) {
      return n * style[0] * parent.root.height * 0.01;
    }
  }

  return n;
}

function calRelative$1(currentStyle, k, v, parent, isWidth) {
  if (v[1] === AUTO$8) {
    v = 0;
  } else if ([PX$9, NUMBER$4].indexOf(v[1]) > -1) {
    v = v[0];
  } else if (v[1] === PERCENT$a) {
    if (isWidth) {
      v = calRelativePercent(v[0], parent, WIDTH$7);
    } else {
      v = calRelativePercent(v[0], parent, HEIGHT$7);
    }
  } else if (v[1] === REM$e) {
    v = v[0] * parent.root.computedStyle[FONT_SIZE$f];
  } else if (v[1] === VW$e) {
    v = v[0] * parent.root.width * 0.01;
  } else if (v[1] === VH$e) {
    v = v[0] * parent.root.height * 0.01;
  }

  return v;
}

function calAbsolute$1(currentStyle, k, v, size, root) {
  if (v[1] === AUTO$8) {
    v = 0;
  } else if ([PX$9, NUMBER$4, DEG$1, RGBA$2, STRING$2].indexOf(v[1]) > -1) {
    v = v[0];
  } else if (v[1] === PERCENT$a) {
    v = v[0] * size * 0.01;
  } else if (v[1] === REM$e) {
    v = v[0] * root.computedStyle[FONT_SIZE$f];
  } else if (v[1] === VW$e) {
    v = v[0] * root.width * 0.01;
  } else if (v[1] === VH$e) {
    v = v[0] * root.height * 0.01;
  }

  return v;
}

function equalStyle$1(k, a, b, target) {
  if (!a || !b) {
    return a === b;
  }

  if (k === TRANSFORM$4) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0, len = a.length; i < len; i++) {
      var oa = a[i];
      var ob = b[i];

      if (oa[0] !== ob[0]) {
        return false;
      } // translate/matrix等都是数组


      if (!equalArr$1(oa[1], ob[1])) {
        return false;
      }
    }

    return true;
  }

  if (k === FILTER$6) {
    if (a.length !== b.length) {
      return false;
    }

    for (var _i = 0, _len = a.length; _i < _len; _i++) {
      if (!equalArr$1(a[_i], b[_i])) {
        return false;
      }
    }
  }

  if (k === BACKGROUND_SIZE$2) {
    if (a.length !== b.length) {
      return false;
    }

    for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
      var aa = a[_i2],
          bb = b[_i2];

      if (aa[0][0] !== bb[0][0] || aa[0][1] !== bb[0][1] || aa[1][0] !== bb[1][0] || aa[1][1] !== bb[1][1]) {
        return false;
      }
    }

    return true;
  }

  if (k === TRANSFORM_ORIGIN$4 || RADIUS_HASH$1.hasOwnProperty(k)) {
    return a[0][0] === b[0][0] && a[0][1] === b[0][1] && a[1][0] === b[1][0] && a[1][1] === b[1][1];
  }

  if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3 || LENGTH_HASH$1.hasOwnProperty(k) || EXPAND_HASH$1.hasOwnProperty(k)) {
    return a[0] === b[0] && a[1] === b[1];
  }

  if (k === BOX_SHADOW$9) {
    return equalArr$1(a, b);
  }

  if (COLOR_HASH$1.hasOwnProperty(k)) {
    return a[1] === b[1] && equalArr$1(a[0], b[0]);
  }

  if (GRADIENT_HASH$1.hasOwnProperty(k) && a.k === b.k && GRADIENT_TYPE$1.hasOwnProperty(a.k)) {
    var av = a.v;
    var bv = b.v;

    if (a.d !== b.d || av.length !== bv.length) {
      return false;
    }

    for (var _i3 = 0, _len3 = av.length; _i3 < _len3; _i3++) {
      var ai = av[_i3];
      var bi = bv[_i3];

      if (ai.length !== bi.length) {
        return false;
      }

      for (var j = 0; j < 4; j++) {
        if (ai[0][j] !== bi[0][j]) {
          return false;
        }
      }

      if (ai.length > 1) {
        if (ai[1][0] !== bi[1][0] || ai[1][1] !== bi[1][1]) {
          return false;
        }
      }
    }

    return true;
  } // multi都是纯值数组，equalArr本身即递归，非multi根据类型判断


  if (isGeom$2(target.tagName, k) && (target.isMulti || Array.isArray(a) && Array.isArray(b))) {
    return equalArr$1(a, b);
  }

  return a === b;
}

function isRelativeOrAbsolute$2(node) {
  var position = node.currentStyle[POSITION$5];
  return position === 'relative' || position === 'absolute';
}

var VALUE = (_VALUE = {}, _defineProperty(_VALUE, POSITION$5, true), _defineProperty(_VALUE, DISPLAY$a, true), _defineProperty(_VALUE, STYLE_KEY$2.BACKGROUND_REPEAT, true), _defineProperty(_VALUE, FLEX_DIRECTION$2, true), _defineProperty(_VALUE, FLEX_GROW$1, true), _defineProperty(_VALUE, FLEX_SHRINK$1, true), _defineProperty(_VALUE, FLEX_WRAP$1, true), _defineProperty(_VALUE, JUSTIFY_CONTENT$1, true), _defineProperty(_VALUE, ALIGN_ITEMS$1, true), _defineProperty(_VALUE, ALIGN_SELF$1, true), _defineProperty(_VALUE, STYLE_KEY$2.OVERFLOW, true), _defineProperty(_VALUE, STYLE_KEY$2.MIX_BLEND_MODE, true), _defineProperty(_VALUE, STYLE_KEY$2.STROKE_LINECAP, true), _defineProperty(_VALUE, STYLE_KEY$2.STROKE_LINEJOIN, true), _defineProperty(_VALUE, STYLE_KEY$2.STROKE_MITERLIMIT, true), _defineProperty(_VALUE, STYLE_KEY$2.FILL_RULE, true), _defineProperty(_VALUE, OPACITY$5, true), _defineProperty(_VALUE, Z_INDEX$4, true), _defineProperty(_VALUE, BACKGROUND_CLIP$2, true), _defineProperty(_VALUE, TEXT_OVERFLOW$2, true), _defineProperty(_VALUE, LINE_CLAMP$1, true), _VALUE); // 仅1维数组

var ARRAY_0 = (_ARRAY_ = {}, _defineProperty(_ARRAY_, COLOR$5, true), _defineProperty(_ARRAY_, TEXT_STROKE_COLOR$4, true), _defineProperty(_ARRAY_, BACKGROUND_COLOR$2, true), _defineProperty(_ARRAY_, STYLE_KEY$2.BORDER_TOP_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$2.BORDER_RIGHT_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$2.BORDER_BOTTOM_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$2.BORDER_LEFT_COLOR, true), _ARRAY_); // 仅2维数组且只有2个值

var ARRAY_0_1 = (_ARRAY_0_ = {}, _defineProperty(_ARRAY_0_, STYLE_KEY$2.BORDER_TOP_LEFT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$2.BORDER_TOP_RIGHT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$2.BORDER_BOTTOM_RIGHT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$2.BORDER_BOTTOM_LEFT_RADIUS, true), _defineProperty(_ARRAY_0_, TRANSFORM_ORIGIN$4, true), _defineProperty(_ARRAY_0_, PERSPECTIVE_ORIGIN$4, true), _ARRAY_0_);

function cloneStyle$1(style, keys) {
  if (!keys) {
    keys = Object.keys(style).map(function (i) {
      if (!GEOM$2.hasOwnProperty(i)) {
        i = parseInt(i);
      }

      return i;
    });
  }

  var res = {};

  for (var i = 0, len = keys.length; i < len; i++) {
    var k = keys[i];
    var v = style[k]; // 渐变特殊处理

    if (k === BACKGROUND_IMAGE$2) {
      res[k] = v.map(function (item) {
        // 可能为null
        if (item && item.k) {
          return util.clone(item);
        } else {
          return item;
        }
      });
    } else if (k === FILL$2 || k === STROKE$1) {
      res[k] = v.map(function (item) {
        // 渐变
        // 可能非法为空
        if (item && item.k) {
          return util.clone(item);
        } // 颜色
        else {
          return item.slice(0);
        }
      });
    } else if (k === TRANSFORM$4 || k === FILTER$6) {
      if (v) {
        var n = v.slice(0);

        for (var _i4 = 0, _len4 = n.length; _i4 < _len4; _i4++) {
          n[_i4] = n[_i4].slice(0);
          n[_i4][1] = n[_i4][1].slice(0);
        }

        res[k] = n;
      }
    } else if (k === BOX_SHADOW$9) {
      if (v) {
        v = v.map(function (item) {
          var n = item.slice(0);
          n[4] = n[4].slice(0);
          return n;
        });
        res[k] = v;
      }
    } else if (k === TRANSLATE_PATH$1) {
      if (v) {
        res[k] = v.map(function (item) {
          return item.slice(0);
        });
      }
    } // position等直接值类型赋值
    else if (VALUE.hasOwnProperty(k)) {
      res[k] = v;
    } // geom自定义属性
    else if (GEOM$2.hasOwnProperty(k)) {
      res[k] = util.clone(v);
    } // 其余皆是数组或空，默认是一维数组只需slice即可
    else if (v) {
      var _n = res[k] = v.slice(0); // 特殊引用里数组某项再次clone


      if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3) {
        for (var _i5 = 0, _len5 = _n.length; _i5 < _len5; _i5++) {
          _n[_i5] = _n[_i5].slice(0);
        }
      } else if (k === BACKGROUND_SIZE$2) {
        for (var _i6 = 0, _len6 = _n.length; _i6 < _len6; _i6++) {
          _n[_i6] = _n[_i6].slice(0);
          _n[_i6][0] = _n[_i6][0].slice(0);
          _n[_i6][1] = _n[_i6][1].slice(0);
        }
      } else if (ARRAY_0.hasOwnProperty(k)) {
        _n[0] = _n[0].slice(0);
      } else if (ARRAY_0_1.hasOwnProperty(k)) {
        _n[0] = _n[0].slice(0);
        _n[1] = _n[1].slice(0);
      } else if (k === TRANSFORM$4) {
        for (var _i7 = 0, _len7 = _n.length; _i7 < _len7; _i7++) {
          _n[_i7] = _n[_i7].slice(0);
        }
      } else if (k === ROTATE_3D$3) {
        _n[3] = _n[3].slice(0);
      }
    }
  }

  return res;
}

var css = {
  normalize: normalize$1,
  computeMeasure: computeMeasure,
  computeReflow: computeReflow,
  setFontStyle: setFontStyle,
  getFontFamily: getFontFamily,
  getBaseLine: getBaseLine,
  calRelative: calRelative$1,
  calAbsolute: calAbsolute$1,
  equalStyle: equalStyle$1,
  isRelativeOrAbsolute: isRelativeOrAbsolute$2,
  cloneStyle: cloneStyle$1
};

var _enums$STYLE_KEY$m = enums.STYLE_KEY,
    COLOR$4 = _enums$STYLE_KEY$m.COLOR,
    FONT_WEIGHT$3 = _enums$STYLE_KEY$m.FONT_WEIGHT,
    FONT_FAMILY$3 = _enums$STYLE_KEY$m.FONT_FAMILY,
    FONT_SIZE$e = _enums$STYLE_KEY$m.FONT_SIZE,
    FONT_STYLE$3 = _enums$STYLE_KEY$m.FONT_STYLE,
    LETTER_SPACING$1 = _enums$STYLE_KEY$m.LETTER_SPACING,
    TEXT_STROKE_COLOR$3 = _enums$STYLE_KEY$m.TEXT_STROKE_COLOR,
    TEXT_STROKE_WIDTH$2 = _enums$STYLE_KEY$m.TEXT_STROKE_WIDTH,
    TEXT_STROKE_OVER$2 = _enums$STYLE_KEY$m.TEXT_STROKE_OVER;
/**
 * 表示一行文本的类，保存它的位置、内容、从属信息，在布局阶段生成，并在渲染阶段被Text调用render()
 * 关系上直属于Text类，一个Text类可能因为换行原因导致有多个TextBox，一行内容中也可能有不同Text从而不同TextBox
 * 另外本类还会被LineBoxManager添加到LineBox里，LineBox为一行中的inline/文本组合，之间需要进行垂直对齐
 * 在textOverflow为ellipsis时，可能会收到后面节点的向前回退（后面不足放下…），使得省略号发生在本节点
 */

var TextBox = /*#__PURE__*/function () {
  function TextBox(parent, index, x, y, w, h, content, wList) {
    _classCallCheck(this, TextBox);

    this.__parent = parent;
    this.__index = index;
    this.__x = x;
    this.__y = y;
    this.__width = w;
    this.__height = h;
    this.__content = content;
    this.__wList = wList;
    this.__virtualDom = {};
  }
  /**
   * 渲染阶段被Text类调用，多行Text会有多个TextBox，内容被分拆开
   * @param renderMode
   * @param ctx
   * @param computedStyle
   * @param cacheStyle Text父节点Dom的缓存样式，相比computedStyle可以直接用，比如color被缓存为style字符串
   * @param dx
   * @param dy
   */


  _createClass(TextBox, [{
    key: "render",
    value: function render(renderMode, ctx, computedStyle, cacheStyle, dx, dy) {
      var content = this.content,
          x = this.x,
          y = this.y,
          parent = this.parent,
          wList = this.wList,
          width = this.width;
      var ox = parent.ox,
          oy = parent.oy;
      y += css.getBaseLine(computedStyle);
      x += ox + dx;
      y += oy + dy;
      this.__endX = x + width;
      this.__endY = y;
      var letterSpacing = computedStyle[LETTER_SPACING$1],
          textStrokeWidth = computedStyle[TEXT_STROKE_WIDTH$2],
          textStrokeColor = computedStyle[TEXT_STROKE_COLOR$3];
      var i = 0,
          length = content.length;

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        var overFill = computedStyle[TEXT_STROKE_OVER$2] === 'fill';

        if (letterSpacing) {
          for (; i < length; i++) {
            if (overFill) {
              ctx.fillText(content.charAt(i), x, y);
            }

            if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3)) {
              ctx.strokeText(content.charAt(i), x, y);
            }

            if (!overFill) {
              ctx.fillText(content.charAt(i), x, y);
            }

            x += wList[i] + letterSpacing;
          }
        } else {
          if (overFill) {
            ctx.fillText(content, x, y);
          }

          if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3)) {
            ctx.strokeText(content, x, y);
          }

          if (!overFill) {
            ctx.fillText(content, x, y);
          }
        }
      } else if (renderMode === mode.SVG) {
        var props = [['x', x], ['y', y], ['fill', cacheStyle[COLOR$4]], ['font-family', computedStyle[FONT_FAMILY$3]], ['font-weight', computedStyle[FONT_WEIGHT$3]], ['font-style', computedStyle[FONT_STYLE$3]], ['font-size', computedStyle[FONT_SIZE$e] + 'px']]; // svg无法定义stroke的over

        if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3)) {
          props.push(['stroke', cacheStyle[TEXT_STROKE_COLOR$3]]);
          props.push(['stroke-width', computedStyle[TEXT_STROKE_WIDTH$2]]);
        }

        if (letterSpacing) {
          props.push(['letter-spacing', letterSpacing]);
        }

        this.__virtualDom = {
          type: 'item',
          tagName: 'text',
          props: props,
          content: util.encodeHtml(content)
        };
      }
    }
  }, {
    key: "__offsetX",
    value: function __offsetX(diff) {
      this.__x += diff;
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff) {
      this.__y += diff;
    }
  }, {
    key: "x",
    get: function get() {
      return this.__x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.__y;
    }
  }, {
    key: "endX",
    get: function get() {
      return this.__endX;
    }
  }, {
    key: "endY",
    get: function get() {
      return this.__endY;
    }
  }, {
    key: "width",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "outerWidth",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "height",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "outerHeight",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "content",
    get: function get() {
      return this.__content;
    }
  }, {
    key: "baseLine",
    get: function get() {
      return this.parent.baseLine;
    }
  }, {
    key: "virtualDom",
    get: function get() {
      return this.__virtualDom;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.__parent;
    }
  }, {
    key: "parentLineBox",
    get: function get() {
      return this.__parentLineBox;
    }
  }, {
    key: "wList",
    get: function get() {
      return this.__wList;
    }
  }]);

  return TextBox;
}();

var SIZE = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192];
var NUMBER$3 = [128, 64, 32, 16, 8, 4, 2, 1, 1, 1, 1];
var MAX = SIZE[SIZE.length - 1];
var HASH_CANVAS = {};
var uuid$2 = 0;

var Page = /*#__PURE__*/function () {
  function Page(size, number) {
    _classCallCheck(this, Page);

    this.__size = size;
    this.__number = number;
    this.__free = this.__total = number * number;
    size *= number;
    this.__width = size;
    this.__height = size;
    var offscreen = this.__canvas = inject.getCacheCanvas(size, size, null, number);

    if (offscreen) {
      this.__offscreen = offscreen;
    } // 1/0标识n*n个单元格是否空闲可用，一维数组表示


    this.__grid = [];

    for (var i = 0; i < this.__total; i++) {
      this.__grid.push(1);
    }

    this.__uuid = uuid$2++; // webgl贴图缓存使用，一旦更新则标识记录，绑定某号纹理单元查看变化才更新贴图

    this.__update = false;
    this.time = 0;
  }

  _createClass(Page, [{
    key: "add",
    value: function add() {
      var number = this.number,
          grid = this.grid;

      for (var i = 0; i < number; i++) {
        for (var j = 0; j < number; j++) {
          var index = i * number + j;

          if (grid[index]) {
            grid[index] = 0;
            this.__free--;
            return index;
          }
        }
      } // 理论不可能进入，除非bug


      throw new Error('Can not find free page');
    }
  }, {
    key: "del",
    value: function del(pos) {
      if (!this.grid[pos]) {
        this.grid[pos] = 1;
        this.__free++;
      }
    }
  }, {
    key: "getCoords",
    value: function getCoords(pos) {
      var size = this.size,
          number = this.number;
      var x = pos % number;
      var y = Math.floor(pos / number);
      return [x * size, y * size];
    }
  }, {
    key: "uuid",
    get: function get() {
      return this.__uuid;
    }
  }, {
    key: "size",
    get: function get() {
      return this.__size;
    }
  }, {
    key: "width",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "height",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "number",
    get: function get() {
      return this.__number;
    }
  }, {
    key: "total",
    get: function get() {
      return this.__total;
    }
  }, {
    key: "free",
    get: function get() {
      return this.__free;
    }
  }, {
    key: "grid",
    get: function get() {
      return this.__grid;
    }
  }, {
    key: "offscreen",
    get: function get() {
      return this.__offscreen;
    }
  }, {
    key: "canvas",
    get: function get() {
      return this.offscreen.canvas;
    }
  }, {
    key: "ctx",
    get: function get() {
      return this.offscreen.ctx;
    }
  }, {
    key: "update",
    get: function get() {
      return this.__update;
    },
    set: function set(v) {
      this.__update = v;
    }
  }], [{
    key: "getInstance",
    value: function getInstance(size) {
      if (size > MAX) {
        return;
      }

      var s = SIZE[0];
      var n = NUMBER$3[0]; // 使用刚好满足的尺寸

      for (var i = 0, len = SIZE.length; i < len; i++) {
        s = SIZE[i];
        n = NUMBER$3[i];

        if (SIZE[i] >= size) {
          break;
        }
      }

      var list = HASH_CANVAS[s] = HASH_CANVAS[s] || []; // 从hash列表中尝试取可用的一页，找不到就生成新的页

      var page;

      for (var _i = 0, _len = list.length; _i < _len; _i++) {
        var item = list[_i];

        if (item.free) {
          page = item;
          break;
        }
      }

      if (!page) {
        page = new Page(s, n);

        if (!page.offscreen) {
          inject.error('Can not create off-screen for page');
          return;
        }

        list.push(page);
      }

      var pos = page.add();
      return {
        page: page,
        pos: pos
      };
    }
  }, {
    key: "CONFIG",
    get: function get() {
      return {
        SIZE: SIZE,
        NUMBER: NUMBER$3
      };
    },
    set: function set(v) {
      if (!v || !Array.isArray(v.SIZE) || !Array.isArray(v.NUMBER)) {
        return;
      }

      SIZE = v.SIZE;
      NUMBER$3 = v.NUMBER;
      MAX = SIZE[SIZE.length - 1];
    }
  }, {
    key: "MAX",
    get: function get() {
      return MAX;
    }
  }, {
    key: "genUuid",
    value: function genUuid() {
      return uuid$2++;
    }
  }]);

  return Page;
}();

function calDeg(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  var atan = Math.atan(Math.abs(dy) / Math.abs(dx)); // 2象限

  if (dx < 0 && dy >= 0) {
    return Math.PI - atan;
  } // 3象限


  if (dx < 0 && dy < 0) {
    return atan - Math.PI;
  } // 1象限


  if (dx >= 0 && dy >= 0) {
    return atan;
  } // 4象限，顺时针正好


  return -atan;
}

function rotate(theta) {
  var sin = Math.sin(theta);
  var cos = Math.cos(theta);
  var t = mx.identity();
  t[0] = t[5] = cos;
  t[1] = sin;
  t[4] = -sin;
  return t;
}
/**
 * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
 * @param points
 */


function pointIndex(points) {
  var _points = _slicedToArray(points, 6),
      x1 = _points[0],
      y1 = _points[1],
      x2 = _points[2],
      y2 = _points[3],
      x3 = _points[4],
      y3 = _points[5];

  var index = [0, 1, 2]; // 将a点放入最左

  if (x2 < x1 && x2 < x3) {
    var _ref = [x2, y2, x1, y1];
    x1 = _ref[0];
    y1 = _ref[1];
    x2 = _ref[2];
    y2 = _ref[3];
    index[0] = 1;
    index[1] = 0;
  } else if (x3 < x2 && x3 < x1) {
    var _ref2 = [x3, y3, x1, y1];
    x1 = _ref2[0];
    y1 = _ref2[1];
    x3 = _ref2[2];
    y3 = _ref2[3];
    index[0] = 2;
    index[2] = 0;
  } // 有可能出现2个并列的情况，判断取上面那个


  if (x1 === x2) {
    if (y1 > y2) {
      var _ref3 = [x2, y2, x1, y1];
      x1 = _ref3[0];
      y1 = _ref3[1];
      x2 = _ref3[2];
      y2 = _ref3[3];
      var t = index[0];
      index[0] = index[1];
      index[1] = t;
    }
  } else if (x1 === x3) {
    if (y1 > y3) {
      var _ref4 = [x3, y3, x1, y1];
      x1 = _ref4[0];
      y1 = _ref4[1];
      x3 = _ref4[2];
      y3 = _ref4[3];
      var _t = index[0];
      index[0] = index[2];
      index[2] = _t;
    }
  } // ab到ac要顺时针旋转，即2个向量夹角为正，用向量叉乘判断正负


  var cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);

  if (cross < 0) {
    var _ref5 = [x3, y3, x2, y2];
    x2 = _ref5[0];
    y2 = _ref5[1];
    x3 = _ref5[2];
    y3 = _ref5[3];
    var _t2 = index[1];
    index[1] = index[2];
    index[2] = _t2;
  }

  return [x1, y1, x2, y2, x3, y3, index];
}
/**
 * 第2个点根据第一个点的交换顺序交换
 * @param points
 * @param index
 * @returns {[]}
 */


function pointByIndex(points, index) {
  var res = [];

  for (var i = 0, len = index.length; i < len; i++) {
    var j = index[i];
    res.push(points[j * 2]);
    res.push(points[j * 2 + 1]);
  }

  return res;
}
/**
 * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
 * @param source 源3个点
 * @param target 目标3个点
 * @returns 交换顺序后的点坐标
 */


function exchangeOrder(source, target) {
  var _pointIndex = pointIndex(source),
      _pointIndex2 = _slicedToArray(_pointIndex, 7),
      sx1 = _pointIndex2[0],
      sy1 = _pointIndex2[1],
      sx2 = _pointIndex2[2],
      sy2 = _pointIndex2[3],
      sx3 = _pointIndex2[4],
      sy3 = _pointIndex2[5],
      index = _pointIndex2[6];

  var _pointByIndex = pointByIndex(target, index),
      _pointByIndex2 = _slicedToArray(_pointByIndex, 6),
      tx1 = _pointByIndex2[0],
      ty1 = _pointByIndex2[1],
      tx2 = _pointByIndex2[2],
      ty2 = _pointByIndex2[3],
      tx3 = _pointByIndex2[4],
      ty3 = _pointByIndex2[5];

  return [[sx1, sy1, sx2, sy2, sx3, sy3], [tx1, ty1, tx2, ty2, tx3, ty3]];
}
/**
 * 存在一种情况，变换结果使得三角形镜像相反了，即顶点a越过bc线，判断是否溢出
 * @param source
 * @param target
 * @returns {boolean}是否溢出
 */


function isOverflow(source, target) {
  var _source = _slicedToArray(source, 6),
      sx1 = _source[0],
      sy1 = _source[1],
      sx2 = _source[2],
      sy2 = _source[3],
      sx3 = _source[4],
      sy3 = _source[5];

  var _target = _slicedToArray(target, 6),
      tx1 = _target[0],
      ty1 = _target[1],
      tx2 = _target[2],
      ty2 = _target[3],
      tx3 = _target[4],
      ty3 = _target[5];

  var cross1 = (sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1);
  var cross2 = (tx2 - tx1) * (ty3 - ty1) - (tx3 - tx1) * (ty2 - ty1);
  return cross1 > 0 && cross2 < 0 || cross1 < 0 && cross2 > 0;
}

function transform(source, target) {
  var _source2 = _slicedToArray(source, 6),
      sx1 = _source2[0],
      sy1 = _source2[1],
      sx2 = _source2[2],
      sy2 = _source2[3],
      sx3 = _source2[4],
      sy3 = _source2[5];

  var _target2 = _slicedToArray(target, 6),
      tx1 = _target2[0],
      ty1 = _target2[1],
      tx2 = _target2[2],
      ty2 = _target2[3],
      tx3 = _target2[4],
      ty3 = _target2[5]; // 记录翻转


  var overflow = isOverflow(source, target); // 第0步，将源三角第1个a点移到原点

  var m = mx.identity();
  m[12] = -sx1;
  m[13] = -sy1;
  var t; // 第1步，以第1条边ab为基准，将其贴合x轴上，为后续倾斜不干扰做准备

  var theta = calDeg(sx1, sy1, sx2, sy2);

  if (theta !== 0) {
    t = rotate(-theta);
    m = mx.multiply(t, m);
  } // 第2步，以第1条边AB为基准，缩放x轴ab至目标相同长度，可与4步合并


  var ls = geom$1.pointsDistance(sx1, sy1, sx2, sy2);
  var lt = geom$1.pointsDistance(tx1, ty1, tx2, ty2); // if(ls !== lt) {
  // let scale = lt / ls;
  // t = matrix.identity();
  // t[0] = scale;
  // m = matrix.multiply(t, m);
  // }
  // 第3步，缩放y，先将目标三角形旋转到x轴平行，再变换坐标计算

  var n = mx.identity();
  n[12] = -tx1;
  n[13] = -ty1;
  theta = calDeg(tx1, ty1, tx2, ty2); // 记录下这个旋转角度，后面源三角形要反向旋转

  var alpha = theta;

  if (theta !== 0) {
    t = rotate(-theta);
    n = mx.multiply(t, n);
  } // 目标三角反向旋转至x轴后的坐标
  // 源三角目前的第3点坐标y值即为长度，因为a点在原点0无需减去


  var ls2 = Math.abs(mx.calPoint([sx3, sy3], m)[1]);
  var lt2 = Math.abs(mx.calPoint([tx3, ty3], n)[1]); // 缩放y
  // if(ls2 !== lt2) {
  // let scale = lt / ls;
  // t = matrix.identity();
  // t[3] = scale;
  // m = matrix.multiply(t, m);
  // }

  if (ls !== lt || ls2 !== lt2) {
    t = mx.identity();

    if (ls !== lt) {
      t[0] = lt / ls;
    }

    if (ls2 !== lt2) {
      t[5] = lt2 / ls2;
    }

    m = mx.multiply(t, m);
  } // 第4步，x轴倾斜，用余弦定理求目前a和A的夹角


  n = m;

  var _matrix$calPoint = mx.calPoint([sx1, sy1], n),
      _matrix$calPoint2 = _slicedToArray(_matrix$calPoint, 2),
      ax1 = _matrix$calPoint2[0],
      ay1 = _matrix$calPoint2[1];

  var _matrix$calPoint3 = mx.calPoint([sx2, sy2], n),
      _matrix$calPoint4 = _slicedToArray(_matrix$calPoint3, 2),
      ax2 = _matrix$calPoint4[0],
      ay2 = _matrix$calPoint4[1];

  var _matrix$calPoint5 = mx.calPoint([sx3, sy3], n),
      _matrix$calPoint6 = _slicedToArray(_matrix$calPoint5, 2),
      ax3 = _matrix$calPoint6[0],
      ay3 = _matrix$calPoint6[1];

  var ab = geom$1.pointsDistance(ax1, ay1, ax2, ay2);
  var ac = geom$1.pointsDistance(ax1, ay1, ax3, ay3);
  var bc = geom$1.pointsDistance(ax3, ay3, ax2, ay2);
  var AB = geom$1.pointsDistance(tx1, ty1, tx2, ty2);
  var AC = geom$1.pointsDistance(tx1, ty1, tx3, ty3);
  var BC = geom$1.pointsDistance(tx3, ty3, tx2, ty2);
  var a = geom$1.angleBySide(bc, ab, ac);
  var A = geom$1.angleBySide(BC, AB, AC); // 先至90°，再旋转至目标角，可以合并成tan相加，不知道为什么不能直接tan倾斜差值角度

  if (a !== A) {
    t = mx.identity();
    t[4] = Math.tan(a - Math.PI * 0.5) + Math.tan(Math.PI * 0.5 - A);
    m = mx.multiply(t, m);
  } // 发生翻转时特殊处理按x轴垂直翻转


  if (overflow) {
    m[1] = -m[1];
    m[5] = -m[5];
    m[13] = -m[13];
  } // 第5步，再次旋转，角度为目标旋转到x轴的负值，可与下步合并


  if (alpha !== 0) {
    t = rotate(alpha); // m = matrix.multiply(t, m);
  } else {
    t = mx.identity();
  } // 第6步，移动第一个点的差值
  // t = matrix.identity();


  t[12] = tx1;
  t[13] = ty1;
  return mx.multiply(t, m);
}

var tar = {
  exchangeOrder: exchangeOrder,
  isOverflow: isOverflow,
  transform: transform
};

var math = {
  matrix: mx,
  tar: tar,
  geom: geom$1
};

var _enums$STYLE_KEY$l = enums.STYLE_KEY,
    TRANSLATE_X$3 = _enums$STYLE_KEY$l.TRANSLATE_X,
    TRANSLATE_Y$3 = _enums$STYLE_KEY$l.TRANSLATE_Y,
    TRANSLATE_Z$3 = _enums$STYLE_KEY$l.TRANSLATE_Z,
    SCALE_X$2 = _enums$STYLE_KEY$l.SCALE_X,
    SCALE_Y$2 = _enums$STYLE_KEY$l.SCALE_Y,
    SCALE_Z$1 = _enums$STYLE_KEY$l.SCALE_Z,
    SKEW_X$1 = _enums$STYLE_KEY$l.SKEW_X,
    SKEW_Y$1 = _enums$STYLE_KEY$l.SKEW_Y,
    ROTATE_X$1 = _enums$STYLE_KEY$l.ROTATE_X,
    ROTATE_Y$1 = _enums$STYLE_KEY$l.ROTATE_Y,
    ROTATE_Z$1 = _enums$STYLE_KEY$l.ROTATE_Z,
    ROTATE_3D$2 = _enums$STYLE_KEY$l.ROTATE_3D,
    PERSPECTIVE$4 = _enums$STYLE_KEY$l.PERSPECTIVE,
    MATRIX$2 = _enums$STYLE_KEY$l.MATRIX,
    FONT_SIZE$d = _enums$STYLE_KEY$l.FONT_SIZE;
var PX$8 = o$4.PX,
    PERCENT$9 = o$4.PERCENT,
    REM$d = o$4.REM,
    VW$d = o$4.VW,
    VH$d = o$4.VH;
var matrix = math.matrix,
    geom = math.geom;
var identity = matrix.identity,
    multiply$1 = matrix.multiply,
    isE$1 = matrix.isE;
var d2r = geom.d2r;

function calSingle(t, k, v) {
  if (k === TRANSLATE_X$3) {
    t[12] = v;
  } else if (k === TRANSLATE_Y$3) {
    t[13] = v;
  } else if (k === TRANSLATE_Z$3) {
    t[14] = v;
  } else if (k === SCALE_X$2) {
    t[0] = v;
  } else if (k === SCALE_Y$2) {
    t[5] = v;
  } else if (k === SCALE_Z$1) {
    t[10] = v;
  } else if (k === SKEW_X$1) {
    v = d2r(v);
    t[4] = Math.tan(v);
  } else if (k === SKEW_Y$1) {
    v = d2r(v);
    t[1] = Math.tan(v);
  } else if (k === ROTATE_X$1) {
    v = d2r(v);
    var sin = Math.sin(v);
    var cos = Math.cos(v);
    t[5] = t[10] = cos;
    t[6] = sin;
    t[9] = -sin;
  } else if (k === ROTATE_Y$1) {
    v = d2r(v);

    var _sin = Math.sin(v);

    var _cos = Math.cos(v);

    t[0] = t[10] = _cos;
    t[8] = _sin;
    t[2] = -_sin;
  } else if (k === ROTATE_Z$1) {
    v = d2r(v);

    var _sin2 = Math.sin(v);

    var _cos2 = Math.cos(v);

    t[0] = t[5] = _cos2;
    t[1] = _sin2;
    t[4] = -_sin2;
  } else if (k === ROTATE_3D$2) {
    var _v = v,
        _v2 = _slicedToArray(_v, 4),
        x = _v2[0],
        y = _v2[1],
        z = _v2[2],
        r = _v2[3];

    r = d2r(r[0]);
    var s = Math.sin(r);
    var c = Math.cos(r);

    if (x && !y && !z) {
      if (x < 0) {
        s = -s;
      }

      t[5] = c;
      t[9] = -s;
      t[6] = s;
      t[10] = c;
    } else if (y && !x && !z) {
      if (y < 0) {
        s = -s;
      }

      t[0] = c;
      t[8] = s;
      t[2] = -s;
      t[10] = c;
    } else if (z && !x && !y) {
      if (z < 0) {
        s = -s;
      }

      t[0] = c;
      t[4] = -s;
      t[1] = s;
      t[5] = c;
    } else {
      var len = Math.sqrt(x * x + y * y + z * z);

      if (len !== 1) {
        var rlen = 1 / len;
        x *= rlen;
        y *= rlen;
        z *= rlen;
      }

      var nc = 1 - c;
      var xy = x * y;
      var yz = y * z;
      var zx = z * x;
      var xs = x * s;
      var ys = y * s;
      var zs = z * s;
      t[0] = x * x * nc + c;
      t[1] = xy * nc + zs;
      t[2] = zx * nc - ys;
      t[3] = 0;
      t[4] = xy * nc - zs;
      t[5] = y * y * nc + c;
      t[6] = yz * nc + xs;
      t[7] = 0;
      t[8] = zx * nc + ys;
      t[9] = yz * nc - xs;
      t[10] = z * z * nc + c;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
    }
  } else if (k === PERSPECTIVE$4 && v > 0) {
    v = Math.max(v, 1);
    t[11] = -1 / v;
  } else if (k === MATRIX$2) {
    util.assignMatrix(t, v);
  }
}

function calMatrix(transform, ow, oh, root) {
  var list = normalize(transform, ow, oh, root);
  var m = identity();
  list.forEach(function (item) {
    var _item = _slicedToArray(item, 2),
        k = _item[0],
        v = _item[1];

    var t = identity();
    calSingle(t, k, v);
    m = multiply$1(m, t);
  });
  return m;
} // 已有计算好的变换矩阵，根据tfo原点计算最终的matrix


function calMatrixByOrigin(m, transformOrigin) {
  var _transformOrigin = _slicedToArray(transformOrigin, 2),
      ox = _transformOrigin[0],
      oy = _transformOrigin[1];

  var res = m.slice(0);

  if (ox === 0 && oy === 0 || isE$1(m)) {
    return res;
  }

  res = multiply$1([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
  res = multiply$1(res, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -ox, -oy, 0, 1]);
  return res;
} // img缩放svg下专用，无rem


function calMatrixWithOrigin(transform, transformOrigin, ow, oh) {
  var m = calMatrix(transform, ow, oh);
  return calMatrixByOrigin(m, transformOrigin);
}

function normalizeSingle(k, v, ow, oh, root) {
  if (k === TRANSLATE_X$3 || k === TRANSLATE_Z$3) {
    if (v[1] === PERCENT$9) {
      return v[0] * ow * 0.01;
    } else if (v[1] === REM$d) {
      return v[0] * root.computedStyle[FONT_SIZE$d];
    } else if (v[1] === VW$d) {
      return v[0] * root.width * 0.01;
    } else if (v[1] === VH$d) {
      return v[0] * root.height * 0.01;
    }
  } else if (k === TRANSLATE_Y$3) {
    if (v[1] === PERCENT$9) {
      return v[0] * oh * 0.01;
    } else if (v[1] === REM$d) {
      return v[0] * root.computedStyle[FONT_SIZE$d];
    } else if (v[1] === VW$d) {
      return v[0] * root.width * 0.01;
    } else if (v[1] === VH$d) {
      return v[0] * root.height * 0.01;
    }
  } else if (k === MATRIX$2) {
    return v;
  } else if (k === ROTATE_3D$2) {
    return v;
  }

  return v[0];
}

function normalize(transform, ow, oh, root) {
  var res = [];
  transform.forEach(function (item) {
    var _item2 = _slicedToArray(item, 2),
        k = _item2[0],
        v = _item2[1];

    res.push([k, normalizeSingle(k, v, ow, oh, root)]);
  });
  return res;
}

function calOrigin(transformOrigin, w, h, root) {
  var tfo = [];
  transformOrigin.forEach(function (item, i) {
    if (item[1] === PX$8) {
      tfo.push(item[0]);
    } else if (item[1] === PERCENT$9) {
      tfo.push(item[0] * (i ? h : w) * 0.01);
    } else if (item[1] === REM$d) {
      tfo.push(item[0] * root.computedStyle[FONT_SIZE$d]);
    } else if (item[1] === VW$d) {
      tfo.push(item[0] * root.width * 0.01);
    } else if (item[1] === VH$d) {
      tfo.push(item[0] * root.height * 0.01);
    }
  });
  return tfo;
}

function calMatrixByPerspective(m, pm) {
  if (!isE$1(pm)) {
    m = multiply$1(pm, m);
  }

  return m;
}

function calPerspectiveMatrix(ppt, po) {
  if (ppt && ppt > 0) {
    var res = identity();
    ppt = Math.max(ppt, 1);
    res[11] = -1 / ppt;

    var _po = _slicedToArray(po, 2),
        ox = _po[0],
        oy = _po[1];

    if (ox || oy) {
      res = multiply$1([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
      res = multiply$1(res, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -ox, -oy, 0, 1]);
    }

    return res;
  }
} // 是否有透视矩阵应用


function isPerspectiveMatrix(m) {
  if (!m) {
    return;
  }

  return !!(m[3] || m[7] || m[11]);
}

var tf = {
  calMatrix: calMatrix,
  calOrigin: calOrigin,
  calMatrixByPerspective: calMatrixByPerspective,
  calPerspectiveMatrix: calPerspectiveMatrix,
  calMatrixByOrigin: calMatrixByOrigin,
  calMatrixWithOrigin: calMatrixWithOrigin,
  isPerspectiveMatrix: isPerspectiveMatrix
};

/**
 * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
 * 根据模糊参数sigma求卷积核尺寸
 * @param sigma
 * @returns {number}
 */
function kernelSize(sigma) {
  if (sigma <= 0) {
    return 0;
  }

  var d = Math.floor(sigma * 3 * Math.sqrt(2 * Math.PI) / 4 + 0.5);

  if (d < 2) {
    d = 2;
  }

  if (d % 2 === 0) {
    d++;
  }

  return d;
}
/**
 * 根据sigma求模糊扩展尺寸，卷积核求得后为d，再求半径/2，然后因为算法要执行3次，所以*3
 * 比如本来d为5，半径2.5算上自身像素点则各方向扩展2，*3则扩展6
 * @param sigma
 * @returns {number}
 */


function outerSize(sigma) {
  var d = kernelSize(sigma);
  return outerSizeByD(d);
}

function outerSizeByD(d) {
  return Math.floor(d * 0.5) * 3;
}
/**
 * 一维高斯正态分布，根据标准差和卷积核尺寸返回一维权重数组
 * @param sigma
 * @param d
 */


function gaussianWeight(sigma, d) {
  var list = [];
  var len = Math.floor(d * 0.5);
  var total = 0;

  for (var i = len; i >= 0; i--) {
    var n = Math.pow(Math.E, -Math.pow(i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));
    list.push(n);
    total += n;
  }

  for (var _i = 1; _i <= len; _i++) {
    var _n = Math.pow(Math.E, -Math.pow(_i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));

    list.push(_n);
    total += _n;
  }

  if (total !== 1) {
    for (var _i2 = 0; _i2 < d; _i2++) {
      list[_i2] /= total;
    }
  }

  return list;
}

var blur = {
  kernelSize: kernelSize,
  outerSize: outerSize,
  outerSizeByD: outerSizeByD,
  gaussianWeight: gaussianWeight
};

var _enums$STYLE_KEY$k = enums.STYLE_KEY,
    TRANSFORM_ORIGIN$3 = _enums$STYLE_KEY$k.TRANSFORM_ORIGIN,
    TRANSFORM$3 = _enums$STYLE_KEY$k.TRANSFORM,
    DISPLAY$9 = _enums$STYLE_KEY$k.DISPLAY,
    VISIBILITY$6 = _enums$STYLE_KEY$k.VISIBILITY,
    _enums$NODE_KEY$9 = enums.NODE_KEY,
    NODE_OPACITY$3 = _enums$NODE_KEY$9.NODE_OPACITY,
    NODE_CACHE$5 = _enums$NODE_KEY$9.NODE_CACHE,
    NODE_CACHE_FILTER$3 = _enums$NODE_KEY$9.NODE_CACHE_FILTER,
    NODE_CACHE_OVERFLOW$3 = _enums$NODE_KEY$9.NODE_CACHE_OVERFLOW,
    NODE_HAS_CONTENT$1 = _enums$NODE_KEY$9.NODE_HAS_CONTENT,
    NODE_COMPUTED_STYLE$5 = _enums$NODE_KEY$9.NODE_COMPUTED_STYLE; // 根据一个共享cache的信息，生成一个独立的离屏canvas，一般是filter,mask用

function genSingle(cache, message) {
  var size = cache.size,
      sx1 = cache.sx1,
      sy1 = cache.sy1,
      width = cache.width,
      height = cache.height,
      bbox = cache.bbox;
  var offscreen = inject.getCacheCanvas(width, height, null, message);
  offscreen.x = 0;
  offscreen.y = 0;
  offscreen.bbox = bbox;
  offscreen.size = size;
  offscreen.sx1 = sx1;
  offscreen.sy1 = sy1;
  offscreen.dx = cache.dx;
  offscreen.dy = cache.dy;
  offscreen.dbx = cache.dbx;
  offscreen.dby = cache.dby;
  offscreen.width = width;
  offscreen.height = height;
  return offscreen;
}

var Cache = /*#__PURE__*/function () {
  function Cache(w, h, bbox, page, pos, x1, y1) {
    _classCallCheck(this, Cache);

    this.__init(w, h, bbox, page, pos, x1, y1);
  }

  _createClass(Cache, [{
    key: "__init",
    value: function __init(w, h, bbox, page, pos, x1, y1) {
      this.__width = w;
      this.__height = h;
      this.__bbox = bbox;
      this.__page = page;
      this.__pos = pos;

      var _page$getCoords = page.getCoords(pos),
          _page$getCoords2 = _slicedToArray(_page$getCoords, 2),
          x = _page$getCoords2[0],
          y = _page$getCoords2[1];

      this.__x = x;
      this.__y = y;

      this.__appendData(x1, y1);

      if (page.canvas) {
        this.__enabled = true;
        var ctx = page.ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (debug.flag) {
          page.canvas.setAttribute && page.canvas.setAttribute('size', page.size);
        }
      }
    }
  }, {
    key: "__appendData",
    value: function __appendData(sx1, sy1) {
      this.sx1 = sx1; // 去除margin的左上角原点坐标

      this.sy1 = sy1;
      var bbox = this.bbox;
      this.dx = this.x - bbox[0]; // cache坐标和box原点的差值

      this.dy = this.y - bbox[1];
      this.dbx = sx1 - bbox[0]; // 原始x1/y1和box原点的差值

      this.dby = sy1 - bbox[1];
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      this.page.update = true;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.available) {
        var ctx = this.ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var size = this.page.size;
        ctx.clearRect(this.x, this.y, size, size);
        this.__available = false;
      }
    }
  }, {
    key: "release",
    value: function release() {
      if (this.enabled) {
        this.clear();
        this.page.del(this.pos);
        this.__page = null;
        this.__enabled = false;
      }
    }
  }, {
    key: "reset",
    value: function reset(bbox, x1, y1) {
      // 尺寸没变复用之前的并清空
      if (util.equalArr(this.bbox, bbox) && this.enabled) {
        this.clear();
        return;
      }

      this.release();
      var w = Math.ceil(bbox[2] - bbox[0]);
      var h = Math.ceil(bbox[3] - bbox[1]);
      var res = Page.getInstance(Math.max(w, h));

      if (!res) {
        this.__enabled = false;
        return;
      }

      var page = res.page,
          pos = res.pos;

      this.__init(w, h, bbox, page, pos, x1, y1);
    } // 是否功能可用，生成离屏canvas及尺寸超限

  }, {
    key: "enabled",
    get: function get() {
      return this.__enabled;
    } // 是否有可用缓存内容

  }, {
    key: "available",
    get: function get() {
      return this.enabled && this.__available;
    }
  }, {
    key: "bbox",
    get: function get() {
      return this.__bbox;
    }
  }, {
    key: "page",
    get: function get() {
      return this.__page;
    }
  }, {
    key: "canvas",
    get: function get() {
      return this.page.canvas;
    }
  }, {
    key: "ctx",
    get: function get() {
      return this.page.ctx;
    }
  }, {
    key: "size",
    get: function get() {
      return this.page.size;
    }
  }, {
    key: "x",
    get: function get() {
      return this.__x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.__y;
    }
  }, {
    key: "width",
    get: function get() {
      return this.__width;
    }
  }, {
    key: "height",
    get: function get() {
      return this.__height;
    }
  }, {
    key: "pos",
    get: function get() {
      return this.__pos;
    }
  }], [{
    key: "MAX",
    get: function get() {
      return Page.MAX;
    }
  }, {
    key: "getInstance",
    value: function getInstance(bbox, x1, y1) {
      var w = Math.ceil(bbox[2] - bbox[0]);
      var h = Math.ceil(bbox[3] - bbox[1]);
      var res = Page.getInstance(Math.max(w, h));

      if (!res) {
        return;
      }

      var page = res.page,
          pos = res.pos;
      return new Cache(w, h, bbox, page, pos, x1, y1);
    }
    /**
     * 复制cache的一块出来单独作为cacheFilter，尺寸边距保持一致，用浏览器原生ctx.filter滤镜
     * @param cache
     * @param filter
     * @returns {{canvas: *, ctx: *, release(): void, available: boolean, draw()}}
     */

  }, {
    key: "genFilter",
    value: function genFilter(cache, filter) {
      var d = 0;
      filter.forEach(function (item) {
        var _item = _slicedToArray(item, 2),
            k = _item[0],
            v = _item[1];

        if (k === 'blur') {
          d = blur.outerSize(v);
        }
      });
      var x = cache.x,
          y = cache.y,
          size = cache.size,
          canvas = cache.canvas,
          sx1 = cache.sx1,
          sy1 = cache.sy1,
          width = cache.width,
          height = cache.height,
          bbox = cache.bbox;
      bbox = bbox.slice(0);
      bbox[0] -= d;
      bbox[1] -= d;
      bbox[2] += d;
      bbox[3] += d;
      var offscreen = inject.getCacheCanvas(width + d * 2, height + d * 2, null, 'filter1');
      offscreen.ctx.filter = painter.canvasFilter(filter);
      offscreen.ctx.drawImage(canvas, x, y, width, height, d, d, width, height);
      offscreen.ctx.filter = 'none';
      offscreen.draw();
      offscreen.bbox = bbox;
      offscreen.x = 0;
      offscreen.y = 0;
      offscreen.size = size;
      offscreen.sx1 = sx1 - d;
      offscreen.sy1 = sy1 - d;
      offscreen.dx = cache.dx;
      offscreen.dy = cache.dy;
      offscreen.dbx = cache.dbx;
      offscreen.dby = cache.dby;
      offscreen.width = width + d * 2;
      offscreen.height = height + d * 2;
      return offscreen;
    }
  }, {
    key: "genMask",
    value: function genMask(target, next, isClip, transform, tfo) {
      var cacheMask = genSingle(target, 'mask1');
      var list = [];

      while (next && next.isMask) {
        list.push(next);
        next = next.next;
      }

      var x = cacheMask.x,
          y = cacheMask.y,
          ctx = cacheMask.ctx,
          dbx = cacheMask.dbx,
          dby = cacheMask.dby;
      tfo[0] += x + dbx;
      tfo[1] += y + dby;
      var inverse = tf.calMatrixByOrigin(transform, tfo); // 先将mask本身绘制到cache上，再设置模式绘制dom本身，因为都是img所以1个就够了

      list.forEach(function (item) {
        var __config = item.__config;
        var cacheOverflow = __config[NODE_CACHE_OVERFLOW$3],
            cacheFilter = __config[NODE_CACHE_FILTER$3],
            cache = __config[NODE_CACHE$5];
        var source = cacheOverflow && cacheOverflow.available && cacheOverflow;

        if (!source) {
          source = cacheFilter && cacheFilter.available && cacheFilter;
        }

        if (!source) {
          source = cache && cache.available && cache;
        }

        if (source) {
          ctx.globalAlpha = __config[NODE_OPACITY$3];
          Cache.drawCache(source, cacheMask, __config[NODE_COMPUTED_STYLE$5][TRANSFORM$3], mx.identity(), __config[NODE_COMPUTED_STYLE$5][TRANSFORM_ORIGIN$3].slice(0), inverse);
        } // 没有内容或者img没加载成功导致没有内容，有内容且可见则是超限，不可能进这里
        else if (__config[NODE_HAS_CONTENT$1] && __config[NODE_COMPUTED_STYLE$5][DISPLAY$9] !== 'none' && __config[NODE_COMPUTED_STYLE$5][VISIBILITY$6] !== 'hidden') {
          inject.error('CacheMask is oversize');
        }
      });
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = isClip ? 'source-out' : 'source-in';
      Cache.drawCache(target, cacheMask);
      ctx.globalCompositeOperation = 'source-over';
      cacheMask.draw(ctx);
      return cacheMask;
    }
    /**
     * 如果不超过bbox，直接用已有的total/filter/mask，否则生成一个新的
     */

  }, {
    key: "genOverflow",
    value: function genOverflow(target, node) {
      var bbox = target.bbox;
      var sx = node.sx,
          sy = node.sy,
          outerWidth = node.outerWidth,
          outerHeight = node.outerHeight;
      var xe = sx + outerWidth;
      var ye = sy + outerHeight;

      if (bbox[0] < sx || bbox[1] < sy || bbox[2] > xe || bbox[3] > ye) {
        var cacheOverflow = genSingle(target, 'overflow');
        var ctx = cacheOverflow.ctx;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        Cache.drawCache(target, cacheOverflow);
        cacheOverflow.draw(ctx);
        ctx.globalCompositeOperation = 'destination-in';
        ctx.fillStyle = '#FFF';
        ctx.beginPath();
        ctx.rect(sx - bbox[0], sy - bbox[1], outerWidth, outerHeight);
        ctx.fill();
        ctx.closePath();
        ctx.globalCompositeOperation = 'source-over';
        return cacheOverflow;
      }
    }
    /**
     * bbox变化时直接用老的cache内容重设bbox
     * @param cache
     * @param bbox
     */

  }, {
    key: "updateCache",
    value: function updateCache(cache, bbox) {
      var old = cache.bbox;

      if (!util.equalArr(bbox, old)) {
        var dx = old[0] - bbox[0];
        var dy = old[1] - bbox[1];
        var newCache = Cache.getInstance(bbox);

        if (newCache && newCache.enabled) {
          var ox = cache.x,
              oy = cache.y,
              canvas = cache.canvas,
              width = cache.width,
              height = cache.height;
          var nx = newCache.x,
              ny = newCache.y;
          newCache.sx1 = cache.sx1;
          newCache.sy1 = cache.sy1;
          newCache.dx = cache.dx + dx;
          newCache.dy = cache.dy + dy;
          newCache.dbx = cache.dbx + dx;
          newCache.dby = cache.dby + dy;
          newCache.ctx.drawImage(canvas, ox, oy, width, height, dx + nx, dy + ny, width, height);
          newCache.__available = true;
          cache.release();
          return newCache;
        }
      } else {
        return cache;
      }
    }
  }, {
    key: "drawCache",
    value: function drawCache(source, target, transform, matrix, tfo, inverse) {
      var tx = target.x,
          ty = target.y,
          sx1 = target.sx1,
          sy1 = target.sy1,
          ctx = target.ctx,
          dbx = target.dbx,
          dby = target.dby;
      var x = source.x,
          y = source.y,
          canvas = source.canvas,
          sx2 = source.sx1,
          sy2 = source.sy1,
          dbx2 = source.dbx,
          dby2 = source.dby,
          width = source.width,
          height = source.height;
      var ox = tx + sx2 - sx1 + dbx - dbx2;
      var oy = ty + sy2 - sy1 + dby - dby2;

      if (transform && matrix && tfo) {
        tfo[0] += ox;
        tfo[1] += oy;
        var m = tf.calMatrixByOrigin(transform, tfo);
        matrix = mx.multiply(matrix, m);

        if (inverse) {
          // 很多情况mask和target相同matrix，可简化计算
          if (util.equalArr(matrix, inverse)) {
            matrix = mx.identity();
          } else {
            inverse = mx.inverse(inverse);
            matrix = mx.multiply(inverse, matrix);
          }
        }

        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      }

      ctx.drawImage(canvas, x, y, width, height, ox, oy, width, height);
    }
  }, {
    key: "draw",
    value: function draw(ctx, opacity, matrix, cache) {
      ctx.globalAlpha = opacity;
      ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      var x = cache.x,
          y = cache.y,
          canvas = cache.canvas,
          sx1 = cache.sx1,
          sy1 = cache.sy1,
          dbx = cache.dbx,
          dby = cache.dby,
          width = cache.width,
          height = cache.height;
      ctx.drawImage(canvas, x, y, width, height, sx1 - dbx, sy1 - dby, width, height);
    }
  }]);

  return Cache;
}();

var _TRANSFORMS;
var STYLE_KEY$1 = enums.STYLE_KEY,
    _enums$STYLE_KEY$j = enums.STYLE_KEY,
    TRANSLATE_X$2 = _enums$STYLE_KEY$j.TRANSLATE_X,
    TRANSLATE_Y$2 = _enums$STYLE_KEY$j.TRANSLATE_Y,
    TRANSLATE_Z$2 = _enums$STYLE_KEY$j.TRANSLATE_Z,
    OPACITY$4 = _enums$STYLE_KEY$j.OPACITY,
    FILTER$5 = _enums$STYLE_KEY$j.FILTER,
    PERSPECTIVE$3 = _enums$STYLE_KEY$j.PERSPECTIVE,
    PERSPECTIVE_ORIGIN$3 = _enums$STYLE_KEY$j.PERSPECTIVE_ORIGIN;
var ENUM = {
  // 低位表示<repaint级别
  NONE: 0,
  //                                          0
  TRANSLATE_X: 1,
  //                                   1
  TRANSLATE_Y: 2,
  //                                  10
  TRANSLATE_Z: 4,
  //                                 100
  TRANSFORM: 8,
  //                                  1000
  TRANSFORM_ALL: 15,
  //                             1111
  OPACITY: 16,
  //                                  10000
  FILTER: 32,
  //                                  100000
  MIX_BLEND_MODE: 64,
  //                         1000000
  PERSPECTIVE: 128,
  //                          10000000
  REPAINT: 256,
  //                             100000000
  // 高位表示reflow
  REFLOW: 512,
  //                             1000000000
  // 特殊高位表示rebuild
  REBUILD: 1024 //                          10000000000

};
var TRANSFORMS = (_TRANSFORMS = {}, _defineProperty(_TRANSFORMS, STYLE_KEY$1.SCALE_X, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.SCALE_Y, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.SCALE_Z, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.ROTATE_X, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.ROTATE_Y, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.ROTATE_Z, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.ROTATE_3D, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.TRANSFORM, true), _defineProperty(_TRANSFORMS, STYLE_KEY$1.TRANSFORM_ORIGIN, true), _TRANSFORMS);
var o$1 = Object.assign({
  contain: function contain(lv, value) {
    return (lv & value) > 0;
  },

  /**
   * 得出等级
   * @param k
   * @returns {number|*}
   */
  getLevel: function getLevel(k) {
    if (o$2.isIgnore(k)) {
      return ENUM.NONE;
    }

    if (k === TRANSLATE_X$2) {
      return ENUM.TRANSLATE_X;
    } else if (k === TRANSLATE_Y$2) {
      return ENUM.TRANSLATE_Y;
    } else if (k === TRANSLATE_Z$2) {
      return ENUM.TRANSLATE_Z;
    } else if (TRANSFORMS.hasOwnProperty(k)) {
      return ENUM.TRANSFORM;
    } else if (k === OPACITY$4) {
      return ENUM.OPACITY;
    } else if (k === FILTER$5) {
      return ENUM.FILTER;
    } else if (k === PERSPECTIVE$3 || k === PERSPECTIVE_ORIGIN$3) {
      return ENUM.PERSPECTIVE;
    } else if (o$2.isRepaint(k)) {
      return ENUM.REPAINT;
    }

    return ENUM.REFLOW;
  },
  isReflow: function isReflow(lv) {
    return !this.isRepaint(lv);
  },
  isRepaint: function isRepaint(lv) {
    return lv < ENUM.REFLOW;
  },
  isRebuild: function isRebuild(lv) {
    return lv >= ENUM.REBUILD;
  }
}, ENUM);
o$1.TRANSFORMS = TRANSFORMS;

var _enums$STYLE_KEY$i = enums.STYLE_KEY,
    DISPLAY$8 = _enums$STYLE_KEY$i.DISPLAY,
    LINE_HEIGHT$3 = _enums$STYLE_KEY$i.LINE_HEIGHT,
    FONT_SIZE$c = _enums$STYLE_KEY$i.FONT_SIZE,
    FONT_FAMILY$2 = _enums$STYLE_KEY$i.FONT_FAMILY,
    FONT_STYLE$2 = _enums$STYLE_KEY$i.FONT_STYLE,
    FONT_WEIGHT$2 = _enums$STYLE_KEY$i.FONT_WEIGHT,
    COLOR$3 = _enums$STYLE_KEY$i.COLOR,
    VISIBILITY$5 = _enums$STYLE_KEY$i.VISIBILITY,
    LETTER_SPACING = _enums$STYLE_KEY$i.LETTER_SPACING,
    OVERFLOW$3 = _enums$STYLE_KEY$i.OVERFLOW,
    WHITE_SPACE$1 = _enums$STYLE_KEY$i.WHITE_SPACE,
    TEXT_OVERFLOW$1 = _enums$STYLE_KEY$i.TEXT_OVERFLOW,
    WIDTH$6 = _enums$STYLE_KEY$i.WIDTH,
    TEXT_STROKE_COLOR$2 = _enums$STYLE_KEY$i.TEXT_STROKE_COLOR,
    TEXT_STROKE_WIDTH$1 = _enums$STYLE_KEY$i.TEXT_STROKE_WIDTH,
    _enums$NODE_KEY$8 = enums.NODE_KEY,
    NODE_CACHE$4 = _enums$NODE_KEY$8.NODE_CACHE,
    NODE_LIMIT_CACHE$2 = _enums$NODE_KEY$8.NODE_LIMIT_CACHE,
    NODE_DOM_PARENT$6 = _enums$NODE_KEY$8.NODE_DOM_PARENT,
    NODE_MATRIX_EVENT$4 = _enums$NODE_KEY$8.NODE_MATRIX_EVENT,
    NODE_OPACITY$2 = _enums$NODE_KEY$8.NODE_OPACITY,
    NODE_VIRTUAL_DOM$2 = _enums$NODE_KEY$8.NODE_VIRTUAL_DOM,
    _enums$UPDATE_KEY$5 = enums.UPDATE_KEY,
    UPDATE_NODE$5 = _enums$UPDATE_KEY$5.UPDATE_NODE,
    UPDATE_MEASURE$2 = _enums$UPDATE_KEY$5.UPDATE_MEASURE,
    UPDATE_FOCUS$4 = _enums$UPDATE_KEY$5.UPDATE_FOCUS,
    UPDATE_CONFIG$5 = _enums$UPDATE_KEY$5.UPDATE_CONFIG;
var ELLIPSIS = textCache.ELLIPSIS;
var AUTO$7 = o$4.AUTO,
    REM$c = o$4.REM,
    VW$c = o$4.VW,
    VH$c = o$4.VH;

var Text = /*#__PURE__*/function (_Node) {
  _inherits(Text, _Node);

  var _super = _createSuper(Text);

  function Text(content) {
    var _this;

    _classCallCheck(this, Text);

    _this = _super.call(this);
    _this.__content = util.isNil(content) ? '' : content.toString();
    _this.__textBoxes = [];
    _this.__charWidthList = [];
    _this.__charWidth = 0;
    _this.__textWidth = 0;
    return _this;
  }
  /**
   * 预先计算每个字的宽度，在每次布局渲染前做
   * @param renderMode
   * @param ctx
   * @private
   */


  _createClass(Text, [{
    key: "__computeMeasure",
    value: function __computeMeasure(renderMode, ctx) {
      var content = this.content,
          computedStyle = this.computedStyle,
          charWidthList = this.charWidthList; // 每次都要清空重新计算，计算会有缓存

      charWidthList.splice(0);
      var ffs = computedStyle[FONT_FAMILY$2].split(',');
      var ff = 'arial';

      for (var i = 0, len = ffs.length; i < len; i++) {
        if (inject.checkSupportFontFamily(ffs[i])) {
          ff = ffs[i];
          break;
        }
      }

      this.__ff = ff;
      var fs = computedStyle[FONT_SIZE$c];
      var fw = computedStyle[FONT_WEIGHT$2];
      var key = this.__key = computedStyle[FONT_SIZE$c] + ',' + ff + ',' + fw;
      var wait = textCache.data[key] = textCache.data[key] || {
        ff: ff,
        fs: fs,
        fw: fw,
        hash: {},
        s: ''
      };
      var cache = textCache.charWidth[key] = textCache.charWidth[key] || {};
      var sum = 0;
      var needMeasure = false; // text-overflow:ellipse需要，即便没有也要先测量，其基于最近非inline父节点的字体

      var bp = this.domParent;

      while (bp.currentStyle[DISPLAY$8] === 'inline') {
        bp = bp.domParent;
      }

      this.__bp = bp;
      var parentComputedStyle = bp.computedStyle;
      var pff = 'arial';

      for (var _i = 0, pffs = parentComputedStyle[FONT_FAMILY$2].split(','), _len = pffs.length; _i < _len; _i++) {
        if (inject.checkSupportFontFamily(pffs[_i])) {
          ff = ffs[_i];
          break;
        }
      }

      var pfs = parentComputedStyle[FONT_SIZE$c];
      var pfw = parentComputedStyle[FONT_WEIGHT$2];
      var pKey = this.__pKey = pfs + ',' + pff + ',' + pfw;
      var parentCache = textCache.charWidth[pKey] = textCache.charWidth[pKey] || {};

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (renderMode === mode.WEBGL) {
          ctx = inject.getCacheCanvas(16, 16, '__$$CHECK_SUPPORT_FONT_FAMILY$$__').ctx;
        }

        if (!parentCache.hasOwnProperty(ELLIPSIS)) {
          ctx.font = css.setFontStyle(parentComputedStyle);
          parentCache[ELLIPSIS] = ctx.measureText(ELLIPSIS).width;
        }

        ctx.font = css.setFontStyle(computedStyle);
      } else if (renderMode === mode.SVG) {
        if (!parentCache.hasOwnProperty(ELLIPSIS)) {
          parentCache[ELLIPSIS] = 0;

          var _wait = textCache.data[pKey] = textCache.data[pKey] || {
            ff: pff,
            fs: pfs,
            fw: pfw,
            hash: {},
            s: ''
          };

          _wait.s += ELLIPSIS;
          needMeasure = true;
        }
      } // 逐字测量，canvas可瞬间得到信息，svg先预存统一进行


      for (var _i2 = 0, length = content.length; _i2 < length; _i2++) {
        var _char = content.charAt(_i2);

        var mw = void 0;

        if (cache.hasOwnProperty(_char)) {
          mw = cache[_char];
          charWidthList.push(mw);
          sum += mw;
          this.__charWidth = Math.max(this.charWidth, mw);
        } else if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          mw = cache[_char] = ctx.measureText(_char).width;
          charWidthList.push(mw);
          sum += mw;
          this.__charWidth = Math.max(this.charWidth, mw);
        } else {
          if (!wait.hash.hasOwnProperty(_char)) {
            wait.s += _char;
          }

          wait.hash[_char] = true; // 先预存标识位-1，测量完后替换它

          charWidthList.push(-1);
          needMeasure = true;
        }
      }

      this.__textWidth = sum;

      if (needMeasure) {
        textCache.list.push(this);
      }
    }
  }, {
    key: "__measureCb",
    value: function __measureCb() {
      var content = this.content,
          charWidthList = this.charWidthList;
      var key = this.__key;
      var cache = textCache.charWidth[key];
      var sum = 0;

      for (var i = 0, len = charWidthList.length; i < len; i++) {
        if (charWidthList[i] < 0) {
          var mw = charWidthList[i] = cache[content.charAt(i)];
          sum += mw;
          this.__charWidth = Math.max(this.charWidth, mw);
        }
      }

      this.__textWidth = sum;
    }
    /**
     * text在virtual时和普通一样，无需特殊处理
     * endSpace由外界inline布局控制，末尾最后一行的空白mpb，包含递归情况，递归为多个嵌套末尾节点的空白mpb之和
     * 即便宽度不足，每行还是强制渲染一个字符，换行依据lx开始，因为x可能是从中间开始的，非inline则两个相等
     * 最后一个字符排版时要考虑末尾mpb，排不下的话回退删掉这个字符，如果最后一个字符另起开头，排不下也强制排，每行至少1个字符
     * 在textOverflow时很特殊，多个inline同行，回退可能到前一个inline节点，这个通过x和lx判断是否行首，决定至少1个字符规则
     * @param data
     * @private
     */

  }, {
    key: "__layout",
    value: function __layout(data) {
      var __cache = this.__config[NODE_CACHE$4];

      if (__cache) {
        __cache.release();
      }

      var x = data.x,
          y = data.y,
          w = data.w,
          _data$lx = data.lx,
          lx = _data$lx === void 0 ? x : _data$lx,
          lineBoxManager = data.lineBoxManager,
          _data$endSpace = data.endSpace,
          endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
          _data$lineClamp = data.lineClamp,
          lineClamp = _data$lineClamp === void 0 ? 0 : _data$lineClamp,
          _data$lineClampCount = data.lineClampCount,
          lineClampCount = _data$lineClampCount === void 0 ? 0 : _data$lineClampCount;
      this.__x = this.__sx1 = x;
      this.__y = this.__sy1 = y;
      var isDestroyed = this.isDestroyed,
          content = this.content,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle,
          textBoxes = this.textBoxes,
          charWidthList = this.charWidthList,
          root = this.root,
          __ff = this.__ff,
          __key = this.__key;
      textBoxes.splice(0);
      var __config = this.__config;
      __config[NODE_LIMIT_CACHE$2] = false; // 空内容w/h都为0可以提前跳出

      if (isDestroyed || currentStyle[DISPLAY$8] === 'none' || !content) {
        return lineClampCount;
      }

      this.__ox = this.__oy = 0; // 顺序尝试分割字符串为TextBox，形成多行，begin为每行起始索引，i是当前字符索引

      var begin = 0;
      var i = 0;
      var beginSpace = x - lx; // x>=lx，当第一行非起始处时前面被prev节点占据，这个差值可认为是count宽度

      var count = beginSpace;
      var length = content.length;
      var maxW = 0;
      var lineHeight = computedStyle[LINE_HEIGHT$3],
          letterSpacing = computedStyle[LETTER_SPACING],
          whiteSpace = computedStyle[WHITE_SPACE$1],
          fontSize = computedStyle[FONT_SIZE$c],
          fontWeight = computedStyle[FONT_WEIGHT$2]; // 特殊字体中特殊字符连续时需减少一定的padding量

      var padding = o$3.info[__ff].padding;
      var needReduce = !!padding;
      var lastChar;
      var ew = textCache.charWidth[this.__pKey][ELLIPSIS];
      var lineCount = 0; // 不换行特殊对待，同时考虑overflow和textOverflow

      if (whiteSpace === 'nowrap') {
        var isTextOverflow; // block的overflow:hidden和textOverflow:clip/ellipsis才生效，inline要看最近非inline父元素

        var bp = this.__bp;
        var _bp$currentStyle = bp.currentStyle,
            display = _bp$currentStyle[DISPLAY$8],
            overflow = _bp$currentStyle[OVERFLOW$3],
            width = _bp$currentStyle[WIDTH$6],
            textOverflow = _bp$currentStyle[TEXT_OVERFLOW$1]; // 只要是overflow隐藏，不管textOverflow如何（默认是clip等同于overflow:hidden的功能）都截取

        if (overflow === 'hidden') {
          while (i < length) {
            count += charWidthList[i] + letterSpacing;

            if (count > w) {
              // block/flex无需宽度，inline-block需要设置宽度才生效
              if (display === 'block' || display === 'flex') {
                isTextOverflow = true;
              } else if (width[1] !== AUTO$7) {
                isTextOverflow = true;
              }

              break;
            }

            i++;
          }
        } else {
          while (i < length) {
            count += charWidthList[i++] + letterSpacing;
          }
        } // ellipsis生效情况，本节点开始向前回退查找，尝试放下一部分字符


        if (isTextOverflow && textOverflow === 'ellipsis') {
          var _this$__lineBack = this.__lineBack(count, w, beginSpace, endSpace, ew, letterSpacing, begin, i, length, lineCount, lineHeight, lx, x, y, maxW, textBoxes, content, charWidthList, lineBoxManager);

          var _this$__lineBack2 = _slicedToArray(_this$__lineBack, 2);

          y = _this$__lineBack2[0];
          maxW = _this$__lineBack2[1];
        } // 默认clip跟随overflow:hidden，无需感知
        else {
          var textBox = new TextBox(this, textBoxes.length, x, y, count - beginSpace, lineHeight, content, charWidthList);
          textBoxes.push(textBox);
          lineBoxManager.addItem(textBox);
          maxW = count - beginSpace;
          y += lineHeight;
        }
      } // 普通换行，注意x和lx的区别，可能相同（block起始处）可能不同（非起始处），第1行从x开始，第2行及以后都从lx开始
      // 然后第一次换行还有特殊之处，可能同一行前半部行高很大，此时y增加并非自身的lineHeight，而是整体LineBox的
      else {
        while (i < length) {
          var cw = charWidthList[i] + letterSpacing;
          count += cw; // 连续字符减少padding，除了连续还需判断char是否在padding的hash中

          if (needReduce) {
            var _char2 = content[i];

            if (_char2 === lastChar && padding.hasOwnProperty(_char2) && padding[_char2]) {
              var hasCache = void 0,
                  p = textCache.padding[__key] = textCache.padding[__key] || {};

              if (textCache.padding.hasOwnProperty(__key)) {
                if (p.hasOwnProperty(_char2)) {
                  hasCache = true;
                  count -= p[_char2];
                }
              }

              if (!hasCache) {
                var n = 0;

                if (root.renderMode === mode.CANVAS) {
                  root.ctx.font = css.setFontStyle(computedStyle);
                  var w1 = root.ctx.measureText(_char2).width;
                  var w2 = root.ctx.measureText(_char2 + _char2).width;
                  n = w1 * 2 - w2;
                  n *= padding[_char2];
                } else if (root.renderMode === mode.SVG) {
                  n = inject.measureTextSync(__key, __ff, fontSize, fontWeight, _char2);
                  n *= padding[_char2];
                }

                count -= n;
                p[_char2] = n;
              }
            }

            lastChar = _char2;
          } // 忽略零宽字符


          if (cw === 0) {
            i++;
            continue;
          } // 换行都要判断i不是0的时候，第1个字符强制不换行


          if (count === w) {
            // 多行文本截断，这里肯定需要回退
            if (lineClamp && lineCount + lineClampCount >= lineClamp - 1) {
              var _this$__lineBack3 = this.__lineBack(count, w, beginSpace, endSpace, ew, letterSpacing, begin, i, length, lineCount, lineHeight, lx, x, y, maxW, textBoxes, content, charWidthList, lineBoxManager);

              var _this$__lineBack4 = _slicedToArray(_this$__lineBack3, 2);

              y = _this$__lineBack4[0];
              maxW = _this$__lineBack4[1];
              lineCount++;
              break;
            }

            var _textBox = void 0; // 特殊情况，恰好最后一行最后一个排满，此时查看末尾mpb，要防止i为0的情况首个字符特殊不回退，无需看开头mpb


            if (i === length - 1 && count > w - endSpace && i) {
              count -= charWidthList[i--];
            }

            i++;

            if (!lineCount) {
              maxW = count - beginSpace;
              _textBox = new TextBox(this, textBoxes.length, x, y, maxW, lineHeight, content.slice(begin, i), charWidthList.slice(begin, i));
            } else {
              _textBox = new TextBox(this, textBoxes.length, lx, y, count, lineHeight, content.slice(begin, i), charWidthList.slice(begin, i));
              maxW = Math.max(maxW, count);
            } // 必须先添加再设置y，当有diff的lineHeight时，第一个换行不影响，再换行时第2个换行即第3行会被第1行影响


            textBoxes.push(_textBox);
            lineBoxManager.addItem(_textBox, true);
            y += Math.max(lineHeight, lineBoxManager.lineHeight);
            begin = i;
            count = 0;
            lineCount++;
            lastChar = null; // 换行后连续字符reduce不生效重新计数
          } // 奇怪的精度问题，暂时不用相等判断，而是为原本w宽度加一点点冗余1e-10
          else if (count > w + 1e-10) {
            // 多行文本截断，这里肯定需要回退
            if (lineClamp && lineCount + lineClampCount >= lineClamp - 1) {
              var _this$__lineBack5 = this.__lineBack(count, w, beginSpace, endSpace, ew, letterSpacing, begin, i, length, lineCount, lineHeight, lx, x, y, maxW, textBoxes, content, charWidthList, lineBoxManager);

              var _this$__lineBack6 = _slicedToArray(_this$__lineBack5, 2);

              y = _this$__lineBack6[0];
              maxW = _this$__lineBack6[1];
              lineCount++;
              break;
            } // 普通非多行文本阶段逻辑


            var _width = void 0; // 宽度不足时无法跳出循环，至少也要塞个字符形成一行，无需判断第1行，因为是否放得下逻辑在dom中做过了，
            // 如果第1行放不下，一定会另起一行，此时作为开头再放不下才会进这里，这个if只有0或1个字符的情况


            if (i <= begin) {
              _width = count;
            } // 超过2个字符回退1个
            else {
              _width = count - charWidthList[i--];
            }

            i++; // 根据是否第一行分开处理行首空白

            var _textBox2 = void 0;

            if (!lineCount) {
              maxW = _width - beginSpace;
              _textBox2 = new TextBox(this, textBoxes.length, x, y, maxW, lineHeight, content.slice(begin, i), charWidthList.slice(begin, i));
            } else {
              _textBox2 = new TextBox(this, textBoxes.length, lx, y, _width, lineHeight, content.slice(begin, i), charWidthList.slice(begin, i));
              maxW = Math.max(maxW, _width);
            } // 必须先添加再设置y，同上


            textBoxes.push(_textBox2);
            lineBoxManager.addItem(_textBox2, true);
            y += Math.max(lineHeight, lineBoxManager.lineHeight);
            begin = i;
            count = 0;
            lineCount++;
            lastChar = null;
          } else {
            i++;
          }
        } // 换行后Text的x重设为lx


        if (lineCount) {
          this.__x = this.__sx1 = lx;
        } // 最后一行，只有一行未满时也进这里，需查看末尾mpb，排不下回退一个字符
        // 声明了lineClamp时特殊考虑，这里一定是最后一行，要对比行数不能超过，超过忽略掉这些文本


        if (begin < length && (!lineClamp || lineCount + lineClampCount < lineClamp)) {
          var _textBox3;

          if (!lineCount) {
            var needBack; // 防止开头第一个begin=0时回退，这在inline有padding且是第一个child时会发生

            if (begin && count > w - endSpace) {
              needBack = true;
              count -= charWidthList[length - 1];
            }

            maxW = count - beginSpace;
            _textBox3 = new TextBox(this, textBoxes.length, x, y, maxW, lineHeight, content.slice(begin, needBack ? length - 1 : length), charWidthList.slice(begin, needBack ? length - 1 : length));
            textBoxes.push(_textBox3);
            lineBoxManager.addItem(_textBox3);
            y += Math.max(lineHeight, lineBoxManager.lineHeight);

            if (needBack) {
              var _width2 = charWidthList[length - 1];
              _textBox3 = new TextBox(this, textBoxes.length, lx, y, _width2, lineHeight, content.slice(length - 1), charWidthList.slice(length - 1));
              maxW = Math.max(maxW, _width2);
              textBoxes.push(_textBox3);
              lineBoxManager.setNewLine();
              lineBoxManager.addItem(_textBox3);
              y += lineHeight;
              lineCount++;
            }
          } else {
            var _needBack; // 防止begin在结尾时回退，必须要有个字符，这在最后一行1个字符排不下时会出现


            if (count > w - endSpace && begin < length - 1) {
              _needBack = true;
              count -= charWidthList[length - 1];
            }

            _textBox3 = new TextBox(this, textBoxes.length, lx, y, count, lineHeight, content.slice(begin, _needBack ? length - 1 : length), charWidthList.slice(begin, _needBack ? length - 1 : length));
            maxW = Math.max(maxW, count);
            textBoxes.push(_textBox3);
            lineBoxManager.addItem(_textBox3);
            y += Math.max(lineHeight, lineBoxManager.lineHeight);

            if (_needBack) {
              var _width3 = charWidthList[length - 1];
              _textBox3 = new TextBox(this, textBoxes.length, lx, y, _width3, lineHeight, content.slice(length - 1), charWidthList.slice(length - 1));
              maxW = Math.max(maxW, _width3);
              textBoxes.push(_textBox3);
              lineBoxManager.setNewLine();
              lineBoxManager.addItem(_textBox3);
              y += lineHeight;
              lineCount++;
            }
          }
        }
      }

      this.__width = maxW;
      this.__height = y - data.y;
      this.__baseLine = css.getBaseLine(computedStyle);
      return lineCount;
    } // 末尾行因ellipsis的缘故向前回退字符生成textBox，可能会因不满足宽度导致无法生成，此时向前继续回退TextBox

  }, {
    key: "__lineBack",
    value: function __lineBack(count, w, beginSpace, endSpace, ew, letterSpacing, begin, i, length, lineCount, lineHeight, lx, x, y, maxW, textBoxes, content, charWidthList, lineBoxManager) {
      for (; i >= begin; i--) {
        count -= charWidthList[i] + letterSpacing;

        if (count + ew + endSpace <= w) {
          // 至少1个字符不用回退，到0也没找到需要回退
          if (i) {
            maxW = count - (lineCount ? 0 : beginSpace);
            var textBox = new TextBox(this, textBoxes.length, lineCount ? lx : x, y, maxW, lineHeight, content.slice(begin, i), charWidthList.slice(begin, i));
            textBoxes.push(textBox);
            lineBoxManager.addItem(textBox, true);
            y += Math.max(lineHeight, lineBoxManager.lineHeight);
            this.__ellipsis = true;
            break;
          }
        }
      } // 最后也没找到，看是否要查找前一个inline节点，还是本身是行首兜底首字母


      if (i < 0) {
        var lineBox = lineBoxManager.lineBox; // lineBox为空是行首，至少放1个字符

        if (!lineBox.size) {
          maxW = count - (lineCount ? 0 : beginSpace);

          var _textBox4 = new TextBox(this, textBoxes.length, lineCount ? lx : x, y, maxW, lineHeight, content.charAt(begin), charWidthList.slice(begin, begin + 1));

          textBoxes.push(_textBox4);
          lineBoxManager.addItem(_textBox4, true);
          y += Math.max(lineHeight, lineBoxManager.lineHeight);
          this.__ellipsis = true;
        } // 向前查找inline节点，可能会有前面inline嵌套，因此直接用lineBox，不会出现inlineBlock，
        // 这里和css不同，ib强制超限换行不会同行
        else {
          var list = lineBox.list;

          outer: for (var j = list.length - 1; j >= 0; j--) {
            var tb = list[j];
            var _content = tb.content,
                wList = tb.wList,
                width = tb.width; // 整体减去可以说明可能在这个tb中，只要最后发现不是空文本节点就行，否则继续；第0个强制进入保证1字符

            if (count - width + ew <= w || !j) {
              // 找到可以跳出outer循环，找不到继续，注意第0个且1个字符判断
              for (var k = wList.length - 1; k >= 0; k--) {
                if (!k && !j || count + ew <= w) {
                  tb.__content = _content;
                  tb.__width = width;
                  tb.parent.__ellipsis = true;
                  break outer;
                } else {
                  var w2 = wList[k];
                  tb.__endY -= w2;
                  width -= w2;
                  _content = _content.slice(0, k);
                  count -= w2;
                  wList.pop();
                }
              }
            } // 不够则看前一个tb并且删掉这个
            else {
              count -= width;
            }

            list.pop();
            tb.parent.textBoxes.pop();
          }
        }
      }

      return [y, maxW];
    }
  }, {
    key: "__offsetX",
    value: function __offsetX(diff, isLayout) {
      _get(_getPrototypeOf(Text.prototype), "__offsetX", this).call(this, diff, isLayout);

      if (isLayout) {
        this.textBoxes.forEach(function (item) {
          item.__offsetX(diff);
        });
      }

      this.__sx1 += diff;
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff, isLayout) {
      _get(_getPrototypeOf(Text.prototype), "__offsetY", this).call(this, diff, isLayout);

      if (isLayout) {
        this.textBoxes.forEach(function (item) {
          item.__offsetY(diff);
        });
      }

      this.__sy1 += diff;
    }
  }, {
    key: "__tryLayInline",
    value: function __tryLayInline(w) {
      return w - this.charWidthList[0];
    }
  }, {
    key: "__inlineSize",
    value: function __inlineSize() {
      var minX, maxX;
      this.textBoxes.forEach(function (item, i) {
        if (i) {
          minX = Math.min(minX, item.x);
          maxX = Math.max(maxX, item.x + item.width);
        } else {
          minX = item.x;
          maxX = item.x + item.width;
        }
      });
      this.__x = minX;
      this.__sx = this.__sx1 = minX + this.ox;
      this.__width = maxX - minX;
    }
  }, {
    key: "__calMaxAndMinWidth",
    value: function __calMaxAndMinWidth() {
      var n = 0;
      this.charWidthList.forEach(function (item) {
        n = Math.max(n, item);
      });
      return {
        max: this.textWidth,
        min: n
      };
    }
  }, {
    key: "__calAbsWidth",
    value: function __calAbsWidth(x, y, w) {
      this.__layout({
        x: x,
        y: y,
        w: w
      }, true);

      return this.width;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var dx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var dy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var isDestroyed = this.isDestroyed,
          computedStyle = this.computedStyle,
          textBoxes = this.textBoxes,
          cacheStyle = this.cacheStyle,
          __ellipsis = this.__ellipsis,
          __bp = this.__bp,
          __config = this.__config;

      if (renderMode === mode.SVG) {
        __config[NODE_VIRTUAL_DOM$2] = this.__virtualDom = {
          type: 'text',
          children: []
        };
      }

      if (isDestroyed || computedStyle[DISPLAY$8] === 'none' || computedStyle[VISIBILITY$5] === 'hidden' || !textBoxes.length) {
        return;
      }

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        // webgl借用离屏canvas绘制文本，cache标识为true是普通绘制，否则是超限降级情况
        if (renderMode === mode.WEBGL) {
          if (cache) {
            var sx = this.sx,
                sy = this.sy,
                bbox = this.bbox;
            var __cache = __config[NODE_CACHE$4];

            if (__cache) {
              __cache.reset(bbox, sx, sy);
            } else {
              __cache = Cache.getInstance(bbox, sx, sy);
            }

            if (__cache && __cache.enabled) {
              __config[NODE_CACHE$4] = __cache;
              __cache.__available = true;
              ctx = __cache.ctx;
              dx += __cache.dx;
              dy += __cache.dy;
              __config[NODE_LIMIT_CACHE$2] = false;
            } else {
              __config[NODE_LIMIT_CACHE$2] = true;
              return;
            }
          } else {
            var _root = this.root;
            var c = inject.getCacheCanvas(_root.width, _root.height, '__$$OVERSIZE$$__');
            ctx = c.ctx;
            var _config$NODE_DOM_PAR = __config[NODE_DOM_PARENT$6].__config,
                m = _config$NODE_DOM_PAR[NODE_MATRIX_EVENT$4],
                opacity = _config$NODE_DOM_PAR[NODE_OPACITY$2];
            ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            ctx.globalAlpha = opacity;
          }
        }

        var _font = css.setFontStyle(computedStyle);

        if (ctx.font !== _font) {
          ctx.font = _font;
        }

        var color = cacheStyle[COLOR$3];

        if (ctx.fillStyle !== color) {
          ctx.fillStyle = color;
        }

        var strokeWidth = computedStyle[TEXT_STROKE_WIDTH$1];

        if (ctx.lineWidth !== strokeWidth) {
          ctx.lineWidth = strokeWidth;
        }

        var strokeColor = cacheStyle[TEXT_STROKE_COLOR$2];

        if (ctx.strokeStyle !== strokeColor) {
          ctx.strokeStyle = strokeColor;
        }
      } // 可能为空，整个是个ellipsis


      textBoxes.forEach(function (item) {
        item.render(renderMode, ctx, computedStyle, cacheStyle, dx, dy);
      });

      if (renderMode === mode.SVG) {
        this.virtualDom.children = textBoxes.map(function (textBox) {
          return textBox.virtualDom;
        });
      } // textOverflow的省略号font使用最近非inline的父节点


      if (__ellipsis) {
        var last = textBoxes[textBoxes.length - 1];
        var endX = last.endX,
            endY = last.endY;
        var _computedStyle = __bp.computedStyle;

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          var _font2 = css.setFontStyle(_computedStyle);

          if (ctx.font !== _font2) {
            ctx.font = _font2;
          }

          var _color = __bp.__cacheStyle[COLOR$3];

          if (ctx.fillStyle !== _color) {
            ctx.fillStyle = _color;
          }

          ctx.fillText(ELLIPSIS, endX, endY);
        } else if (renderMode === mode.SVG) {
          var props = [['x', endX], ['y', endY], ['fill', __bp.__cacheStyle[COLOR$3]], ['font-family', _computedStyle[FONT_FAMILY$2]], ['font-weight', _computedStyle[FONT_WEIGHT$2]], ['font-style', _computedStyle[FONT_STYLE$2]], ['font-size', _computedStyle[FONT_SIZE$c] + 'px']];
          this.virtualDom.children.push({
            type: 'item',
            tagName: 'text',
            props: props,
            content: ELLIPSIS
          });
        }
      }
    }
  }, {
    key: "__deepScan",
    value: function __deepScan(cb) {
      cb(this);
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      if (this.isDestroyed) {
        return;
      }

      _get(_getPrototypeOf(Text.prototype), "__destroy", this).call(this);

      var __cache = this.__config[NODE_CACHE$4];

      if (__cache) {
        __cache.release();
      }
    }
  }, {
    key: "getComputedStyle",
    value: function getComputedStyle(key) {
      return this.domParent.getComputedStyle(key);
    }
  }, {
    key: "updateContent",
    value: function updateContent(s, cb) {
      var self = this;

      if (s === self.__content) {
        if (util.isFunction(cb)) {
          cb(-1);
        }

        return;
      }

      root.delRefreshTask(self.__task);
      root.addRefreshTask(self.__task = {
        __before: function __before() {
          self.__content = s;
          var res = {};
          var vd = self.domParent;
          res[UPDATE_NODE$5] = vd;
          res[UPDATE_MEASURE$2] = true;
          res[UPDATE_FOCUS$4] = o$1.REFLOW;
          res[UPDATE_CONFIG$5] = vd.__config;
          var root = vd.root;

          root.__addUpdate(vd, vd.__config, root, root.__config, res);
        },
        __after: function __after(diff) {
          if (util.isFunction(cb)) {
            cb(diff);
          }
        }
      });
    }
  }, {
    key: "content",
    get: function get() {
      return this.__content;
    },
    set: function set(v) {
      this.__content = v;
    }
  }, {
    key: "textBoxes",
    get: function get() {
      return this.__textBoxes;
    }
  }, {
    key: "charWidthList",
    get: function get() {
      return this.__charWidthList;
    }
  }, {
    key: "charWidth",
    get: function get() {
      return this.__charWidth;
    }
  }, {
    key: "firstCharWidth",
    get: function get() {
      return this.charWidthList[0] || 0;
    }
  }, {
    key: "textWidth",
    get: function get() {
      return this.__textWidth;
    }
  }, {
    key: "baseLine",
    get: function get() {
      return this.__baseLine;
    }
  }, {
    key: "root",
    get: function get() {
      return (this.domParent || {}).root;
    }
  }, {
    key: "currentStyle",
    get: function get() {
      return (this.domParent || {}).currentStyle;
    }
  }, {
    key: "style",
    get: function get() {
      return this.__style;
    }
  }, {
    key: "computedStyle",
    get: function get() {
      return (this.domParent || {}).computedStyle;
    }
  }, {
    key: "cacheStyle",
    get: function get() {
      return (this.domParent || {}).__cacheStyle;
    }
  }, {
    key: "bbox",
    get: function get() {
      var sx = this.sx,
          sy = this.sy,
          width = this.width,
          height = this.height,
          root = this.root,
          _this$currentStyle = this.currentStyle;
      _this$currentStyle = _this$currentStyle === void 0 ? {} : _this$currentStyle;
      var _this$currentStyle$TE = _this$currentStyle[TEXT_STROKE_WIDTH$1],
          textStrokeWidth = _this$currentStyle$TE === void 0 ? [0] : _this$currentStyle$TE;
      var half = 0;

      if (textStrokeWidth[1] === REM$c) {
        half = Math.max(textStrokeWidth[0] * root.computedStyle[FONT_SIZE$c] * 0.5, half);
      } else if (textStrokeWidth[1] === VW$c) {
        half = Math.max(textStrokeWidth[0] * root.width * 0.01 * 0.5, half);
      } else if (textStrokeWidth[1] === VH$c) {
        half = Math.max(textStrokeWidth[0] * root.height * 0.01 * 0.5, half);
      } else {
        half = Math.max(textStrokeWidth[0] * 0.5, half);
      }

      half += 1;
      return [sx - half, sy - half, sx + width + half, sy + height + half];
    }
  }, {
    key: "isShadowRoot",
    get: function get() {
      return !this.parent && this.host && this.host !== this.root;
    }
  }, {
    key: "matrix",
    get: function get() {
      return this.domParent.matrix;
    }
  }, {
    key: "matrixEvent",
    get: function get() {
      return this.domParent.matrixEvent;
    }
  }]);

  return Text;
}(Node);

Text.prototype.__renderByMask = Text.prototype.render;

var TYPE_VD$3 = $$type.TYPE_VD,
    TYPE_GM$3 = $$type.TYPE_GM,
    TYPE_CP$3 = $$type.TYPE_CP;
/**
 * 2. 打平children中的数组，变成一维
 * 3. 合并相连的Text节点，即string内容
 */

function flattenJson(parent) {
  if (Array.isArray(parent)) {
    return parent.map(function (item) {
      return flattenJson(item);
    });
  } else if (!parent || [TYPE_VD$3, TYPE_GM$3, TYPE_CP$3].indexOf(parent.$$type) === -1 || !Array.isArray(parent.children)) {
    return parent;
  }

  var list = [];
  traverseJson(list, parent.children, {
    lastText: null
  });
  parent.children = list;
  return parent;
}

function traverseJson(list, children, options) {
  if (Array.isArray(children)) {
    children.forEach(function (item) {
      traverseJson(list, item, options);
    });
  } else if (children && (children.$$type === TYPE_VD$3 || children.$$type === TYPE_GM$3)) {
    if (['canvas', 'svg', 'webgl'].indexOf(children.tagName) > -1) {
      throw new Error('Can not nest canvas/svg/webgl');
    }

    if (children.$$type === TYPE_VD$3) {
      flattenJson(children);
    }

    list.push(children);
    options.lastText = null;
  } else if (children && children.$$type === TYPE_CP$3) {
    list.push(children); // 强制component即便返回text也形成一个独立的节点，合并在layout布局中做

    options.lastText = null;
  } // 排除掉空的文本，连续的text合并
  else if (!util.isNil(children) && children !== '') {
    if (options.lastText !== null) {
      list[list.length - 1] = options.lastText += children;
    } else {
      list.push(children);
    }
  }
}

var _enums$NODE_KEY$7 = enums.NODE_KEY,
    NODE_DOM_PARENT$5 = _enums$NODE_KEY$7.NODE_DOM_PARENT,
    NODE_STYLE$5 = _enums$NODE_KEY$7.NODE_STYLE,
    NODE_CURRENT_STYLE$6 = _enums$NODE_KEY$7.NODE_CURRENT_STYLE,
    NODE_COMPUTED_STYLE$4 = _enums$NODE_KEY$7.NODE_COMPUTED_STYLE,
    NODE_MATRIX$3 = _enums$NODE_KEY$7.NODE_MATRIX,
    NODE_MATRIX_EVENT$3 = _enums$NODE_KEY$7.NODE_MATRIX_EVENT;
var TYPE_VD$2 = $$type.TYPE_VD,
    TYPE_GM$2 = $$type.TYPE_GM,
    TYPE_CP$2 = $$type.TYPE_CP;
var Xom$1, Dom$1, Img$1, Geom$1, Component$1;

function initRoot(cd, root) {
  var c = flattenJson({
    tagName: root.tagName,
    props: {},
    children: cd,
    $$type: TYPE_VD$2
  });
  root.__json = c;
  root.__host = root;
  var children = build(c.children, root, root);
  return relation(root, children);
}

function initDom(json, root, host, parent) {
  var vd = build(json, root, host);
  return relation(parent, vd);
}

function initCp(json, root, host) {
  if (util.isObject(json)) {
    // cp的flatten在__init中自己做
    return build(json, root, host);
  } // text的relation会由上层如Root设置
  else {
    return new Text(json);
  }
}

function initCp2(json, root, host, parent) {
  var vd = new json.klass(json.props);
  vd.__tagName = json.tagName || vd.__tagName;
  vd.__root = root;
  vd.__host = host;
  vd.__json = json;

  vd.__init();

  return relation(parent, vd);
}
/**
 * 将初始json文件生成virtualDom
 * @param json
 * @param root
 * @param host
 * @param hasP 出现过p标签
 * @returns vd
 */


function build(json, root, host, hasP) {
  if (Array.isArray(json)) {
    return json.map(function (item) {
      return build(item, root, host, hasP);
    });
  }

  var vd;

  if (util.isObject(json) && json.$$type) {
    var tagName = json.tagName,
        props = json.props,
        children = json.children,
        klass = json.klass,
        _$$type = json.$$type,
        __inheritAnimate = json.__inheritAnimate,
        __animateRecords = json.__animateRecords; // 更新过程中无变化的cp直接使用原来生成的

    if (_$$type === TYPE_CP$2 && json.__placeholder) {
      return json.__placeholder;
    }

    if (_$$type === TYPE_VD$2) {
      if (tagName === 'img') {
        vd = new Img$1(tagName, props);

        if (Array.isArray(children) && children.length) {
          throw new Error('Img can not contain children');
        }
      } else {
        vd = new Dom$1(tagName, props);
      } // 检查p不能包含div


      if (tagName === 'p') {
        hasP = true;
      } else if (tagName === 'div' && hasP) {
        throw new Error('Markup p can not contain div');
      }

      if (Array.isArray(children)) {
        children = relation(vd, build(children, root, host, hasP));
      } else {
        children = [];
      }

      vd.__children = children;
    } else if (_$$type === TYPE_GM$2) {
      var _klass = Geom$1.getRegister(tagName);

      vd = new _klass(tagName, props);
    } else if (_$$type === TYPE_CP$2) {
      vd = new klass(props);
      vd.__tagName = tagName || vd.__tagName;
    } else {
      return new Text(json);
    } // 根parse需要用到真正的vd引用，然后vd也要引用json，用以做domApi


    json.vd = vd;
    vd.__json = json; // 递归parse中的动画记录需特殊处理，将target改为真正的vd引用

    if (__animateRecords) {
      vd.__animateRecords = __animateRecords;

      __animateRecords.list.forEach(function (item) {
        item.target = item.target.vd;
      });

      delete json.__animateRecords;
    } // 更新过程中key相同或者普通相同的vd继承动画


    if (__inheritAnimate) {
      util.extendAnimate(__inheritAnimate, vd);
      delete json.__inheritAnimate;
    }

    vd.__root = root;
    vd.__host = host;

    if (_$$type === TYPE_CP$2) {
      vd.__init();
    }

    var ref = props.ref;

    if (util.isString(ref) && ref || util.isNumber(ref)) {
      host.ref[ref] = vd;
    } else if (util.isFunction(ref)) {
      ref(vd);
    }

    return vd;
  }

  return new Text(json);
}
/**
 * 设置关系，父子和兄弟
 * @param parent
 * @param children
 * @param options
 * @returns {Xom|Text|Component}
 */


function relation(parent, children) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (Array.isArray(children)) {
    children.forEach(function (item) {
      relation(parent, item, options);
    });
  } else if (children instanceof Xom$1 || children instanceof Component$1 || children instanceof Text) {
    children.__parent = parent;
    children.__domParent = parent; // 极为恶心，为了v8的性能优化，text复用parent的__config部分，但domParent重设

    if (children instanceof Text) {
      [NODE_STYLE$5, NODE_CURRENT_STYLE$6, NODE_COMPUTED_STYLE$4, NODE_MATRIX$3, NODE_MATRIX_EVENT$3].forEach(function (k) {
        children.__config[k] = parent.__config[k];
      });
    }

    if (children.__config) {
      children.__config[NODE_DOM_PARENT$5] = parent;
    }

    if (options.prev) {
      options.prev.__next = children;
      children.__prev = options.prev;
    }

    options.prev = children; // 文字视作为父节点的直接文字子节点

    if (children instanceof Component$1) {
      var sr = children.shadowRoot;

      if (sr instanceof Text) {
        sr.__parent = parent;
        [NODE_STYLE$5, NODE_CURRENT_STYLE$6, NODE_COMPUTED_STYLE$4, NODE_MATRIX$3, NODE_MATRIX_EVENT$3].forEach(function (k) {
          children.__config[k] = parent.__config[k];
        });
      }

      sr.__domParent = parent;

      if (sr.__config) {
        sr.__config[NODE_DOM_PARENT$5] = parent;
      }
    }
  }

  return children;
}

var builder = {
  ref: function ref(o) {
    Xom$1 = o.Xom;
    Dom$1 = o.Dom;
    Img$1 = o.Img;
    Geom$1 = o.Geom;
    Component$1 = o.Component;
  },
  initRoot: initRoot,
  initDom: initDom,
  initCp: initCp,
  initCp2: initCp2,
  relation: relation
};

var isFunction$7 = util.isFunction;

var Event = /*#__PURE__*/function () {
  function Event() {
    _classCallCheck(this, Event);

    this.__eHash = {};
  }

  _createClass(Event, [{
    key: "on",
    value: function on(id, handle) {
      if (!isFunction$7(handle)) {
        return;
      }

      var self = this;

      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          self.on(id[i], handle);
        }
      } else {
        if (!self.__eHash.hasOwnProperty(id)) {
          self.__eHash[id] = [];
        } // 遍历防止此handle被侦听过了


        for (var _i = 0, item = self.__eHash[id], _len = item.length; _i < _len; _i++) {
          if (item[_i] === handle) {
            return self;
          }
        }

        self.__eHash[id].push(handle);
      }

      return self;
    }
  }, {
    key: "once",
    value: function once(id, handle) {
      if (!isFunction$7(handle)) {
        return;
      }

      var self = this; // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比

      function cb() {
        for (var _len2 = arguments.length, data = new Array(_len2), _key = 0; _key < _len2; _key++) {
          data[_key] = arguments[_key];
        }

        handle.apply(self, data);
        self.off(id, cb);
      }

      cb.__karasEventCb = handle;

      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          self.once(id[i], handle);
        }
      } else if (handle) {
        self.on(id, cb);
      }

      return this;
    }
  }, {
    key: "off",
    value: function off(id, handle) {
      var self = this;

      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          self.off(id[i], handle);
        }
      } else if (self.__eHash.hasOwnProperty(id)) {
        if (handle) {
          for (var _i2 = 0, item = self.__eHash[id], _len3 = item.length; _i2 < _len3; _i2++) {
            // 需考虑once包裹的引用对比
            if (item[_i2] === handle || item[_i2].__karasEventCb === handle) {
              item.splice(_i2, 1);
              break;
            }
          }
        } // 未定义为全部清除
        else {
          delete self.__eHash[id];
        }
      }

      return this;
    }
  }, {
    key: "emit",
    value: function emit(id) {
      var self = this;

      for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key2 = 1; _key2 < _len4; _key2++) {
        data[_key2 - 1] = arguments[_key2];
      }

      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          self.emit(id[i], data);
        }
      } else {
        if (self.__eHash.hasOwnProperty(id)) {
          var list = self.__eHash[id];

          if (list.length) {
            list = list.slice();

            for (var _i3 = 0, _len5 = list.length; _i3 < _len5; _i3++) {
              var cb = list[_i3];

              if (isFunction$7(cb)) {
                cb.apply(self, data);
              }
            }
          }
        }
      }

      return this;
    }
  }], [{
    key: "mix",
    value: function mix() {
      for (var i = arguments.length - 1; i >= 0; i--) {
        var o = i < 0 || arguments.length <= i ? undefined : arguments[i];
        var event = new Event();
        o.__eHash = {};
        var fns = ['on', 'once', 'off', 'emit'];

        for (var j = fns.length - 1; j >= 0; j--) {
          var fn = fns[j];
          o[fn] = event[fn];
        }
      }
    }
  }]);

  return Event;
}();

_defineProperty(Event, "REFRESH", 'refresh');

_defineProperty(Event, "PAUSE", 'pause');

_defineProperty(Event, "PLAY", 'play');

_defineProperty(Event, "FRAME", 'frame');

_defineProperty(Event, "FINISH", 'finish');

_defineProperty(Event, "CANCEL", 'cancel');

_defineProperty(Event, "BEGIN", 'begin');

_defineProperty(Event, "END", 'end');

var isNil$b = util.isNil,
    isFunction$6 = util.isFunction,
    clone$3 = util.clone,
    extend$1 = util.extend;
var REGISTER$1 = {};
/**
 * 向上设置cp类型叶子节点，表明从root到本节点这条链路有更新，使得无链路更新的节约递归
 * 在check时树递归会用到，判断是否需要查找cp更新
 * @param cp
 */

function setUpdateFlag(cp) {
  // 去重
  if (cp.__hasUpdate) {
    return;
  }

  cp.__hasUpdate = true;
  var host = cp.host;

  if (host) {
    setUpdateFlag(host);
  }
}

var Component = /*#__PURE__*/function (_Event) {
  _inherits(Component, _Event);

  var _super = _createSuper(Component);

  function Component() {
    var _this;

    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Component);

    _this = _super.call(this);
    _this.__tagName = /(?:function|class)\s+([\w$]+)/.exec(_this.constructor.toString())[1]; // 构建工具中都是arr，手写可能出现hash情况

    if (Array.isArray(props)) {
      _this.props = util.arr2hash(props);
    } else {
      _this.props = props;
    }

    _this.__parent = null;
    _this.__host = null;
    _this.__ref = {};
    _this.state = {};
    _this.__isMounted = false;
    _this.__taskList = [];
    return _this;
  }

  _createClass(Component, [{
    key: "setState",
    value: function setState(n, cb) {
      var _this2 = this;

      var self = this;

      if (isNil$b(n)) {
        n = {};
      } else if (isFunction$6(n)) {
        return;
      } else {
        if (Object.keys(n).length === 0) {
          if (isFunction$6(cb)) {
            cb.call(self);
          }

          return;
        }

        var state = clone$3(self.state);
        n = extend$1(state, n);
      }

      var root = self.root;

      if (root && self.__isMounted) {
        // 一帧之内多次调用，需合并
        if (self.__nextState) {
          Object.assign(self.__nextState, n);

          self.__taskList.push(cb);
        } else {
          self.__nextState = n;
          self.__taskList = [cb]; // 回调更新列表，before执行时splice出来供after执行，防止中途产生的后续setState干扰

          var list = [];
          var t = self.__task = {
            __before: function __before() {
              list = self.__taskList.splice(0); // 标识更新

              setUpdateFlag(_this2);
            },
            __after: function __after() {
              // self.__nextState = null; 由updater.js每次refresh前同步执行清空，这里不能异步清除，否则frame动画会乱序
              list.forEach(function (cb) {
                if (isFunction$6(cb)) {
                  cb.call(self);
                }
              });
            }
          };
          root.addRefreshCp(t);
        }
      } // 构造函数中调用还未render，
      else if (isFunction$6(cb)) {
        self.state = n;
        cb.call(self);
      }
    }
    /**
     * build中调用初始化，json有值时是update过程才有，且处理过flatten
     * @param json
     * @private
     */

  }, {
    key: "__init",
    value: function __init(json) {
      var _this3 = this;

      this.__ref = {};
      var root = this.root;
      var cd = json || flattenJson(this.render());
      var sr = builder.initCp(cd, root, this);
      this.__cd = cd;

      if (sr instanceof Text) ; else if (sr instanceof Node) {
        var style = css.normalize(this.props.style);
        var keys = Object.keys(style);
        extend$1(sr.style, style, keys);
        extend$1(sr.currentStyle, style, keys); // 事件添加到sr

        Object.keys(this.props).forEach(function (k) {
          var v = _this3.props[k];

          if (/^on[a-zA-Z]/.test(k)) {
            k = k.slice(2).toLowerCase();
            sr.listener[k] = v;
          }
        });
      } else if (!(sr instanceof Component)) {
        // 本身build是递归的，子cp已经初始化了
        throw new Error('Component render() must return a dom/text: ' + this);
      } // 自定义事件无视返回强制添加


      Object.keys(this.props).forEach(function (k) {
        var v = _this3.props[k];

        if (/^on-[a-zA-Z\d_$]/.test(k)) {
          k = k.slice(3);

          _this3.on(k, v);
        }
      }); // shadow指向直接renderRoot，shadowRoot考虑到返回Component的递归即hoc高阶组件
      // host是直接所属，hostRoot同考虑到高阶组件

      this.__shadow = sr;
      sr.__host = this; // 递归下去，多层级时执行顺序由里到外，最终会被最上层执行替换

      while (sr instanceof Component) {
        sr.__hostRoot = this;
        sr.shadow.__host = sr;
        sr = sr.shadow;
      }

      this.__shadowRoot = sr;
      sr.__hostRoot = this;

      if (!this.__isMounted) {
        this.__isMounted = true;

        if (isFunction$6(this.componentDidMount)) {
          root.once(Event.REFRESH, function () {
            _this3.componentDidMount();
          });
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      inject.warn('Component must implement render()');
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      if (this.isDestroyed) {
        return;
      }

      this.__isDestroyed = true;
      this.__isMounted = false;

      if (isFunction$6(this.componentWillUnmount)) {
        this.componentWillUnmount();
      }

      this.root.delRefreshTask(this.__task);

      if (this.shadowRoot) {
        this.shadowRoot.__destroy();
      }

      this.__parent = null;
    }
  }, {
    key: "__emitEvent",
    value: function __emitEvent(e, force) {
      var sr = this.shadowRoot;

      if (sr instanceof Text) {
        return;
      }

      var res = sr.__emitEvent(e, force);

      if (res) {
        e.target = this;
        return true;
      }
    }
  }, {
    key: "tagName",
    get: function get() {
      return this.__tagName;
    }
  }, {
    key: "shadow",
    get: function get() {
      return this.__shadow;
    }
  }, {
    key: "shadowRoot",
    get: function get() {
      return this.__shadowRoot;
    }
  }, {
    key: "root",
    get: function get() {
      return this.__root;
    }
  }, {
    key: "host",
    get: function get() {
      return this.__host;
    }
  }, {
    key: "hostRoot",
    get: function get() {
      return this.__hostRoot;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.__parent;
    }
  }, {
    key: "prev",
    get: function get() {
      return this.__prev;
    }
  }, {
    key: "next",
    get: function get() {
      return this.__next;
    }
  }, {
    key: "ref",
    get: function get() {
      return this.__ref;
    }
  }, {
    key: "domParent",
    get: function get() {
      return this.__domParent;
    }
  }, {
    key: "state",
    get: function get() {
      return this.__state;
    },
    set: function set(v) {
      this.__state = v;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.__isDestroyed;
    }
  }], [{
    key: "REGISTER",
    get: function get() {
      return REGISTER$1;
    }
  }, {
    key: "getRegister",
    value: function getRegister(name) {
      if (!name || !util.isString(name) || !/^[A-Z]/.test(name)) {
        throw new Error('Invalid param');
      }

      if (!REGISTER$1.hasOwnProperty(name)) {
        throw new Error("Component has not register: ".concat(name));
      }

      return REGISTER$1[name];
    }
  }, {
    key: "register",
    value: function register(name, obj) {
      if (!name || !util.isString(name) || !/^[A-Z]/.test(name) || !obj.prototype || !(obj.prototype instanceof Component)) {
        throw new Error('Invalid param: Component register');
      }

      if (Component.hasRegister(name)) {
        throw new Error("Component has already register: ".concat(name));
      }

      REGISTER$1[name] = obj;
    }
  }, {
    key: "hasRegister",
    value: function hasRegister(name) {
      return name && REGISTER$1.hasOwnProperty(name);
    }
  }, {
    key: "delRegister",
    value: function delRegister(name) {
      if (Component.hasRegister(name)) {
        delete REGISTER$1[name];
      }
    }
  }]);

  return Component;
}(Event);

Object.keys(o$2.GEOM).concat(['x', 'y', 'ox', 'oy', 'sx', 'sy', // '__sx1',
// '__sx2',
// '__sx3',
// '__sx4',
// '__sx5',
// '__sx6',
// '__sy1',
// '__sy2',
// '__sy3',
// '__sy4',
// '__sy5',
// '__sy6',
'width', 'height', 'outerWidth', 'outerHeight', 'clientWidth', 'clientHeight', 'offsetWidth', 'offsetHeight', 'style', 'animationList', 'animateStyle', 'currentStyle', 'computedStyle', 'currentProps', 'baseLine', 'virtualDom', 'mask', 'maskId', 'textWidth', 'content', 'lineBoxes', 'charWidthList', 'charWidth', '__layoutData', 'availableAnimating', 'effectiveAnimating', 'displayAnimating', 'visibilityAnimating', 'bbox', '__config', 'contentBoxList', 'listener', 'matrix', 'matrixEvent']).forEach(function (fn) {
  Object.defineProperty(Component.prototype, fn, {
    get: function get() {
      var sr = this.shadowRoot;

      if (sr) {
        return sr[fn];
      }
    }
  });
});
['__layout', '__layoutAbs', '__layoutNone', '__tryLayInline', '__offsetX', '__offsetY', '__calAutoBasis', '__calMp', '__calAbs', '__renderAsMask', '__renderByMask', '__mp', 'animate', 'removeAnimate', 'clearAnimate', 'updateStyle', 'getBoundingClientRect', 'getComputedStyle', '__deepScan', 'clearCache', '__structure', '__modifyStruct', '__updateStruct', 'flowChildren', 'absChildren', '__isRealInline', '__calBasis', '__calMinMax', '__computeMeasure', 'appendChild', 'prependChild', 'insertBefore', 'insertAfter', 'removeChild', 'remove'].forEach(function (fn) {
  Component.prototype[fn] = function () {
    var sr = this.shadowRoot;

    if (sr && isFunction$6(sr[fn])) {
      return sr[fn].apply(sr, arguments);
    }
  };
});

var _enums$STYLE_KEY$h = enums.STYLE_KEY,
    SCALE_X$1 = _enums$STYLE_KEY$h.SCALE_X,
    SCALE_Y$1 = _enums$STYLE_KEY$h.SCALE_Y;
var PERCENT$8 = o$4.PERCENT,
    NUMBER$2 = o$4.NUMBER;

function matrixResize(imgWidth, imgHeight, targetWidth, targetHeight, x, y, w, h) {
  if (imgWidth === targetWidth && imgHeight === targetHeight) {
    return;
  }

  var list = [[SCALE_X$1, [targetWidth / imgWidth, NUMBER$2]], [SCALE_Y$1, [targetHeight / imgHeight, NUMBER$2]]];
  var tfo = tf.calOrigin([[0, PERCENT$8], [0, PERCENT$8]], w, h);
  tfo[0] += x;
  tfo[1] += y;
  return tf.calMatrixWithOrigin(list, tfo, w, h);
}

var image = {
  matrixResize: matrixResize
};

var _enums$STYLE_KEY$g = enums.STYLE_KEY,
    BACKGROUND_POSITION_X$2 = _enums$STYLE_KEY$g.BACKGROUND_POSITION_X,
    BACKGROUND_POSITION_Y$2 = _enums$STYLE_KEY$g.BACKGROUND_POSITION_Y,
    FONT_SIZE$b = _enums$STYLE_KEY$g.FONT_SIZE,
    NODE_DEFS_CACHE$5 = enums.NODE_KEY.NODE_DEFS_CACHE;
var clone$2 = util.clone,
    joinArr$2 = util.joinArr;
var canvasPolygon$4 = painter.canvasPolygon,
    svgPolygon$4 = painter.svgPolygon;
var AUTO$6 = o$4.AUTO,
    PX$7 = o$4.PX,
    PERCENT$7 = o$4.PERCENT,
    STRING$1 = o$4.STRING,
    REM$b = o$4.REM,
    VW$b = o$4.VW,
    VH$b = o$4.VH;

function renderBgc(xom, renderMode, ctx, color, list, x, y, w, h, btlr, btrr, bbrr, bblr) {
  var method = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 'fill';
  var isInline = arguments.length > 14 ? arguments[14] : undefined;
  // radial渐变ellipse形状会有matrix，用以从圆缩放到椭圆
  var matrix, cx, cy;

  if (Array.isArray(color)) {
    matrix = color[1];
    cx = color[2];
    cy = color[3];
    color = color[0];
  } // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间


  list = list || border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

  if (!list) {
    list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
  } // 椭圆有matrix，用逆矩阵变化点来完成


  if (matrix) {
    var tfo = [cx, cy];
    matrix = tf.calMatrixByOrigin(matrix, tfo);
    var t = mx.inverse(matrix);
    list = list.map(function (item) {
      if (!item || !item.length) {
        return null;
      }

      var arr = [];

      for (var i = 0, len = item.length; i < len; i += 2) {
        var p = mx.calPoint([item[i], item[i + 1]], t);
        arr.push(p[0]);
        arr.push(p[1]);
      }

      return arr;
    });
  }

  if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
    if (matrix) {
      ctx.save();
      var me = xom.matrixEvent;
      matrix = mx.multiply(me, matrix);
      ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
    }

    ctx.beginPath();

    if (ctx.fillStyle !== color) {
      ctx.fillStyle = color;
    }

    canvasPolygon$4(ctx, list);
    ctx[method]();
    ctx.closePath();

    if (matrix) {
      ctx.restore();
    }
  } else if (renderMode === mode.SVG) {
    var d = svgPolygon$4(list);

    if (isInline) {
      var v = {
        tagName: 'symbol',
        props: [],
        children: [{
          type: 'item',
          tagName: 'path',
          props: [['d', d], ['fill', color]]
        }]
      };

      xom.__config[NODE_DEFS_CACHE$5].push(v);

      return ctx.add(v);
    } else {
      xom.virtualDom.bb.push({
        type: 'item',
        tagName: 'path',
        props: [['d', d], ['fill', color]]
      }); // 椭圆渐变独有

      if (matrix) {
        var bb = xom.virtualDom.bb;
        bb[bb.length - 1].props.push(['transform', "matrix(".concat(joinArr$2(mx.m2m6(matrix), ','), ")")]);
      }
    }
  }
}

function calBackgroundSize(value, w, h, root) {
  var res = [];
  value.forEach(function (item, i) {
    if (item[1] === PX$7) {
      res.push(item[0]);
    } else if (item[1] === PERCENT$7) {
      res.push(item[0] * (i ? h : w) * 0.01);
    } else if (item[1] === REM$b) {
      res.push(item[0] * root.computedStyle[FONT_SIZE$b]);
    } else if (item[1] === VW$b) {
      res.push(item[0] * root.width * 0.01);
    } else if (item[1] === VH$b) {
      res.push(item[0] * root.height * 0.01);
    } else if (item[1] === AUTO$6) {
      res.push(-1);
    } else if (item[1] === STRING$1) {
      res.push(item[0] === 'contain' ? -2 : -3);
    }
  });
  return res;
}

function calBackgroundPosition(position, container, size, root) {
  if (Array.isArray(position)) {
    if (position[1] === PX$7) {
      return position[0];
    } else if (position[1] === PERCENT$7) {
      return (container - size) * position[0] * 0.01;
    } else if (position[1] === REM$b) {
      return position[0] * root.computedStyle[FONT_SIZE$b];
    } else if (position[1] === VW$b) {
      return position[0] * root.width * 0.01;
    } else if (position[1] === VH$b) {
      return position[0] * root.height * 0.01;
    }
  }

  return 0;
}

function renderImage(xom, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, currentStyle, i, backgroundSize, backgroundRepeat, __config, isInline) {
  var source = loadBgi.source; // 无source不绘制，可能错误或加载中

  if (source) {
    var bgW = bx2 - bx1;
    var bgH = by2 - by1;
    var width = loadBgi.width,
        height = loadBgi.height;

    var _ref = backgroundSize[i] || [],
        _ref2 = _slicedToArray(_ref, 2),
        w = _ref2[0],
        h = _ref2[1]; // -1为auto，-2为contain，-3为cover


    if (w === -1 && h === -1) {
      w = width;
      h = height;
    } else if (w === -2) {
      if (width > bgW && height > bgH) {
        w = width / bgW;
        h = height / bgH;

        if (w >= h) {
          w = bgW;
          h = w * height / width;
        } else {
          h = bgH;
          w = h * width / height;
        }
      } else if (width > bgW) {
        w = bgW;
        h = w * height / width;
      } else if (height > bgH) {
        h = bgH;
        w = h * width / height;
      } else {
        w = width;
        h = height;
      }
    } else if (w === -3) {
      if (bgW > width && bgH > height) {
        w = width / bgW;
        h = height / bgH;

        if (w <= h) {
          w = bgW;
          h = w * height / width;
        } else {
          h = bgH;
          w = h * width / height;
        }
      } else if (bgW > width) {
        w = bgW;
        h = w * height / width;
      } else if (bgH > height) {
        h = bgH;
        w = h * width / height;
      } else {
        w = width / bgW;
        h = height / bgH;

        if (w <= h) {
          w = bgW;
          h = w * height / width;
        } else {
          h = bgH;
          w = h * width / height;
        }
      }
    } else if (w === -1) {
      w = h * width / height;
    } else if (h === -1) {
      h = w * height / width;
    }

    var bgX = bx1 + calBackgroundPosition(currentStyle[BACKGROUND_POSITION_X$2][i], bgW, w, xom.root);
    var bgY = by1 + calBackgroundPosition(currentStyle[BACKGROUND_POSITION_Y$2][i], bgH, h, xom.root); // 超出尺寸模拟mask截取

    var needMask = bgX < bx1 || bgY < by1 || bgX + w > bx1 + bgW || bgY + h > by1 + bgH; // 计算因为repeat，需要向4个方向扩展渲染几个数量图片

    var xnl = 0;
    var xnr = 0;
    var ynt = 0;
    var ynb = 0; // repeat-x

    if (['repeat-x', 'repeatX', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
      var diff = bgX - bx1;

      if (diff > 0) {
        xnl = Math.ceil(diff / w);
      }

      diff = bx1 + bgW - bgX - w;

      if (diff > 0) {
        xnr = Math.ceil(diff / w);
      }
    } // repeat-y


    if (['repeat-y', 'repeatY', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
      var _diff = bgY - by1;

      if (_diff > 0) {
        ynt = Math.ceil(_diff / h);
      }

      _diff = by1 + bgH - bgY - h;

      if (_diff > 0) {
        ynb = Math.ceil(_diff / h);
      }
    } // 分同行列和4个角分别判断，先看同行同列，再看4个角的象限


    var repeat = [];

    if (xnl > 0) {
      for (var _i = 0; _i < xnl; _i++) {
        var x = bgX - (_i + 1) * w;
        repeat.push([x, bgY]); // 看最左边超过没有

        if (!needMask && _i === 0 && x < bx1) {
          needMask = true;
        }
      }
    }

    if (xnr > 0) {
      for (var _i2 = 0; _i2 < xnr; _i2++) {
        var _x = bgX + (_i2 + 1) * w;

        repeat.push([_x, bgY]); // 看最右边超过没有

        if (!needMask && _i2 === xnr - 1 && _x + w > bx1 + bgW) {
          needMask = true;
        }
      }
    }

    if (ynt > 0) {
      for (var _i3 = 0; _i3 < ynt; _i3++) {
        var y = bgY - (_i3 + 1) * h;
        repeat.push([bgX, y]); // 看最上边超过没有

        if (!needMask && _i3 === 0 && y < by1) {
          needMask = true;
        }
      }
    }

    if (ynb > 0) {
      for (var _i4 = 0; _i4 < ynb; _i4++) {
        var _y = bgY + (_i4 + 1) * h;

        repeat.push([bgX, _y]); // 看最下边超过没有

        if (!needMask && _i4 === ynb - 1 && _y + w > by1 + bgH) {
          needMask = true;
        }
      }
    } // 原点和同行列十字画完，看4个角的情况


    if (xnl > 0 && ynt > 0) {
      for (var _i5 = 0; _i5 < xnl; _i5++) {
        for (var j = 0; j < ynt; j++) {
          repeat.push([bgX - (_i5 + 1) * w, bgY - (j + 1) * h]);
        }
      }
    }

    if (xnr > 0 && ynt > 0) {
      for (var _i6 = 0; _i6 < xnr; _i6++) {
        for (var _j = 0; _j < ynt; _j++) {
          repeat.push([bgX + (_i6 + 1) * w, bgY - (_j + 1) * h]);
        }
      }
    }

    if (xnl > 0 && ynb > 0) {
      for (var _i7 = 0; _i7 < xnl; _i7++) {
        for (var _j2 = 0; _j2 < ynb; _j2++) {
          repeat.push([bgX - (_i7 + 1) * w, bgY + (_j2 + 1) * h]);
        }
      }
    }

    if (xnr > 0 && ynb > 0) {
      for (var _i8 = 0; _i8 < xnr; _i8++) {
        for (var _j3 = 0; _j3 < ynb; _j3++) {
          repeat.push([bgX + (_i8 + 1) * w, bgY + (_j3 + 1) * h]);
        }
      }
    }

    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      if (needMask) {
        ctx.save();
        renderBgc(this, renderMode, ctx, '#FFF', null, bx1, by1, bgW, bgH, btlr, btrr, bbrr, bblr, 'clip');
      } // 先画不考虑repeat的中心声明的


      ctx.drawImage(source, bgX, bgY, w, h); // 再画重复的十字和4角象限

      repeat.forEach(function (item) {
        ctx.drawImage(source, item[0], item[1], w, h);
      });

      if (needMask) {
        ctx.restore();
      }
    } else if (renderMode === mode.SVG) {
      var matrix = image.matrixResize(width, height, w, h, bgX, bgY, bgW, bgH);
      var props = [['xlink:href', loadBgi.url], ['x', bgX], ['y', bgY], ['width', width], ['height', height]];
      var needResize;

      if (matrix && !mx.isE(matrix)) {
        needResize = true;
        props.push(['transform', 'matrix(' + joinArr$2(mx.m2m6(matrix), ',') + ')']);
      }

      if (needMask) {
        var p1 = [bx1, by1];
        var p2 = [bx2, by2];

        if (needResize) {
          var inverse = mx.inverse(matrix);
          p1 = mx.calPoint(p1, inverse);
          p2 = mx.calPoint(p2, inverse);
        }

        var v = {
          tagName: 'clipPath',
          children: [{
            tagName: 'path',
            props: [['d', "M".concat(p1[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p1[1])], ['fill', '#FFF']]
          }]
        };
        var id = ctx.add(v);

        __config[NODE_DEFS_CACHE$5].push(v);

        props.push(['clip-path', 'url(#' + id + ')']);
      }

      if (isInline) {
        var _v = {
          tagName: 'symbol',
          props: [],
          children: [{
            type: 'img',
            tagName: 'image',
            props: props
          }]
        };

        xom.__config[NODE_DEFS_CACHE$5].push(_v);

        repeat.forEach(function (item) {
          var copy = clone$2(props);

          if (needResize) {
            var _matrix = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

            if (_matrix && !mx.isE(_matrix)) {
              copy[5][1] = 'matrix(' + joinArr$2(mx.m2m6(_matrix), ',') + ')';
            }
          }

          copy[1][1] = item[0];
          copy[2][1] = item[1];

          _v.children.push({
            type: 'img',
            tagName: 'image',
            props: copy
          });
        });
        return ctx.add(_v);
      } else {
        // 先画不考虑repeat的中心声明的
        xom.virtualDom.bb.push({
          type: 'img',
          tagName: 'image',
          props: props
        }); // 再画重复的十字和4角象限

        repeat.forEach(function (item) {
          var copy = clone$2(props);

          if (needResize) {
            var _matrix2 = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

            if (_matrix2 && !mx.isE(_matrix2)) {
              copy[5][1] = 'matrix(' + joinArr$2(mx.m2m6(_matrix2), ',') + ')';
            }
          }

          copy[1][1] = item[0];
          copy[2][1] = item[1];
          xom.virtualDom.bb.push({
            type: 'img',
            tagName: 'image',
            props: copy
          });
        });
      }
    }
  }
}

var bg = {
  renderBgc: renderBgc,
  renderImage: renderImage,
  calBackgroundSize: calBackgroundSize
};

var isFunction$5 = util.isFunction;

function traversal(list, length, diff, after) {
  if (after) {
    for (var i = 0; i < length; i++) {
      var item = list[i];

      if (item[1]) {
        item[1](diff);
      } else {
        item.__after && item.__after(diff);
      }
    }
  } else {
    for (var _i = 0; _i < length; _i++) {
      var _item = list[_i];

      if (_item[0]) {
        _item[0](diff);
      } else {
        _item.__before && _item.__before(diff);
      }
    }
  }
}

var isPause;

var Frame = /*#__PURE__*/function () {
  function Frame() {
    _classCallCheck(this, Frame);

    this.__hookTask = []; // 动画刷新后，每个root注册的刷新回调执行

    this.__task = [];
    this.__taskCp = []; // 区别于task，component专用，和animate等其它不同流水线，在最后执行，防止混了 #122

    this.__now = null;
  }

  _createClass(Frame, [{
    key: "__init",
    value: function __init() {
      var self = this;
      var task = self.task,
          taskCp = self.taskCp;
      inject.cancelAnimationFrame(self.id);
      var last = self.__now = inject.now();

      function cb() {
        // 必须清除，可能会发生重复，当动画finish回调中gotoAndPlay(0)，下方结束判断发现aTask还有值会继续，新的init也会进入再次执行
        inject.cancelAnimationFrame(self.id);
        self.id = inject.requestAnimationFrame(function () {
          if (isPause || !task.length && !taskCp.length) {
            return;
          }

          var now = self.__now = inject.now();
          var diff = now - last;
          diff = Math.max(diff, 0); // let delta = diff * 0.06; // 比例是除以1/60s，等同于*0.06

          last = now; // 优先动画计算

          var clone = task.slice(0);
          var cloneCp = taskCp.splice(0); // task要常驻，taskCp只1次直接splice清空

          var length = clone.length;
          var lengthCp = cloneCp.length;
          traversal(clone, length, diff, false);
          traversal(cloneCp, lengthCp, diff, false); // 执行动画造成的每个Root的刷新并清空

          var list = self.__hookTask.splice(0);

          for (var i = 0, len = list.length; i < len; i++) {
            var item = list[i];
            item && item();
          } // 普通的before/after


          traversal(clone, length, diff, true);
          traversal(cloneCp, lengthCp, diff, true); // 还有则继续，没有则停止节省性能

          if (task.length || taskCp.length) {
            cb();
          }
        });
      }

      cb();
    }
  }, {
    key: "onFrame",
    value: function onFrame(handle) {
      if (!handle) {
        return;
      }

      var task = this.task;

      if (!task.length) {
        this.__init();
      }

      if (isFunction$5(handle)) {
        handle = {
          __after: handle,
          __karasFramecb: handle
        };
      }

      task.push(handle);
    }
  }, {
    key: "offFrame",
    value: function offFrame(handle) {
      if (!handle) {
        return;
      }

      var task = this.task;

      for (var i = 0, len = task.length; i < len; i++) {
        var item = task[i]; // 需考虑nextFrame包裹的引用对比

        if (item === handle || item.__karasFramecb === handle) {
          task.splice(i, 1);
          break;
        }
      }

      if (!task.length) {
        inject.cancelAnimationFrame(this.id);
        this.__now = null;
      }
    }
  }, {
    key: "nextFrame",
    value: function nextFrame(handle) {
      var _this = this;

      if (!handle) {
        return;
      } // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比


      var cb = isFunction$5(handle) ? {
        __after: function __after(diff) {
          handle(diff);

          _this.offFrame(cb);
        }
      } : {
        __before: handle.__before,
        __after: function __after(diff) {
          handle.__after && handle.__after(diff);

          _this.offFrame(cb);
        }
      };
      cb.__karasFramecb = handle;
      this.onFrame(cb);
    }
  }, {
    key: "__nextFrameCp",
    value: function __nextFrameCp(handle) {
      var task = this.task,
          taskCp = this.taskCp;

      if (!task.length && !taskCp.length) {
        this.__init();
      }

      taskCp.push(handle);
    }
  }, {
    key: "pause",
    value: function pause() {
      isPause = true;
    }
  }, {
    key: "resume",
    value: function resume() {
      if (isPause) {
        this.__init();

        isPause = false;
      }
    }
  }, {
    key: "task",
    get: function get() {
      return this.__task;
    }
  }, {
    key: "taskCp",
    get: function get() {
      return this.__taskCp;
    }
  }]);

  return Frame;
}();

var frame = new Frame();

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */
// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
var float32ArraySupported = typeof Float32Array === 'function';

function A(aA1, aA2) {
  return 1.0 - 3.0 * aA2 + 3.0 * aA1;
}

function B(aA1, aA2) {
  return 3.0 * aA2 - 6.0 * aA1;
}

function C(aA1) {
  return 3.0 * aA1;
} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


function calcBezier(aT, aA1, aA2) {
  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


function getSlope(aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide(aX, aA, aB, mX1, mX2) {
  var currentX,
      currentT,
      i = 0;

  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;

    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

  return currentT;
}

function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);

    if (currentSlope === 0.0) {
      return aGuessT;
    }

    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }

  return aGuessT;
}

function LinearEasing(x) {
  return x;
}

function bezier(mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  }

  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  } // Precompute samples table


  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }

  function getTForX(aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }

    --currentSample; // Interpolate to provide an initial guess for t

    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;
    var initialSlope = getSlope(guessForT, mX1, mX2);

    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing(x) {
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0 || x === 1) {
      return x;
    }

    return calcBezier(getTForX(x), mY1, mY2);
  };
}

var easing = {
  linear: bezier(1, 1, 0, 0),
  easeIn: bezier(0.42, 0, 1, 1),
  easeOut: bezier(0, 0, 0.58, 1),
  ease: bezier(0.25, 0.1, 0.25, 1),
  easeInOut: bezier(0.42, 0, 0.58, 1),
  cubicBezier: bezier,
  getEasing: function getEasing(v, v1, v2, v3) {
    if (arguments.length === 4) {
      return bezier(v, v1, v2, v3);
    } else if (Array.isArray(v) && v.length === 4) {
      return bezier(v[0], v[1], v[2], v[3]);
    } else if (v) {
      v = v.toString();
      var timingFunction;

      if (/^\s*(?:cubic-bezier\s*)?\(\s*[\d.]+\s*,\s*[-\d.]+\s*,\s*[\d.]+\s*,\s*[-\d.]+\s*\)\s*$/i.test(v)) {
        v = v.match(/[\d.]+/g);
        timingFunction = bezier(v[0], v[1], v[2], v[3]);
      } else if (v !== 'getEasing') {
        timingFunction = this[v];
      }

      return timingFunction;
    }
  }
};
easing['ease-in'] = easing.easeIn;
easing['ease-out'] = easing.easeOut;
easing['ease-in-out'] = easing.easeInOut;

var _enums$STYLE_KEY$f = enums.STYLE_KEY,
    FILTER$4 = _enums$STYLE_KEY$f.FILTER,
    TRANSFORM_ORIGIN$2 = _enums$STYLE_KEY$f.TRANSFORM_ORIGIN,
    PERSPECTIVE_ORIGIN$2 = _enums$STYLE_KEY$f.PERSPECTIVE_ORIGIN,
    BACKGROUND_CLIP$1 = _enums$STYLE_KEY$f.BACKGROUND_CLIP,
    BACKGROUND_POSITION_X$1 = _enums$STYLE_KEY$f.BACKGROUND_POSITION_X,
    BACKGROUND_POSITION_Y$1 = _enums$STYLE_KEY$f.BACKGROUND_POSITION_Y,
    BOX_SHADOW$8 = _enums$STYLE_KEY$f.BOX_SHADOW,
    TRANSLATE_X$1 = _enums$STYLE_KEY$f.TRANSLATE_X,
    TRANSLATE_Y$1 = _enums$STYLE_KEY$f.TRANSLATE_Y,
    TRANSLATE_Z$1 = _enums$STYLE_KEY$f.TRANSLATE_Z,
    BACKGROUND_SIZE$1 = _enums$STYLE_KEY$f.BACKGROUND_SIZE,
    FONT_SIZE$a = _enums$STYLE_KEY$f.FONT_SIZE,
    FLEX_BASIS$3 = _enums$STYLE_KEY$f.FLEX_BASIS,
    FLEX_DIRECTION$1 = _enums$STYLE_KEY$f.FLEX_DIRECTION,
    WIDTH$5 = _enums$STYLE_KEY$f.WIDTH,
    HEIGHT$6 = _enums$STYLE_KEY$f.HEIGHT,
    TOP$4 = _enums$STYLE_KEY$f.TOP,
    BOTTOM$4 = _enums$STYLE_KEY$f.BOTTOM,
    LINE_HEIGHT$2 = _enums$STYLE_KEY$f.LINE_HEIGHT,
    OPACITY$3 = _enums$STYLE_KEY$f.OPACITY,
    Z_INDEX$3 = _enums$STYLE_KEY$f.Z_INDEX,
    TRANSFORM$2 = _enums$STYLE_KEY$f.TRANSFORM,
    COLOR$2 = _enums$STYLE_KEY$f.COLOR,
    FONT_WEIGHT$1 = _enums$STYLE_KEY$f.FONT_WEIGHT,
    FONT_STYLE$1 = _enums$STYLE_KEY$f.FONT_STYLE,
    FONT_FAMILY$1 = _enums$STYLE_KEY$f.FONT_FAMILY,
    TEXT_ALIGN$1 = _enums$STYLE_KEY$f.TEXT_ALIGN,
    MATRIX$1 = _enums$STYLE_KEY$f.MATRIX,
    ROTATE_3D$1 = _enums$STYLE_KEY$f.ROTATE_3D,
    TRANSLATE_PATH = _enums$STYLE_KEY$f.TRANSLATE_PATH,
    TEXT_STROKE_COLOR$1 = _enums$STYLE_KEY$f.TEXT_STROKE_COLOR,
    TEXT_STROKE_OVER$1 = _enums$STYLE_KEY$f.TEXT_STROKE_OVER,
    _enums$UPDATE_KEY$4 = enums.UPDATE_KEY,
    UPDATE_NODE$4 = _enums$UPDATE_KEY$4.UPDATE_NODE,
    UPDATE_STYLE$2 = _enums$UPDATE_KEY$4.UPDATE_STYLE,
    UPDATE_KEYS$2 = _enums$UPDATE_KEY$4.UPDATE_KEYS,
    UPDATE_CONFIG$4 = _enums$UPDATE_KEY$4.UPDATE_CONFIG,
    _enums$KEY_FRAME_KEY = enums.KEY_FRAME_KEY,
    FRAME_STYLE = _enums$KEY_FRAME_KEY.FRAME_STYLE,
    FRAME_TIME = _enums$KEY_FRAME_KEY.FRAME_TIME,
    FRAME_EASING = _enums$KEY_FRAME_KEY.FRAME_EASING,
    FRAME_TRANSITION = _enums$KEY_FRAME_KEY.FRAME_TRANSITION;
var AUTO$5 = o$4.AUTO,
    PX$6 = o$4.PX,
    PERCENT$6 = o$4.PERCENT,
    INHERIT$2 = o$4.INHERIT,
    RGBA$1 = o$4.RGBA,
    STRING = o$4.STRING,
    NUMBER$1 = o$4.NUMBER,
    REM$a = o$4.REM,
    VW$a = o$4.VW,
    VH$a = o$4.VH,
    calUnit = o$4.calUnit;
var isNil$a = util.isNil,
    isFunction$4 = util.isFunction,
    isNumber = util.isNumber,
    isObject$1 = util.isObject,
    isString = util.isString,
    clone$1 = util.clone,
    equalArr = util.equalArr;
var linear = easing.linear;
var cloneStyle = css.cloneStyle;
var isGeom$1 = o$2.isGeom,
    GEOM$1 = o$2.GEOM;
var COLOR_HASH = key.COLOR_HASH,
    LENGTH_HASH = key.LENGTH_HASH,
    RADIUS_HASH = key.RADIUS_HASH,
    GRADIENT_HASH = key.GRADIENT_HASH,
    EXPAND_HASH = key.EXPAND_HASH,
    GRADIENT_TYPE = key.GRADIENT_TYPE;
var NUM_CAL_HASH = {};
Object.assign(NUM_CAL_HASH, LENGTH_HASH);
Object.assign(NUM_CAL_HASH, EXPAND_HASH);

function unify(frames, target) {
  var hash = {};
  var keys = []; // 获取所有关键帧的属性

  frames.forEach(function (item) {
    var style = item[FRAME_STYLE];
    Object.keys(style).forEach(function (k) {
      var v = style[k]; // 未定义的过滤掉，null空有意义

      if (v !== undefined && !hash.hasOwnProperty(k)) {
        hash[k] = true; // geom为属性字符串，style都为枚举int

        if (!GEOM$1.hasOwnProperty(k)) {
          k = parseInt(k);
        } // path动画要转为translateXY，所以手动添加，使2帧之间存在过渡，有可能之前已存在这个动画，可忽视


        if (k === TRANSLATE_PATH) {
          if (!hash.hasOwnProperty(TRANSLATE_X$1)) {
            keys.push(TRANSLATE_X$1);
          }

          if (!hash.hasOwnProperty(TRANSLATE_Y$1)) {
            keys.push(TRANSLATE_Y$1);
          }

          hash[TRANSLATE_X$1] = hash[TRANSLATE_Y$1] = true;
        }

        keys.push(k);
      }
    });
  }); // 添补没有声明完全的关键帧属性为节点当前值

  frames.forEach(function (item) {
    var style = item[FRAME_STYLE];
    keys.forEach(function (k) {
      if (!style.hasOwnProperty(k) || isNil$a(style[k])) {
        if (GEOM$1.hasOwnProperty(k)) {
          style[k] = target.getProps(k);
        } else {
          style[k] = target.currentStyle[k];
        }
      }
    });
  });
  return keys;
} // 每次初始化时处理继承值，以及转换transform为单matrix矩阵


function inherit(frames, keys, target) {
  var computedStyle = target.computedStyle;
  frames.forEach(function (item) {
    var style = item[FRAME_STYLE];
    keys.forEach(function (k) {
      var v = style[k]; // geom的属性可能在帧中没有

      if (isNil$a(v)) {
        return;
      }

      if (k === TRANSFORM$2) {
        var ow = target.outerWidth;
        var oh = target.outerHeight;
        var m = tf.calMatrix(v, ow, oh);
        style[k] = [[MATRIX$1, m]];
      } else if (v[1] === INHERIT$2) {
        if (k === COLOR$2 || k === TEXT_STROKE_COLOR$1) {
          style[k] = [util.rgba2int(computedStyle[k]), RGBA$1];
        } else if (LENGTH_HASH.hasOwnProperty(k)) {
          style[k] = [computedStyle[k], PX$6];
        } else if (k === FONT_WEIGHT$1) {
          style[k] = [computedStyle[k], NUMBER$1];
        } else if (k === FONT_STYLE$1 || k === FONT_FAMILY$1 || k === TEXT_ALIGN$1 || k === TEXT_STROKE_OVER$1) {
          style[k] = [computedStyle[k], STRING];
        }
      }
    });
  });
}
/**
 * 通知root更新当前动画，需要根据frame的状态来决定是否是同步插入
 * 在异步时，因为动画本身是异步，需要addRefreshTask
 * 而如果此时frame在执行before过程中，说明帧动画本身是在before计算的，需要同步插入
 * @param style
 * @param keys 样式所有的key
 * @param __config
 * @param root
 * @param node
 */


function genBeforeRefresh(style, keys, __config, root, node) {
  var res = {};
  res[UPDATE_NODE$4] = node;
  res[UPDATE_STYLE$2] = style;
  res[UPDATE_KEYS$2] = keys;
  res[UPDATE_CONFIG$4] = __config[I_NODE_CONFIG];

  root.__addUpdate(node, __config[I_NODE_CONFIG], root, __config[I_ROOT_CONFIG], res);

  __config[I_STYLE] = style;
  __config[I_ASSIGNING] = true; // frame每帧回调时，下方先执行计算好变更的样式，这里特殊插入一个hook，让root增加一个刷新操作
  // 多个动画调用因为相同root也只会插入一个，这样在所有动画执行完毕后frame里检查同步进行刷新，解决单异步问题

  root.__frameHook();
}
/**
 * 将每帧的样式格式化，提取出offset属性并转化为时间，提取出缓动曲线easing
 * @param style 关键帧样式
 * @param duration 动画时间长度
 * @param es options的easing曲线控制，frame没有自定义则使用全局的
 * @returns {{style: *, time: number, easing: *, transition: []}}
 */


function framing(style, duration, es) {
  var _style = style,
      offset = _style.offset,
      easing = _style.easing; // 这两个特殊值提出来存储不干扰style

  delete style.offset;
  delete style.easing; // translatePath特殊对待，ae的曲线运动动画

  var translatePath = style.translatePath;
  style = css.normalize(style);

  if (Array.isArray(translatePath) && [6, 8].indexOf(translatePath.length) > -1) {
    style[TRANSLATE_PATH] = translatePath.map(function (item) {
      return calUnit(item);
    });
  }

  var res = [];
  res[FRAME_STYLE] = style;
  res[FRAME_TIME] = offset * duration;
  res[FRAME_EASING] = easing || es;
  res[FRAME_TRANSITION] = [];
  return res;
}

function calByUnit(p, n, container, root) {
  if (p[1] === PX$6) {
    if (n[1] === PERCENT$6) {
      return n[0] * 0.01 * container - p[0];
    } else if (n[1] === REM$a) {
      return n[0] * root.computedStyle[FONT_SIZE$a] - p[0];
    } else if (n[1] === VW$a) {
      return n[0] * root.width * 0.01 - p[0];
    } else if (n[1] === VH$a) {
      return n[0] * root.height * 0.01 - p[0];
    }
  } else if (p[1] === PERCENT$6) {
    if (n[1] === PX$6) {
      return n[0] * 100 / container - p[0];
    } else if (n[1] === REM$a) {
      return n[0] * root.computedStyle[FONT_SIZE$a] * 100 / container - p[0];
    } else if (n[1] === VW$a) {
      return n[0] * root.width / container - p[0];
    } else if (n[1] === VH$a) {
      return n[0] * root.height / container - p[0];
    }
  } else if (p[1] === REM$a) {
    if (n[1] === PX$6) {
      return n[0] / root.computedStyle[FONT_SIZE$a] - p[0];
    } else if (n[1] === PERCENT$6) {
      return n[0] * 0.01 * container / root.computedStyle[FONT_SIZE$a] - p[0];
    } else if (n[1] === VW$a) {
      return n[0] * root.width * 0.01 / root.computedStyle[FONT_SIZE$a] - p[0];
    } else if (n[1] === VH$a) {
      return n[0] * root.height * 0.01 / root.computedStyle[FONT_SIZE$a] - p[0];
    }
  } else if (p[1] === VW$a) {
    if (n[1] === PX$6) {
      return n[0] * 100 / root.width - p[0];
    } else if (n[1] === REM$a) {
      return n[0] * 100 * root.computedStyle[FONT_SIZE$a] / root.width - p[0];
    } else if (n[1] === PERCENT$6) {
      return n[0] * container / root.width - p[0];
    } else if (n[1] === VH$a) {
      return n[0] * root.height / root.width - p[0];
    }
  } else if (p[1] === VH$a) {
    if (n[1] === PX$6) {
      return n[0] * 100 / root.height - p[0];
    } else if (n[1] === REM$a) {
      return n[0] * 100 * root.computedStyle[FONT_SIZE$a] / root.height - p[0];
    } else if (n[1] === VW$a) {
      return n[0] * root.width / root.height - p[0];
    } else if (n[1] === PERCENT$6) {
      return n[0] * container / root.height - p[0];
    }
  }
}
/**
 * 计算两帧之间的差，单位不同的以后面为准，返回的v表示差值
 * 没有变化返回空
 * auto等无法比较的不参与计算，不返回来标识无过度效果
 * @param prev 上一帧样式
 * @param next 下一帧样式
 * @param k 比较的样式名
 * @param target dom对象
 * @param tagName dom名
 * @returns {{k: *, v: *}}
 */


function calDiff(prev, next, k, target, tagName) {
  var res = [k];
  var p = prev[k];
  var n = next[k];

  if (k === TRANSFORM$2) {
    // transform因默认值null很特殊，不存在时需给默认矩阵
    if (!p && !n) {
      return;
    }

    var pm, nm;

    if (p) {
      pm = p[0][1];
    } else {
      pm = mx.identity();
    }

    if (n) {
      nm = n[0][1];
    } else {
      nm = mx.identity();
    } // transform特殊被初始化转成matrix矩阵，直接计算差值


    if (equalArr(pm, nm)) {
      return;
    }

    res[1] = [nm[0] - pm[0], nm[1] - pm[1], nm[2] - pm[2], nm[3] - pm[3], nm[4] - pm[4], nm[5] - pm[5], nm[6] - pm[6], nm[7] - pm[7], nm[8] - pm[8], nm[9] - pm[9], nm[10] - pm[10], nm[11] - pm[11], nm[12] - pm[12], nm[13] - pm[13], nm[14] - pm[14], nm[15] - pm[15]];
    return res;
  } else if (k === ROTATE_3D$1) {
    if (equalArr(p, n)) {
      return;
    }

    res[1] = [n[0] - n[0], n[1] - p[1], n[2] - p[2], [n[3][0] - p[3][0], n[3][1]]];
  } else if (k === FILTER$4) {
    // filter很特殊，里面有多个滤镜，忽视顺序按hash计算，为空视为默认值，如blur默认0，brightness默认1
    var pHash = {},
        nHash = {},
        keyHash = {};

    if (p) {
      p.forEach(function (item) {
        keyHash[item[0]] = true;
        pHash[item[0]] = item[1];
      });
    }

    if (n) {
      n.forEach(function (item) {
        keyHash[item[0]] = true;
        nHash[item[0]] = item[1];
      });
    }

    var v = {},
        hasChange; // 只有blur支持px/rem/vw/vh，其余都是特殊固定单位

    Object.keys(keyHash).forEach(function (k) {
      if (k === 'blur') {
        if (!pHash[k]) {
          v[k] = nHash[k].slice(0);
          hasChange = true;
        } else if (!nHash[k]) {
          v[k] = [-pHash[k][0], pHash[k][1]];
          hasChange = true;
        } else {
          var v2 = calByUnit(pHash[k], nHash[k], 0, target.root);
          v[k] = [v2, pHash[k][1]];
          hasChange = true;
        }
      } else if (k === 'hue-rotate') {
        var nv = isNil$a(nHash[k]) ? 0 : nHash[k][0];
        var pv = isNil$a(pHash[k]) ? 0 : pHash[k][0];

        if (pv !== nv) {
          v[k] = [nv - pv, PERCENT$6];
          hasChange = true;
        }
      } else if (k === 'saturate' || k === 'brightness' || k === 'contrast') {
        var _nv = isNil$a(nHash[k]) ? 100 : nHash[k][0];

        var _pv = isNil$a(pHash[k]) ? 100 : pHash[k][0];

        if (_pv !== _nv) {
          v[k] = [_nv - _pv, PERCENT$6];
          hasChange = true;
        }
      } else if (k === 'grayscale') {
        var _nv2 = isNil$a(nHash[k]) ? 0 : nHash[k][0];

        var _pv2 = isNil$a(pHash[k]) ? 0 : pHash[k][0];

        if (_pv2 !== _nv2) {
          v[k] = [_nv2 - _pv2, PERCENT$6];
          hasChange = true;
        }
      }
    });

    if (!hasChange) {
      return;
    }

    res[1] = v;
  } else if (k === TRANSFORM_ORIGIN$2 || k === PERSPECTIVE_ORIGIN$2) {
    res[1] = [];

    for (var i = 0; i < 2; i++) {
      var pi = p[i];
      var ni = n[i];

      if (pi[1] === ni[1]) {
        res[1].push(ni[0] - pi[0]);
      } else {
        var _v = calByUnit(pi, ni, target[i ? 'outerHeight' : 'outerWidth'], target.root);

        res[1].push(_v || 0);
      }
    }

    if (equalArr(res[1], [0, 0])) {
      return;
    }
  } else if (k === BACKGROUND_POSITION_X$1 || k === BACKGROUND_POSITION_Y$1) {
    res[1] = [];
    var length = Math.min(p.length, n.length);

    for (var _i = 0; _i < length; _i++) {
      var _pi = p[_i],
          _ni = n[_i];

      if (!_pi || !_ni) {
        res[1].push(null);
        continue;
      }

      if (_pi[1] === _ni[1]) {
        var _v2 = _ni[0] - _pi[0];

        if (!_v2) {
          res[1].push(null);
          return;
        }

        res[1].push(_v2);
      } else {
        var k2 = k === BACKGROUND_POSITION_X$1 ? 'offsetWidth' : 'offsetHeight';

        if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
          k2 = k === BACKGROUND_POSITION_X$1 ? 'clientWidth' : 'clientHeight';
        } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
          k2 = k === BACKGROUND_POSITION_X$1 ? 'width' : 'height';
        }

        var _v3 = calByUnit(_pi, _ni, target[k2], target.root);

        if (!_v3) {
          res[1].push(null);
          return;
        }

        res[1].push(_v3);
      }
    }
  } else if (k === BOX_SHADOW$8) {
    res[1] = [];

    for (var _i2 = 0, len = Math.min(p.length, n.length); _i2 < len; _i2++) {
      var a = p[_i2];
      var b = n[_i2];
      var _v4 = []; // x/y/blur/spread

      for (var j = 0; j < 4; j++) {
        _v4.push(b[j] - a[j]);
      } // rgba


      var c = [];

      for (var _j = 0; _j < 4; _j++) {
        c.push(b[4][_j] - a[4][_j]);
      }

      _v4.push(c);

      res[1].push(_v4);
    }
  } else if (EXPAND_HASH.hasOwnProperty(k)) {
    if (p[1] === n[1]) {
      var _v5 = n[0] - p[0];

      if (_v5 === 0) {
        return;
      }

      res[1] = _v5;
    } else {
      var _v6 = calByUnit(p, n, target[k === TRANSLATE_X$1 || k === TRANSLATE_Z$1 ? 'outerWidth' : 'outerHeight'], target.root);

      if (!_v6) {
        return;
      }

      res[1] = _v6;
    }
  } else if (k === BACKGROUND_SIZE$1) {
    res[1] = [];

    var _length = Math.min(p.length, n.length);

    var has;

    for (var _i3 = 0; _i3 < _length; _i3++) {
      var _pi2 = p[_i3],
          _ni2 = n[_i3];

      if (!_pi2 || !_ni2) {
        res[1].push(null);
        continue;
      }

      var temp = [];

      for (var _j2 = 0; _j2 < 2; _j2++) {
        var pp = _pi2[_j2],
            nn = _ni2[_j2];

        if (pp[1] === nn[1]) {
          temp.push(nn[0] - pp[0]);
        } else {
          var _k = _i3 ? 'offsetWidth' : 'offsetHeight';

          if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            _k = _i3 ? 'clientWidth' : 'clientHeight';
          } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            _k = _i3 ? 'width' : 'height';
          }

          var _v7 = calByUnit(pp, nn, target[_k], target.root);

          temp.push(_v7 || 0);
        }
      }

      if (equalArr(temp, [0, 0])) {
        res[1].push(null);
      } else {
        res[1].push(temp);
        has = true;
      }
    }

    if (!has) {
      return;
    }
  } else if (GRADIENT_HASH.hasOwnProperty(k)) {
    // backgroundImage发生了渐变色和图片的变化，fill发生渐变色和纯色的变化等
    res[1] = [];

    var _length2 = Math.min(p.length, n.length);

    for (var _i4 = 0; _i4 < _length2; _i4++) {
      var _pi3 = p[_i4],
          _ni3 = n[_i4];

      if (!_pi3 || !_ni3 || isString(_pi3) || isString(_ni3)) {
        res[1].push(null);
        continue;
      }

      if (_pi3.k !== _ni3.k) {
        res[1].push(null);
        continue;
      }

      var _temp = []; // 渐变

      if (_pi3.k === 'linear' || _pi3.k === 'radial' || _pi3.k === 'conic') {
        var pv = _pi3.v;
        var nv = _ni3.v;
        _temp[0] = [];
        var clientWidth = target.clientWidth;
        var eq = equalArr(pv, nv);

        for (var _i5 = 0, _len = Math.min(pv.length, nv.length); _i5 < _len; _i5++) {
          var _a = pv[_i5];
          var _b = nv[_i5];
          var t = [];
          t.push([_b[0][0] - _a[0][0], _b[0][1] - _a[0][1], _b[0][2] - _a[0][2], _b[0][3] - _a[0][3]]);

          if (_a[1] && _b[1]) {
            if (_a[1][1] === _b[1][1]) {
              t.push(_b[1][0] - _a[1][0]);
            } else {
              var _v8 = calByUnit(_a[1], _b[1], clientWidth, target.root);

              t.push(_v8 || 0);
            }
          }

          _temp[0].push(t);
        } // 线性渐变有角度差值变化


        if (_pi3.k === 'linear') {
          var isArrP = Array.isArray(_pi3.d);
          var isArrN = Array.isArray(_ni3.d);

          if (isArrN !== isArrP) {
            res[1].push(null);
            continue;
          }

          if (isArrP) {
            var _v9 = [_ni3.d[0] - _pi3.d[0], _ni3.d[1] - _pi3.d[1], _ni3.d[2] - _pi3.d[2], _ni3.d[3] - _pi3.d[3]];

            if (eq && equalArr(_v9, [0, 0, 0, 0])) {
              res[1].push(null);
              continue;
            }

            _temp[1] = _v9;
          } else {
            var _v10 = _ni3.d - _pi3.d;

            if (eq && _v10 === 0) {
              res[1].push(null);
              continue;
            }

            _temp[1] = _v10;
          }
        } // 径向渐变的位置
        else if (_pi3.k === 'radial') {
          var _isArrP = Array.isArray(_pi3.z);

          var _isArrN = Array.isArray(_ni3.z);

          if (_isArrN !== _isArrP) {
            res[1].push(null);
            continue;
          }

          if (_isArrP) {
            _temp[2] = [];

            for (var _i6 = 0; _i6 < 5; _i6++) {
              var pz = _pi3.z[_i6]; // 半径比例省略为1

              if (pz === undefined) {
                pz = 1;
              }

              var nz = _ni3.z[_i6];

              if (nz === undefined) {
                nz = 1;
              }

              _temp[2].push(nz - pz);
            }

            if (eq && equalArr(res[4], [0, 0, 0, 0, 0])) {
              res[1].push(null);
            }
          } else {
            _temp[2] = [];

            for (var _i7 = 0; _i7 < 2; _i7++) {
              var _pp = _pi3.p[_i7];
              var np = _ni3.p[_i7];

              if (_pp[1] === np[1]) {
                _temp[2].push(np[0] - _pp[0]);
              } else {
                var _v11 = calByUnit(_pp, np, target[_i7 ? 'clientWidth' : 'clientHeight'], target.root);

                _temp[2].push(_v11 || 0);
              }
            }

            if (eq && equalArr(res[3], [0, 0])) {
              res[1].push(null);
            }
          }
        } else if (_pi3.k === 'conic') {
          _temp[1].push(n.d - p.d);

          _temp[2] = [];

          for (var _i8 = 0; _i8 < 2; _i8++) {
            var _pp2 = p.p[_i8];
            var _np = n.p[_i8];

            if (_pp2[1] === _np[1]) {
              _temp[2].push(_np[0] - _pp2[0]);
            } else {
              var _v12 = calByUnit(_pp2, _np, target[_i8 ? 'clientWidth' : 'clientHeight'], target.root);

              _temp[2].push(_v12 || 0);
            }
          }

          if (eq && res[2] !== 0 && equalArr(res[3], [0, 0])) {
            res[1].push(null);
          }
        }
      } // 纯色
      else {
        if (equalArr(n, _pi3)) {
          res[1].push(null);
        }

        _temp[0] = [_ni3[0] - _pi3[0], _ni3[1] - _pi3[1], _ni3[2] - _pi3[2], _ni3[3] - _pi3[3]];
      }

      res[1].push(_temp);
    }
  } else if (COLOR_HASH.hasOwnProperty(k)) {
    n = n[0];
    p = p[0];

    if (equalArr(n, p) || n[3] === 0 && p[3] === 0) {
      return;
    }

    res[1] = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3] - p[3]];
  } else if (RADIUS_HASH.hasOwnProperty(k)) {
    // x/y都相等无需
    if (n[0][0] === p[0][0] && n[0][1] === p[0][1] && n[1][0] === p[1][0] && n[1][1] === p[1][1]) {
      return;
    }

    res[1] = [];

    for (var _i9 = 0; _i9 < 2; _i9++) {
      if (n[_i9][1] === p[_i9][1]) {
        res[1].push(n[_i9][0] - p[_i9][0]);
      } else {
        var _v13 = calByUnit(p[_i9], n[_i9], target[_i9 ? 'outerHeight' : 'outerWidth'], target.root);

        res[1].push(_v13 || 0);
      }
    }
  } else if (LENGTH_HASH.hasOwnProperty(k)) {
    // auto不做动画
    if (p[1] === AUTO$5 || n[1] === AUTO$5) {
      return;
    }

    var computedStyle = target.computedStyle;
    var parentComputedStyle = (target.domParent || target).computedStyle;
    var diff = 0;

    if (p[1] === n[1]) {
      diff = n[0] - p[0];
    } // lineHeight奇怪的单位变化，%相对于fontSize
    else if (k === LINE_HEIGHT$2) {
      diff = calByUnit(p, n, computedStyle[FONT_SIZE$a], target.root);
    } // fontSize的%相对于parent的
    else if (k === FONT_SIZE$a) {
      diff = calByUnit(p, n, parentComputedStyle[FONT_SIZE$a], target.root);
    } // 相对于父height的特殊属性
    else if (k === FLEX_BASIS$3 && ['column', 'column-reverse', 'columnReverse'].indexOf(computedStyle[FLEX_DIRECTION$1]) > -1 || [HEIGHT$6, TOP$4, BOTTOM$4].indexOf(k) > -1) {
      if (p[1] !== AUTO$5 && n[1] !== AUTO$5) {
        diff = calByUnit(p, n, parentComputedStyle[HEIGHT$6], target.root);
      }
    } // 其余都是相对于父width的
    else {
      if (p[1] !== AUTO$5 && n[1] !== AUTO$5) {
        diff = calByUnit(p, n, parentComputedStyle[WIDTH$5], target.root);
      }
    } // 兜底NaN非法


    if (diff === 0 || isNaN(diff)) {
      return;
    }

    res[1] = diff;
  } else if (GEOM$1.hasOwnProperty(k)) {
    if (isNil$a(p)) {
      return;
    } else if (GEOM$1[k][tagName] && isFunction$4(GEOM$1[k][tagName].calDiff)) {
      var fn = GEOM$1[k][tagName].calDiff;

      if (target.isMulti) {
        var arr = [];

        for (var _i10 = 0, _len2 = Math.min(p.length, n.length); _i10 < _len2; _i10++) {
          arr.push(fn(p[_i10], n[_i10]));
        }

        return arr;
      } else {
        res[1] = fn(p, n);
      }
    } // 特殊处理multi
    else if (target.isMulti) {
      if (k === 'points' || k === 'controls') {
        if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res[1] = [];

        for (var _i11 = 0, _len3 = Math.min(p.length, n.length); _i11 < _len3; _i11++) {
          var _pv3 = p[_i11];
          var _nv3 = n[_i11];

          if (isNil$a(_pv3) || !_pv3.length || isNil$a(_nv3) || !_nv3.length) {
            res[1].push(null);
          } else {
            var v2 = [];

            for (var _j3 = 0, len2 = Math.min(_pv3.length, _nv3.length); _j3 < len2; _j3++) {
              var pv2 = _pv3[_j3];
              var nv2 = _nv3[_j3];

              if (isNil$a(pv2) || isNil$a(nv2)) {
                v2.push(null);
              } else {
                var v3 = [];

                for (var _k2 = 0, len3 = Math.max(pv2.length, nv2.length); _k2 < len3; _k2++) {
                  var pv3 = pv2[_k2];
                  var nv3 = nv2[_k2]; // control由4点变2点

                  if (isNil$a(pv3) || isNil$a(nv3)) {
                    v3.push(0);
                  } else {
                    v3.push(nv3 - pv3);
                  }
                }

                v2.push(v3);
              }
            }

            res[1].push(v2);
          }
        }
      } else if (k === 'controlA' || k === 'controlB') {
        if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res[1] = [];

        for (var _i12 = 0, _len4 = Math.min(p.length, n.length); _i12 < _len4; _i12++) {
          var _pv4 = p[_i12];
          var _nv4 = n[_i12];

          if (isNil$a(_pv4) || !_pv4.length || isNil$a(_nv4) || !_nv4.length) {
            res[1].push(null);
          } else {
            res[1].push([_nv4[0] - _pv4[0], _nv4[1] - _pv4[1]]);
          }
        }
      } else {
        if (n === p || equalArr(n, p) || k === 'edge' || k === 'closure') {
          return;
        }

        var _v14 = [];

        for (var _i13 = 0, _len5 = Math.min(p.length, n.length); _i13 < _len5; _i13++) {
          var _pv5 = p[_i13];
          var _nv5 = n[_i13];

          if (isNil$a(_pv5) || isNil$a(_nv5)) {
            _v14.push(0);
          }

          _v14.push(_nv5 - _pv5);
        }

        res[1] = _v14;
      }
    } // 非multi特殊处理这几类数组类型数据
    else if (k === 'points' || k === 'controls') {
      if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
        return;
      }

      res[1] = [];

      for (var _i14 = 0, _len6 = Math.min(p.length, n.length); _i14 < _len6; _i14++) {
        var _pv6 = p[_i14];
        var _nv6 = n[_i14];

        if (isNil$a(_pv6) || !_pv6.length || isNil$a(_nv6) || !_nv6.length) {
          res[1].push(null);
        } else {
          var _v15 = [];

          for (var _j4 = 0, _len7 = Math.max(_pv6.length, _nv6.length); _j4 < _len7; _j4++) {
            var _pv7 = _pv6[_j4];
            var _nv7 = _nv6[_j4]; // control由4点变2点

            if (isNil$a(_pv7) || isNil$a(_nv7)) {
              _v15.push(0);
            } else {
              _v15.push(_nv7 - _pv7);
            }
          }

          res[1].push(_v15);
        }
      }
    } else if (k === 'controlA' || k === 'controlB') {
      if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
        return;
      }

      res[1] = [n[0] - p[0], n[1] - p[1]];
    } // 其它简单数据，除了edge/closure没有增量
    else {
      if (n === p || k === 'edge' || k === 'closure') {
        return;
      } else {
        res[1] = n - p;
      }
    }
  } else if (k === OPACITY$3 || k === Z_INDEX$3) {
    if (n === p) {
      return;
    }

    res[1] = n - p;
  } // 特殊的path，不存在style中但在动画某帧中，不会统一化所以可能反向计算frameR时后一帧没有
  else if (k === TRANSLATE_PATH && p) {
    var k1 = 'offsetWidth',
        _k3 = 'offsetHeight';

    if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
      k1 = 'clientWidth';
      _k3 = 'clientHeight';
    } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
      k1 = 'width';
      _k3 = 'height';
    }

    res[1] = p.map(function (item, i) {
      var _item = _slicedToArray(item, 2),
          v = _item[0],
          u = _item[1];

      if (u === PERCENT$6) {
        if (i % 2 === 0) {
          return [(parseFloat(v) || 0) * 0.01 * target[k1], PX$6];
        } else {
          return [(parseFloat(v) || 0) * 0.01 * target[_k3], PX$6];
        }
      } else if (u === REM$a) {
        return [(parseFloat(v) || 0) * root.computedStyle[FONT_SIZE$a] * 100, PX$6];
      } else if (u === VW$a) {
        return [(parseFloat(v) || 0) * 0.01 * root.width, PX$6];
      } else if (u === VH$a) {
        return [(parseFloat(v) || 0) * 0.01 * root.height, PX$6];
      } else {
        return [parseFloat(v) || 0, PX$6];
      }
    });
  } // display等不能有增量过程的
  else {
    return;
  }

  return res;
} // 计算两帧之间不相同的变化，存入transition，相同的忽略


function calFrame(prev, next, keys, target, tagName) {
  keys.forEach(function (k) {
    var ts = calDiff(prev[FRAME_STYLE], next[FRAME_STYLE], k, target, tagName); // 可以形成过渡的才会产生结果返回

    if (ts) {
      prev[FRAME_TRANSITION].push(ts);
    }
  });
  return next;
}

function binarySearch(i, j, time, frames) {
  if (i === j) {
    var _frame = frames[i];

    if (_frame[FRAME_TIME] > time) {
      return i - 1;
    }

    return i;
  } else {
    var middle = i + (j - i >> 1);
    var _frame2 = frames[middle];

    if (_frame2[FRAME_TIME] === time) {
      return middle;
    } else if (_frame2[FRAME_TIME] > time) {
      return binarySearch(i, Math.max(middle - 1, i), time, frames);
    } else {
      return binarySearch(Math.min(middle + 1, j), j, time, frames);
    }
  }
}

function getEasing(ea) {
  var timingFunction;

  if (ea) {
    if (timingFunction = /^\s*steps\s*\(\s*(\d+)(?:\s*,\s*(\w+))?\s*\)/i.exec(ea)) {
      var steps = parseInt(timingFunction[1]);
      var stepsD = timingFunction[2];

      timingFunction = function timingFunction(percent) {
        // steps有效定义正整数
        if (steps && steps > 0) {
          var per = 1 / steps;
          var n = stepsD === 'start' ? Math.ceil(percent / per) : Math.floor(percent / per);
          return n / steps;
        }

        return percent;
      };
    } else {
      timingFunction = easing.getEasing(ea);
    }
  }

  return timingFunction;
}
/**
 * 根据百分比和缓动函数计算中间态样式
 * 当easing定义为steps时，优先计算
 * @param frame 当前帧
 * @param keys 所有样式key
 * @param percent 到下一帧时间的百分比
 * @param target vd
 * @returns {*}
 */


function calIntermediateStyle(frame, keys, percent, target) {
  var style = cloneStyle(frame[FRAME_STYLE], keys);
  var timingFunction = getEasing(frame[FRAME_EASING]);

  if (timingFunction && timingFunction !== linear) {
    percent = timingFunction(percent);
  }

  var transition = frame[FRAME_TRANSITION];

  var _loop = function _loop(i, len) {
    var _transition$i = _slicedToArray(transition[i], 2),
        k = _transition$i[0],
        v = _transition$i[1];

    var st = style[k]; // transform特殊处理，只有1个matrix，有可能不存在，需给默认矩阵

    if (k === TRANSFORM$2) {
      if (!st) {
        st = style[k] = [[MATRIX$1, mx.identity()]];
      }

      for (var _i15 = 0; _i15 < 16; _i15++) {
        st[0][1][_i15] += v[_i15] * percent;
      }
    } // 特殊的曲线运动计算，转换为translateXY，出现在最后一定会覆盖原本的translate防重
    else if (k === TRANSLATE_PATH) {
      var t = 1 - percent;

      if (v.length === 8) {
        style[TRANSLATE_X$1] = [v[0][0] * t * t * t + 3 * v[2][0] * percent * t * t + 3 * v[4][0] * percent * percent * t + v[6][0] * percent * percent * percent, PX$6];
        style[TRANSLATE_Y$1] = [v[1][0] * t * t * t + 3 * v[3][0] * percent * t * t + 3 * v[5][0] * percent * percent * t + v[7][0] * percent * percent * percent, PX$6];
      } else if (v.length === 6) {
        style[TRANSLATE_X$1] = [v[0][0] * t * t + 2 * v[2][0] * percent * t + v[4][0] * percent * percent, PX$6];
        style[TRANSLATE_Y$1] = [v[1][0] * t * t + 3 * v[3][0] * percent * t + v[5][0] * percent * percent, PX$6];
      }
    } else if (k === ROTATE_3D$1) {
      st[0] += v[0] * percent;
      st[1] += v[1] * percent;
      st[2] += v[2] * percent;
      st[3][0] += v[3][0] * percent;
    } else if (NUM_CAL_HASH.hasOwnProperty(k)) {
      if (v) {
        st[0] += v * percent;
      }
    } else if (k === FILTER$4) {
      // 只有1个样式声明了filter另外一个为空，会造成无样式，需初始化数组并在下面计算出样式存入
      if (!st) {
        st = style[k] = [];
      } // 将已有的样式按key存入引用来操作


      var hash = {};
      st.forEach(function (item) {
        hash[item[0]] = item[1];
      });
      Object.keys(v).forEach(function (k) {
        if (hash.hasOwnProperty(k)) {
          hash[k][0] += v[k][0] * percent;
        } else {
          // 2个关键帧中有1个未声明，需新建样式存入
          if (k === 'blur' || k === 'hue-rotate' || k === 'grayscale') {
            var n = v[k].slice(0);
            n[0] *= percent;
            st.push([k, n]);
          } // 默认值是1而非0
          else if (k === 'saturate' || k === 'brightness' || k === 'contrast') {
            var _n = v[k].slice(0);

            _n[0] = 100 + _n[0] * percent;
            st.push([k, _n]);
          }
        }
      });
    } else if (RADIUS_HASH.hasOwnProperty(k)) {
      for (var _i16 = 0; _i16 < 2; _i16++) {
        st[_i16][0] += v[_i16] * percent;
      }
    } else if (k === TRANSFORM_ORIGIN$2 || k === PERSPECTIVE_ORIGIN$2) {
      if (v[0] !== 0) {
        st[0][0] += v[0] * percent;
      }

      if (v[1] !== 0) {
        st[1][0] += v[1] * percent;
      }
    } else if (k === BOX_SHADOW$8) {
      for (var _i17 = 0, _len8 = Math.min(st.length, v.length); _i17 < _len8; _i17++) {
        // x/y/blur/spread
        for (var j = 0; j < 4; j++) {
          st[_i17][j] += v[_i17][j] * percent;
        } // rgba


        for (var _j5 = 0; _j5 < 4; _j5++) {
          st[_i17][4][_j5] += v[_i17][4][_j5] * percent;
        }
      }
    } else if (k === BACKGROUND_SIZE$1) {
      st.forEach(function (item, i) {
        if (v[i]) {
          item[0][0] += v[i][0] * percent;
          item[1][0] += v[i][1] * percent;
        }
      });
    } else if (k === BACKGROUND_POSITION_X$1 || k === BACKGROUND_POSITION_Y$1) {
      st.forEach(function (item, i) {
        if (v[i]) {
          item[0] += v[i] * percent;
        }
      });
    } else if (GRADIENT_HASH.hasOwnProperty(k)) {
      st.forEach(function (st2, i) {
        var v2 = v[i];

        if (!v2) {
          return;
        }

        var _v16 = _slicedToArray(v2, 4),
            c = _v16[0],
            d = _v16[1],
            p = _v16[2],
            z = _v16[3];

        if (GRADIENT_TYPE.hasOwnProperty(st2.k)) {
          for (var _i18 = 0, _len9 = Math.min(st2.v.length, c.length); _i18 < _len9; _i18++) {
            var a = st2.v[_i18];
            var b = c[_i18];
            a[0][0] += b[0][0] * percent;
            a[0][1] += b[0][1] * percent;
            a[0][2] += b[0][2] * percent;
            a[0][3] += b[0][3] * percent;

            if (a[1] && b[1]) {
              a[1][0] += b[1] * percent;
            }
          }

          if (st2.k === 'linear' && st2.d !== undefined && d !== undefined) {
            if (Array.isArray(d)) {
              st2.d[0] += d[0] * percent;
              st2.d[1] += d[1] * percent;
              st2.d[2] += d[2] * percent;
              st2.d[3] += d[3] * percent;
            } else {
              st2.d += d * percent;
            }
          }

          if (st2.k === 'radial') {
            if (st2.z !== undefined && z !== undefined) {
              st2.z[0] += z[0] * percent;
              st2.z[1] += z[1] * percent;
              st2.z[2] += z[2] * percent;
              st2.z[3] += z[3] * percent;
              st2.z[4] += z[4] * percent;
            } else if (st2.p !== undefined && p !== undefined) {
              st2.p[0][0] += p[0] * percent;
              st2.p[1][0] += p[1] * percent;
            }
          } else if (st2.k === 'conic' && st2.d !== undefined && d !== undefined) {
            st2.d += d * percent;
            st2.p[0][0] += p[0] * percent;
            st2.p[1][0] += p[1] * percent;
          }
        } // fill纯色
        else {
          st2[0] += c[0] * percent;
          st2[1] += c[1] * percent;
          st2[2] += c[2] * percent;
          st2[3] += c[3] * percent;
        }
      });
    } // color可能超限[0,255]，但浏览器已经做了限制，无需关心
    else if (COLOR_HASH.hasOwnProperty(k)) {
      st = st[0];
      st[0] += v[0] * percent;
      st[1] += v[1] * percent;
      st[2] += v[2] * percent;
      st[3] += v[3] * percent;
    } else if (GEOM$1.hasOwnProperty(k)) {
      var _st = style[k];
      var tagName = target.tagName;

      if (GEOM$1[k][tagName] && isFunction$4(GEOM$1[k][tagName].calIncrease)) {
        var fn = GEOM$1[k][tagName].calIncrease;

        if (target.isMulti) {
          style[k] = _st.map(function (item, i) {
            return fn(item, v[i], percent);
          });
        } else {
          style[k] = fn(_st, v, percent);
        }
      } else if (target.isMulti) {
        if (k === 'points' || k === 'controls') {
          for (var _i19 = 0, _len10 = Math.min(_st.length, v.length); _i19 < _len10; _i19++) {
            var o = _st[_i19];
            var n = v[_i19];

            if (!isNil$a(o) && !isNil$a(n)) {
              for (var _j6 = 0, len2 = Math.min(o.length, n.length); _j6 < len2; _j6++) {
                var o2 = o[_j6];
                var n2 = n[_j6];

                if (!isNil$a(o2) && !isNil$a(n2)) {
                  for (var _k4 = 0, len3 = Math.min(o2.length, n2.length); _k4 < len3; _k4++) {
                    if (!isNil$a(o2[_k4]) && !isNil$a(n2[_k4])) {
                      o2[_k4] += n2[_k4] * percent;
                    }
                  }
                }
              }
            }
          }
        } else if (k === 'controlA' || k === 'controlB') {
          v.forEach(function (item, i) {
            var st2 = _st[i];

            if (!isNil$a(item) && !isNil$a(st2)) {
              for (var _i20 = 0, _len11 = Math.min(st2.length, item.length); _i20 < _len11; _i20++) {
                var _o = st2[_i20];
                var _n2 = item[_i20];

                if (!isNil$a(_o) && !isNil$a(_n2)) {
                  st2[_i20] += _n2 * percent;
                }
              }
            }
          });
        } else {
          v.forEach(function (item, i) {
            if (!isNil$a(item) && !isNil$a(_st[i])) {
              _st[i] += item * percent;
            }
          });
        }
      } else {
        if (k === 'points' || k === 'controls') {
          for (var _i21 = 0, _len12 = Math.min(_st.length, v.length); _i21 < _len12; _i21++) {
            var _o2 = _st[_i21];
            var _n3 = v[_i21];

            if (!isNil$a(_o2) && !isNil$a(_n3)) {
              for (var _j7 = 0, _len13 = Math.min(_o2.length, _n3.length); _j7 < _len13; _j7++) {
                if (!isNil$a(_o2[_j7]) && !isNil$a(_n3[_j7])) {
                  _o2[_j7] += _n3[_j7] * percent;
                }
              }
            }
          }
        } else if (k === 'controlA' || k === 'controlB') {
          if (!isNil$a(_st[0]) && !isNil$a(v[0])) {
            _st[0] += v[0] * percent;
          }

          if (!isNil$a(_st[1]) && !isNil$a(v[1])) {
            _st[1] += v[1] * percent;
          }
        } else {
          if (!isNil$a(_st) && !isNil$a(v)) {
            style[k] += v * percent;
          }
        }
      }
    } else if (k === OPACITY$3 || k === Z_INDEX$3) {
      style[k] += v * percent; // 精度问题可能会超过[0,1]区间

      if (k === OPACITY$3) {
        if (style[k] < 0) {
          style[k] = 0;
        } else if (style[k] > 1) {
          style[k] = 1;
        }
      }
    }
  };

  for (var i = 0, len = transition.length; i < len; i++) {
    _loop(i);
  }

  return style;
}

function gotoOverload(options, cb) {
  if (isFunction$4(options)) {
    cb = options;
    options = {};
  }

  return [options || {}, cb];
}

var uuid$1 = 0;
var I_ASSIGNING = 0;
var I_IN_FPS = 1;
var I_IS_DELAY = 2;
var I_BEGIN = 3;
var I_END = 4;
var I_FINISHED = 5;
var I_NEXT_END = 6;
var I_FIRST_PLAY = 7;
var I_FRAME_CB = 8;
var I_PLAY_CB = 9;
var I_TARGET = 10;
var I_ROOT = 11;
var I_FRAMES = 12;
var I_FRAMES_R = 13;
var I_CURRENT_TIME = 14;
var I_NEXT_TIME = 15;
var I_STYLE = 16;
var I_DURATION = 17;
var I_ITERATIONS = 18;
var I_FILL = 19;
var I_PLAYBACK_RATE = 20;
var I_PLAY_COUNT = 21;
var I_PLAY_STATE = 22;
var I_DESTROYED = 23;
var I_START_TIME = 24;
var I_FPS_TIME = 25;
var I_EASING = 26;
var I_ENTER_FRAME = 27;
var I_DELAY = 28;
var I_END_DELAY = 29;
var I_KEYS = 30;
var I_ORIGIN_STYLE = 31;
var I_CURRENT_FRAMES = 32;
var I_CURRENT_FRAME = 33;
var I_SPF_LIMIT = 34;
var I_FPS = 35;
var I_DIRECTION = 36;
var I_CAL_DIFF_TIME = 37;
var I_FIRST_ENTER = 38;
var I_STAY_BEGIN = 39;
var I_STAY_END = 40;
var I_IS2 = 41;
var I_END_TIME = 42;
var I_NODE_CONFIG = 43;
var I_ROOT_CONFIG = 44;
var I_OUT_BEGIN_DELAY = 45;
var I_TIME_STAMP = 46;

var Animation = /*#__PURE__*/function (_Event) {
  _inherits(Animation, _Event);

  var _super = _createSuper(Animation);

  function Animation(target, list, options) {
    var _this;

    _classCallCheck(this, Animation);

    _this = _super.call(this);
    _this.__id = uuid$1++;
    list = clone$1(list || []);

    if (Array.isArray(list)) {
      list = list.filter(function (item) {
        return item && isObject$1(item);
      });
    } // 动画过程另外一种形式，object描述k-v形式
    else if (list && isObject$1(list)) {
      var nl = [];
      Object.keys(list).forEach(function (k) {
        var v = list[k];

        if (Array.isArray(v)) {
          for (var i = 0, len = v.length; i < len; i++) {
            var o = nl[i] = nl[i] || {
              offset: i / (len - 1)
            };
            o[k] = v[i];
          }
        }
      });
      list = nl;
    } else {
      list = [];
    }

    if (isNumber(options)) {
      _this.__options = {
        duration: options
      };
      options = _this.__options;
    }

    var op = _this.__options = options || {
      duration: 0
    };
    var root = target.root;
    var config = _this.__config = [false, // assigning
    false, // inFps
    false, // isDelay
    false, // begin
    false, // end
    false, // finished
    false, // nextBegin
    true, // firstPlay
    _this.__frameCb, null, // playCb
    target, root, null, // frames
    null, // framesR
    0, // currentTime
    0, // nextTime
    {}, // style
    0, // duration
    1, // iterations
    'none', // fill
    1, // playbackRate
    0, // playCount
    'idle', false, // destroy
    0, // startTime
    0, // fpsTime
    op.easing, false, // enterFrame
    0, // delay
    0, // endDelay
    null, // keys,
    null, // originStyle,
    null, // currentFrames
    null, // currentFrame
    false, // spfLimit
    60, // fps
    'normal', // direction
    _this.__calDiffTime, true, // firstEnter,
    false, // stayBegin
    false, // stayEnd
    false, // is2
    0, // endTime
    target.__config, // nodeConfig
    root && root.__config, // rootConfig，destroy后root可能为空
    false // outBeginDelay
    ];
    var iterations = _this.iterations = op.iterations;
    var duration = _this.duration = op.duration;

    var _this$__init = _this.__init(list, iterations, duration, op.easing, target),
        _this$__init2 = _slicedToArray(_this$__init, 4),
        frames = _this$__init2[0],
        framesR = _this$__init2[1],
        keys = _this$__init2[2],
        originStyle = _this$__init2[3];

    config[I_FRAMES] = frames;
    config[I_FRAMES_R] = framesR;
    config[I_KEYS] = keys;
    config[I_ORIGIN_STYLE] = originStyle;

    if (frames.length === 2) {
      config[I_IS2] = true;
      config[I_END_TIME] = frames[1][FRAME_TIME];
    }

    var fps = parseInt(op.fps) || 0;

    if (fps <= 0) {
      fps = 60;
    }

    _this.fps = fps;
    _this.spfLimit = op.spfLimit;
    _this.delay = op.delay;
    _this.endDelay = op.endDelay;
    _this.playbackRate = op.playbackRate;
    _this.fill = op.fill;
    _this.iterations = op.iterations;
    _this.direction = op.direction;
    config[I_CURRENT_FRAMES] = {
      reverse: true,
      'alternate-reverse': true
    }.hasOwnProperty(op.direction) ? framesR : frames; // 时间戳

    config[I_TIME_STAMP] = frame.__now; // 性能优化访问

    _this[0] = _this.__before;
    _this[1] = _this.__after;
    return _this;
  }

  _createClass(Animation, [{
    key: "__init",
    value: function __init(list, iterations, duration, easing, target) {
      if (list.length < 1) {
        return [[], [], [], {}];
      } // 过滤时间非法的，过滤后续offset<=前面的


      var offset = -1;
      var tagName = target.tagName;

      var _loop2 = function _loop2(_i22, _len14) {
        var current = list[_i22];

        if (current.hasOwnProperty('offset')) {
          current.offset = parseFloat(current.offset) || 0;
          current.offset = Math.max(0, current.offset);
          current.offset = Math.min(1, current.offset); // 超过区间[0,1]

          if (isNaN(current.offset) || current.offset < 0 || current.offset > 1) {
            list.splice(_i22, 1);
            _i22--;
            _len14--;
            i = _i22;
            len = _len14;
            return "continue";
          } // <=前面的
          else if (current.offset <= offset) {
            list.splice(_i22, 1);
            _i22--;
            _len14--;
            i = _i22;
            len = _len14;
            return "continue";
          }
        } // 缩写处理


        Object.keys(current).forEach(function (k) {
          if (abbr$1.hasOwnProperty(k)) {
            abbr$1.toFull(current, k);
          }
        }); // 检查key合法性

        Object.keys(current).forEach(function (k) {
          if (k !== 'easing' && k !== 'offset' && !o$2.isValid(tagName, k)) {
            delete current[k];
          }
        });
        i = _i22;
        len = _len14;
      };

      for (var i = 0, len = list.length; i < len; i++) {
        var _ret = _loop2(i, len);

        if (_ret === "continue") continue;
      } // 只有1帧复制出来变成2帧方便运行


      if (list.length === 1) {
        list[0] = clone$1(list[0]);

        if (list[0].offset === 1) {
          list.unshift({
            offset: 0
          });
        } else {
          var copy = clone$1(list[0]);
          copy.offset = 1;
          list.push(copy);
        }
      } // 强制clone防止同引用
      else {
        list.forEach(function (item, i) {
          list[i] = clone$1(item);
        });
      } // 首尾时间偏移强制为[0, 1]，不是的话前后加空帧


      var first = list[0];

      if (first.hasOwnProperty('offset') && first.offset > 0) {
        first = {
          offset: 0
        };
        list.unshift(first);
      } else {
        first.offset = 0;
      }

      var last = list[list.length - 1];

      if (last.hasOwnProperty('offset') && last.offset < 1) {
        last = {
          offset: 1
        };
        list.push(last);
      } else {
        last.offset = 1;
      } // 计算没有设置offset的时间


      for (var _i23 = 1, _len15 = list.length; _i23 < _len15; _i23++) {
        var start = list[_i23]; // 从i=1开始offset一定>0，找到下一个有offset的，均分中间无声明的

        if (!start.hasOwnProperty('offset')) {
          var end = void 0;
          var j = _i23 + 1;

          for (; j < _len15; j++) {
            end = list[j];

            if (end.hasOwnProperty('offset')) {
              break;
            }
          }

          var num = j - _i23 + 1;
          start = list[_i23 - 1];
          var per = (end.offset - start.offset) / num;

          for (var k = _i23; k < j; k++) {
            var item = list[k];
            item.offset = start.offset + per * (k + 1 - _i23);
          }

          _i23 = j;
        }
      }

      var frames = []; // 换算每一关键帧样式标准化

      list.forEach(function (item) {
        frames.push(framing(item, duration, easing));
      }); // 为方便两帧之间计算变化，强制统一所有帧的css属性相同，没有写的为节点的当前样式currentStyle

      var keys = unify(frames, target);
      inherit(frames, keys, target);
      var framesR = clone$1(frames).reverse(); // 存储原本样式以便恢复用

      var style = target.style,
          props = target.props;
      var originStyle = {};
      keys.forEach(function (k) {
        if (isGeom$1(tagName, k)) {
          originStyle[k] = props[k];
        }

        originStyle[k] = style[k];
      }); // 再计算两帧之间的变化，存入transition属性

      var length = frames.length;
      var prev = frames[0];

      for (var _i24 = 1; _i24 < length; _i24++) {
        var next = frames[_i24];
        prev = calFrame(prev, next, keys, target, tagName);
      } // 反向存储帧的倒排结果


      framesR.forEach(function (item) {
        item[FRAME_TIME] = duration - item[FRAME_TIME];
        item[FRAME_TRANSITION] = [];
      });
      prev = framesR[0];

      for (var _i25 = 1; _i25 < length; _i25++) {
        var _next = framesR[_i25];
        prev = calFrame(prev, _next, keys, target, tagName);
      }

      return [frames, framesR, keys, originStyle];
    }
  }, {
    key: "__clean",
    value: function __clean(isFinish) {
      var __config = this.__config;

      this.__cancelTask();

      __config[I_NEXT_TIME] = 0;
      var restore;
      var style = __config[I_STYLE];
      var keys = __config[I_KEYS];
      var target = __config[I_TARGET];

      if (isFinish) {
        __config[I_CURRENT_TIME] = __config[I_DELAY] + __config[I_DURATION] + __config[I_END_DELAY];

        if (__config[I_PLAY_STATE] === 'finish') {
          return;
        }

        __config[I_PLAY_STATE] = 'finish'; // cancel需要清除finish根据情况保留

        if (!__config[I_STAY_END]) {
          __config[I_STYLE] = {};
          restore = true;
        }
      } else {
        __config[I_PLAY_COUNT] = __config[I_CURRENT_TIME] = 0;

        if (__config[I_PLAY_STATE] === 'idle') {
          return;
        }

        __config[I_PLAY_STATE] = 'idle';
        __config[I_STYLE] = {};
        restore = true;
      } // 动画取消结束不停留在最后一帧需要还原target原本的样式，需要对比目前是否是由本动画赋值的


      if (restore) {
        keys.forEach(function (k) {
          if (GEOM$1.hasOwnProperty(k)) {
            if (target.__currentProps[k] === style[k]) {
              target.__currentProps[k] = target.props[k];
            }
          } else {
            if (target.__currentStyle[k] === style[k]) {
              target.__currentStyle[k] = target.style[k];
            }
          }
        });
      }
    }
  }, {
    key: "__frameCb",
    value: function __frameCb(__config, diff, isDelay) {
      this.emit(Event.FRAME, diff, isDelay);

      if (__config[I_FIRST_PLAY]) {
        __config[I_FIRST_PLAY] = false;
        this.emit(Event.PLAY);
      }

      if (isFunction$4(__config[I_PLAY_CB])) {
        __config[I_PLAY_CB].call(this, diff, isDelay);

        __config[I_PLAY_CB] = null;
      }
    }
  }, {
    key: "__calDiffTime",
    value: function __calDiffTime(__config, diff) {
      var playbackRate = __config[I_PLAYBACK_RATE];
      var spfLimit = __config[I_SPF_LIMIT];
      var fps = __config[I_FPS];
      var v = __config[I_CURRENT_TIME] = __config[I_NEXT_TIME]; // 定帧限制每帧时间间隔最大为spf

      if (spfLimit) {
        if (spfLimit === true) {
          diff = Math.min(diff, 1000 / fps);
        } else if (spfLimit > 0) {
          diff = Math.min(diff, spfLimit);
        }
      } // 播放时间累加，并且考虑播放速度加成


      if (playbackRate !== 1 && playbackRate > 0) {
        diff *= playbackRate;
      }

      __config[I_NEXT_TIME] += diff;
      return [v, diff];
    }
  }, {
    key: "play",
    value: function play(cb) {
      var __config = this.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var playState = __config[I_PLAY_STATE];
      var frames = __config[I_FRAMES];

      if (isDestroyed || duration <= 0 || frames.length < 1) {
        return this;
      }

      if (playState === 'running') {
        return this;
      }

      this.__cancelTask();

      __config[I_PLAY_CB] = cb;
      __config[I_PLAY_STATE] = 'running'; // 每次play调用标识第一次运行，需响应play事件和回调

      __config[I_FIRST_PLAY] = true; // 防止finish/cancel事件重复触发，每次播放重置

      this.__hasFin = false;
      this.__hasCancel = false; // 只有第一次调用会进初始化，另外finish/cancel视为销毁也会重新初始化

      if (!__config[I_ENTER_FRAME]) {
        __config[I_ENTER_FRAME] = true;
        var framesR = __config[I_FRAMES_R];
        var direction = __config[I_DIRECTION]; // 初始化根据方向确定帧序列

        __config[I_CURRENT_FRAMES] = {
          reverse: true,
          'alternate-reverse': true
        }.hasOwnProperty(direction) ? framesR : frames;
        __config[I_CURRENT_TIME] = __config[I_NEXT_TIME] = __config[I_FPS_TIME] = 0;
      } // 添加每帧回调且立刻执行，本次执行调用refreshTask也是下一帧再渲染，frame的每帧都是下一帧


      frame.offFrame(this);
      frame.onFrame(this);
      __config[I_START_TIME] = frame.__now;
      __config[I_END] = false;
      return this;
    }
  }, {
    key: "__before",
    value: function __before(diff) {
      var __config = this.__config;
      __config[I_TIME_STAMP] = frame.__now;
      var target = __config[I_TARGET];
      var fps = __config[I_FPS];
      var playCount = __config[I_PLAY_COUNT];
      var currentFrames = __config[I_CURRENT_FRAMES];
      var iterations = __config[I_ITERATIONS];
      var stayBegin = __config[I_STAY_BEGIN];
      var stayEnd = __config[I_STAY_END];
      var delay = __config[I_DELAY];
      var root = __config[I_ROOT];
      var is2 = __config[I_IS2];
      var endTime = __config[I_END_TIME];
      var duration = __config[I_DURATION];
      var endDelay = __config[I_END_DELAY];
      var length = currentFrames.length; // 用本帧和上帧时间差，计算累加运行时间currentTime，以便定位当前应该处于哪个时刻

      var _config$I_CAL_DIFF_T = __config[I_CAL_DIFF_TIME](__config, diff),
          _config$I_CAL_DIFF_T2 = _slicedToArray(_config$I_CAL_DIFF_T, 2),
          currentTime = _config$I_CAL_DIFF_T2[0],
          d = _config$I_CAL_DIFF_T2[1];

      diff = d; // 增加的fps功能，当<60时计算跳帧，每帧运行依旧累加时间，达到fps时重置，第一帧强制不跳

      if (!__config[I_FIRST_ENTER] && fps < 60) {
        diff = __config[I_FPS_TIME] += diff;

        if (diff < 1000 / fps) {
          __config[I_IN_FPS] = true;
          return;
        }

        __config[I_FPS_TIME] = 0;
      }

      __config[I_FIRST_ENTER] = false; // delay仅第一次生效

      if (playCount === 0 && currentTime < delay) {
        if (stayBegin) {
          var _currentFrame = __config[I_CURRENT_FRAME] = currentFrames[0];

          var _current = _currentFrame[FRAME_STYLE];
          genBeforeRefresh(_current, __config[I_KEYS], __config, root, target);
        } // 即便不刷新，依旧执行帧回调，同时标明让后续第一帧响应begin


        __config[I_OUT_BEGIN_DELAY] = true;
        __config[I_IS_DELAY] = true;
        return;
      } // 减去delay，计算在哪一帧，仅首轮


      if (playCount === 0) {
        currentTime -= delay;
      }

      if (currentTime === 0 || __config[I_OUT_BEGIN_DELAY]) {
        __config[I_OUT_BEGIN_DELAY] = false;
        __config[I_BEGIN] = true;
      } // 超过duration非尾轮需处理回到开头，触发新一轮动画事件，这里可能时间间隔非常大直接跳过几轮


      var round;

      while (currentTime >= duration && playCount < iterations - 1) {
        currentTime -= duration;
        __config[I_NEXT_TIME] -= duration;
        playCount = ++__config[I_PLAY_COUNT];
        __config[I_BEGIN] = true;
        round = true;
      } // 如果发生轮换，需重新确定正反向


      if (round) {
        var direction = __config[I_DIRECTION];
        var frames = __config[I_FRAMES];
        var framesR = __config[I_FRAMES_R];
        var isAlternate = {
          alternate: true,
          'alternate-reverse': true
        }.hasOwnProperty(direction); // 有正反向播放需要重设帧序列

        if (isAlternate) {
          var isEven = playCount % 2 === 0;

          if (direction === 'alternate') {
            currentFrames = __config[I_CURRENT_FRAMES] = isEven ? frames : framesR;
          } else {
            currentFrames = __config[I_CURRENT_FRAMES] = isEven ? framesR : frames;
          }
        }
      }

      var isLastCount = playCount >= iterations - 1; // 只有2帧可优化，否则2分查找当前帧

      var i, frameTime;

      if (is2) {
        i = currentTime < endTime ? 0 : 1;
        frameTime = endTime;
      } else {
        i = binarySearch(0, length - 1, currentTime, currentFrames);
        frameTime = currentFrames[i][FRAME_TIME];
      } // 最后一帧结束动画，仅最后一轮才会进入，需处理endDelay


      var isLastFrame = isLastCount && i === length - 1;
      var percent = 0;

      if (isLastFrame) ; // 否则根据目前到下一帧的时间差，计算百分比，再反馈到变化数值上
      else if (is2) {
        percent = currentTime / duration;
      } else {
        var total = currentFrames[i + 1][FRAME_TIME] - frameTime;
        percent = (currentTime - frameTime) / total;
      }

      var inEndDelay,
          currentFrame = currentFrames[i],
          current;
      __config[I_CURRENT_FRAME] = currentFrame;
      /** 这里要考虑全几种场景：
       * 1. 单次播放无endDelay且fill不停留（有/无差异，下同）
       * 2. 单次播放无endDelay且fill停留
       * 3. 单次播放有endDelay且fill不停留
       * 4. 单次播放有endDelay且fill停留
       * 5. 多次播放无endDelay且fill不停留（尾次/非尾次，下同）
       * 6. 多次播放无endDelay且fill停留
       * 7. 多次播放有endDelay且fill不停留
       * 8. 多次播放有endDelay且fill停留
       */

      var needClean;

      if (isLastFrame) {
        inEndDelay = currentTime < duration + endDelay; // 停留对比最后一帧，endDelay可能会多次进入这里，第二次进入样式相等不再重绘

        if (stayEnd) {
          current = cloneStyle(currentFrame[FRAME_STYLE], __config[I_KEYS]);
        } // 不停留或超过endDelay则计算还原，有endDelay且fill模式不停留会再次进入这里
        else {
          current = cloneStyle(__config[I_ORIGIN_STYLE], __config[I_KEYS]);
        } // 进入endDelay或结束阶段触发end事件，注意只触发一次，防重在触发的地方做


        __config[I_NEXT_END] = true;

        if (!inEndDelay) {
          __config[I_PLAY_COUNT]++;
          __config[I_FINISHED] = true;
          frame.offFrame(this);
          needClean = true;
          __config[I_NEXT_TIME] = 0;
        }
      } else {
        current = calIntermediateStyle(currentFrame, __config[I_KEYS], percent, target);
      } // 无论两帧之间是否有变化，都生成计算结果赋给style，去重在root做


      genBeforeRefresh(current, __config[I_KEYS], __config, root, target);

      if (needClean) {
        this.__clean(true);
      }
    }
  }, {
    key: "__after",
    value: function __after(diff) {
      var __config = this.__config;
      __config[I_ASSIGNING] = false;

      if (__config[I_IN_FPS]) {
        __config[I_IN_FPS] = false;
        return;
      }

      __config[I_FRAME_CB].call(this, __config, diff, __config[I_IS_DELAY]);

      __config[I_IS_DELAY] = false;

      if (__config[I_BEGIN]) {
        __config[I_BEGIN] = false;
        this.emit(Event.BEGIN, __config[I_PLAY_COUNT]);
      } // end事件只触发一次，末轮进入endDelay或直接结束时


      if (__config[I_NEXT_END] && !__config[I_END]) {
        __config[I_END] = true;
        this.emit(Event.END, __config[I_PLAY_COUNT] - 1);
      }

      if (__config[I_FINISHED]) {
        __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
        __config[I_PLAY_STATE] = 'finished';
        this.emit(Event.FINISH);
      }
    }
  }, {
    key: "pause",
    value: function pause(silence) {
      var __config = this.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var pending = this.pending;

      if (isDestroyed || duration <= 0 || pending) {
        return this;
      }

      __config[I_PLAY_STATE] = 'paused';

      this.__cancelTask();

      if (!silence) {
        this.emit(Event.PAUSE);
      }

      return this;
    }
  }, {
    key: "resume",
    value: function resume(cb) {
      var __config = this.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var playState = __config[I_PLAY_STATE];

      if (isDestroyed || duration <= 0 || playState !== 'paused') {
        return this;
      }

      return this.play(cb);
    }
  }, {
    key: "finish",
    value: function finish(cb) {
      var self = this;
      var __config = self.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var playState = __config[I_PLAY_STATE];
      var frames = __config[I_FRAMES];

      if (isDestroyed || duration <= 0 || frames.length < 1 || playState === 'finished' || playState === 'idle') {
        return self;
      } // 先清除所有回调任务，多次调用finish也会清除只留最后一次


      self.__cancelTask();

      var root = __config[I_ROOT];
      var originStyle = __config[I_ORIGIN_STYLE];

      if (root) {
        var current; // 停留在最后一帧

        if (__config[I_STAY_END]) {
          __config[I_CURRENT_FRAME] = frames[frames.length - 1];
          current = frames[frames.length - 1][FRAME_STYLE];
        } else {
          current = originStyle;
        }

        root.addRefreshTask({
          __before: function __before() {
            __config[I_ASSIGNING] = true;
            genBeforeRefresh(current, __config[I_KEYS], __config, root, __config[I_TARGET]);

            self.__clean(true);
          },
          __after: function __after(diff) {
            if (!self.__hasFin) {
              self.__hasFin = true;
              __config[I_ASSIGNING] = false;

              __config[I_FRAME_CB].call(self, __config, diff);

              __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
              self.emit(Event.FINISH);
            }

            if (isFunction$4(cb)) {
              cb.call(self, diff);
            }
          }
        });
      }

      return self;
    }
  }, {
    key: "cancel",
    value: function cancel(cb) {
      var self = this;
      var __config = self.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var playState = __config[I_PLAY_STATE];
      var frames = __config[I_FRAMES];

      if (isDestroyed || duration <= 0 || playState === 'idle' || frames.length < 1) {
        return self;
      }

      self.__cancelTask();

      var root = __config[I_ROOT];
      var originStyle = __config[I_ORIGIN_STYLE];

      if (root) {
        root.addRefreshTask({
          __before: function __before() {
            __config[I_ASSIGNING] = true;
            genBeforeRefresh(originStyle, __config[I_KEYS], __config, root, __config[I_TARGET]);

            self.__clean();
          },
          __after: function __after(diff) {
            if (!self.__hasCancel) {
              self.__hasCancel = true;
              __config[I_ASSIGNING] = false;

              __config[I_FRAME_CB].call(self, __config, diff);

              __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
              self.emit(Event.CANCEL);
            }

            if (isFunction$4(cb)) {
              cb.call(self, diff);
            }
          }
        });
      }

      return self;
    }
  }, {
    key: "gotoAndPlay",
    value: function gotoAndPlay(v, options, cb) {
      var __config = this.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var frames = __config[I_FRAMES];
      var delay = __config[I_DELAY];
      var endDelay = __config[I_END_DELAY];

      if (isDestroyed || duration <= 0 || frames.length < 1) {
        return this;
      }

      var _gotoOverload = gotoOverload(options, cb);

      var _gotoOverload2 = _slicedToArray(_gotoOverload, 2);

      options = _gotoOverload2[0];
      cb = _gotoOverload2[1];

      // 计算出时间点直接累加播放
      this.__goto(v, options.isFrame, options.excludeDelay);

      if (v > duration + delay + endDelay) {
        return this.finish(cb);
      }

      return this.play(cb);
    }
  }, {
    key: "gotoAndStop",
    value: function gotoAndStop(v, options, cb) {
      var _this2 = this;

      var __config = this.__config;
      var isDestroyed = __config[I_DESTROYED];
      var duration = __config[I_DURATION];
      var frames = __config[I_FRAMES];
      var delay = __config[I_DELAY];
      var endDelay = __config[I_END_DELAY];

      if (isDestroyed || duration <= 0 || frames.length < 1) {
        return this;
      }

      var _gotoOverload3 = gotoOverload(options, cb);

      var _gotoOverload4 = _slicedToArray(_gotoOverload3, 2);

      options = _gotoOverload4[0];
      cb = _gotoOverload4[1];
      v = this.__goto(v, options.isFrame, options.excludeDelay);

      if (v > duration + delay + endDelay) {
        return this.finish(cb);
      } // 先play一帧，回调里模拟暂停


      return this.play(function (diff) {
        __config[I_PLAY_STATE] = 'paused';

        _this2.__cancelTask();

        if (isFunction$4(cb)) {
          cb.call(_this2, diff);
        }
      });
    } // 同步赋予，用在extendAnimate

  }, {
    key: "assignCurrentStyle",
    value: function assignCurrentStyle() {
      var __config = this.__config;
      var style = __config[I_STYLE];
      var target = __config[I_TARGET];
      var keys = __config[I_KEYS];
      keys.forEach(function (i) {
        if (style.hasOwnProperty(i)) {
          var v = style[i]; // geom的属性变化

          if (GEOM$1.hasOwnProperty(i)) {
            target.currentProps[i] = v;
          } // 样式
          else {
            // 将动画样式直接赋给currentStyle
            target.currentStyle[i] = v;
          }
        }
      });
    }
  }, {
    key: "__goto",
    value: function __goto(v, isFrame, excludeDelay) {
      var __config = this.__config;
      var duration = __config[I_DURATION];
      __config[I_PLAY_STATE] = 'paused';

      this.__cancelTask();

      if (isNaN(v) || v < 0) {
        throw new Error('Param of gotoAnd(Play/Stop) is illegal: ' + v);
      }

      if (isFrame) {
        v = (v - 1) / this.spf;
      }

      if (excludeDelay) {
        v += __config[I_DELAY];
      } // 超过一轮去掉delay


      if (v > duration + __config[I_DELAY]) {
        v -= __config[I_DELAY];
      } // 超过时间长度需要累加次数


      __config[I_PLAY_COUNT] = 0;

      while (v > duration && __config[I_PLAY_COUNT] < __config[I_ITERATIONS] - 1) {
        __config[I_PLAY_COUNT]++;
        v -= duration;
      } // 在时间范围内设置好时间，复用play直接跳到播放点


      __config[I_NEXT_TIME] = v; // 防止play()重置时间和当前帧组，提前计算好

      __config[I_ENTER_FRAME] = true;
      var frames = __config[I_FRAMES];
      var framesR = __config[I_FRAMES_R];
      var direction = __config[I_DIRECTION];

      if ({
        alternate: true,
        'alternate-reverse': true
      }.hasOwnProperty(direction)) {
        var isEven = __config[I_PLAY_COUNT] % 2 === 0;

        if (direction === 'alternate') {
          __config[I_CURRENT_FRAMES] = isEven ? frames : framesR;
        } else {
          __config[I_CURRENT_FRAMES] = isEven ? framesR : frames;
        }
      }

      return v;
    }
  }, {
    key: "addControl",
    value: function addControl() {
      var ac = this.root.animateController;

      if (ac) {
        ac.add(this);
      }
    }
  }, {
    key: "removeControl",
    value: function removeControl() {
      var ac = this.root.animateController;

      if (ac) {
        ac.remove(this);
      }
    }
  }, {
    key: "__stayBegin",
    value: function __stayBegin() {
      return {
        backwards: true,
        both: true
      }.hasOwnProperty(this.fill);
    }
  }, {
    key: "__stayEnd",
    value: function __stayEnd() {
      return {
        forwards: true,
        both: true
      }.hasOwnProperty(this.fill);
    }
  }, {
    key: "__setTarget",
    value: function __setTarget(target) {
      this.__target = target;
      this.__config[I_TARGET] = target;
      this.__config[I_NODE_CONFIG] = target.__config;
    }
  }, {
    key: "__cancelTask",
    value: function __cancelTask() {
      frame.offFrame(this);
      this.__config[I_PLAY_CB] = null;
    }
  }, {
    key: "__destroy",
    value: function __destroy(sync) {
      var self = this;
      var __config = self.__config;

      if (__config[I_DESTROYED]) {
        return;
      }

      self.removeControl(); // clean异步执行，因为里面的样式还原需要等到下一帧，否则同步执行清除后，紧接着的新同步动画获取不到currentStyle

      if (sync) {
        self.__clean();

        __config[I_TARGET] = null;
      } else {
        frame.nextFrame({
          __before: function __before() {
            self.__clean();

            __config[I_TARGET] = null;
          }
        });
      }

      __config[I_START_TIME] = 0;
      __config[I_DESTROYED] = true;
    }
  }, {
    key: "__checkModify",
    value: function __checkModify() {
      var __config = this.__config;

      if (__config[I_PLAY_STATE] !== 'idle' && __config[I_PLAY_STATE] !== 'finished') {
        inject.warn('Modification will not come into effect when animation is running');
      }
    }
  }, {
    key: "id",
    get: function get() {
      return this.__id;
    }
  }, {
    key: "target",
    get: function get() {
      return this.__config[I_TARGET];
    }
  }, {
    key: "root",
    get: function get() {
      return this.__config[I_ROOT];
    }
  }, {
    key: "keys",
    get: function get() {
      return this.__config[I_KEYS];
    }
  }, {
    key: "style",
    get: function get() {
      return this.__config[I_STYLE];
    }
  }, {
    key: "options",
    get: function get() {
      return this.__options;
    }
  }, {
    key: "duration",
    get: function get() {
      return this.__config[I_DURATION];
    },
    set: function set(v) {
      v = Math.max(0, parseFloat(v) || 0);
      var __config = this.__config;

      if (__config[I_DURATION] !== v) {
        __config[I_DURATION] = v;
        __config[I_END_TIME] = v;

        this.__checkModify();
      }

      return v;
    }
  }, {
    key: "delay",
    get: function get() {
      return this.__config[I_DELAY];
    },
    set: function set(v) {
      v = Math.max(0, parseFloat(v) || 0);
      var __config = this.__config;

      if (__config[I_DELAY] !== v) {
        __config[I_DELAY] = v;

        this.__checkModify();
      }

      return v;
    }
  }, {
    key: "endDelay",
    get: function get() {
      return this.__config[I_END_DELAY];
    },
    set: function set(v) {
      v = Math.max(0, parseFloat(v) || 0);
      var __config = this.__config;

      if (__config[I_END_DELAY] !== v) {
        __config[I_END_DELAY] = v;

        this.__checkModify();
      }

      return v;
    }
  }, {
    key: "fps",
    get: function get() {
      return this.__config[I_FPS];
    },
    set: function set(v) {
      v = parseInt(v) || 60;
      var __config = this.__config;

      if (__config[I_FPS] !== v) {
        if (v <= 0) {
          v = 60;
        }

        __config[I_FPS] = v;
      }

      return v;
    }
  }, {
    key: "spf",
    get: function get() {
      return 1 / this.fps;
    }
  }, {
    key: "iterations",
    get: function get() {
      return this.__config[I_ITERATIONS];
    },
    set: function set(v) {
      if (v === Infinity || util.isString(v) && v.toLowerCase() === 'infinity') {
        v = Infinity;
      } else {
        v = parseInt(v);

        if (isNaN(v) || v < 0) {
          v = 1;
        }
      }

      var __config = this.__config;

      if (__config[I_ITERATIONS] !== v) {
        __config[I_ITERATIONS] = v;
      }

      return v;
    }
  }, {
    key: "fill",
    get: function get() {
      return this.__config[I_FILL];
    },
    set: function set(v) {
      v = v || 'none';
      var __config = this.__config;

      if (__config[I_FILL] !== v) {
        __config[I_FILL] = v;

        this.__checkModify();
      }

      __config[I_STAY_BEGIN] = {
        backwards: true,
        both: true
      }.hasOwnProperty(v);
      __config[I_STAY_END] = {
        forwards: true,
        both: true
      }.hasOwnProperty(v);
      return v;
    }
  }, {
    key: "direction",
    get: function get() {
      return this.__config[I_DIRECTION];
    },
    set: function set(v) {
      v = v || 'normal';
      var __config = this.__config;

      if (__config[I_DIRECTION] !== v) {
        __config[I_DIRECTION] = v;

        this.__checkModify();
      }

      return v;
    }
  }, {
    key: "frames",
    get: function get() {
      return this.__config[I_FRAMES];
    }
  }, {
    key: "framesR",
    get: function get() {
      return this.__config[I_FRAMES_R];
    }
  }, {
    key: "playbackRate",
    get: function get() {
      return this.__config[I_PLAYBACK_RATE];
    },
    set: function set(v) {
      v = parseFloat(v) || 1;

      if (v <= 0) {
        v = 1;
      }

      var __config = this.__config;

      if (__config[I_PLAYBACK_RATE] !== v) {
        __config[I_PLAYBACK_RATE] = v;
      }

      return v;
    }
  }, {
    key: "easing",
    get: function get() {
      return this.__config[I_EASING];
    }
  }, {
    key: "startTime",
    get: function get() {
      return this.__config[I_START_TIME];
    }
  }, {
    key: "currentTime",
    get: function get() {
      return this.__config[I_CURRENT_TIME];
    },
    set: function set(v) {
      v = Math.max(0, parseFloat(v) || 0);
      var __config = this.__config;

      if (__config[I_CURRENT_TIME] !== v) {
        __config[I_CURRENT_TIME] = v;
        __config[I_NEXT_TIME] = v;
      }

      return v;
    }
  }, {
    key: "nextTime",
    get: function get() {
      return this.__config[I_NEXT_TIME];
    },
    set: function set(v) {
      v = Math.max(0, parseFloat(v) || 0);
      var __config = this.__config;

      if (__config[I_NEXT_TIME] !== v) {
        __config[I_NEXT_TIME] = v;
      }

      return v;
    }
  }, {
    key: "timestamp",
    get: function get() {
      return this.__config[I_TIME_STAMP];
    }
  }, {
    key: "pending",
    get: function get() {
      return this.__config[I_PLAY_STATE] !== 'running';
    }
  }, {
    key: "finished",
    get: function get() {
      return this.__config[I_PLAY_STATE] === 'finished';
    }
  }, {
    key: "playState",
    get: function get() {
      return this.__config[I_PLAY_STATE];
    }
  }, {
    key: "playCount",
    get: function get() {
      return this.__config[I_PLAY_COUNT];
    },
    set: function set(v) {
      v = Math.max(0, parseInt(v) || 0);
      var __config = this.__config;

      if (__config[I_PLAY_COUNT] !== v) {
        __config[I_PLAY_COUNT] = v;
      }

      return v;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.__config[I_DESTROYED];
    }
  }, {
    key: "animating",
    get: function get() {
      var __config = this.__config;
      var playState = __config[I_PLAY_STATE];

      if (playState === 'idle') {
        return false;
      }

      return playState !== 'finished' || __config[I_STAY_END] || __config[I_STAY_BEGIN];
    }
  }, {
    key: "spfLimit",
    get: function get() {
      var __config = this.__config;
      return __config[I_SPF_LIMIT];
    },
    set: function set(v) {
      if (util.isNumber(v) || /^\d/.test(v)) {
        v = Math.max(0, parseInt(v) || 0);
      } else {
        v = !!v;
      }

      var __config = this.__config;

      if (__config[I_SPF_LIMIT] !== v) {
        __config[I_SPF_LIMIT] = v;
      }

      return v;
    }
  }, {
    key: "assigning",
    get: function get() {
      return this.__config[I_ASSIGNING];
    }
  }]);

  return Animation;
}(Event);

var NODE_DEFS_CACHE$4 = enums.NODE_KEY.NODE_DEFS_CACHE;
var int2rgba$2 = util.int2rgba;
var canvasPolygon$3 = painter.canvasPolygon,
    svgPolygon$3 = painter.svgPolygon;

function renderBoxShadow(xom, renderMode, ctx, data, x1, y1, x2, y2, w, h) {
  var _data = _slicedToArray(data, 6),
      x = _data[0],
      y = _data[1],
      sigma = _data[2],
      spread = _data[3],
      color = _data[4],
      inset = _data[5];

  var c = int2rgba$2(color);
  var n = Math.abs(sigma) * 2 + Math.abs(spread) * 2 + Math.abs(x) * 2 + Math.abs(y) * 2; // box本身坐标顺时针

  var box = [[x1, y1], [x2, y1], [x2, y2], [x1, y2], [x1, y1]]; // 算上各种偏移/扩散的最外层坐标，且逆时针

  var outer = [[x1 - n, y1 - n], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n]];

  if (color[3] > 0 && (sigma > 0 || spread > 0)) {
    if (renderMode === mode.CANVAS | renderMode === mode.WEBGL) {
      ctx.save();
      ctx.beginPath(); // inset裁剪box外面

      if (inset === 'inset') {
        var xa = x1 + x + spread;
        var ya = y1 + y + spread;
        var xb = x2 + x - spread;
        var yb = y2 + y - spread;
        var spreadBox = [[xa, ya], [xb, ya], [xb, yb], [xa, yb]]; // 是否相交判断需要绘制

        var cross = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [spreadBox[0][0], spreadBox[0][1], spreadBox[2][0], spreadBox[2][1]]);

        if (!cross) {
          return;
        }

        cross = [[cross[0], cross[1]], [cross[2], cross[1]], [cross[2], cross[3]], [cross[0], cross[3]], [cross[0], cross[1]]]; // 扩散区域类似边框填充

        if (spread) {
          canvasPolygon$3(ctx, cross);
          canvasPolygon$3(ctx, box.slice(0).reverse());
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== c) {
            ctx.fillStyle = c;
          }

          canvasPolygon$3(ctx, box);
          ctx.fill();
          ctx.closePath();
          ctx.restore();
          ctx.save();
          ctx.beginPath();
          canvasPolygon$3(ctx, cross);
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== '#FFF') {
            ctx.fillStyle = '#FFF';
          }

          ctx.shadowColor = c;
          ctx.shadowBlur = sigma; // 画在外围的空心矩形，宽度要比blur大，n考虑了这一情况取了最大值

          canvasPolygon$3(ctx, [[xa, ya], [xb, ya], [xb, yb], [x1 - n, yb], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, yb], [xa, yb], [xa, ya]]);
        } else {
          canvasPolygon$3(ctx, box);
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== '#FFF') {
            ctx.fillStyle = '#FFF';
          }

          ctx.shadowOffsetX = x;
          ctx.shadowOffsetY = y;
          ctx.shadowColor = c;
          ctx.shadowBlur = sigma;
          canvasPolygon$3(ctx, [[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]]);
        }
      } // outset需裁减掉box本身的内容，clip()非零环绕显示box外的阴影内容，fill()绘制在内无效
      else {
        var _xa = x1 + x - spread;

        var _ya = y1 + y - spread;

        var _xb = x2 + x + spread;

        var _yb = y2 + y + spread;

        var blurBox = [[_xa, _ya], [_xb, _ya], [_xb, _yb], [_xa, _yb]];

        var _cross = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [blurBox[0][0], blurBox[0][1], blurBox[2][0], blurBox[2][1]]); // 分为是否有spread，因模糊成本spread区域将没有模糊


        if (spread) {
          // 扩散区域类似边框填充
          canvasPolygon$3(ctx, box);
          canvasPolygon$3(ctx, blurBox.slice(0).reverse());
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== c) {
            ctx.fillStyle = c;
          }

          canvasPolygon$3(ctx, blurBox);
          ctx.fill();
          ctx.closePath();
          ctx.restore();
          ctx.save();
          ctx.beginPath(); // 阴影部分看相交情况裁剪，有相交时逆时针绘制相交区域即可排除之

          if (_cross) {
            canvasPolygon$3(ctx, [[_cross[0], _cross[1]], [_cross[2], _cross[1]], [_cross[2], _cross[3]], [_cross[0], _cross[3]], [_cross[0], _cross[1]]].reverse());
          }

          canvasPolygon$3(ctx, box);
          canvasPolygon$3(ctx, blurBox);
          canvasPolygon$3(ctx, outer);
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== '#FFF') {
            ctx.fillStyle = '#FFF';
          }

          ctx.shadowColor = c;
          ctx.shadowBlur = sigma;
          canvasPolygon$3(ctx, blurBox);
        } else {
          canvasPolygon$3(ctx, box);
          canvasPolygon$3(ctx, outer);
          ctx.clip();
          ctx.closePath();
          ctx.beginPath();

          if (ctx.fillStyle !== '#FFF') {
            ctx.fillStyle = '#FFF';
          }

          ctx.shadowOffsetX = x;
          ctx.shadowOffsetY = y;
          ctx.shadowColor = c;
          ctx.shadowBlur = sigma;
          canvasPolygon$3(ctx, box);
        }
      }

      ctx.fill();
      ctx.closePath();
      ctx.restore();
    } else if (renderMode === mode.SVG) {
      var d = blur.outerSize(sigma);

      if (inset === 'inset') {
        var _xa2 = x1 + x + spread;

        var _ya2 = y1 + y + spread;

        var _xb2 = x2 + x - spread;

        var _yb2 = y2 + y - spread;

        var _spreadBox = [[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [_xa2, _yb2]];

        var _cross2 = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_spreadBox[0][0], _spreadBox[0][1], _spreadBox[2][0], _spreadBox[2][1]]);

        if (!_cross2) {
          return;
        }

        _cross2 = [[_cross2[0], _cross2[1]], [_cross2[2], _cross2[1]], [_cross2[2], _cross2[3]], [_cross2[0], _cross2[3]], [_cross2[0], _cross2[1]]];

        if (spread) {
          var v = {
            tagName: 'filter',
            props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
            children: [{
              tagName: 'feDropShadow',
              props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
            }]
          };

          xom.__config[NODE_DEFS_CACHE$4].push(v);

          var filter = ctx.add(v);
          var v2 = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon$3(_cross2) + svgPolygon$3(box.slice(0).reverse())], ['fill', '#FFF']]
            }]
          };
          var clip = ctx.add(v2);

          xom.__config[NODE_DEFS_CACHE$4].push(v2);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3(box)], ['fill', c], ['clip-path', 'url(#' + clip + ')']]
          });
          v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon$3(_cross2)], ['fill', '#FFF']]
            }]
          };
          clip = ctx.add(v);

          xom.__config[NODE_DEFS_CACHE$4].push(v);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3([[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [x1 - n, _yb2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, _yb2], [_xa2, _yb2], [_xa2, _ya2]])], ['fill', '#FFF'], ['filter', 'url(#' + filter + ')'], ['clip-path', 'url(#' + clip + ')']]
          });
        } else {
          var _v = {
            tagName: 'filter',
            props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
            children: [{
              tagName: 'feDropShadow',
              props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
            }]
          };

          var _filter = ctx.add(_v);

          xom.__config[NODE_DEFS_CACHE$4].push(_v);

          _v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', '#FFF']]
            }]
          };

          var _clip = ctx.add(_v);

          xom.__config[NODE_DEFS_CACHE$4].push(_v);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3([[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]])], ['fill', '#FFF'], ['filter', 'url(#' + _filter + ')'], ['clip-path', 'url(#' + _clip + ')']]
          });
        }
      } else {
        var _xa3 = x1 + x - spread;

        var _ya3 = y1 + y - spread;

        var _xb3 = x2 + x + spread;

        var _yb3 = y2 + y + spread;

        var _blurBox = [[_xa3, _ya3], [_xb3, _ya3], [_xb3, _yb3], [_xa3, _yb3]];

        var _cross3 = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_blurBox[0][0], _blurBox[0][1], _blurBox[2][0], _blurBox[2][1]]);

        if (spread) {
          var _v2 = {
            tagName: 'filter',
            props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
            children: [{
              tagName: 'feDropShadow',
              props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
            }]
          };

          var _filter2 = ctx.add(_v2);

          xom.__config[NODE_DEFS_CACHE$4].push(_v2);

          _v2 = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon$3(box) + svgPolygon$3(_blurBox.slice(0).reverse())], ['fill', '#FFF']]
            }]
          };

          var _clip2 = ctx.add(_v2);

          xom.__config[NODE_DEFS_CACHE$4].push(_v2);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3(_blurBox)], ['fill', c], ['clip-path', 'url(#' + _clip2 + ')']]
          });
          _v2 = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', (_cross3 ? svgPolygon$3([[_cross3[0], _cross3[1]], [_cross3[2], _cross3[1]], [_cross3[2], _cross3[3]], [_cross3[0], _cross3[3]], [_cross3[0], _cross3[1]]].reverse()) : '') + svgPolygon$3(box) + svgPolygon$3(_blurBox) + svgPolygon$3(outer)], ['fill', '#FFF']]
            }]
          };
          _clip2 = ctx.add(_v2);

          xom.__config[NODE_DEFS_CACHE$4].push(_v2);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3(_blurBox)], ['fill', '#FFF'], ['filter', 'url(#' + _filter2 + ')'], ['clip-path', 'url(#' + _clip2 + ')']]
          });
        } else {
          var _v3 = {
            tagName: 'filter',
            props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
            children: [{
              tagName: 'feDropShadow',
              props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
            }]
          };

          var _filter3 = ctx.add(_v3);

          xom.__config[NODE_DEFS_CACHE$4].push(_v3);

          _v3 = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon$3(box) + svgPolygon$3(outer)], ['fill', '#FFF']]
            }]
          };

          var _clip3 = ctx.add(_v3);

          xom.__config[NODE_DEFS_CACHE$4].push(_v3);

          xom.virtualDom.bb.push({
            type: 'item',
            tagName: 'path',
            props: [['d', svgPolygon$3(box)], ['fill', '#FFF'], ['filter', 'url(#' + _filter3 + ')'], ['clip-path', 'url(#' + _clip3 + ')']]
          });
        }
      }
    }
  }
}

var bs = {
  renderBoxShadow: renderBoxShadow
};

var MBM_HASH = {
  multiply: true,
  screen: true,
  overlay: true,
  darken: true,
  lighten: true,
  'color-dodge': true,
  'color-burn': true,
  'hard-light': true,
  'soft-light': true,
  difference: true,
  exclusion: true,
  hue: true,
  saturation: true,
  color: true,
  luminosity: true
};

function mbmName$2(v) {
  if (v) {
    return v.replace(/[A-Z]/, function ($0) {
      return '-' + $0.toLowerCase();
    });
  }
}

function isValidMbm$2(v) {
  return MBM_HASH.hasOwnProperty(mbmName$2(v));
}

var mbm = {
  mbmName: mbmName$2,
  isValidMbm: isValidMbm$2
};

var _enums$STYLE_KEY$e = enums.STYLE_KEY,
    MARGIN_LEFT$6 = _enums$STYLE_KEY$e.MARGIN_LEFT,
    MARGIN_RIGHT$5 = _enums$STYLE_KEY$e.MARGIN_RIGHT,
    PADDING_LEFT$6 = _enums$STYLE_KEY$e.PADDING_LEFT,
    PADDING_RIGHT$5 = _enums$STYLE_KEY$e.PADDING_RIGHT,
    BORDER_LEFT_WIDTH$6 = _enums$STYLE_KEY$e.BORDER_LEFT_WIDTH,
    BORDER_RIGHT_WIDTH$5 = _enums$STYLE_KEY$e.BORDER_RIGHT_WIDTH;
/**
 * 获取inline的每一行内容的矩形坐标4个点，同时附带上border的矩形，比前面4个点尺寸大或相等（有无border/padding）
 * @param xom
 * @param contentBoxList
 * @param start
 * @param end
 * @param lineBox
 * @param baseLine
 * @param lineHeight
 * @param diffL
 * @param isStart
 * @param isEnd
 * @param backgroundClip
 * @param paddingTop
 * @param paddingRight
 * @param paddingBottom
 * @param paddingLeft
 * @param borderTopWidth
 * @param borderRightWidth
 * @param borderBottomWidth
 * @param borderLeftWidth
 * @returns {(*|number)[]}
 */

function getInlineBox(xom, contentBoxList, start, end, lineBox, baseLine, lineHeight, diffL, isStart, isEnd, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth) {
  // 根据bgClip确定y伸展范围，inline渲染bg扩展到pb的位置不影响布局
  var eyt = 0,
      eyb = 0;

  if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
    eyt = paddingTop;
    eyb = paddingBottom;
  } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
    eyt = paddingTop + borderTopWidth;
    eyb = paddingBottom + borderBottomWidth;
  } // 同y的border伸展范围，其影响border渲染


  var pbt = paddingTop + borderTopWidth;
  var pbb = paddingBottom + borderBottomWidth; // inline的baseLine和lineBox的差值

  var diff = lineBox.baseLine - baseLine; // x坐标取首尾contentBox的左右2侧，clip布局时已算好；y是根据lineHeight和lineBox的高度以及baseLine对齐后计算的

  var x1 = start.x;
  var dom = start instanceof TextBox ? start.parent.domParent : start.domParent;

  while (dom !== xom) {
    var list = dom.contentBoxList;

    if (start === list[0]) {
      var _dom$computedStyle = dom.computedStyle,
          marginLeft = _dom$computedStyle[MARGIN_LEFT$6],
          _paddingLeft = _dom$computedStyle[PADDING_LEFT$6],
          _borderLeftWidth = _dom$computedStyle[BORDER_LEFT_WIDTH$6];
      x1 -= marginLeft + _paddingLeft + _borderLeftWidth;
    }

    dom = dom.domParent;
  }

  var bx1 = x1;

  if (isStart) {
    if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
      x1 -= paddingLeft;
    } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
      x1 -= paddingLeft + borderLeftWidth;
    }

    bx1 -= paddingLeft + borderLeftWidth;
  }

  var y1 = lineBox.y + diff - eyt;
  var by1 = lineBox.y + diff - pbt;
  var x2 = end.x + end.outerWidth; // TextBox的parent是Text，再是Dom，这里一定是inline，无嵌套就是xom本身，有则包含若干层最上层还是xom

  dom = end instanceof TextBox ? end.parent.domParent : end.domParent; // 从end开始，向上获取dom节点的尾部mpb进行累加，直到xom跳出

  while (dom !== xom) {
    var _list = dom.contentBoxList;

    if (end === _list[_list.length - 1]) {
      var _dom$computedStyle2 = dom.computedStyle,
          marginRight = _dom$computedStyle2[MARGIN_RIGHT$5],
          _paddingRight = _dom$computedStyle2[PADDING_RIGHT$5],
          _borderRightWidth = _dom$computedStyle2[BORDER_RIGHT_WIDTH$5];
      x2 += marginRight + _paddingRight + _borderRightWidth;
    }

    dom = dom.domParent;
  }

  var bx2 = x2;

  if (isEnd) {
    if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
      x2 += paddingRight;
    } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
      x2 += paddingRight + borderRightWidth;
    }

    bx2 += paddingRight + borderRightWidth;
  }

  var y2 = lineBox.y + diff + lineHeight - diffL + eyb;
  var by2 = lineBox.y + diff + lineHeight - diffL + pbb; // x要考虑xom的ox值

  x1 += xom.ox;
  x2 += xom.ox;
  bx1 += xom.ox;
  bx2 += xom.ox;
  y1 += xom.oy;
  y2 += xom.oy;
  by1 += xom.oy;
  by2 += xom.oy;
  return [x1, y1, x2, y2, bx1, by1, bx2, by2];
}
/**
 * 统计inline的所有contentBox排成一行时的总宽度，考虑嵌套的mpb
 * @param xom
 * @param contentBoxList
 * @returns {number}
 */


function getInlineWidth(xom, contentBoxList) {
  var sum = 0;
  var length = contentBoxList.length;

  for (var i = 0; i < length; i++) {
    var contentBox = contentBoxList[i];
    sum += contentBox.width; // 嵌套时，首尾box考虑mpb

    var dom = contentBox instanceof TextBox ? contentBox.parent.domParent : contentBox.domParent;

    while (dom !== xom) {
      var list = dom.contentBoxList;

      if (contentBox === list[0]) {
        var _dom$computedStyle3 = dom.computedStyle,
            marginLeft = _dom$computedStyle3[MARGIN_LEFT$6],
            paddingLeft = _dom$computedStyle3[PADDING_LEFT$6],
            borderLeftWidth = _dom$computedStyle3[BORDER_LEFT_WIDTH$6];
        sum += marginLeft + paddingLeft + borderLeftWidth;
      }

      if (contentBox === list[list.length - 1]) {
        var _dom$computedStyle4 = dom.computedStyle,
            marginRight = _dom$computedStyle4[MARGIN_RIGHT$5],
            paddingRight = _dom$computedStyle4[PADDING_RIGHT$5],
            borderRightWidth = _dom$computedStyle4[BORDER_RIGHT_WIDTH$5];
        sum += marginRight + paddingRight + borderRightWidth;
      }

      dom = dom.domParent;
    }
  }

  return sum;
}

var inline = {
  getInlineBox: getInlineBox,
  getInlineWidth: getInlineWidth
};

var svgPolygon$2 = painter.svgPolygon;
var CANVAS = mode.CANVAS,
    SVG = mode.SVG,
    WEBGL = mode.WEBGL;
var STYLE_KEY = enums.STYLE_KEY,
    STYLE_RV_KEY = enums.STYLE_RV_KEY,
    style2Upper = enums.style2Upper,
    _enums$STYLE_KEY$d = enums.STYLE_KEY,
    BORDER_TOP_LEFT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_TOP_LEFT_RADIUS,
    BORDER_TOP_RIGHT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_TOP_RIGHT_RADIUS,
    BORDER_BOTTOM_LEFT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_BOTTOM_LEFT_RADIUS,
    BORDER_BOTTOM_RIGHT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_BOTTOM_RIGHT_RADIUS,
    PADDING_LEFT$5 = _enums$STYLE_KEY$d.PADDING_LEFT,
    PADDING_RIGHT$4 = _enums$STYLE_KEY$d.PADDING_RIGHT,
    PADDING_TOP$4 = _enums$STYLE_KEY$d.PADDING_TOP,
    PADDING_BOTTOM$4 = _enums$STYLE_KEY$d.PADDING_BOTTOM,
    MARGIN_LEFT$5 = _enums$STYLE_KEY$d.MARGIN_LEFT,
    MARGIN_TOP$4 = _enums$STYLE_KEY$d.MARGIN_TOP,
    MARGIN_BOTTOM$4 = _enums$STYLE_KEY$d.MARGIN_BOTTOM,
    MARGIN_RIGHT$4 = _enums$STYLE_KEY$d.MARGIN_RIGHT,
    BORDER_LEFT_WIDTH$5 = _enums$STYLE_KEY$d.BORDER_LEFT_WIDTH,
    BORDER_TOP_WIDTH$4 = _enums$STYLE_KEY$d.BORDER_TOP_WIDTH,
    BORDER_BOTTOM_WIDTH$4 = _enums$STYLE_KEY$d.BORDER_BOTTOM_WIDTH,
    BORDER_RIGHT_WIDTH$4 = _enums$STYLE_KEY$d.BORDER_RIGHT_WIDTH,
    TOP$3 = _enums$STYLE_KEY$d.TOP,
    RIGHT$2 = _enums$STYLE_KEY$d.RIGHT,
    BOTTOM$3 = _enums$STYLE_KEY$d.BOTTOM,
    LEFT$2 = _enums$STYLE_KEY$d.LEFT,
    POSITION$4 = _enums$STYLE_KEY$d.POSITION,
    DISPLAY$7 = _enums$STYLE_KEY$d.DISPLAY,
    WIDTH$4 = _enums$STYLE_KEY$d.WIDTH,
    HEIGHT$5 = _enums$STYLE_KEY$d.HEIGHT,
    MATRIX = _enums$STYLE_KEY$d.MATRIX,
    TRANSLATE_X = _enums$STYLE_KEY$d.TRANSLATE_X,
    TRANSLATE_Y = _enums$STYLE_KEY$d.TRANSLATE_Y,
    TRANSLATE_Z = _enums$STYLE_KEY$d.TRANSLATE_Z,
    TRANSFORM$1 = _enums$STYLE_KEY$d.TRANSFORM,
    SCALE_X = _enums$STYLE_KEY$d.SCALE_X,
    SCALE_Y = _enums$STYLE_KEY$d.SCALE_Y,
    SCALE_Z = _enums$STYLE_KEY$d.SCALE_Z,
    ROTATE_X = _enums$STYLE_KEY$d.ROTATE_X,
    ROTATE_Y = _enums$STYLE_KEY$d.ROTATE_Y,
    ROTATE_Z = _enums$STYLE_KEY$d.ROTATE_Z,
    SKEW_X = _enums$STYLE_KEY$d.SKEW_X,
    SKEW_Y = _enums$STYLE_KEY$d.SKEW_Y,
    PERSPECTIVE$2 = _enums$STYLE_KEY$d.PERSPECTIVE,
    PERSPECTIVE_ORIGIN$1 = _enums$STYLE_KEY$d.PERSPECTIVE_ORIGIN,
    ROTATE_3D = _enums$STYLE_KEY$d.ROTATE_3D,
    TRANSFORM_ORIGIN$1 = _enums$STYLE_KEY$d.TRANSFORM_ORIGIN,
    BACKGROUND_POSITION_X = _enums$STYLE_KEY$d.BACKGROUND_POSITION_X,
    BACKGROUND_POSITION_Y = _enums$STYLE_KEY$d.BACKGROUND_POSITION_Y,
    BACKGROUND_SIZE = _enums$STYLE_KEY$d.BACKGROUND_SIZE,
    BACKGROUND_COLOR$1 = _enums$STYLE_KEY$d.BACKGROUND_COLOR,
    BACKGROUND_IMAGE$1 = _enums$STYLE_KEY$d.BACKGROUND_IMAGE,
    BACKGROUND_REPEAT = _enums$STYLE_KEY$d.BACKGROUND_REPEAT,
    BOX_SHADOW$7 = _enums$STYLE_KEY$d.BOX_SHADOW,
    OPACITY$2 = _enums$STYLE_KEY$d.OPACITY,
    Z_INDEX$2 = _enums$STYLE_KEY$d.Z_INDEX,
    BORDER_TOP_STYLE = _enums$STYLE_KEY$d.BORDER_TOP_STYLE,
    BORDER_RIGHT_STYLE = _enums$STYLE_KEY$d.BORDER_RIGHT_STYLE,
    BORDER_BOTTOM_STYLE = _enums$STYLE_KEY$d.BORDER_BOTTOM_STYLE,
    BORDER_LEFT_STYLE = _enums$STYLE_KEY$d.BORDER_LEFT_STYLE,
    FILTER$3 = _enums$STYLE_KEY$d.FILTER,
    OVERFLOW$2 = _enums$STYLE_KEY$d.OVERFLOW,
    MIX_BLEND_MODE$3 = _enums$STYLE_KEY$d.MIX_BLEND_MODE,
    TEXT_OVERFLOW = _enums$STYLE_KEY$d.TEXT_OVERFLOW,
    BORDER_TOP_COLOR = _enums$STYLE_KEY$d.BORDER_TOP_COLOR,
    BORDER_BOTTOM_COLOR = _enums$STYLE_KEY$d.BORDER_BOTTOM_COLOR,
    BORDER_LEFT_COLOR = _enums$STYLE_KEY$d.BORDER_LEFT_COLOR,
    BORDER_RIGHT_COLOR = _enums$STYLE_KEY$d.BORDER_RIGHT_COLOR,
    FONT_STYLE = _enums$STYLE_KEY$d.FONT_STYLE,
    COLOR$1 = _enums$STYLE_KEY$d.COLOR,
    VISIBILITY$4 = _enums$STYLE_KEY$d.VISIBILITY,
    POINTER_EVENTS$1 = _enums$STYLE_KEY$d.POINTER_EVENTS,
    BORDER_TOP = _enums$STYLE_KEY$d.BORDER_TOP,
    BORDER_RIGHT = _enums$STYLE_KEY$d.BORDER_RIGHT,
    BORDER_BOTTOM = _enums$STYLE_KEY$d.BORDER_BOTTOM,
    BORDER_LEFT = _enums$STYLE_KEY$d.BORDER_LEFT,
    BACKGROUND_CLIP = _enums$STYLE_KEY$d.BACKGROUND_CLIP,
    FONT_SIZE$9 = _enums$STYLE_KEY$d.FONT_SIZE,
    FONT_FAMILY = _enums$STYLE_KEY$d.FONT_FAMILY,
    LINE_HEIGHT$1 = _enums$STYLE_KEY$d.LINE_HEIGHT,
    TEXT_STROKE_COLOR = _enums$STYLE_KEY$d.TEXT_STROKE_COLOR,
    TEXT_STROKE_WIDTH = _enums$STYLE_KEY$d.TEXT_STROKE_WIDTH,
    TEXT_STROKE_OVER = _enums$STYLE_KEY$d.TEXT_STROKE_OVER,
    _enums$UPDATE_KEY$3 = enums.UPDATE_KEY,
    UPDATE_NODE$3 = _enums$UPDATE_KEY$3.UPDATE_NODE,
    UPDATE_FOCUS$3 = _enums$UPDATE_KEY$3.UPDATE_FOCUS,
    UPDATE_STYLE$1 = _enums$UPDATE_KEY$3.UPDATE_STYLE,
    UPDATE_OVERWRITE$1 = _enums$UPDATE_KEY$3.UPDATE_OVERWRITE,
    UPDATE_KEYS$1 = _enums$UPDATE_KEY$3.UPDATE_KEYS,
    UPDATE_CONFIG$3 = _enums$UPDATE_KEY$3.UPDATE_CONFIG,
    UPDATE_REMOVE_DOM$1 = _enums$UPDATE_KEY$3.UPDATE_REMOVE_DOM,
    STRUCT_HAS_MASK$1 = enums.STRUCT_KEY.STRUCT_HAS_MASK,
    _enums$NODE_KEY$6 = enums.NODE_KEY,
    NODE_TAG_NAME$1 = _enums$NODE_KEY$6.NODE_TAG_NAME,
    NODE_CACHE_STYLE$2 = _enums$NODE_KEY$6.NODE_CACHE_STYLE,
    NODE_CURRENT_STYLE$5 = _enums$NODE_KEY$6.NODE_CURRENT_STYLE,
    NODE_COMPUTED_STYLE$3 = _enums$NODE_KEY$6.NODE_COMPUTED_STYLE,
    NODE_STYLE$4 = _enums$NODE_KEY$6.NODE_STYLE,
    NODE_STRUCT$3 = _enums$NODE_KEY$6.NODE_STRUCT,
    NODE_OPACITY$1 = _enums$NODE_KEY$6.NODE_OPACITY,
    NODE_MATRIX_EVENT$2 = _enums$NODE_KEY$6.NODE_MATRIX_EVENT,
    NODE_MATRIX$2 = _enums$NODE_KEY$6.NODE_MATRIX,
    NODE_LIMIT_CACHE$1 = _enums$NODE_KEY$6.NODE_LIMIT_CACHE,
    NODE_HAS_CONTENT = _enums$NODE_KEY$6.NODE_HAS_CONTENT,
    NODE_REFRESH_LV$2 = _enums$NODE_KEY$6.NODE_REFRESH_LV,
    NODE_CACHE$3 = _enums$NODE_KEY$6.NODE_CACHE,
    NODE_CACHE_TOTAL$2 = _enums$NODE_KEY$6.NODE_CACHE_TOTAL,
    NODE_CACHE_FILTER$2 = _enums$NODE_KEY$6.NODE_CACHE_FILTER,
    NODE_CACHE_MASK$2 = _enums$NODE_KEY$6.NODE_CACHE_MASK,
    NODE_CACHE_OVERFLOW$2 = _enums$NODE_KEY$6.NODE_CACHE_OVERFLOW,
    NODE_IS_DESTROYED$1 = _enums$NODE_KEY$6.NODE_IS_DESTROYED,
    NODE_DEFS_CACHE$3 = _enums$NODE_KEY$6.NODE_DEFS_CACHE,
    NODE_DOM_PARENT$4 = _enums$NODE_KEY$6.NODE_DOM_PARENT,
    NODE_IS_INLINE$1 = _enums$NODE_KEY$6.NODE_IS_INLINE,
    NODE_PERSPECTIVE_MATRIX$1 = _enums$NODE_KEY$6.NODE_PERSPECTIVE_MATRIX,
    NODE_IS_MASK$3 = _enums$NODE_KEY$6.NODE_IS_MASK,
    NODE_VIRTUAL_DOM$1 = _enums$NODE_KEY$6.NODE_VIRTUAL_DOM;
var AUTO$4 = o$4.AUTO,
    PX$5 = o$4.PX,
    PERCENT$5 = o$4.PERCENT,
    INHERIT$1 = o$4.INHERIT,
    NUMBER = o$4.NUMBER,
    REM$9 = o$4.REM,
    VW$9 = o$4.VW,
    VH$9 = o$4.VH,
    DEG = o$4.DEG;
var int2rgba$1 = util.int2rgba,
    rgba2int = util.rgba2int,
    joinArr$1 = util.joinArr,
    isNil$9 = util.isNil;
var calRelative = css.calRelative;
var GEOM = o$2.GEOM;
var mbmName$1 = mbm.mbmName,
    isValidMbm$1 = mbm.isValidMbm;
var point2d = mx.point2d;
var contain$3 = o$1.contain,
    NONE$3 = o$1.NONE,
    TF = o$1.TRANSFORM,
    REFLOW$2 = o$1.REFLOW,
    REPAINT$2 = o$1.REPAINT,
    TX = o$1.TRANSLATE_X,
    TY = o$1.TRANSLATE_Y,
    TZ = o$1.TRANSLATE_Z;

function getFirstEmptyInlineWidth(xom) {
  var n = 0;
  var flowChildren = xom.flowChildren;
  var length = flowChildren.length;

  for (var i = 0; i < length; i++) {
    var child = flowChildren[i];

    if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
      if (child.flowChildren.length) {
        n += getFirstEmptyInlineWidth(child);
        break;
      } else if (child.__config[NODE_IS_INLINE$1]) {
        n += child.outerWidth;
      }
    } else {
      break;
    }
  }

  return n;
}

function getLastEmptyInlineWidth(xom) {
  var n = 0;
  var flowChildren = xom.flowChildren;
  var length = flowChildren.length;

  for (var i = length - 1; i >= 0; i--) {
    var child = flowChildren[i];

    if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
      if (child.flowChildren.length) {
        n += getLastEmptyInlineWidth(child);
        break;
      } else {
        n += child.outerWidth;
      }
    } else {
      break;
    }
  }

  return n;
}

var Xom = /*#__PURE__*/function (_Node) {
  _inherits(Xom, _Node);

  var _super = _createSuper(Xom);

  function Xom(tagName) {
    var _this;

    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Xom);

    _this = _super.call(this); // 构建工具中都是arr，手写可能出现hash情况

    if (Array.isArray(props)) {
      _this.props = util.arr2hash(props);
    } else {
      _this.props = props;
    }

    _this.__tagName = tagName;
    _this.__style = _this.props.style || {}; // style被解析后的k-v形式

    _this.__currentStyle = {}; // 动画过程中绘制一开始会merge动画样式

    _this.__computedStyle = {}; // 类似getComputedStyle()将currentStyle计算好数值赋给

    _this.__listener = {};
    Object.keys(_this.props).forEach(function (k) {
      var v = _this.props[k];

      if (/^on[a-zA-Z]/.test(k)) {
        k = k.slice(2).toLowerCase();
        _this.listener[k] = v;
      }
    });
    _this.__animationList = [];
    _this.__loadBgi = {
      // 刷新回调函数，用以destroy取消用
      cb: function cb() {}
    };
    _this.__cacheStyle = {}; // 是否缓存重新计算computedStyle的样式key

    _this.__cacheDefs = []; // svg专用，缓存渲染时使用已有的defs，diff过程用，否则会defs被清空

    var isClip = _this.__isClip = !!_this.props.clip;
    var isMask = _this.__isMask = isClip || !!_this.props.mask;
    var config = _this.__config;
    config[NODE_TAG_NAME$1] = tagName;
    config[NODE_CACHE_STYLE$2] = _this.__cacheStyle;
    config[NODE_CURRENT_STYLE$5] = _this.__currentStyle;
    config[NODE_COMPUTED_STYLE$3] = _this.__computedStyle;
    config[NODE_REFRESH_LV$2] = REFLOW$2;
    config[NODE_STYLE$4] = _this.__style;
    config[NODE_MATRIX$2] = [];
    config[NODE_MATRIX_EVENT$2] = [];
    config[NODE_DEFS_CACHE$3] = _this.__cacheDefs;
    config[NODE_IS_MASK$3] = isMask;
    _this.__frameAnimateList = [];
    _this.__contentBoxList = []; // inline存储内容用
    // this.__json domApi需要获取生成时的json引用，builder过程添加，如appendChild时json也需要跟着变更

    return _this;
  }

  _createClass(Xom, [{
    key: "__structure",
    value: function __structure(i, lv, j) {
      var res = _get(_getPrototypeOf(Xom.prototype), "__structure", this).call(this, i, lv, j);

      if (this.__hasMask) {
        res[STRUCT_HAS_MASK$1] = this.__hasMask;
      }

      this.__config[NODE_STRUCT$3] = res;
      return res;
    } // 设置margin/padding的实际值，layout时执行，inline的垂直方向仍然计算值，但在布局时被忽略

  }, {
    key: "__mp",
    value: function __mp(currentStyle, computedStyle, w) {
      var _this2 = this;

      ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
        var a = STYLE_KEY[style2Upper('margin' + k)];
        var b = STYLE_KEY[style2Upper('padding' + k)];
        computedStyle[a] = _this2.__mpWidth(currentStyle[a], w);
        computedStyle[b] = _this2.__mpWidth(currentStyle[b], w);
      });
    }
  }, {
    key: "__mpWidth",
    value: function __mpWidth(mp, w) {
      if (mp[1] === PX$5) {
        return mp[0];
      } else if (mp[1] === PERCENT$5) {
        return mp[0] * w * 0.01;
      } else if (mp[1] === REM$9) {
        return mp[0] * this.root.computedStyle[FONT_SIZE$9];
      } else if (mp[1] === VW$9) {
        return mp[0] * this.root.width * 0.01;
      } else if (mp[1] === VH$9) {
        return mp[0] * this.root.height * 0.01;
      }

      return 0;
    } // dom常用的几种尺寸赋值

  }, {
    key: "__ioSize",
    value: function __ioSize(w, h) {
      var computedStyle = this.computedStyle;
      this.__clientWidth = w += computedStyle[PADDING_LEFT$5] + computedStyle[PADDING_RIGHT$4];
      this.__clientHeight = h += computedStyle[PADDING_TOP$4] + computedStyle[PADDING_BOTTOM$4];
      this.__offsetWidth = w += computedStyle[BORDER_LEFT_WIDTH$5] + computedStyle[BORDER_RIGHT_WIDTH$4];
      this.__offsetHeight = h += computedStyle[BORDER_TOP_WIDTH$4] + computedStyle[BORDER_BOTTOM_WIDTH$4];
      this.__outerWidth = w + computedStyle[MARGIN_LEFT$5] + computedStyle[MARGIN_RIGHT$4];
      this.__outerHeight = h + computedStyle[MARGIN_TOP$4] + computedStyle[MARGIN_BOTTOM$4];
    } // 换算margin/padding为px单位，onlyFixedValue只考虑绝对值，不考虑百分比等

  }, {
    key: "__calMp",
    value: function __calMp(v, w, onlyFixedValue) {
      var n = 0;

      if (v[1] === PX$5) {
        n += v[0];
      } else if (v[1] === PERCENT$5 && !onlyFixedValue) {
        v[0] *= w * 0.01;
        v[1] = PX$5;
        n += v[0];
      } else if (v[1] === REM$9) {
        n += v[0] * this.root.computedStyle[FONT_SIZE$9];
      } else if (v[1] === VW$9) {
        n += v[0] * this.root.width * 0.01;
      } else if (v[1] === VH$9) {
        n += v[0] * this.root.height * 0.01;
      }

      return n;
    } // 为basis的b/min/max添加mpb，只有当b未显示指定等于w/content时才加，同时返回mpb值

  }, {
    key: "__addMp",
    value: function __addMp(isDirectionRow, w, currentStyle, res, isDirectItem) {
      var marginLeft = currentStyle[MARGIN_LEFT$5],
          marginTop = currentStyle[MARGIN_TOP$4],
          marginRight = currentStyle[MARGIN_RIGHT$4],
          marginBottom = currentStyle[MARGIN_BOTTOM$4],
          paddingLeft = currentStyle[PADDING_LEFT$5],
          paddingTop = currentStyle[PADDING_TOP$4],
          paddingRight = currentStyle[PADDING_RIGHT$4],
          paddingBottom = currentStyle[PADDING_BOTTOM$4],
          borderTopWidth = currentStyle[BORDER_TOP_WIDTH$4],
          borderRightWidth = currentStyle[BORDER_RIGHT_WIDTH$4],
          borderBottomWidth = currentStyle[BORDER_BOTTOM_WIDTH$4],
          borderLeftWidth = currentStyle[BORDER_LEFT_WIDTH$5];

      if (isDirectionRow) {
        var mp = this.__calMp(marginLeft, w, !isDirectItem) + this.__calMp(marginRight, w, !isDirectItem) + this.__calMp(paddingLeft, w, !isDirectItem) + this.__calMp(paddingRight, w, !isDirectItem);

        if (borderLeftWidth[1] === PX$5) {
          mp += borderLeftWidth[0];
        } else if (borderLeftWidth[1] === REM$9) {
          mp += borderLeftWidth[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (borderLeftWidth[1] === VW$9) {
          mp += borderLeftWidth[0] * this.root.width * 0.01;
        } else if (borderLeftWidth[1] === VH$9) {
          mp += borderLeftWidth[0] * this.root.height * 0.01;
        }

        if (borderRightWidth[1] === PX$5) {
          mp += borderRightWidth[0];
        } else if (borderRightWidth[1] === REM$9) {
          mp += borderRightWidth[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (borderRightWidth[1] === VW$9) {
          mp += borderRightWidth[0] * this.root.width * 0.01;
        } else if (borderRightWidth[1] === VH$9) {
          mp += borderRightWidth[0] * this.root.height * 0.01;
        }

        res = res.map(function (item) {
          return item + mp;
        });
      } else {
        var _mp = this.__calMp(marginTop, w, !isDirectItem) + this.__calMp(marginBottom, w, !isDirectItem) + this.__calMp(paddingTop, w, !isDirectItem) + this.__calMp(paddingBottom, w, !isDirectItem);

        if (borderTopWidth[1] === PX$5) {
          _mp += borderTopWidth[0];
        } else if (borderTopWidth[1] === REM$9) {
          _mp += borderTopWidth[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (borderTopWidth[1] === VW$9) {
          _mp += borderTopWidth[0] * this.root.width * 0.01;
        } else if (borderTopWidth[1] === VH$9) {
          _mp += borderTopWidth[0] * this.root.height * 0.01;
        }

        if (borderBottomWidth[1] === PX$5) {
          _mp += borderBottomWidth[0];
        } else if (borderBottomWidth[1] === REM$9) {
          _mp += borderBottomWidth[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (borderBottomWidth[1] === VW$9) {
          _mp += borderBottomWidth[0] * this.root.width * 0.01;
        } else if (borderBottomWidth[1] === VH$9) {
          _mp += borderBottomWidth[0] * this.root.height * 0.01;
        }

        res = res.map(function (item) {
          return item + _mp;
        });
      }

      return res;
    } // absolute且无尺寸时，isVirtual标明先假布局一次计算尺寸，还有flex列计算时
    // fromAbs为absolute节点特有省略计算标识，本节点是abs时真正布局传入

  }, {
    key: "__layout",
    value: function __layout(data, isVirtual, fromAbs) {
      css.computeReflow(this, this.isShadowRoot);
      var w = data.w;
      var isDestroyed = this.isDestroyed,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle,
          __config = this.__config;
      var display = computedStyle[DISPLAY$7];
      var width = currentStyle[WIDTH$4],
          position = currentStyle[POSITION$4];
      this.clearCache();
      this.__layoutData = {
        x: data.x,
        y: data.y,
        w: data.w,
        h: data.h,
        lx: data.lx
      };
      __config[NODE_REFRESH_LV$2] = REFLOW$2;
      __config[NODE_LIMIT_CACHE$1] = false;
      __config[NODE_IS_INLINE$1] = false; // 防止display:none不统计mask，isVirtual忽略，abs布局后续会真正来走一遍

      if (!isVirtual) {
        var next = this.next; // mask关系只有布局才会变更，普通渲染关系不会改变，clip也是mask的一种

        if (!this.isMask && next && next.isMask) {
          var count = 0;

          while (next) {
            if (next.isMask) {
              count++;
            } else {
              break;
            }

            next = next.next;
          }

          this.__hasMask = count;
        }
      }

      this.__ox = this.__oy = 0;

      if (isDestroyed || display === 'none') {
        this.__width = this.__height = this.__clientWidth = this.__clientHeight = this.__offsetWidth = this.__offsetHeight = this.__outerWidth = this.__outerHeight = computedStyle[WIDTH$4] = computedStyle[HEIGHT$5] = 0;
        this.__x = data.x;
        this.__y = data.y;

        this.__layoutNone();

        return;
      } // margin/padding在abs前已经计算过了，无需二次计算


      if (!fromAbs) {
        this.__mp(currentStyle, computedStyle, w);
      } // inline的width/height无效，其它有效


      if (width[1] !== AUTO$4) {
        if (this.__isRealInline() && currentStyle[DISPLAY$7] === 'inline') {
          width[0] = 0;
          width[1] = AUTO$4;
        } else {
          switch (width[1]) {
            case PX$5:
              w = width[0];
              break;

            case PERCENT$5:
              w *= width[0] * 0.01;
              break;

            case REM$9:
              w = width[0] * this.root.computedStyle[FONT_SIZE$9];
              break;

            case VW$9:
              w = width[0] * this.root.width * 0.01;
              break;

            case VH$9:
              w = width[0] * this.root.height * 0.01;
              break;
          }
        }
      }

      var lineClampCount = 0; // 4种布局，默认block，inlineBlock基本可以复用inline逻辑，除了尺寸

      if (display === 'flex') {
        this.__layoutFlex(data, isVirtual);
      } else if (display === 'inlineBlock' || display === 'inline-block') {
        lineClampCount = this.__layoutInline(data, isVirtual);
      } else if (display === 'inline') {
        lineClampCount = this.__layoutInline(data, isVirtual, true);
      } else {
        this.__layoutBlock(data, isVirtual);
      } // relative渲染时做偏移，百分比基于父元素，若父元素没有定高则为0


      if (position === 'relative') {
        var top = currentStyle[TOP$3],
            right = currentStyle[RIGHT$2],
            bottom = currentStyle[BOTTOM$3],
            left = currentStyle[LEFT$2];
        var parent = this.parent;

        if (top[1] !== AUTO$4) {
          var n = calRelative(currentStyle, TOP$3, top, parent);

          this.__offsetY(n);

          computedStyle[TOP$3] = n;
          computedStyle[BOTTOM$3] = 'auto';
        } else if (bottom[1] !== AUTO$4) {
          var _n = calRelative(currentStyle, BOTTOM$3, bottom, parent);

          this.__offsetY(-_n);

          computedStyle[BOTTOM$3] = _n;
          computedStyle[TOP$3] = 'auto';
        } else {
          computedStyle[TOP$3] = computedStyle[BOTTOM$3] = 'auto';
        }

        if (left[1] !== AUTO$4) {
          var _n2 = calRelative(currentStyle, LEFT$2, left, parent, true);

          this.__offsetX(_n2);

          computedStyle[LEFT$2] = _n2;
          computedStyle[RIGHT$2] = 'auto';
        } else if (right[1] !== AUTO$4) {
          var _n3 = calRelative(currentStyle, RIGHT$2, right, parent, true);

          this.__offsetX(-_n3);

          computedStyle[RIGHT$2] = _n3;
          computedStyle[LEFT$2] = 'auto';
        } else {
          computedStyle[LEFT$2] = computedStyle[RIGHT$2] = 'auto';
        }
      } else if (position !== 'absolute') {
        computedStyle[TOP$3] = computedStyle[BOTTOM$3] = computedStyle[LEFT$2] = computedStyle[RIGHT$2] = 'auto';
      } // 计算结果存入computedStyle和6个坐标，inline在其inlineSize特殊处理


      var x = this.__sx = this.x + this.ox;
      var y = this.__sy = this.y + this.oy;

      if (!__config[NODE_IS_INLINE$1]) {
        x = this.__sx1 = x + computedStyle[MARGIN_LEFT$5];
        x = this.__sx2 = x + computedStyle[BORDER_LEFT_WIDTH$5];
        x = this.__sx3 = x + computedStyle[PADDING_LEFT$5];
        x = this.__sx4 = x + this.width;
        x = this.__sx5 = x + computedStyle[PADDING_RIGHT$4];
        this.__sx6 = x + computedStyle[BORDER_RIGHT_WIDTH$4];
        y = this.__sy1 = y + computedStyle[MARGIN_TOP$4];
        y = this.__sy2 = y + computedStyle[BORDER_TOP_WIDTH$4];
        y = this.__sy3 = y + computedStyle[PADDING_TOP$4];
        y = this.__sy4 = y + this.height;
        y = this.__sy5 = y + computedStyle[PADDING_BOTTOM$4];
        this.__sy6 = y + computedStyle[BORDER_BOTTOM_WIDTH$4];
      }

      computedStyle[WIDTH$4] = this.width;
      computedStyle[HEIGHT$5] = this.height; // abs布局的不执行，在__layoutAbs末尾做，防止未布局没有尺寸从而动画计算错误

      if (!fromAbs) {
        this.__execAr();
      }

      return lineClampCount;
    }
  }, {
    key: "__execAr",
    value: function __execAr() {
      // 动态json引用时动画暂存，第一次布局时处理这些动画到root的animateController上
      var ar = this.__animateRecords;

      if (ar) {
        this.__animateRecords = null; // parse没有dom时，animate的target引用都是json，vd后生成需重新赋值

        ar.list.forEach(function (item) {
          if (item.target.vd instanceof Xom) {
            item.target = item.target.vd;
          }
        });
        var ac = ar.controller || this.root.animateController; // 不自动播放进入记录列表，初始化并等待手动调用

        if (ar.options && ar.options.autoPlay === false) {
          ac.__records2 = ac.__records2.concat(ar.list);
          ac.init(ac.__records2, ac.list2);
        } else {
          ac.__records = ac.__records.concat(ar.list);

          ac.__playAuto();
        }
      }
    }
  }, {
    key: "__layoutNone",
    value: function __layoutNone() {
      var computedStyle = this.computedStyle;
      computedStyle[DISPLAY$7] = 'none';
      computedStyle[MARGIN_TOP$4] = computedStyle[MARGIN_RIGHT$4] = computedStyle[MARGIN_BOTTOM$4] = computedStyle[MARGIN_LEFT$5] = computedStyle[PADDING_TOP$4] = computedStyle[PADDING_RIGHT$4] = computedStyle[PADDING_BOTTOM$4] = computedStyle[PADDING_LEFT$5] = 0;
    } // 预先计算是否是固定宽高，布局点位和尺寸考虑margin/border/padding

  }, {
    key: "__preLayout",
    value: function __preLayout(data, isInline) {
      var x = data.x,
          y = data.y,
          w = data.w,
          h = data.h,
          w2 = data.w2,
          h2 = data.h2,
          w3 = data.w3,
          h3 = data.h3,
          lx = data.lx,
          nowrap = data.nowrap,
          lineBoxManager = data.lineBoxManager,
          _data$endSpace = data.endSpace,
          endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace;
      this.__x = x;
      this.__y = y;
      var currentStyle = this.currentStyle,
          computedStyle = this.computedStyle;
      var width = currentStyle[WIDTH$4],
          height = currentStyle[HEIGHT$5];
      var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$4],
          borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
          borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$4],
          borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
          marginTop = computedStyle[MARGIN_TOP$4],
          marginRight = computedStyle[MARGIN_RIGHT$4],
          marginBottom = computedStyle[MARGIN_BOTTOM$4],
          marginLeft = computedStyle[MARGIN_LEFT$5],
          paddingTop = computedStyle[PADDING_TOP$4],
          paddingRight = computedStyle[PADDING_RIGHT$4],
          paddingBottom = computedStyle[PADDING_BOTTOM$4],
          paddingLeft = computedStyle[PADDING_LEFT$5]; // 除了auto外都是固定宽高度

      var fixedWidth;
      var fixedHeight; // 绝对定位是left+right这种其实等于定义了width，但不能修改原始style，存入特殊变量标识

      if (w2 !== undefined) {
        fixedWidth = true;
        w = w2;
      } // flex时也会用到，子级得出目标主尺寸后按这个来
      else if (w3 !== undefined) {
        fixedWidth = true;
        w = w3;
      } else if (width[1] !== AUTO$4) {
        fixedWidth = true;

        switch (width[1]) {
          case PX$5:
            w = width[0];
            break;

          case PERCENT$5:
            w *= width[0] * 0.01;
            break;

          case REM$9:
            w = width[0] * this.root.computedStyle[FONT_SIZE$9];
            break;

          case VW$9:
            w = width[0] * this.root.width * 0.01;
            break;

          case VH$9:
            w = width[0] * this.root.height * 0.01;
            break;
        }
      }

      if (h2 !== undefined) {
        fixedHeight = true;
        h = h2;
      } else if (h3 !== undefined) {
        fixedHeight = true;
        h = h3;
      } else if (height[1] !== AUTO$4) {
        fixedHeight = true;

        switch (height[1]) {
          case PX$5:
            h = height[0];
            break;

          case PERCENT$5:
            h *= height[0] * 0.01;
            break;

          case REM$9:
            h = height[0] * this.root.computedStyle[FONT_SIZE$9];
            break;

          case VW$9:
            h = height[0] * this.root.width * 0.01;
            break;

          case VH$9:
            h = height[0] * this.root.height * 0.01;
            break;
        }
      } // margin/padding/border影响x和y和尺寸，注意inline的y不受mpb影响


      x += borderLeftWidth + marginLeft + paddingLeft;
      data.x = x;

      if (!isInline) {
        y += borderTopWidth + marginTop + paddingTop;
      }

      data.y = y; // inline的w/h很特殊，需不考虑inline自身水平的mpb以便换行，因为mpb只在首尾行生效，所以首尾需特殊处理中间忽略
      // 当嵌套inline时更加复杂，假如inline有尾部mpb，最后一行需考虑，如果此inline是父的最后一个且父有mpb需叠加

      var selfEndSpace = 0;

      if (isInline) {
        selfEndSpace = paddingRight + borderRightWidth + marginRight;
      } // 传入w3/h3时，flex的item已知目标主尺寸，需减去mpb，其一定是block和inline互斥


      if (!isInline) {
        if (width[1] === AUTO$4 || w3 !== undefined) {
          w -= borderLeftWidth + borderRightWidth + marginLeft + marginRight + paddingLeft + paddingRight;
        }

        if (height[1] === AUTO$4 || h3 !== undefined) {
          h -= borderTopWidth + borderBottomWidth + marginTop + marginBottom + paddingTop + paddingBottom;
        }
      }

      return {
        fixedWidth: fixedWidth,
        fixedHeight: fixedHeight,
        x: x,
        y: y,
        w: w,
        h: h,
        lx: lx,
        lineBoxManager: lineBoxManager,
        nowrap: nowrap,
        endSpace: endSpace,
        selfEndSpace: selfEndSpace
      };
    } // 处理margin:xx auto居中对齐或右对齐

  }, {
    key: "__marginAuto",
    value: function __marginAuto(style, data) {
      var position = style[POSITION$4],
          display = style[DISPLAY$7],
          marginLeft = style[MARGIN_LEFT$5],
          marginRight = style[MARGIN_RIGHT$4],
          width = style[WIDTH$4];

      if (position !== 'absolute' && (display === 'block' || display === 'flex') && (width[1] !== AUTO$4 || this.tagName === 'img') && marginLeft[1] === AUTO$4 && marginRight[1] === AUTO$4) {
        var ow = this.outerWidth;

        if (ow < data.w) {
          this.__offsetX((data.w - ow) * 0.5, true);
        }
      }
    }
  }, {
    key: "__calMatrix",
    value: function __calMatrix(lv, __cacheStyle, currentStyle, computedStyle, __config, sx1, sy1, offsetWidth, offsetHeight) {
      var _this3 = this;

      if (__config[NODE_IS_INLINE$1]) {
        computedStyle[TRANSFORM_ORIGIN$1] = [sx1, sy1];
        return __cacheStyle[MATRIX] = mx.identity();
      }

      var matrixCache = __cacheStyle[MATRIX]; // tx/ty变化特殊优化

      if (matrixCache && lv < REFLOW$2 && !contain$3(lv, TF)) {
        var x = 0,
            y = 0,
            z = 0;

        if (contain$3(lv, TX)) {
          var v = currentStyle[TRANSLATE_X];

          if (isNil$9(v)) {
            v = 0;
          } else if (v[1] === PERCENT$5) {
            v = v[0] * this.offsetWidth * 0.01;
          } else if (v[1] === REM$9) {
            v = v[0] * this.root.computedStyle[FONT_SIZE$9];
          } else if (v[1] === VW$9) {
            v = v[0] * this.root.width * 0.01;
          } else if (v[1] === VH$9) {
            v = v[0] * this.root.height * 0.01;
          } else {
            v = v[0];
          }

          x = v - (computedStyle[TRANSLATE_X] || 0);
          computedStyle[TRANSLATE_X] = v;
          computedStyle[TRANSFORM$1][12] += x;
          matrixCache[12] += x;
        }

        if (contain$3(lv, TY)) {
          var _v = currentStyle[TRANSLATE_Y];

          if (isNil$9(_v)) {
            _v = 0;
          } else if (_v[1] === PERCENT$5) {
            _v = _v[0] * this.offsetHeight * 0.01;
          } else if (_v[1] === REM$9) {
            _v = _v[0] * this.root.computedStyle[FONT_SIZE$9];
          } else if (_v[1] === VW$9) {
            _v = _v[0] * this.root.width * 0.01;
          } else if (_v[1] === VH$9) {
            _v = _v[0] * this.root.height * 0.01;
          } else {
            _v = _v[0];
          }

          y = _v - (computedStyle[TRANSLATE_Y] || 0);
          computedStyle[TRANSLATE_Y] = _v;
          computedStyle[TRANSFORM$1][13] += y;
          matrixCache[13] += y;
        }

        if (contain$3(lv, TZ)) {
          var _v2 = currentStyle[TRANSLATE_Z];

          if (isNil$9(_v2)) {
            _v2 = 0;
          } else if (_v2[1] === PERCENT$5) {
            _v2 = _v2[0] * this.offsetWidth * 0.01;
          } else if (_v2[1] === REM$9) {
            _v2 = _v2[0] * this.root.computedStyle[FONT_SIZE$9];
          } else if (_v2[1] === VW$9) {
            _v2 = _v2[0] * this.root.width * 0.01;
          } else if (_v2[1] === VH$9) {
            _v2 = _v2[0] * this.root.height * 0.01;
          } else {
            _v2 = _v2[0];
          }

          z = _v2 - (computedStyle[TRANSLATE_Z] || 0);
          computedStyle[TRANSLATE_Z] = _v2;
          computedStyle[TRANSFORM$1][14] += z;
          matrixCache[14] += z;
        }

        __cacheStyle[MATRIX] = matrixCache;
      } // 先根据cache计算需要重新计算的computedStyle
      else {
        if (sx1 === undefined) {
          sx1 = this.__sx1;
          sy1 = this.__sy1;
          offsetWidth = this.offsetWidth;
          offsetHeight = this.offsetHeight;
        }

        if (__cacheStyle[TRANSFORM_ORIGIN$1] === undefined) {
          __cacheStyle[TRANSFORM_ORIGIN$1] = true;
          matrixCache = null;
          computedStyle[TRANSFORM_ORIGIN$1] = tf.calOrigin(currentStyle[TRANSFORM_ORIGIN$1], offsetWidth, offsetHeight, this.root);
        }

        if (__cacheStyle[TRANSFORM$1] === undefined || __cacheStyle[TRANSLATE_X] === undefined || __cacheStyle[TRANSLATE_Y] === undefined || __cacheStyle[TRANSLATE_Z] === undefined || __cacheStyle[ROTATE_X] === undefined || __cacheStyle[ROTATE_Y] === undefined || __cacheStyle[ROTATE_Z] === undefined || __cacheStyle[ROTATE_3D] === undefined || __cacheStyle[SCALE_X] === undefined || __cacheStyle[SCALE_Y] === undefined || __cacheStyle[SCALE_Z] === undefined || __cacheStyle[SKEW_X] === undefined || __cacheStyle[SKEW_Y] === undefined) {
          __cacheStyle[TRANSFORM$1] = __cacheStyle[TRANSLATE_X] = __cacheStyle[TRANSLATE_Y] = __cacheStyle[TRANSLATE_Z] = __cacheStyle[ROTATE_X] = __cacheStyle[ROTATE_Y] = __cacheStyle[ROTATE_Z] = __cacheStyle[SCALE_X] = __cacheStyle[SCALE_Y] = __cacheStyle[SCALE_Z] = __cacheStyle[SKEW_X] = __cacheStyle[SKEW_Y] = true;
          matrixCache = null;
          var matrix; // transform相对于自身

          if (currentStyle[TRANSFORM$1]) {
            matrix = tf.calMatrix(currentStyle[TRANSFORM$1], offsetWidth, offsetHeight, this.root);
          } // 没有transform则看是否有扩展的css独立变换属性
          else {
            var temp = [];
            [TRANSLATE_X, TRANSLATE_Y, TRANSLATE_Z, ROTATE_X, ROTATE_Y, ROTATE_Z, ROTATE_3D, SKEW_X, SKEW_Y, SCALE_X, SCALE_Y, SCALE_Z].forEach(function (k) {
              // 删除之前遗留的
              delete computedStyle[k];
              var v = currentStyle[k];

              if (isNil$9(v)) {
                return;
              }

              if (k === ROTATE_3D) {
                computedStyle[k] = [v[0], v[1], v[2], v[3][0]];

                if (v[3][0] === 0) {
                  return;
                }

                temp.push([k, v]);
                return;
              }

              computedStyle[k] = v[0]; // scale为1和其它为0避免计算浪费

              var isScale = k === SCALE_X || k === SCALE_Y || k === SCALE_Z;

              if (v[0] === 1 && isScale || !isScale && v[0] === 0) {
                return;
              }

              if (v[1] === PERCENT$5) {
                if (k === TRANSLATE_X || k === TRANSLATE_Z) {
                  computedStyle[k] = v[0] * offsetWidth * 0.01;
                } else if (k === TRANSLATE_Y) {
                  computedStyle[k] = v[0] * offsetHeight * 0.01;
                }
              } else if (v[1] === REM$9) {
                if (k === TRANSLATE_X || k === TRANSLATE_Z) {
                  computedStyle[k] = v[0] * _this3.root.computedStyle[FONT_SIZE$9];
                } else if (k === TRANSLATE_Y) {
                  computedStyle[k] = v[0] * _this3.root.computedStyle[FONT_SIZE$9];
                }
              } else if (v[1] === VW$9) {
                if (k === TRANSLATE_X || k === TRANSLATE_Z) {
                  computedStyle[k] = v[0] * _this3.root.width * 0.01;
                } else if (k === TRANSLATE_Y) {
                  computedStyle[k] = v[0] * _this3.root.width * 0.01;
                }
              } else if (v[1] === VH$9) {
                if (k === TRANSLATE_X || k === TRANSLATE_Z) {
                  computedStyle[k] = v[0] * _this3.root.height * 0.01;
                } else if (k === TRANSLATE_Y) {
                  computedStyle[k] = v[0] * _this3.root.height * 0.01;
                }
              }

              temp.push([k, v]);
            });

            if (temp.length) {
              matrix = tf.calMatrix(temp, offsetWidth, offsetHeight, this.root);
            }
          }

          computedStyle[TRANSFORM$1] = matrix || mx.identity();
        }

        if (!matrixCache) {
          var m = computedStyle[TRANSFORM$1];
          var tfo = computedStyle[TRANSFORM_ORIGIN$1].slice(0);
          tfo[0] += sx1 || 0;
          tfo[1] += sy1 || 0;
          matrixCache = __cacheStyle[MATRIX] = tf.calMatrixByOrigin(m, tfo);
        }
      }

      return matrixCache;
    }
    /**
     * 将currentStyle计算为computedStyle，同时存入cacheStyle可缓存的结果防止无变更重复计算
     * @param renderMode
     * @param ctx
     * @param parent
     * @param __cacheStyle
     * @param currentStyle
     * @param computedStyle
     * @param clientWidth
     * @param clientHeight
     * @param offsetWidth
     * @param offsetHeight
     * @param borderTopWidth
     * @param borderRightWidth
     * @param borderBottomWidth
     * @param borderLeftWidth
     * @param paddingTop
     * @param paddingRight
     * @param paddingBottom
     * @param paddingLeft
     * @param x1
     * @param x2
     * @param x3
     * @param x4
     * @param x5
     * @param x6
     * @param y1
     * @param y2
     * @param y3
     * @param y4
     * @param y5
     * @param y6
     * @returns {*[]}
     * @private
     */

  }, {
    key: "__calCache",
    value: function __calCache(renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6) {
      var _this4 = this;

      var bx1 = x1,
          by1 = y1,
          bx2 = x6,
          by2 = y6;
      var backgroundClip = computedStyle[BACKGROUND_CLIP] = currentStyle[BACKGROUND_CLIP]; // 默认border-box

      if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
        bx1 = x2;
        by1 = y2;
        bx2 = x5;
        by2 = y5;
      } else if (backgroundClip === 'contentBox' || backgroundClip === 'content-box') {
        bx1 = x3;
        by1 = y3;
        bx2 = x4;
        by2 = y4;
      }

      var isInline = this.__config[NODE_IS_INLINE$1];

      if (isInline && !this.contentBoxList.length) {
        isInline = false;
      } // 这些直接赋值的不需要再算缓存


      [OPACITY$2, Z_INDEX$2, BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE, BORDER_LEFT_STYLE, BACKGROUND_REPEAT, OVERFLOW$2, MIX_BLEND_MODE$3, TEXT_OVERFLOW, BACKGROUND_CLIP].forEach(function (k) {
        computedStyle[k] = currentStyle[k];
      });

      if (isNil$9(__cacheStyle[FILTER$3])) {
        __cacheStyle[FILTER$3] = true;

        this.__calFilter(currentStyle, computedStyle);
      }

      if (isNil$9(__cacheStyle[BACKGROUND_POSITION_X])) {
        __cacheStyle[BACKGROUND_POSITION_X] = true;
        var bgX = currentStyle[BACKGROUND_POSITION_X];
        computedStyle[BACKGROUND_POSITION_X] = (bgX || []).map(function (item) {
          if (item[1] === PX$5) {
            return item[0];
          }

          if (item[1] === REM$9) {
            return item[0] * _this4.root.computedStyle[FONT_SIZE$9];
          }

          if (item[1] === VW$9) {
            return item[0] * _this4.root.width * 0.01;
          }

          if (item[1] === VH$9) {
            return item[0] * _this4.root.height * 0.01;
          }

          if (item[1] === PERCENT$5) {
            return item[0] + '%';
          }
        });
      }

      if (isNil$9(__cacheStyle[BACKGROUND_POSITION_Y])) {
        __cacheStyle[BACKGROUND_POSITION_Y] = true;
        var bgY = currentStyle[BACKGROUND_POSITION_Y];
        computedStyle[BACKGROUND_POSITION_Y] = (bgY || []).map(function (item) {
          if (item[1] === PX$5) {
            return item[0];
          }

          if (item[1] === REM$9) {
            return item[0] * _this4.root.computedStyle[FONT_SIZE$9];
          }

          if (item[1] === VW$9) {
            return item[0] * _this4.root.width * 0.01;
          }

          if (item[1] === VH$9) {
            return item[0] * _this4.root.height * 0.01;
          }

          if (item[1] === PERCENT$5) {
            return item[0] + '%';
          }
        });
      }

      if (isNil$9(__cacheStyle[BACKGROUND_SIZE])) {
        __cacheStyle[BACKGROUND_SIZE] = true;
        computedStyle[BACKGROUND_SIZE] = (currentStyle[BACKGROUND_SIZE] || []).map(function (item) {
          return bg.calBackgroundSize(item, bx2 - bx1, by2 - by1, _this4.root);
        });
      }

      if (isNil$9(__cacheStyle[BACKGROUND_IMAGE$1])) {
        var bgI = computedStyle[BACKGROUND_IMAGE$1] = currentStyle[BACKGROUND_IMAGE$1].slice(0);
        __cacheStyle[BACKGROUND_IMAGE$1] = bgI.map(function (bgi, i) {
          if (!bgi) {
            return null;
          } // 防止隐藏不加载背景图


          if (util.isString(bgi)) {
            var loadBgi = _this4.__loadBgi[i] = _this4.__loadBgi[i] || {};
            var cache = inject.IMG[BACKGROUND_IMAGE$1];

            if (cache && cache.state === inject.LOADED) {
              loadBgi.url = BACKGROUND_IMAGE$1;
              loadBgi.source = cache.source;
              loadBgi.width = cache.width;
              loadBgi.height = cache.height;
            } else if (loadBgi.url !== bgi) {
              // 可能改变导致多次加载，每次清空，成功后还要比对url是否相同
              loadBgi.url = bgi;
              loadBgi.source = null;
              var node = _this4;
              var root = node.root;
              inject.measureImg(bgi, function (data) {
                // 还需判断url，防止重复加载时老的替换新的，失败不绘制bgi
                if (data.success && data.url === loadBgi.url && !_this4.isDestroyed) {
                  loadBgi.source = data.source;
                  loadBgi.width = data.width;
                  loadBgi.height = data.height;
                  root.delRefreshTask(loadBgi.cb);
                  root.addRefreshTask(loadBgi.cb = {
                    __before: function __before() {
                      __cacheStyle[BACKGROUND_IMAGE$1] = undefined;
                      var res = {};
                      res[UPDATE_NODE$3] = node;
                      res[UPDATE_FOCUS$3] = REPAINT$2;
                      res[UPDATE_CONFIG$3] = node.__config;

                      root.__addUpdate(node, node.__config, root, root.__config, res);
                    }
                  });
                }
              }, {
                ctx: ctx,
                root: root,
                width: bx2 - bx1,
                height: by2 - by1
              });
            }

            return true;
          } else if (!isInline && bgi.k) {
            // gradient在渲染时才生成
            return true;
          }
        });
      }

      if (isNil$9(__cacheStyle[BOX_SHADOW$7])) {
        __cacheStyle[BOX_SHADOW$7] = true;
        computedStyle[BOX_SHADOW$7] = (currentStyle[BOX_SHADOW$7] || []).map(function (item) {
          return item.map(function (item2, i) {
            if (i > 3) {
              return item2;
            }

            var v = item2[0];

            if (item2[1] === PERCENT$5) {
              if (i % 2 === 0) {
                v *= 0.01 * (bx2 - bx1);
              } else {
                v *= 0.01 * (by2 - by1);
              }
            } else if (item2[1] === REM$9) {
              v = v * _this4.root.computedStyle[FONT_SIZE$9];
            } else if (item2[1] === VW$9) {
              v = v * _this4.root.width * 0.01;
            } else if (item2[1] === VH$9) {
              v = v * _this4.root.height * 0.01;
            }

            return v;
          });
        });
      }

      [BACKGROUND_COLOR$1, BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR, BORDER_LEFT_COLOR].forEach(function (k) {
        if (isNil$9(__cacheStyle[k])) {
          __cacheStyle[k] = int2rgba$1(computedStyle[k] = currentStyle[k][0]);
        }
      }); // 圆角边计算

      if (isNil$9(__cacheStyle[BORDER_TOP_LEFT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_TOP_RIGHT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1])) {
        __cacheStyle[BORDER_TOP_LEFT_RADIUS$1] = __cacheStyle[BORDER_TOP_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1] = true; // 非替代的inline计算看contentBox首尾

        if (isInline) {
          border.calBorderRadiusInline(this.contentBoxList, currentStyle, computedStyle, this.root);
        } // 普通block整体计算
        else {
          border.calBorderRadius(offsetWidth, offsetHeight, currentStyle, computedStyle, this.root);
        }
      } // width/style/radius影响border，color不影响渲染缓存


      var btlr = computedStyle[BORDER_TOP_LEFT_RADIUS$1];
      var btrr = computedStyle[BORDER_TOP_RIGHT_RADIUS$1];
      var bbrr = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1];
      var bblr = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1];
      ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
        k = 'border' + k;
        var k2 = STYLE_KEY[style2Upper(k)];
        var kw = STYLE_KEY[style2Upper(k + 'Width')];
        var ks = STYLE_KEY[style2Upper(k + 'Style')]; // width/style变更影响border重新计算

        if (isNil$9(__cacheStyle[kw])) {
          __cacheStyle[kw] = true;
          __cacheStyle[k2] = undefined;
        }

        if (isNil$9(__cacheStyle[ks])) {
          __cacheStyle[ks] = true;
          __cacheStyle[k2] = undefined;
        }

        if (isNil$9(__cacheStyle[k2])) {
          if (k2 === BORDER_TOP) {
            if (borderTopWidth > 0) {
              if (!isInline) {
                var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                __cacheStyle[k2] = border.calPoints(borderTopWidth, computedStyle[ks], deg1, deg2, x1, x2, x5, x6, y1, y2, y5, y6, 0, btlr, btrr);
              }
            } else {
              __cacheStyle[k2] = [];
            }
          } else if (k2 === BORDER_RIGHT) {
            if (borderRightWidth > 0) {
              if (!isInline) {
                var _deg = Math.atan(borderRightWidth / borderTopWidth);

                var _deg2 = Math.atan(borderRightWidth / borderBottomWidth);

                __cacheStyle[k2] = border.calPoints(borderRightWidth, computedStyle[ks], _deg, _deg2, x1, x2, x5, x6, y1, y2, y5, y6, 1, btrr, bbrr);
              }
            } else {
              __cacheStyle[k2] = [];
            }
          } else if (k2 === BORDER_BOTTOM) {
            if (borderBottomWidth > 0) {
              if (!isInline) {
                var _deg3 = Math.atan(borderBottomWidth / borderLeftWidth);

                var _deg4 = Math.atan(borderBottomWidth / borderRightWidth);

                __cacheStyle[k2] = border.calPoints(borderBottomWidth, computedStyle[ks], _deg3, _deg4, x1, x2, x5, x6, y1, y2, y5, y6, 2, bblr, bbrr);
              }
            } else {
              __cacheStyle[k2] = [];
            }
          } else if (k2 === BORDER_LEFT) {
            if (borderLeftWidth > 0) {
              if (!isInline) {
                var _deg5 = Math.atan(borderLeftWidth / borderTopWidth);

                var _deg6 = Math.atan(borderLeftWidth / borderBottomWidth);

                __cacheStyle[k2] = border.calPoints(borderLeftWidth, computedStyle[ks], _deg5, _deg6, x1, x2, x5, x6, y1, y2, y5, y6, 3, btlr, bblr);
              }
            } else {
              __cacheStyle[k2] = [];
            }
          }
        }
      }); // 强制计算继承性的

      var parentComputedStyle = parent && parent.computedStyle;

      if (currentStyle[FONT_STYLE][1] === INHERIT$1) {
        computedStyle[FONT_STYLE] = parent ? parentComputedStyle[FONT_STYLE] : 'normal';
      } else if (isNil$9(__cacheStyle[FONT_STYLE])) {
        computedStyle[FONT_STYLE] = currentStyle[FONT_STYLE][0];
      }

      __cacheStyle[FONT_STYLE] = computedStyle[FONT_STYLE];

      if (currentStyle[COLOR$1][1] === INHERIT$1) {
        computedStyle[COLOR$1] = parent ? parentComputedStyle[COLOR$1] : [0, 0, 0, 1];
        __cacheStyle[COLOR$1] = int2rgba$1(computedStyle[COLOR$1]);
      } else if (isNil$9(__cacheStyle[COLOR$1])) {
        computedStyle[COLOR$1] = rgba2int(currentStyle[COLOR$1][0]);
        __cacheStyle[COLOR$1] = int2rgba$1(computedStyle[COLOR$1]);
      }

      if (currentStyle[TEXT_STROKE_COLOR][1] === INHERIT$1) {
        computedStyle[TEXT_STROKE_COLOR] = parent ? parentComputedStyle[TEXT_STROKE_COLOR] : [0, 0, 0, 1];
        __cacheStyle[TEXT_STROKE_COLOR] = int2rgba$1(computedStyle[TEXT_STROKE_COLOR]);
      } else if (isNil$9(__cacheStyle[TEXT_STROKE_COLOR])) {
        computedStyle[TEXT_STROKE_COLOR] = rgba2int(currentStyle[TEXT_STROKE_COLOR][0]);
        __cacheStyle[TEXT_STROKE_COLOR] = int2rgba$1(computedStyle[TEXT_STROKE_COLOR]);
      }

      if (currentStyle[TEXT_STROKE_WIDTH][1] === INHERIT$1) {
        computedStyle[TEXT_STROKE_WIDTH] = parent ? parentComputedStyle[TEXT_STROKE_WIDTH] : 0;
        __cacheStyle[TEXT_STROKE_WIDTH] = true;
      } else if (isNil$9(__cacheStyle[TEXT_STROKE_WIDTH])) {
        var v = currentStyle[TEXT_STROKE_WIDTH];

        if (v[1] === REM$9) {
          v = v[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (v[1] === VW$9) {
          v = v[0] * this.root.width * 0.01;
        } else if (v[1] === VH$9) {
          v = v[0] * this.root.height * 0.01;
        } else {
          v = v[0];
        }

        computedStyle[TEXT_STROKE_WIDTH] = v;
        __cacheStyle[TEXT_STROKE_WIDTH] = true;
      }

      if (currentStyle[TEXT_STROKE_OVER][1] === INHERIT$1) {
        __cacheStyle[TEXT_STROKE_OVER] = computedStyle[TEXT_STROKE_OVER] = parent ? parentComputedStyle[TEXT_STROKE_OVER] : 'none';
      } else {
        __cacheStyle[TEXT_STROKE_OVER] = computedStyle[TEXT_STROKE_OVER] = currentStyle[TEXT_STROKE_OVER][0];
      }

      if (currentStyle[VISIBILITY$4][1] === INHERIT$1) {
        computedStyle[VISIBILITY$4] = parent ? parentComputedStyle[VISIBILITY$4] : 'visible';
      } else if (isNil$9(__cacheStyle[VISIBILITY$4])) {
        computedStyle[VISIBILITY$4] = currentStyle[VISIBILITY$4][0];
      }

      __cacheStyle[VISIBILITY$4] = computedStyle[VISIBILITY$4];

      if (currentStyle[POINTER_EVENTS$1][1] === INHERIT$1) {
        computedStyle[POINTER_EVENTS$1] = parent ? parentComputedStyle[POINTER_EVENTS$1] : 'auto';
      } else if (isNil$9(__cacheStyle[POINTER_EVENTS$1])) {
        computedStyle[POINTER_EVENTS$1] = currentStyle[POINTER_EVENTS$1][0];
      }

      __cacheStyle[POINTER_EVENTS$1] = computedStyle[POINTER_EVENTS$1];
      return [bx1, by1, bx2, by2];
    }
  }, {
    key: "__calPerspective",
    value: function __calPerspective(__cacheStyle, currentStyle, computedStyle, __config, sx1, sy1) {
      var rebuild;

      if (isNil$9(__cacheStyle[PERSPECTIVE$2])) {
        __cacheStyle[PERSPECTIVE$2] = true;
        rebuild = true;
        var v = currentStyle[PERSPECTIVE$2];
        var ppt = 0;

        if (v[1] === REM$9) {
          ppt = v[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (v[1] === VW$9) {
          ppt = v[0] * this.root.width * 0.01;
        } else if (v[1] === VH$9) {
          ppt = v[0] * this.root.height * 0.01;
        } else {
          ppt = v[0];
        }

        computedStyle[PERSPECTIVE$2] = ppt;
      }

      if (isNil$9(__cacheStyle[PERSPECTIVE_ORIGIN$1])) {
        __cacheStyle[PERSPECTIVE_ORIGIN$1] = true;
        rebuild = true;
        computedStyle[PERSPECTIVE_ORIGIN$1] = tf.calOrigin(currentStyle[PERSPECTIVE_ORIGIN$1], this.offsetWidth, this.offsetHeight, this.root);
      }

      if (rebuild) {
        if (sx1 === undefined) {
          sx1 = this.__sx1;
          sy1 = this.__sy1;
        }

        var po = computedStyle[PERSPECTIVE_ORIGIN$1].slice(0);
        po[0] += sx1 || 0;
        po[1] += sy1 || 0;
        __config[NODE_PERSPECTIVE_MATRIX$1] = tf.calPerspectiveMatrix(computedStyle[PERSPECTIVE$2], po);
      }
    }
  }, {
    key: "__calFilter",
    value: function __calFilter(currentStyle, computedStyle) {
      var _this5 = this;

      return computedStyle[FILTER$3] = (currentStyle[FILTER$3] || []).map(function (item) {
        var _item = _slicedToArray(item, 2),
            k = _item[0],
            v = _item[1]; // 部分%单位的滤镜强制使用数字


        if (v[1] === PX$5 || v[1] === DEG || v[1] === PERCENT$5 || v[1] === NUMBER) {
          v = v[0];
        } else if (v[1] === REM$9) {
          v = v[0] * _this5.root.computedStyle[FONT_SIZE$9];
        } else if (v[1] === VW$9) {
          v = v[0] * _this5.root.width * 0.01;
        } else if (v[1] === VH$9) {
          v = v[0] * _this5.root.height * 0.01;
        }

        return [k, v];
      });
    }
  }, {
    key: "__calContent",
    value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
      if (renderMode === CANVAS || renderMode === WEBGL) {
        if (lv < REPAINT$2) {
          return this.__hasContent;
        }

        var visibility = currentStyle[VISIBILITY$4];

        if (visibility !== 'hidden') {
          var bgI = currentStyle[BACKGROUND_IMAGE$1];

          if (Array.isArray(bgI)) {
            for (var i = 0, len = bgI.length; i < len; i++) {
              if (bgI[i]) {
                return true;
              }
            }
          }

          if (currentStyle[BACKGROUND_COLOR$1][0][3] > 0) {
            var width = computedStyle[WIDTH$4],
                height = computedStyle[HEIGHT$5],
                paddingTop = computedStyle[PADDING_TOP$4],
                paddingRight = computedStyle[PADDING_RIGHT$4],
                paddingBottom = computedStyle[PADDING_BOTTOM$4],
                paddingLeft = computedStyle[PADDING_LEFT$5];

            if (width && height || paddingTop || paddingRight || paddingBottom || paddingLeft) {
              return true;
            }
          }

          for (var list = ['Top', 'Right', 'Bottom', 'Left'], _i = 0, _len = list.length; _i < _len; _i++) {
            var k = list[_i];

            if (computedStyle[STYLE_KEY[style2Upper('border' + k + 'Width')]] > 0 && currentStyle[STYLE_KEY[style2Upper('border' + k + 'Color')]][0][3] > 0) {
              return true;
            }
          }

          var _bs = currentStyle[BOX_SHADOW$7];

          if (Array.isArray(_bs)) {
            for (var _i2 = 0, _len2 = _bs.length; _i2 < _len2; _i2++) {
              var item = _bs[_i2];

              if (item && (item[2] > 0 || item[3] > 0)) {
                return true;
              }
            }
          }
        }
      }

      return false;
    }
    /**
     * 渲染基础方法，Dom/Geom公用
     * @param renderMode
     * @param lv
     * @param ctx canvas/svg/webgl共用
     * @param cache 是否开启缓存
     * @return Object
     * x1/x2/x3/x4/y1/y2/y3/y4 坐标
     * break svg判断无变化提前跳出
     * cacheError 离屏申请失败，仅canvas
     * offscreenBlend 无cache时的离屏canvas，仅canvas
     * offscreenFilter 无cache时的离屏canvas，仅canvas
     * offscreenMask 无cache时的离屏canvas，仅canvas
     * offscreenOverflow 无cache时的离屏canvas，仅canvas
     */

  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var _this6 = this;

      var isDestroyed = this.isDestroyed,
          root = this.root,
          __config = this.__config;
      var __cache = __config[NODE_CACHE$3];
      var __cacheStyle = __config[NODE_CACHE_STYLE$2];
      var currentStyle = __config[NODE_CURRENT_STYLE$5];
      var computedStyle = __config[NODE_COMPUTED_STYLE$3]; // 渲染完认为完全无变更，等布局/动画/更新重置

      __config[NODE_REFRESH_LV$2] = NONE$3; // >=REPAINT才会进入这里，清空bbox

      this.__bbox = null;

      if (isDestroyed) {
        return {
          isDestroyed: isDestroyed,
          "break": true
        };
      }

      var virtualDom; // svg设置vd上的lv属性标明<REPAINT时应用缓存，初始化肯定没有

      if (renderMode === SVG) {
        virtualDom = __config[NODE_VIRTUAL_DOM$1] = this.__virtualDom = {
          bb: [],
          children: [],
          visibility: 'visible'
        }; // svg mock，每次都生成，每个节点都是局部根，更新时自底向上清除

        if (!__config[NODE_CACHE_TOTAL$2]) {
          __config[NODE_CACHE_TOTAL$2] = {
            available: true,
            release: function release() {
              this.available = false;
              delete virtualDom.cache;
            }
          };
        } else if (!__config[NODE_CACHE_TOTAL$2].available) {
          __config[NODE_CACHE_TOTAL$2].available = true;
        }
      }

      var display = computedStyle[DISPLAY$7]; // canvas返回信息，svg已经初始化好了vd

      if (display === 'none') {
        return {
          "break": true
        };
      } // 使用sx和sy渲染位置，考虑了relative和translate影响


      var clientWidth = this.clientWidth,
          clientHeight = this.clientHeight,
          offsetWidth = this.offsetWidth,
          offsetHeight = this.offsetHeight,
          __hasMask = this.__hasMask;
      var paddingTop = computedStyle[PADDING_TOP$4],
          paddingRight = computedStyle[PADDING_RIGHT$4],
          paddingBottom = computedStyle[PADDING_BOTTOM$4],
          paddingLeft = computedStyle[PADDING_LEFT$5],
          borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
          borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
          borderTopWidth = computedStyle[BORDER_TOP_WIDTH$4],
          borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$4];
      var isRealInline = __config[NODE_IS_INLINE$1]; // 考虑mpb的6个坐标，inline比较特殊单独计算

      var x1 = this.__sx1;
      var x2 = this.__sx2;
      var x3 = this.__sx3;
      var x4 = this.__sx4;
      var x5 = this.__sx5;
      var x6 = this.__sx6;
      var y1 = this.__sy1;
      var y2 = this.__sy2;
      var y3 = this.__sy3;
      var y4 = this.__sy4;
      var y5 = this.__sy5;
      var y6 = this.__sy6;
      var res = {
        ctx: ctx,
        x1: x1,
        x2: x2,
        x3: x3,
        x4: x4,
        x5: x5,
        x6: x6,
        y1: y1,
        y2: y2,
        y3: y3,
        y4: y4,
        y5: y5,
        y6: y6,
        sx1: x1,
        sx2: x2,
        sx3: x3,
        sx4: x4,
        sx5: x5,
        sx6: x6,
        sy1: y1,
        sy2: y2,
        sy3: y3,
        sy4: y4,
        sy5: y5,
        sy6: y6
      }; // 防止cp直接返回cp嵌套，拿到真实dom的parent

      var p = __config[NODE_DOM_PARENT$4];

      var hasContent = this.__hasContent = __config[NODE_HAS_CONTENT] = this.__calContent(renderMode, lv, currentStyle, computedStyle);

      this.__calPerspective(__cacheStyle, currentStyle, computedStyle, __config);

      var matrix = this.__calMatrix(lv, __cacheStyle, currentStyle, computedStyle, __config, x1, y1, offsetWidth, offsetHeight); // canvas特殊申请离屏缓存


      var dx = 0,
          dy = 0;

      if (cache && (renderMode === CANVAS || renderMode === WEBGL)) {
        // 无内容可释放并提前跳出，geom覆盖特殊判断，因为后面子类会绘制矢量，img也覆盖特殊判断，加载完肯定有内容
        if (!hasContent && this.__releaseWhenEmpty(__cache)) {
          res["break"] = true;
          __config[NODE_LIMIT_CACHE$1] = false;
        } // 新生成根据最大尺寸，排除margin从border开始还要考虑阴影滤镜等，geom单独在dom里做
        else if (!__config[NODE_LIMIT_CACHE$1]) {
          var bbox = this.bbox;

          if (__cache) {
            __cache.reset(bbox, x1, y1);
          } else {
            __cache = Cache.getInstance(bbox, x1, y1);
          } // cache成功设置坐标偏移，否则为超过最大尺寸限制不使用缓存


          if (__cache && __cache.enabled) {
            __cache.__bbox = bbox;
            ctx = __cache.ctx;
            dx = __cache.dx;
            dy = __cache.dy; // 重置ctx为cache的，以及绘制坐标为cache的区域

            if (dx) {
              res.x1 = x1 += dx;
              res.x2 = x2 += dx;
              res.x3 = x3 += dx;
              res.x4 = x4 += dx;
              res.x5 = x5 += dx;
              res.x6 = x6 += dx;
            }

            if (dy) {
              res.y1 = y1 += dy;
              res.y2 = y2 += dy;
              res.y3 = y3 += dy;
              res.y4 = y4 += dy;
              res.y5 = y5 += dy;
              res.y6 = y6 += dy;
            }

            res.ctx = ctx;
          } else {
            __config[NODE_LIMIT_CACHE$1] = true;
            __cache = null;
            res.limitCache = res["break"] = true;
          }

          __config[NODE_CACHE$3] = __cache;
        }
      } // 降级的webgl绘制
      else if (renderMode === WEBGL) {
        var c = inject.getCacheCanvas(root.width, root.height, '__$$OVERSIZE$$__');
        res.ctx = ctx = c.ctx;
      }

      res.dx = dx;
      res.dy = dy; // 计算好cacheStyle的内容，以及位图缓存指数

      var _this$__calCache = this.__calCache(renderMode, ctx, p, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6),
          _this$__calCache2 = _slicedToArray(_this$__calCache, 4),
          bx1 = _this$__calCache2[0],
          by1 = _this$__calCache2[1],
          bx2 = _this$__calCache2[2],
          by2 = _this$__calCache2[3];

      res.bx1 = bx1;
      res.by1 = by1;
      res.bx2 = bx2;
      res.by2 = by2;
      var backgroundColor = computedStyle[BACKGROUND_COLOR$1],
          borderTopColor = computedStyle[BORDER_TOP_COLOR],
          borderRightColor = computedStyle[BORDER_RIGHT_COLOR],
          borderBottomColor = computedStyle[BORDER_BOTTOM_COLOR],
          borderLeftColor = computedStyle[BORDER_LEFT_COLOR],
          borderTopLeftRadius = computedStyle[BORDER_TOP_LEFT_RADIUS$1],
          borderTopRightRadius = computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
          borderBottomRightRadius = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
          borderBottomLeftRadius = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
          visibility = computedStyle[VISIBILITY$4],
          backgroundRepeat = computedStyle[BACKGROUND_REPEAT],
          backgroundImage = computedStyle[BACKGROUND_IMAGE$1],
          opacity = computedStyle[OPACITY$2],
          filter = computedStyle[FILTER$3],
          backgroundSize = computedStyle[BACKGROUND_SIZE],
          boxShadow = computedStyle[BOX_SHADOW$7],
          overflow = computedStyle[OVERFLOW$2],
          mixBlendMode = computedStyle[MIX_BLEND_MODE$3],
          backgroundClip = computedStyle[BACKGROUND_CLIP]; // 先设置透明度，canvas可以向上累积

      if (renderMode === CANVAS || renderMode === WEBGL) {
        if (p) {
          opacity *= p.__config[NODE_OPACITY$1];
        }

        __config[NODE_OPACITY$1] = opacity;
      } else if (renderMode === SVG) {
        if (opacity === 1) {
          delete virtualDom.opacity;
        } else {
          virtualDom.opacity = opacity;
        }
      } // canvas/svg/事件需要3种不同的matrix


      if (renderMode === SVG) {
        if (!mx.isE(matrix)) {
          virtualDom.transform = 'matrix(' + joinArr$1(mx.m2m6(matrix), ',') + ')';
        } else {
          delete virtualDom.transform;
        }

        virtualDom.visibility = visibility;
      }

      var m = __config[NODE_MATRIX$2];
      util.assignMatrix(m, matrix); // 变换和canvas要以父元素matrixEvent为基础，svg使用自身即css规则，webgl在struct渲染时另算

      if (p) {
        if (p.perspectiveMatrix) {
          matrix = mx.multiply(p.perspectiveMatrix, matrix);
        }

        matrix = mx.multiply(p.matrixEvent, matrix);
      } // 为了引用不变，防止变化后text子节点获取不到，恶心的v8优化，初始化在构造函数中空数组


      m = __config[NODE_MATRIX_EVENT$2];
      util.assignMatrix(m, matrix); // 无离屏功能或超限视为不可缓存本身，等降级无cache再次绘制，webgl一样

      if (res.limitCache) {
        return res;
      } // 按照顺序依次检查生成offscreen离屏功能，顺序在structs中渲染离屏时用到，多个离屏时隔离并且后面有前面的ctx引用


      var offscreenBlend;

      if (mixBlendMode !== 'normal' && isValidMbm$1(mixBlendMode)) {
        mixBlendMode = mbmName$1(mixBlendMode);

        if (renderMode === CANVAS && !cache) {
          var width = root.width,
              height = root.height;
          var c = inject.getCacheCanvas(width, height, null, 'blend');
          offscreenBlend = {
            ctx: ctx,
            target: c,
            mixBlendMode: mixBlendMode,
            matrix: matrix
          };
          ctx = c.ctx;
        } else if (renderMode === SVG) {
          virtualDom.mixBlendMode = mixBlendMode;
        }
      } // svg特殊没有mbm删除
      else if (renderMode === SVG) {
        delete virtualDom.mixBlendMode;
      }

      var offscreenMask;

      if (__hasMask) {
        if (renderMode === CANVAS && !cache) {
          var _width = root.width,
              _height = root.height;

          var _c = inject.getCacheCanvas(_width, _height, null, 'mask1');

          offscreenMask = {
            ctx: ctx,
            target: _c,
            matrix: matrix
          };
          ctx = _c.ctx;
        }
      } // 无cache时canvas的blur需绘制到离屏上应用后反向绘制回来，有cache在Dom里另生成一个filter的cache


      var hasFilter = filter && filter.length;
      var offscreenFilter;

      if (hasFilter) {
        if (renderMode === CANVAS && !cache) {
          var _width2 = root.width,
              _height2 = root.height;

          var _c2 = inject.getCacheCanvas(_width2, _height2, null, 'filter1');

          offscreenFilter = {
            ctx: ctx,
            filter: filter,
            target: _c2,
            matrix: matrix
          };
          ctx = _c2.ctx;
        } else if (renderMode === SVG) {
          virtualDom.filter = painter.svgFilter(filter);
        }
      } else if (renderMode === SVG) {
        delete virtualDom.filter;
      } // 根据backgroundClip的不同值要调整bg渲染坐标尺寸，也会影响borderRadius


      var btlr = borderTopLeftRadius.slice(0);
      var btrr = borderTopRightRadius.slice(0);
      var bbrr = borderBottomRightRadius.slice(0);
      var bblr = borderBottomLeftRadius.slice(0);

      if (backgroundClip === 'padding-box' || backgroundClip === 'paddingBox') {
        btlr[0] -= borderLeftWidth;
        btlr[1] -= borderTopWidth;
        btrr[0] -= borderRightWidth;
        btrr[1] -= borderTopWidth;
        bbrr[0] -= borderRightWidth;
        bbrr[1] -= borderBottomWidth;
        bblr[0] -= borderLeftWidth;
        bblr[1] -= borderBottomWidth;
      } else if (backgroundClip === 'content-box' || backgroundClip === 'contentBox') {
        btlr[0] -= borderLeftWidth + paddingLeft;
        btlr[1] -= borderTopWidth + paddingTop;
        btrr[0] -= borderRightWidth + paddingRight;
        btrr[1] -= borderTopWidth + paddingTop;
        bbrr[0] -= borderRightWidth + paddingRight;
        bbrr[1] -= borderBottomWidth + paddingBottom;
        bblr[0] -= borderLeftWidth + paddingLeft;
        bblr[1] -= borderBottomWidth + paddingBottom;
      } // overflow:hidden，最后判断，filter/mask优先


      var offscreenOverflow, borderList;

      if (overflow === 'hidden' && display !== 'inline') {
        borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);

        if (renderMode === CANVAS && !cache) {
          var _width3 = root.width,
              _height3 = root.height;

          var _c3 = inject.getCacheCanvas(_width3, _height3, null, 'overflow');

          offscreenOverflow = {
            ctx: ctx,
            target: _c3,
            matrix: matrix
          };
          ctx = _c3.ctx;
          offscreenOverflow.x = x1;
          offscreenOverflow.y = y1;
          offscreenOverflow.offsetWidth = offsetWidth;
          offscreenOverflow.offsetHeight = offsetHeight;
          offscreenOverflow.list = borderList;
        } else if (renderMode === SVG) {
          var d = svgPolygon$2(borderList) || "M".concat(x1, ",").concat(y1, "L").concat(x1 + offsetWidth, ",").concat(y1, "L").concat(x1 + offsetWidth, ",").concat(y1 + offsetHeight, "L").concat(x1, ",").concat(y1 + offsetHeight, ",L").concat(x1, ",").concat(y1);
          var v = {
            tagName: 'clipPath',
            props: [],
            children: [{
              tagName: 'path',
              props: [['d', d]]
            }]
          };
          var id = ctx.add(v);

          __config[NODE_DEFS_CACHE$3].push(v);

          virtualDom.overflow = 'url(#' + id + ')';
        }
      } else if (renderMode === SVG) {
        delete virtualDom.overflow;
      } // 无法使用缓存时主画布直接绘制需设置


      if (renderMode === CANVAS && !cache) {
        res.offscreenBlend = offscreenBlend;
        res.offscreenMask = offscreenMask;
        res.offscreenFilter = offscreenFilter;
        res.offscreenOverflow = offscreenOverflow;
        res.ctx = ctx;
        ctx.globalAlpha = opacity;
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      } // 隐藏不渲染


      if ((visibility === 'hidden' || res["break"]) && (renderMode === CANVAS || renderMode === WEBGL)) {
        res["break"] = true;
        return res;
      }

      if (__cache && __cache.enabled) {
        __cache.__available = true;
      }
      /**
       * inline的渲染同block/ib不一样，不是一个矩形区域
       * 它根据内部的contentBox渲染，contentBox是指lineBox中的内容，即TextBox/inline/ib元素
       * 首尾可能不满行，比如从一半开始或一半结束，甚至可能没有内容
       * 两行之间可能不满，如果lineBox的高度>lineHeight的话，另外特殊字体如arial拥有lineGap也会产生间隙，背景色不绘制这个间隙
       * x轴根据contentBox的范围坐标，y则固定和font/lineHeight相关
       * 圆角发生在首尾lineBox处，中间不会有，bgi则产生类似bgc作为mask的效果
       * 另外要注意多个时的顺序，必须依次渲染，后面的bb可能会覆盖前面行的
       */


      if (isRealInline) {
        var contentBoxList = this.contentBoxList;
        var length = contentBoxList.length;
        var hasBgi = backgroundImage.some(function (item) {
          return item;
        });

        if (length) {
          var _ret = function () {
            var fontSize = computedStyle[FONT_SIZE$9],
                fontFamily = computedStyle[FONT_FAMILY],
                lineHeight = computedStyle[LINE_HEIGHT$1];
            var iw = 0,
                ih = 0;
            var offscreen,
                svgBgSymbol = []; // bgi视作inline排满一行绘制，然后按分行拆开给每行

            if (hasBgi) {
              iw = inline.getInlineWidth(_this6, contentBoxList);
              ih = lineHeight;

              if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
                iw += paddingLeft + paddingRight;
                ih += paddingTop + paddingBottom;
              } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
                iw += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                ih += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
              }

              if (renderMode === CANVAS || renderMode === WEBGL) {
                offscreen = inject.getCacheCanvas(iw, ih, '__$$INLINE_BGI$$__');
              }

              var _length = backgroundImage.length;
              backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
                if (!bgi) {
                  return;
                }

                i = _length - 1 - i;

                if (util.isString(bgi)) {
                  var loadBgi = _this6.__loadBgi[i];

                  if (loadBgi.url === backgroundImage[i]) {
                    var uuid = bg.renderImage(_this6, renderMode, offscreen && offscreen.ctx || ctx, loadBgi, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, currentStyle, i, backgroundSize, backgroundRepeat, __config, true);

                    if (renderMode === SVG && uuid) {
                      svgBgSymbol.push(uuid);
                    }
                  }
                } else if (bgi.k) {
                  var gd = _this6.__gradient(renderMode, ctx, 0, 0, iw, ih, bgi);

                  if (gd) {
                    if (gd.k === 'conic') {
                      var _uuid = gradient.renderConic(_this6, renderMode, offscreen && offscreen.ctx || ctx, gd.v, 0, 0, iw, lineHeight, btlr, btrr, bbrr, bblr, true);

                      if (renderMode === SVG && _uuid) {
                        svgBgSymbol.push(_uuid);
                      }
                    } else {
                      var _uuid2 = bg.renderBgc(_this6, renderMode, offscreen && offscreen.ctx || ctx, gd.v, null, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, 'fill', true);

                      if (renderMode === SVG && _uuid2) {
                        svgBgSymbol.push(_uuid2);
                      }
                    }
                  }
                }
              });
            } // 获取当前dom的baseLine，再减去lineBox的baseLine得出差值，这样渲染范围y就是lineBox的y+差值为起始，lineHeight为高


            var ff = css.getFontFamily(fontFamily);
            var baseLine = css.getBaseLine(computedStyle); // lineGap，一般为0，某些字体如arial有，渲染高度需减去它，最终是lineHeight - diffL

            var diffL = fontSize * (o$3.info[ff].lgr || 0); // 注意只有1个的时候特殊情况，圆角只在首尾行出现

            var isFirst = true;
            var lastContentBox = contentBoxList[0],
                lastLineBox = lastContentBox.parentLineBox; // bgi需统计宽度累计值，将当前行所处理想单行的x范围位置计算出来，并进行bgi贴图绘制，svg还需统计第几行

            var countW = 0;

            for (var i = 0; i < length; i++) {
              var contentBox = contentBoxList[i];

              if (contentBox.parentLineBox !== lastLineBox) {
                (function () {
                  // 上一行
                  var _inline$getInlineBox = inline.getInlineBox(_this6, contentBoxList, lastContentBox, contentBoxList[i - 1], lastLineBox, baseLine, lineHeight, diffL, isFirst, false, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                      _inline$getInlineBox2 = _slicedToArray(_inline$getInlineBox, 8),
                      ix1 = _inline$getInlineBox2[0],
                      iy1 = _inline$getInlineBox2[1],
                      ix2 = _inline$getInlineBox2[2],
                      iy2 = _inline$getInlineBox2[3],
                      bx1 = _inline$getInlineBox2[4],
                      by1 = _inline$getInlineBox2[5],
                      bx2 = _inline$getInlineBox2[6],
                      by2 = _inline$getInlineBox2[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                  if (isFirst) {
                    var n = getFirstEmptyInlineWidth(_this6);
                    ix1 -= n;
                    bx1 -= n;
                  }

                  if (backgroundColor[3] > 0) {
                    bg.renderBgc(_this6, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], null, ix1 + dx, iy1 + dy, ix2 - ix1, iy2 - iy1, btlr, [0, 0], [0, 0], bblr);
                  }

                  var w = ix2 - ix1; // canvas的bg位图裁剪

                  if ((renderMode === CANVAS || renderMode === WEBGL) && offscreen) {
                    ctx.drawImage(offscreen.canvas, countW, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                  } //svg则特殊判断
                  else if (renderMode === SVG && svgBgSymbol.length) {
                    svgBgSymbol.forEach(function (symbol) {
                      if (symbol) {
                        var _v3 = {
                          tagName: 'clipPath',
                          props: [],
                          children: [{
                            tagName: 'path',
                            props: [['d', "M".concat(countW, ",", 0, "L").concat(w + countW, ",", 0, "L").concat(w + countW, ",").concat(ih, "L").concat(countW, ",").concat(ih, ",L").concat(countW, ",", 0)]]
                          }]
                        };
                        var clip = ctx.add(_v3);

                        __config[NODE_DEFS_CACHE$3].push(_v3);

                        virtualDom.bb.push({
                          type: 'item',
                          tagName: 'use',
                          props: [['xlink:href', '#' + symbol], ['x', ix1 - countW], ['y', iy1], ['clip-path', 'url(#' + clip + ')']]
                        });
                      }
                    });
                  }

                  countW += w;

                  if (boxShadow) {
                    boxShadow.forEach(function (item) {
                      bs.renderBoxShadow(_this6, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1);
                    });
                  }

                  if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                    var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                    var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                    var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], [0, 0]);
                    border.renderBorder(_this6, renderMode, ctx, list, __cacheStyle[BORDER_TOP_COLOR], dx, dy);
                  }

                  if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                    var _deg7 = Math.atan(borderBottomWidth / borderLeftWidth);

                    var _deg8 = Math.atan(borderBottomWidth / borderRightWidth);

                    var _list = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg7, _deg8, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], [0, 0]);

                    border.renderBorder(_this6, renderMode, ctx, _list, __cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                  }

                  if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                    var _deg9 = Math.atan(borderLeftWidth / borderTopWidth);

                    var _deg10 = Math.atan(borderLeftWidth / borderBottomWidth);

                    var _list2 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg9, _deg10, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                    border.renderBorder(_this6, renderMode, ctx, _list2, __cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                  }

                  isFirst = false;
                  lastContentBox = contentBox;
                  lastLineBox = contentBox.parentLineBox;
                })();
              } // 最后一个特殊判断


              if (i === length - 1) {
                (function () {
                  var _inline$getInlineBox3 = inline.getInlineBox(_this6, contentBoxList, lastContentBox, contentBoxList[i], lastLineBox, baseLine, lineHeight, diffL, isFirst, true, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                      _inline$getInlineBox4 = _slicedToArray(_inline$getInlineBox3, 8),
                      ix1 = _inline$getInlineBox4[0],
                      iy1 = _inline$getInlineBox4[1],
                      ix2 = _inline$getInlineBox4[2],
                      iy2 = _inline$getInlineBox4[3],
                      bx1 = _inline$getInlineBox4[4],
                      by1 = _inline$getInlineBox4[5],
                      bx2 = _inline$getInlineBox4[6],
                      by2 = _inline$getInlineBox4[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                  if (isFirst) {
                    var _n4 = getFirstEmptyInlineWidth(_this6);

                    ix1 -= _n4;
                    bx1 -= _n4;
                  } // 要算上末尾空白inline，可能有多个和递归嵌套


                  var n = getLastEmptyInlineWidth(_this6);
                  ix2 += n;
                  bx2 += n;

                  if (backgroundColor[3] > 0) {
                    bg.renderBgc(_this6, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], null, ix1 + dx, iy1 + dy, ix2 - ix1, iy2 - iy1, isFirst ? btlr : [0, 0], btrr, bbrr, isFirst ? bblr : [0, 0]);
                  }

                  var w = ix2 - ix1; // canvas的bg位图裁剪

                  if ((renderMode === CANVAS || renderMode === WEBGL) && offscreen) {
                    ctx.drawImage(offscreen.canvas, countW, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                  } //svg则特殊判断
                  else if (renderMode === SVG && svgBgSymbol.length) {
                    svgBgSymbol.forEach(function (symbol) {
                      if (symbol) {
                        var _v4 = {
                          tagName: 'clipPath',
                          props: [],
                          children: [{
                            tagName: 'path',
                            props: [['d', "M".concat(countW, ",", 0, "L").concat(w + countW, ",", 0, "L").concat(w + countW, ",").concat(ih, "L").concat(countW, ",").concat(ih, ",L").concat(countW, ",", 0)]]
                          }]
                        };
                        var clip = ctx.add(_v4);

                        __config[NODE_DEFS_CACHE$3].push(_v4);

                        virtualDom.bb.push({
                          type: 'item',
                          tagName: 'use',
                          props: [['xlink:href', '#' + symbol], ['x', ix1 - countW], ['y', iy1], ['clip-path', 'url(#' + clip + ')']]
                        });
                      }
                    });
                  }

                  if (boxShadow) {
                    boxShadow.forEach(function (item) {
                      bs.renderBoxShadow(_this6, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1);
                    });
                  }

                  if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                    var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                    var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                    var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], btrr);
                    border.renderBorder(_this6, renderMode, ctx, list, __cacheStyle[BORDER_TOP_COLOR], dx, dy);
                  }

                  if (borderRightWidth > 0 && borderRightColor[3] > 0) {
                    var _deg11 = Math.atan(borderRightWidth / borderTopWidth);

                    var _deg12 = Math.atan(borderRightWidth / borderBottomWidth);

                    var _list3 = border.calPoints(borderRightWidth, computedStyle[BORDER_RIGHT_STYLE], _deg11, _deg12, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 1, btlr, btrr);

                    border.renderBorder(_this6, renderMode, ctx, _list3, __cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
                  }

                  if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                    var _deg13 = Math.atan(borderBottomWidth / borderLeftWidth);

                    var _deg14 = Math.atan(borderBottomWidth / borderRightWidth);

                    var _list4 = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg13, _deg14, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], btrr);

                    border.renderBorder(_this6, renderMode, ctx, _list4, __cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                  }

                  if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                    var _deg15 = Math.atan(borderLeftWidth / borderTopWidth);

                    var _deg16 = Math.atan(borderLeftWidth / borderBottomWidth);

                    var _list5 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg15, _deg16, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                    border.renderBorder(_this6, renderMode, ctx, _list5, __cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                  }
                })();
              }
            }

            if (offscreen) {
              offscreen.ctx.clearRect(0, 0, iw, ih);
            }

            return {
              v: res
            };
          }();

          if (_typeof(_ret) === "object") return _ret.v;
        } // 无内容且无尺寸的无需渲染
        else if (bx1 === bx2 || by1 === by2) {
          return res;
        }
      } // block渲染，bgc垫底


      if (backgroundColor[3] > 0) {
        bg.renderBgc(this, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
      } // 渐变或图片叠加


      if (backgroundImage) {
        var _length2 = backgroundImage.length;
        backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
          if (!bgi) {
            return;
          }

          i = _length2 - 1 - i;

          if (util.isString(bgi)) {
            var loadBgi = _this6.__loadBgi[i];

            if (loadBgi.url === backgroundImage[i]) {
              bg.renderImage(_this6, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, currentStyle, i, backgroundSize, backgroundRepeat, __config);
            }
          } else if (bgi.k) {
            var gd = _this6.__gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi);

            if (gd) {
              if (gd.k === 'conic') {
                gradient.renderConic(_this6, renderMode, ctx, gd.v, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
              } else {
                bg.renderBgc(_this6, renderMode, ctx, gd.v, borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
              }
            }
          }
        });
      } // boxShadow可能会有多个


      if (boxShadow) {
        boxShadow.forEach(function (item) {
          bs.renderBoxShadow(_this6, renderMode, ctx, item, x1, y1, x6, y6, x6 - x1, y6 - y1);
        });
      } // 边框需考虑尖角，两条相交边平分45°夹角


      if (borderTopWidth > 0 && borderTopColor[3] > 0) {
        border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_TOP], __cacheStyle[BORDER_TOP_COLOR]);
      }

      if (borderRightWidth > 0 && borderRightColor[3] > 0) {
        border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_RIGHT], __cacheStyle[BORDER_RIGHT_COLOR]);
      }

      if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
        border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_BOTTOM], __cacheStyle[BORDER_BOTTOM_COLOR]);
      }

      if (borderLeftWidth > 0 && borderLeftColor[3] > 0) {
        border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_LEFT], __cacheStyle[BORDER_LEFT_COLOR]);
      }

      return res;
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      if (this.isDestroyed) {
        return;
      }

      _get(_getPrototypeOf(Xom.prototype), "__destroy", this).call(this);

      var root = this.root;
      this.clearAnimate();
      this.clearFrameAnimate();
      root.delRefreshTask(this.__loadBgi.cb);
      root.delRefreshTask(this.__task);
      this.__task = null;
      this.__root = null;
      this.clearCache();
    } // 先查找到注册了事件的节点，再捕获冒泡判断增加性能

  }, {
    key: "__emitEvent",
    value: function __emitEvent(e, force) {
      var isDestroyed = this.isDestroyed,
          computedStyle = this.computedStyle,
          isMask = this.isMask;

      if (isDestroyed || computedStyle[DISPLAY$7] === 'none' || e.__stopPropagation || isMask) {
        return;
      }

      var type = e.event.type;
      var listener = this.listener,
          __hasMask = this.__hasMask;
      var cb;

      if (listener.hasOwnProperty(type)) {
        cb = listener[type];
      } // touchmove之类强制的直接由Root通知即可


      if (force) {
        if (computedStyle[POINTER_EVENTS$1] !== 'none' && util.isFunction(cb) && !e.__stopImmediatePropagation) {
          cb.call(this, e);
        }

        return true;
      } // 非force的判断事件坐标是否在节点内


      if (this.willResponseEvent(e)) {
        // 如果有mask，点在mask上才行，点在clip外才行
        if (__hasMask) {
          var next = this.next;
          var isClip = next.isClip;
          var hasEmitMask;

          while (next && next.isMask) {
            if (next.willResponseEvent(e, true)) {
              hasEmitMask = true;
              break;
            }

            next = next.next;
          }

          if (!isClip && !hasEmitMask) {
            return;
          }
        }

        if (util.isFunction(cb) && !e.__stopImmediatePropagation) {
          cb.call(this, e);
        }

        return true;
      }
    }
  }, {
    key: "willResponseEvent",
    value: function willResponseEvent(e, ignore) {
      var x = e.x,
          y = e.y;
      var __sx1 = this.__sx1,
          __sy1 = this.__sy1,
          offsetWidth = this.offsetWidth,
          offsetHeight = this.offsetHeight,
          matrixEvent = this.matrixEvent,
          computedStyle = this.computedStyle;

      if (computedStyle[POINTER_EVENTS$1] === 'none') {
        return;
      }

      var inThis = geom$1.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + offsetWidth, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight, __sx1, __sy1 + offsetHeight, matrixEvent);

      if (inThis) {
        if (!e.target && !ignore) {
          e.target = this; // 缓存target给move用

          if (e.event.type === 'touchstart') {
            this.root && (this.root.__touchstartTarget = this);
          }
        }

        return true;
      }
    }
  }, {
    key: "__gradient",
    value: function __gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi) {
      var iw = bx2 - bx1;
      var ih = by2 - by1; // 无尺寸无需创建渐变

      if (!iw || !ih) {
        return;
      }

      var k = bgi.k,
          v = bgi.v,
          d = bgi.d,
          s = bgi.s,
          z = bgi.z,
          p = bgi.p;
      var cx = bx1 + iw * 0.5;
      var cy = by1 + ih * 0.5;
      var res = {
        k: k
      };

      if (k === 'linear') {
        var gd = gradient.getLinear(v, d, bx1, by1, cx, cy, iw, ih, this.root);
        res.v = this.__getLg(renderMode, ctx, gd);
      } else if (k === 'radial') {
        var _gd = gradient.getRadial(v, s, z, p, bx1, by1, bx2, by2, this.root);

        if (_gd) {
          res.v = this.__getRg(renderMode, ctx, _gd);

          if (_gd.matrix) {
            res.v = [res.v, _gd.matrix, _gd.cx, _gd.cy];
          }
        }
      } else if (k === 'conic') {
        var bbox = this.bbox;
        var m1 = Math.max(Math.abs(bbox[2] - bbox[0]), Math.abs(bbox[3] - bbox[1]));
        var m2 = Math.max(Math.abs(iw), Math.abs(ih));

        var _gd2 = gradient.getConic(v, d, p, bx1, by1, bx2, by2, m1 / m2, this.root);

        res.v = this.__getCg(renderMode, ctx, _gd2);
      }

      return res;
    }
  }, {
    key: "__getLg",
    value: function __getLg(renderMode, ctx, gd) {
      if (renderMode === CANVAS || renderMode === WEBGL) {
        var lg = ctx.createLinearGradient(gd.x1, gd.y1, gd.x2, gd.y2);
        gd.stop.forEach(function (item) {
          lg.addColorStop(item[1], int2rgba$1(item[0]));
        });
        return lg;
      } else if (renderMode === SVG) {
        var v = {
          tagName: 'linearGradient',
          props: [['x1', gd.x1], ['y1', gd.y1], ['x2', gd.x2], ['y2', gd.y2]],
          children: gd.stop.map(function (item) {
            return {
              tagName: 'stop',
              props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
            };
          })
        };
        var uuid = ctx.add(v);

        this.__config[NODE_DEFS_CACHE$3].push(v);

        return 'url(#' + uuid + ')';
      }
    }
  }, {
    key: "__getRg",
    value: function __getRg(renderMode, ctx, gd) {
      if (renderMode === CANVAS || renderMode === WEBGL) {
        var rg = ctx.createRadialGradient(gd.cx, gd.cy, 0, gd.cx, gd.cy, gd.r);
        gd.stop.forEach(function (item) {
          rg.addColorStop(item[1], int2rgba$1(item[0]));
        });
        return rg;
      } else if (renderMode === SVG) {
        var v = {
          tagName: 'radialGradient',
          props: [['cx', gd.cx], ['cy', gd.cy], ['r', gd.r]],
          children: gd.stop.map(function (item) {
            return {
              tagName: 'stop',
              props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
            };
          })
        };
        var uuid = ctx.add(v);

        this.__config[NODE_DEFS_CACHE$3].push(v);

        return 'url(#' + uuid + ')';
      }
    }
  }, {
    key: "__getCg",
    value: function __getCg(renderMode, ctx, gd) {
      var cx = gd.cx,
          cy = gd.cy,
          r = gd.r,
          deg = gd.deg,
          stop = gd.stop;
      var len = stop.length - 1;

      if (stop[len][1] < 1) {
        stop.push([stop[len][0].slice(0), 1]);
      }

      if (stop[0][1] > 0) {
        stop.unshift([stop[0][0].slice(0), 0]);
      } // canvas采用点色值计算法，svg则分360度画块


      var res = [];

      if (renderMode === CANVAS || renderMode === WEBGL) {
        return gd;
      } else if (renderMode === SVG) {
        var offset = 0.5;
        var prev; // 根据2个stop之间的百分比得角度差划分块数，每0.5°一块，不足也算

        var list = [];

        for (var i = 0, _len3 = stop.length; i < _len3 - 1; i++) {
          var begin = stop[i][1] * 360;

          var _end = stop[i + 1][1] * 360;

          var diff = _end - begin;
          var n = Math.ceil(diff);
          var per = diff / n; // 计算每块的2个弧端点

          var bc = stop[i][0];
          var ec = stop[i + 1][0];
          var dc = [ec[0] - bc[0], ec[1] - bc[1], ec[2] - bc[2], ec[3] - bc[3]];
          var pc = [dc[0] / n, dc[1] / n, dc[2] / n, dc[3] / n];

          for (var j = 0; j < n; j++) {
            var _geom$pointOnCircle = geom$1.pointOnCircle(cx, cy, r, begin + per * j + deg - offset),
                _geom$pointOnCircle2 = _slicedToArray(_geom$pointOnCircle, 2),
                x1 = _geom$pointOnCircle2[0],
                y1 = _geom$pointOnCircle2[1];

            var _geom$pointOnCircle3 = geom$1.pointOnCircle(cx, cy, r, begin + per * j + deg + offset),
                _geom$pointOnCircle4 = _slicedToArray(_geom$pointOnCircle3, 2),
                _x = _geom$pointOnCircle4[0],
                _y = _geom$pointOnCircle4[1];

            list.push([x1, y1, _x, _y, Math.round(bc[0] + pc[0] * j), Math.round(bc[1] + pc[1] * j), Math.round(bc[2] + pc[2] * j), Math.round(bc[3] + pc[3] * j)]);
          }
        } // 最后一段补自己末尾颜色特殊处理


        var end = list[0].slice(0);

        var _geom$pointOnCircle5 = geom$1.pointOnCircle(cx, cy, r, deg),
            _geom$pointOnCircle6 = _slicedToArray(_geom$pointOnCircle5, 2),
            x2 = _geom$pointOnCircle6[0],
            y2 = _geom$pointOnCircle6[1];

        end[2] = x2;
        end[3] = y2;
        var s = stop[stop.length - 1][0];
        end[4] = s[0];
        end[5] = s[1];
        end[6] = s[2];
        end[7] = s[3];
        list.push(end);

        for (var _i3 = 0, _len4 = list.length; _i3 < _len4; _i3++) {
          var cur = list[_i3];

          if (prev) {
            var v = {
              tagName: 'linearGradient',
              props: [['x1', prev[0]], ['y1', prev[1]], ['x2', cur[2]], ['y2', cur[3]]],
              children: [{
                tagName: 'stop',
                props: [['stop-color', int2rgba$1([prev[4], prev[5], prev[6], prev[7]])], ['offset', '0%']]
              }, {
                tagName: 'stop',
                props: [['stop-color', int2rgba$1([cur[4], cur[5], cur[6], cur[7]])], ['offset', '100%']]
              }]
            };
            var uuid = ctx.add(v);

            this.__config[NODE_DEFS_CACHE$3].push(v);

            res.push([[[cx, cy], [prev[0], prev[1]], [cur[2], cur[3]]], 'url(#' + uuid + ')']);
          }

          prev = cur;
        }
      }

      return res;
    } // canvas清空自身cache，cacheTotal在Root的自底向上逻辑做，svg仅有cacheTotal

  }, {
    key: "clearCache",
    value: function clearCache(onlyTotal) {
      var __config = this.__config;
      var __cacheTotal = __config[NODE_CACHE_TOTAL$2];
      var __cacheFilter = __config[NODE_CACHE_FILTER$2];
      var __cacheMask = __config[NODE_CACHE_MASK$2];
      var __cacheOverflow = __config[NODE_CACHE_OVERFLOW$2];

      if (!onlyTotal) {
        __config[NODE_CACHE_STYLE$2] = this.__cacheStyle = {};
        var __cache = __config[NODE_CACHE$3];

        if (__cache) {
          __cache.release();
        }
      }

      if (__cacheTotal) {
        __cacheTotal.release();
      }

      if (__cacheFilter) {
        __cacheFilter.release();
      }

      if (__cacheMask) {
        __cacheMask.release();
      }

      if (__cacheOverflow) {
        __cacheOverflow.release();
      }
    }
  }, {
    key: "updateStyle",
    value: function updateStyle(style, cb) {
      var node = this;
      var root = node.root,
          __config = node.__config;
      var formatStyle = css.normalize(style); // 有root说明被添加渲染过了

      if (root) {
        root.addRefreshTask(node.__task = {
          __before: function __before() {
            node.__task = null;

            if (__config[NODE_IS_DESTROYED$1]) {
              return;
            } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


            var res = {};
            res[UPDATE_NODE$3] = node;
            res[UPDATE_STYLE$1] = formatStyle;
            res[UPDATE_OVERWRITE$1] = style; // 标识盖原有style样式不仅仅是修改currentStyle，不同于animate

            res[UPDATE_KEYS$1] = Object.keys(formatStyle).map(function (i) {
              if (!GEOM.hasOwnProperty(i)) {
                i = parseInt(i);
              }

              return i;
            });
            res[UPDATE_CONFIG$3] = __config;

            root.__addUpdate(node, __config, root, root.__config, res);
          },
          __after: function __after(diff) {
            if (util.isFunction(cb)) {
              cb.call(node, diff);
            }
          }
        });
      } // 没有是在如parse()还未添加的时候，可以直接同步覆盖
      else {
        Object.assign(this.currentStyle, formatStyle);

        if (util.isFunction(cb)) {
          cb.call(node, -1);
        }
      }
    } // 传入格式化好key/value的样式

  }, {
    key: "updateFormatStyle",
    value: function updateFormatStyle(style, cb) {
      var node = this;
      var root = node.root,
          __config = node.__config;

      if (root) {
        root.addRefreshTask(node.__task = {
          __before: function __before() {
            node.__task = null; // 清除在before，防止after的回调增加新的task误删

            if (__config[NODE_IS_DESTROYED$1]) {
              return;
            } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


            var res = {};
            res[UPDATE_NODE$3] = node;
            res[UPDATE_STYLE$1] = style;
            res[UPDATE_KEYS$1] = Object.keys(style).map(function (i) {
              if (!GEOM.hasOwnProperty(i)) {
                i = parseInt(i);
              }

              return i;
            });
            res[UPDATE_CONFIG$3] = __config;

            root.__addUpdate(node, __config, root, root.__config, res);
          },
          __after: function __after(diff) {
            if (util.isFunction(cb)) {
              cb.call(node, diff);
            }
          }
        });
      } // 没有是在如parse()还未添加的时候，可以直接同步覆盖
      else {
        Object.assign(this.currentStyle, style);

        if (util.isFunction(cb)) {
          cb.call(node, -1);
        }
      }
    }
  }, {
    key: "animate",
    value: function animate(list) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var animation = new Animation(this, list, options);

      if (this.isDestroyed) {
        animation.__destroy(true);

        return animation;
      }

      this.animationList.push(animation);

      if (options.autoPlay === false) {
        return animation;
      }

      return animation.play();
    }
  }, {
    key: "removeAnimate",
    value: function removeAnimate(o) {
      if (o instanceof Animation) {
        var i = this.animationList.indexOf(o);

        if (i > -1) {
          o.cancel();

          o.__destroy();

          this.animationList.splice(i, 1);
        }
      }
    }
  }, {
    key: "clearAnimate",
    value: function clearAnimate() {
      this.animationList.splice(0).forEach(function (o) {
        o.cancel();

        o.__destroy();
      });
    }
  }, {
    key: "frameAnimate",
    value: function frameAnimate(cb) {
      if (util.isFunction(cb)) {
        var list = this.__frameAnimateList; // 防止重复

        for (var i = 0, len = list.length; i < len; i++) {
          if (list[i].__karasFramecb === cb) {
            return cb;
          }
        }

        var enter = {
          __after: function __after(diff) {
            cb(diff);
          },
          __karasFramecb: cb
        };
        list.push(enter);
        frame.onFrame(enter);
        return cb;
      }
    }
  }, {
    key: "removeFrameAnimate",
    value: function removeFrameAnimate(cb) {
      for (var i = 0, list = this.__frameAnimateList, len = list.length; i < len; i++) {
        if (list[i].__karasFramecb === cb) {
          list.splice(i, 1);
          frame.offFrame(cb);
          return;
        }
      }
    }
  }, {
    key: "clearFrameAnimate",
    value: function clearFrameAnimate() {
      this.__frameAnimateList.splice(0).forEach(function (o) {
        frame.offFrame(o);
      });
    }
  }, {
    key: "__computeMeasure",
    value: function __computeMeasure(renderMode, ctx, cb) {
      css.computeMeasure(this);

      if (util.isFunction(cb)) {
        cb(this);
      }
    }
  }, {
    key: "__deepScan",
    value: function __deepScan(cb, options) {
      return cb(this, options);
    } // isLayout为false时，为relative/margin/flex/vertical等

  }, {
    key: "__offsetX",
    value: function __offsetX(diff, isLayout, lv) {
      _get(_getPrototypeOf(Xom.prototype), "__offsetX", this).call(this, diff, isLayout);

      if (isLayout) {
        this.__layoutData.x += diff;
        this.clearCache();
      }

      if (lv !== undefined) {
        this.__config[NODE_REFRESH_LV$2] |= lv;
      }

      this.__sx1 += diff;
      this.__sx2 += diff;
      this.__sx3 += diff;
      this.__sx4 += diff;
      this.__sx5 += diff;
      this.__sx6 += diff;
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff, isLayout, lv) {
      _get(_getPrototypeOf(Xom.prototype), "__offsetY", this).call(this, diff, isLayout);

      if (isLayout) {
        this.__layoutData.y += diff;
        this.clearCache();
      }

      if (lv !== undefined) {
        this.__config[NODE_REFRESH_LV$2] |= lv;
      }

      this.__sy1 += diff;
      this.__sy2 += diff;
      this.__sy3 += diff;
      this.__sy4 += diff;
      this.__sy5 += diff;
      this.__sy6 += diff;
    }
  }, {
    key: "__resizeX",
    value: function __resizeX(diff, lv) {
      this.computedStyle.width = this.__width += diff;
      this.__clientWidth += diff;
      this.__offsetWidth += diff;
      this.__outerWidth += diff;
      this.__layoutData.w += diff;
      this.__sx4 += diff;
      this.__sx5 += diff;
      this.__sx6 += diff;

      if (diff < 0) {
        this.__config[NODE_LIMIT_CACHE$1] = false;
      }

      if (lv !== undefined) {
        this.__config[NODE_REFRESH_LV$2] |= lv;
      }

      this.clearCache();
    }
  }, {
    key: "__resizeY",
    value: function __resizeY(diff, lv) {
      this.computedStyle.height = this.__height += diff;
      this.__clientHeight += diff;
      this.__offsetHeight += diff;
      this.__outerHeight += diff;
      this.__layoutData.h += diff;
      this.__sy4 += diff;
      this.__sy5 += diff;
      this.__sy6 += diff;

      if (diff < 0) {
        this.__config[NODE_LIMIT_CACHE$1] = false;
      }

      if (lv !== undefined) {
        this.__config[NODE_REFRESH_LV$2] |= lv;
      }

      this.clearCache();
    }
  }, {
    key: "__spreadBbox",
    value: function __spreadBbox(boxShadow) {
      var ox = 0,
          oy = 0;

      if (Array.isArray(boxShadow)) {
        boxShadow.forEach(function (item) {
          var _item2 = _slicedToArray(item, 6),
              x = _item2[0],
              y = _item2[1],
              sigma = _item2[2],
              spread = _item2[3],
              inset = _item2[5];

          if (inset !== 'inset') {
            var d = blur.outerSize(sigma);
            d += spread;
            ox = Math.max(ox, x + d);
            oy = Math.max(oy, y + d);
          }
        });
      }

      return [ox, oy];
    }
  }, {
    key: "__releaseWhenEmpty",
    value: function __releaseWhenEmpty(__cache) {
      if (__cache && __cache.available) {
        __cache.release();
      }

      return true;
    }
  }, {
    key: "getComputedStyle",
    value: function getComputedStyle(key) {
      var computedStyle = this.computedStyle;
      var res = {};
      var keys;

      if (key) {
        if (Array.isArray(key)) {
          keys = key;
        } else {
          keys = [key];
        }

        keys = keys.map(function (s) {
          return STYLE_KEY[style2Upper(s)];
        });
      } else {
        keys = Object.keys(computedStyle);
      }

      keys.forEach(function (k) {
        if (GEOM.hasOwnProperty(k)) {
          res[k] = computedStyle[k];
        } else {
          res[STYLE_RV_KEY[k]] = computedStyle[k];
        }
      });
      return res;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      var __sx1 = this.__sx1,
          __sy1 = this.__sy1,
          offsetWidth = this.offsetWidth,
          offsetHeight = this.offsetHeight,
          matrixEvent = this.matrixEvent;
      var p1 = point2d(mx.calPoint([__sx1, __sy1], matrixEvent));
      var p2 = point2d(mx.calPoint([__sx1 + offsetWidth, __sy1], matrixEvent));
      var p3 = point2d(mx.calPoint([__sx1 + offsetWidth, __sy1 + offsetHeight], matrixEvent));
      var p4 = point2d(mx.calPoint([__sx1, __sy1 + offsetHeight], matrixEvent));
      return {
        left: Math.min(p1[0], Math.min(p2[0], Math.min(p3[0], p4[0]))),
        top: Math.min(p1[1], Math.min(p2[1], Math.min(p3[1], p4[1]))),
        right: Math.max(p1[0], Math.max(p2[0], Math.max(p3[0], p4[0]))),
        bottom: Math.max(p1[1], Math.max(p2[1], Math.max(p3[1], p4[1]))),
        points: [p1, p2, p3, p4]
      };
    } // img和geom返回false，在inline布局时判断是否是真的inline

  }, {
    key: "__isRealInline",
    value: function __isRealInline() {
      return true;
    }
  }, {
    key: "remove",
    value: function remove(cb) {
      var self = this;

      if (self.isDestroyed) {
        inject.warn('Remove target is destroyed.');

        if (util.isFunction(cb)) {
          cb();
        }

        return;
      }

      var root = self.root,
          domParent = self.domParent;
      var target = self.isShadowRoot ? self.hostRoot : self; // 特殊情况连续append/remove时候，还未被添加进来找不到所以无需删除

      if (domParent.children.indexOf(target) === -1) {
        if (util.isFunction(cb)) {
          cb();
        }

        return;
      }

      root.delRefreshTask(self.__task);
      root.addRefreshTask(self.__task = {
        __before: function __before() {
          self.__task = null; // 清除在before，防止after的回调增加新的task误删

          var pJson = domParent.__json;
          var i = pJson.children.indexOf(self.isShadowRoot ? self.hostRoot.__json : self.__json);
          var zChildren = domParent.zIndexChildren;
          var j = zChildren.indexOf(self.isShadowRoot ? self.hostRoot : self);

          if (i === -1 || j === -1) {
            throw new Error('Remove index Exception.');
          }

          pJson.children.splice(i, 1);
          domParent.children.splice(i, 1);
          zChildren.splice(j, 1);

          if (self.__prev) {
            self.__prev.__next = self.__next;
          } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


          var res = {};
          res[UPDATE_NODE$3] = self;
          res[UPDATE_FOCUS$3] = o$1.REFLOW;
          res[UPDATE_REMOVE_DOM$1] = true;
          res[UPDATE_CONFIG$3] = self.__config;

          root.__addUpdate(self, self.__config, root, root.__config, res);
        },
        __after: function __after(diff) {
          self.isShadowRoot ? self.hostRoot.__destroy() : self.__destroy();

          if (util.isFunction(cb)) {
            cb.call(self, diff);
          }
        }
      });
    }
  }, {
    key: "tagName",
    get: function get() {
      return this.__tagName;
    }
  }, {
    key: "sx",
    get: function get() {
      return this.__sx;
    }
  }, {
    key: "sy",
    get: function get() {
      return this.__sy;
    }
  }, {
    key: "clientWidth",
    get: function get() {
      return this.__clientWidth || 0;
    }
  }, {
    key: "clientHeight",
    get: function get() {
      return this.__clientHeight || 0;
    }
  }, {
    key: "offsetWidth",
    get: function get() {
      return this.__offsetWidth || 0;
    }
  }, {
    key: "offsetHeight",
    get: function get() {
      return this.__offsetHeight || 0;
    }
  }, {
    key: "outerWidth",
    get: function get() {
      return this.__outerWidth || 0;
    }
  }, {
    key: "outerHeight",
    get: function get() {
      return this.__outerHeight || 0;
    } // 不考虑margin的范围，>=REPAINT渲染或个别有影响的渲染改变（如blur）清空缓存

  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var __sx1 = this.__sx1,
            __sy1 = this.__sy1,
            clientWidth = this.clientWidth,
            clientHeight = this.clientHeight,
            _this$currentStyle = this.currentStyle;
        _this$currentStyle = _this$currentStyle === void 0 ? {} : _this$currentStyle;
        var _this$currentStyle$BO = _this$currentStyle[BORDER_TOP_WIDTH$4],
            borderTopWidth = _this$currentStyle$BO === void 0 ? [0] : _this$currentStyle$BO,
            _this$currentStyle$BO2 = _this$currentStyle[BORDER_RIGHT_WIDTH$4],
            borderRightWidth = _this$currentStyle$BO2 === void 0 ? [0] : _this$currentStyle$BO2,
            _this$currentStyle$BO3 = _this$currentStyle[BORDER_BOTTOM_WIDTH$4],
            borderBottomWidth = _this$currentStyle$BO3 === void 0 ? [0] : _this$currentStyle$BO3,
            _this$currentStyle$BO4 = _this$currentStyle[BORDER_LEFT_WIDTH$5],
            borderLeftWidth = _this$currentStyle$BO4 === void 0 ? [0] : _this$currentStyle$BO4,
            _this$currentStyle$BO5 = _this$currentStyle[BOX_SHADOW$7],
            boxShadow = _this$currentStyle$BO5 === void 0 ? [] : _this$currentStyle$BO5;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        clientWidth += borderLeftWidth[0] + borderRightWidth[0];
        clientHeight += borderTopWidth[0] + borderBottomWidth[0];
        var half = 1;
        this.__bbox = [__sx1 - ox - half, __sy1 - oy - half, __sx1 + clientWidth + ox + half, __sy1 + clientHeight + oy + half];
      }

      return this.__bbox;
    }
  }, {
    key: "listener",
    get: function get() {
      return this.__listener;
    }
  }, {
    key: "matrix",
    get: function get() {
      return this.__config[NODE_MATRIX$2];
    }
  }, {
    key: "matrixEvent",
    get: function get() {
      return this.__config[NODE_MATRIX_EVENT$2];
    }
  }, {
    key: "perspectiveMatrix",
    get: function get() {
      return this.__config[NODE_PERSPECTIVE_MATRIX$1];
    }
  }, {
    key: "style",
    get: function get() {
      return this.__style;
    }
  }, {
    key: "computedStyle",
    get: function get() {
      return this.__computedStyle;
    }
  }, {
    key: "animationList",
    get: function get() {
      return this.__animationList;
    }
  }, {
    key: "currentStyle",
    get: function get() {
      return this.__currentStyle;
    }
  }, {
    key: "isShadowRoot",
    get: function get() {
      return !this.parent && this.host && this.host !== this.root;
    }
  }, {
    key: "contentBoxList",
    get: function get() {
      return this.__contentBoxList;
    }
  }, {
    key: "baseLine",
    get: function get() {
      return this.offsetHeight;
    }
  }, {
    key: "firstBaseLine",
    get: function get() {
      return this.offsetHeight;
    }
  }, {
    key: "isMask",
    get: function get() {
      return this.__isMask;
    }
  }, {
    key: "isClip",
    get: function get() {
      return this.__isClip;
    }
  }]);

  return Xom;
}(Node);

var _enums$STYLE_KEY$c = enums.STYLE_KEY,
    DISPLAY$6 = _enums$STYLE_KEY$c.DISPLAY,
    MARGIN_LEFT$4 = _enums$STYLE_KEY$c.MARGIN_LEFT,
    BORDER_LEFT_WIDTH$4 = _enums$STYLE_KEY$c.BORDER_LEFT_WIDTH,
    PADDING_LEFT$4 = _enums$STYLE_KEY$c.PADDING_LEFT,
    PADDING_RIGHT$3 = _enums$STYLE_KEY$c.PADDING_RIGHT,
    BORDER_RIGHT_WIDTH$3 = _enums$STYLE_KEY$c.BORDER_RIGHT_WIDTH,
    MARGIN_RIGHT$3 = _enums$STYLE_KEY$c.MARGIN_RIGHT;
/**
 * css中常见的概念，一行内容，里面可能有若干不同的内容，仅在布局阶段出现，不参与渲染逻辑
 * 本类是个抽象逻辑概念，会包含Text的内容TextBox和inlineBlock等节点，而内容TextBox则属于Text
 * 一个Text可能因为换行产生多个TextBox，从而形成不同行的内容就属于不同的LineBox
 * 本类属于block（包含flex和inlineBlock，下同）节点下，一个dom会有个专门列表，
 * 包含若干个LineBox保存着若干行文本内容TextBox，不直接关联Text，
 * inline则不会有此对象和列表，其复用最近block父层的，这样解决嵌套问题，
 * block在布局时将列表向孩子传递下去，每遇到block会重新生成
 * 每当发生换行时，专门列表中会新生成一个LineBox，让后续内容继续跟随新的LB
 * LB内部要进行垂直对齐，Text内容较简单x字符底部为baseLine，inlineBlock等节点按最后一行baseLine
 */

var LineBox = /*#__PURE__*/function () {
  function LineBox(x, y, lineHeight, baseLine) {
    _classCallCheck(this, LineBox);

    this.__list = [];
    this.__x = x;
    this.__y = y;
    this.__lineHeight = lineHeight; // 可能出现空的inline，因此一个inline进入布局时先设置当前lineBox的最小lineHeight/baseLine

    this.__baseLine = baseLine;
  }

  _createClass(LineBox, [{
    key: "add",
    value: function add(item) {
      this.list.push(item);
      item.__parentLineBox = this;
    }
  }, {
    key: "verticalAlign",
    value: function verticalAlign() {
      var n = this.baseLine; // 只有1个也需要对齐，因为可能内嵌了空inline使得baseLine发生变化

      if (this.list.length) {
        this.list.forEach(function (item) {
          var m = item.baseLine;

          if (m !== n) {
            item.__offsetY(n - m);
          }
        });
      }
    }
  }, {
    key: "__offsetX",
    value: function __offsetX(diff) {
      this.__x += diff;
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff) {
      this.__y += diff;
    }
    /**
     * 防止非行首空inline，每当遇到inline就设置当前lineBox的lineHeight/baseLine，这样有最小值兜底
     * @param l
     * @param b
     * @private
     */

  }, {
    key: "__setLB",
    value: function __setLB(l, b) {
      this.__lineHeight = Math.max(l, this.__lineHeight);
      this.__baseLine = Math.max(b, this.__baseLine);
    }
  }, {
    key: "list",
    get: function get() {
      return this.__list;
    }
  }, {
    key: "size",
    get: function get() {
      return this.__list.length;
    }
  }, {
    key: "x",
    get: function get() {
      return this.__x;
    }
  }, {
    key: "y",
    get: function get() {
      return this.__y;
    }
  }, {
    key: "endY",
    get: function get() {
      return this.y + this.height;
    }
  }, {
    key: "width",
    get: function get() {
      var list = this.list;
      var length = list.length;

      if (length) {
        var first = list[0];
        var last = list[length - 1];
        var x1 = first.x;
        var dom = first instanceof TextBox ? first.parent.domParent : first.domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

        while (true) {
          var _list = dom.contentBoxList;
          var _dom$computedStyle = dom.computedStyle,
              display = _dom$computedStyle[DISPLAY$6],
              marginLeft = _dom$computedStyle[MARGIN_LEFT$4],
              borderLeftWidth = _dom$computedStyle[BORDER_LEFT_WIDTH$4],
              paddingLeft = _dom$computedStyle[PADDING_LEFT$4];

          if (display !== 'inline') {
            break;
          }

          if (first === _list[0]) {
            x1 -= marginLeft + borderLeftWidth + paddingLeft;
          }

          dom = dom.domParent;
        }

        var x2 = last.x + last.outerWidth;
        dom = last instanceof TextBox ? last.parent.domParent : last.domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

        while (true) {
          var _list2 = dom.contentBoxList;
          var _dom$computedStyle2 = dom.computedStyle,
              _display = _dom$computedStyle2[DISPLAY$6],
              marginRight = _dom$computedStyle2[MARGIN_RIGHT$3],
              borderRightWidth = _dom$computedStyle2[BORDER_RIGHT_WIDTH$3],
              paddingRight = _dom$computedStyle2[PADDING_RIGHT$3];

          if (_display !== 'inline') {
            break;
          }

          if (first === _list2[_list2.length - 1]) {
            x2 += marginRight + borderRightWidth + paddingRight;
          }

          dom = dom.domParent;
        }

        return x2 - x1;
      }

      return 0;
    }
  }, {
    key: "height",
    get: function get() {
      return this.lineHeight;
    }
  }, {
    key: "baseLine",
    get: function get() {
      var baseLine = 0;
      this.list.forEach(function (item) {
        baseLine = Math.max(baseLine, item.baseLine);
      });
      return Math.max(this.__baseLine, baseLine);
    }
  }, {
    key: "lineHeight",
    get: function get() {
      var lineHeight = 0; // 只有TextBox和InlineBlock

      this.list.forEach(function (item) {
        lineHeight = Math.max(lineHeight, item.outerHeight);
      });
      return Math.max(this.__lineHeight, lineHeight);
    }
  }]);

  return LineBox;
}();

/**
 * 维护一个上下文的LineBox，向LineBox中添加Item以及新增下一行的LineBox，多个LineBox组成一个区域
 * 一个block/inlineBlock拥有一个本类对象，上下文即对应这个dom流，而inline则复用最近非inline父元素的
 * 同时LineBox可能连续也可能不连续，不连续的是中间有block之类的隔离开来
 */

var LineBoxManager = /*#__PURE__*/function () {
  function LineBoxManager(x, y, lineHeight, baseLine) {
    _classCallCheck(this, LineBoxManager);

    this.__x = this.__lastX = x; // last存储目前最后一行LineBox的结尾位置，供后续inline使用

    this.__y = this.__lastY = y;
    this.__maxX = x;
    this.__domList = [];
    this.__domStack = [];
    this.__list = []; // 包含若干LineBox

    this.__isNewLine = true; // 区域内是否是新行，容器dom（block）开头肯定是

    this.__lineHeight = lineHeight;
    this.__baseLine = baseLine;
    this.__isEnd = true; // 在dom中是否一个区域处在结尾，外部控制
  }
  /**
   * 每次换行时重新生成LineBox存入列表，同时由于flow流当前一定是流（dom）的结尾，设置isEnd
   * @returns {LineBox}
   */


  _createClass(LineBoxManager, [{
    key: "genLineBox",
    value: function genLineBox(x, y) {
      var lineBox = new LineBox(x, y, this.__lineHeight, this.__baseLine);
      this.list.push(lineBox);
      this.__isEnd = true;
      return lineBox;
    }
    /**
     * inline的特殊调用，防止空内容但有mbp的inline不占位，放入一个有lineHeight的空lineBox
     * 只有新行开头时需要，后面的无论是否有内容都会影响lineHeight
     * @param x
     * @param y
     * @param l
     * @param b
     * @returns {LineBox}
     */

  }, {
    key: "genLineBoxByInlineIfNewLine",
    value: function genLineBoxByInlineIfNewLine(x, y, l, b) {
      var lineHeight = Math.max(this.__lineHeight, l);
      var baseLine = Math.max(this.__baseLine, b);

      if (this.__isNewLine) {
        var lineBox = new LineBox(x, y, lineHeight, baseLine);
        this.list.push(lineBox);
        this.__isEnd = true;
        this.__isNewLine = false;
        return lineBox;
      }
    }
  }, {
    key: "setLbOrGenLineBoxByInline",
    value: function setLbOrGenLineBoxByInline(x, y, l, b) {
      var lineHeight = Math.max(this.__lineHeight, l);
      var baseLine = Math.max(this.__baseLine, b);
      var lineBox;
      var list = this.list;

      if (this.__isNewLine) {
        lineBox = new LineBox(x, y, lineHeight, baseLine);
        list.push(lineBox);
        this.__isEnd = true;
        this.__isNewLine = false;
        return lineBox;
      } else {
        var length = list.length;
        lineBox = list[length - 1];

        lineBox.__setLB(l, b);
      }
    }
    /**
     * 外部设置为结尾，如一个LineBox后出现一个block，此时会被隔断，不再作为流的末尾
     */

  }, {
    key: "setNotEnd",
    value: function setNotEnd() {
      this.__isEnd = false;
    }
    /**
     * 外部设置新行，下次新生成LineBox
     */

  }, {
    key: "setNewLine",
    value: function setNewLine() {
      this.__isNewLine = true;
    }
    /**
     * 当前LineBox放入一个新项，当新行时（如第一行）产生一个新的LineBox并存入列表
     * 是否新区域和新行都是可以被外部控制，默认第一行是新
     * 当被隔断后会被外部重置新行，这样会生成新的来作为新加项的LineBox
     * 当换行时外部也会调用新行，这样再次添加Item时会自动生成新的LineBox而不是用之前的
     * @param o TextBox/Inline/InlineBlock
     * @param nextNewLine 是否设置newLine，标明下次添加新生成LineBox
     * @returns {LineBox}
     */

  }, {
    key: "addItem",
    value: function addItem(o, nextNewLine) {
      var lineBox;

      if (this.__isNewLine) {
        this.__isNewLine = false;
        lineBox = this.genLineBox(o.x, o.y);
      } else {
        var list = this.list;
        var length = list.length;
        lineBox = list[length - 1];
      } // inline递归过程中所有inline父子顺序列表，每个dom都需要对当前内容保存


      this.__domStack.forEach(function (item) {
        item.__contentBoxList.push(o);
      });

      lineBox.add(o); // 设置结束x的位置给next的inline标记用，o可能是TextBox或inlineBlock，当next新行时注意位置

      if (nextNewLine) {
        this.__isNewLine = true;
        this.__lastX = o.x;
        this.__lastY = o.y + o.outerHeight;
      } else {
        this.__lastX = o.x + o.outerWidth;
        this.__lastY = o.y;
      }

      this.__maxX = Math.max(this.__maxX, o.x + o.outerWidth);
      return lineBox;
    }
  }, {
    key: "horizonAlign",
    value: function horizonAlign(w, textAlign) {
      this.list.forEach(function (lineBox) {
        var diff = w - lineBox.width;

        if (diff > 0) {
          if (textAlign === 'center') {
            diff *= 0.5;
          }

          lineBox.__offsetX(diff);

          lineBox.list.forEach(function (item) {
            item.__offsetX(diff, true);
          });
        }
      });
    }
  }, {
    key: "verticalAlign",
    value: function verticalAlign() {
      this.list.forEach(function (lineBox) {
        lineBox.verticalAlign();
      });
    }
  }, {
    key: "addX",
    value: function addX(n) {
      this.__lastX += n;
    }
    /**
     * inline递归过程中布局调用，不断出入栈dom对象，获取当前行状态下有哪些dom还在
     * @param dom
     */

  }, {
    key: "pushContentBoxList",
    value: function pushContentBoxList(dom) {
      this.__domList.push(dom);

      this.__domStack.push(dom);
    }
  }, {
    key: "popContentBoxList",
    value: function popContentBoxList() {
      this.__domStack.pop();
    }
  }, {
    key: "__offsetX",
    value: function __offsetX(diff) {
      this.list.forEach(function (lineBox) {
        lineBox.__offsetX(diff);
      });
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff) {
      this.list.forEach(function (lineBox) {
        lineBox.__offsetY(diff);
      });
    }
    /**
     * inline的特殊调用，非行首无论是否有内容都设置lineBox的lineHeight
     * @param l
     * @param b
     * @private
     */

  }, {
    key: "setLbByInlineIfNotNewLine",
    value: function setLbByInlineIfNotNewLine(l, b) {
      var length = this.list.length;

      if (length && !this.isNewLine) {
        this.list[length - 1].__setLB(l, b);
      }
    }
  }, {
    key: "size",
    get: function get() {
      return this.list.length;
    }
  }, {
    key: "lastX",
    get: function get() {
      return this.__lastX;
    }
  }, {
    key: "lastY",
    get: function get() {
      return this.__lastY;
    }
  }, {
    key: "endY",
    get: function get() {
      var list = this.list;
      var length = list.length;

      if (length) {
        return list[length - 1].endY;
      }

      return this.__y;
    }
  }, {
    key: "isEnd",
    get: function get() {
      return this.__isEnd;
    }
  }, {
    key: "isNewLine",
    get: function get() {
      return this.__isNewLine;
    }
  }, {
    key: "breakLine",
    get: function get() {
      return this.list.length > 1;
    }
  }, {
    key: "domList",
    get: function get() {
      return this.__domList;
    }
  }, {
    key: "baseLine",
    get: function get() {
      var list = this.list;
      var length = list.length;

      if (length) {
        var n = 0;

        for (var i = 0; i < length - 1; i++) {
          n += list[i].height;
        }

        return n + list[length - 1].baseLine;
      }

      return 0;
    }
  }, {
    key: "firstBaseLine",
    get: function get() {
      var list = this.list;
      var length = list.length;

      if (length) {
        return list[0].baseLine;
      }

      return 0;
    }
  }, {
    key: "lineHeight",
    get: function get() {
      var list = this.list;

      if (list.length) {
        return list[list.length - 1].lineHeight;
      }

      return 0;
    }
  }, {
    key: "lineBox",
    get: function get() {
      var list = this.list;

      if (list.length) {
        return list[list.length - 1];
      }
    }
  }, {
    key: "list",
    get: function get() {
      return this.__list;
    }
  }, {
    key: "width",
    get: function get() {
      var w = 0;
      this.list.forEach(function (item) {
        w = Math.max(w, item.width);
      });
      return w;
    }
  }]);

  return LineBoxManager;
}();

var TAG_NAME = {
  'div': true,
  'p': true,
  'span': true,
  'img': true,
  'b': true,
  'strong': true
};
var INLINE = {
  'span': true,
  'img': true,
  'b': true,
  'strong': true
};
var BOLD = {
  'b': true,
  'strong': true
};
var tag = {
  TAG_NAME: TAG_NAME,
  INLINE: INLINE,
  BOLD: BOLD
};

var _enums$STYLE_KEY$b = enums.STYLE_KEY,
    DISPLAY$5 = _enums$STYLE_KEY$b.DISPLAY,
    TOP$2 = _enums$STYLE_KEY$b.TOP,
    BOTTOM$2 = _enums$STYLE_KEY$b.BOTTOM,
    POSITION$3 = _enums$STYLE_KEY$b.POSITION,
    HEIGHT$4 = _enums$STYLE_KEY$b.HEIGHT;
var AUTO$3 = o$4.AUTO,
    PX$4 = o$4.PX,
    PERCENT$4 = o$4.PERCENT;
var REFLOW$1 = o$1.REFLOW;

function offsetAndResizeByNodeOnY(node, root, reflowHash, dy, inDirectAbsList) {
  if (dy) {
    var last;

    do {
      // component的sr没有next兄弟，视为component的next
      while (node.isShadowRoot) {
        node = node.host;
      }

      last = node;
      var isContainer = void 0,
          parent = node.domParent;

      if (parent) {
        var cs = parent.computedStyle;
        var ps = cs[POSITION$3];
        isContainer = parent === root || parent.isShadowRoot || ps === 'relative' || ps === 'absolute';
      } // 先偏移next，忽略有定位的absolute，本身非container也忽略


      var next = node.next;
      var container = void 0;

      while (next) {
        if (next.currentStyle[DISPLAY$5] !== 'none') {
          if (next.currentStyle[POSITION$3] === 'absolute') {
            var _next$currentStyle = next.currentStyle,
                top = _next$currentStyle[TOP$2],
                bottom = _next$currentStyle[BOTTOM$2],
                height = _next$currentStyle[HEIGHT$4];

            if (top[1] === AUTO$3) {
              if (bottom[1] === AUTO$3 || bottom[1] === PX$4) {
                next.__offsetY(dy, true, REFLOW$1);

                next.clearCache();
              } else if (bottom[1] === PERCENT$4) {
                var v = (1 - bottom[0] * 0.01) * dy;

                next.__offsetY(v, true, REFLOW$1);

                next.clearCache();
              }
            } else if (top[1] === PERCENT$4) {
              var _v = top[0] * 0.01 * dy;

              next.__offsetY(_v, true, REFLOW$1);

              next.clearCache();
            } // 高度百分比需发生变化的重新布局，需要在容器内


            if (height[1] === PERCENT$4) {
              if (isContainer) {
                parent.__layoutAbs(parent, null, next);
              } else {
                if (!container) {
                  container = parent;

                  while (container) {
                    if (container === root || container.isShadowRoot) {
                      break;
                    }

                    var _cs = container.currentStyle;

                    if (_cs[POSITION$3] === 'absolute' || _cs[POSITION$3] === 'relative') {
                      break;
                    }

                    container = container.domParent;
                  }
                }

                inDirectAbsList.push([parent, container, next]);
              }
            }
          } else {
            next.__offsetY(dy, true, REFLOW$1);

            next.clearCache();
          }
        }

        next = next.next;
      } // root本身没domParent


      if (!parent) {
        break;
      }

      node = parent; // parent判断是否要resize

      var _node = node,
          currentStyle = _node.currentStyle;
      var isAbs = currentStyle[POSITION$3] === 'absolute';
      var need = void 0;

      if (isAbs) {
        if (currentStyle[HEIGHT$4][1] === AUTO$3 && (currentStyle[TOP$2][1] === AUTO$3 || currentStyle[BOTTOM$2][1] === AUTO$3)) {
          need = true;
        }
      } // height不定则需要
      else if (currentStyle[HEIGHT$4][1] === AUTO$3) {
        need = true;
      }

      if (need) {
        node.__resizeY(dy, REFLOW$1);

        node.clearCache();
      } // abs或者高度不需要继续向上调整提前跳出
      else {
        break;
      }

      if (node === root) {
        break;
      }
    } while (true); // 最后一个递归向上取消总缓存，防止过程中重复next多次无用递归


    while (last) {
      last.clearCache(true);
      last = last.domParent;
    }
  }
}

function clearUniqueReflowId(hash) {
  for (var i in hash) {
    if (hash.hasOwnProperty(i)) {
      var node = hash[i].node;
      delete node.__uniqueReflowId;
    }
  }
}

function getMergeMarginTB(topList, bottomList) {
  var total = 0;
  var max = topList[0];
  var min = topList[0];
  topList.forEach(function (item) {
    total += item;
    max = Math.max(max, item);
    min = Math.min(min, item);
  });
  bottomList.forEach(function (item) {
    total += item;
    max = Math.max(max, item);
    min = Math.min(min, item);
  }); // 正数取最大，负数取最小，正负则相加

  var diff = 0;

  if (max > 0 && min > 0) {
    diff = Math.max(max, min) - total;
  } else if (max < 0 && min < 0) {
    diff = Math.min(max, min) - total;
  } else if (max !== 0 || min !== 0) {
    diff = max + min - total;
  }

  return diff;
}

var reflow = {
  offsetAndResizeByNodeOnY: offsetAndResizeByNodeOnY,
  clearUniqueReflowId: clearUniqueReflowId,
  getMergeMarginTB: getMergeMarginTB
};

var _enums$STYLE_KEY$a = enums.STYLE_KEY,
    POSITION$2 = _enums$STYLE_KEY$a.POSITION,
    DISPLAY$4 = _enums$STYLE_KEY$a.DISPLAY,
    FONT_WEIGHT = _enums$STYLE_KEY$a.FONT_WEIGHT,
    MARGIN_LEFT$3 = _enums$STYLE_KEY$a.MARGIN_LEFT,
    MARGIN_TOP$3 = _enums$STYLE_KEY$a.MARGIN_TOP,
    MARGIN_RIGHT$2 = _enums$STYLE_KEY$a.MARGIN_RIGHT,
    MARGIN_BOTTOM$3 = _enums$STYLE_KEY$a.MARGIN_BOTTOM,
    PADDING_LEFT$3 = _enums$STYLE_KEY$a.PADDING_LEFT,
    PADDING_BOTTOM$3 = _enums$STYLE_KEY$a.PADDING_BOTTOM,
    PADDING_RIGHT$2 = _enums$STYLE_KEY$a.PADDING_RIGHT,
    PADDING_TOP$3 = _enums$STYLE_KEY$a.PADDING_TOP,
    BORDER_TOP_WIDTH$3 = _enums$STYLE_KEY$a.BORDER_TOP_WIDTH,
    BORDER_BOTTOM_WIDTH$3 = _enums$STYLE_KEY$a.BORDER_BOTTOM_WIDTH,
    BORDER_RIGHT_WIDTH$2 = _enums$STYLE_KEY$a.BORDER_RIGHT_WIDTH,
    BORDER_LEFT_WIDTH$3 = _enums$STYLE_KEY$a.BORDER_LEFT_WIDTH,
    TOP$1 = _enums$STYLE_KEY$a.TOP,
    RIGHT$1 = _enums$STYLE_KEY$a.RIGHT,
    BOTTOM$1 = _enums$STYLE_KEY$a.BOTTOM,
    LEFT$1 = _enums$STYLE_KEY$a.LEFT,
    WIDTH$3 = _enums$STYLE_KEY$a.WIDTH,
    HEIGHT$3 = _enums$STYLE_KEY$a.HEIGHT,
    TEXT_ALIGN = _enums$STYLE_KEY$a.TEXT_ALIGN,
    FLEX_DIRECTION = _enums$STYLE_KEY$a.FLEX_DIRECTION,
    FLEX_BASIS$2 = _enums$STYLE_KEY$a.FLEX_BASIS,
    FLEX_SHRINK = _enums$STYLE_KEY$a.FLEX_SHRINK,
    FLEX_GROW = _enums$STYLE_KEY$a.FLEX_GROW,
    ALIGN_SELF = _enums$STYLE_KEY$a.ALIGN_SELF,
    ALIGN_ITEMS = _enums$STYLE_KEY$a.ALIGN_ITEMS,
    JUSTIFY_CONTENT = _enums$STYLE_KEY$a.JUSTIFY_CONTENT,
    Z_INDEX$1 = _enums$STYLE_KEY$a.Z_INDEX,
    WHITE_SPACE = _enums$STYLE_KEY$a.WHITE_SPACE,
    LINE_HEIGHT = _enums$STYLE_KEY$a.LINE_HEIGHT,
    LINE_CLAMP = _enums$STYLE_KEY$a.LINE_CLAMP,
    ORDER = _enums$STYLE_KEY$a.ORDER,
    FLEX_WRAP = _enums$STYLE_KEY$a.FLEX_WRAP,
    ALIGN_CONTENT = _enums$STYLE_KEY$a.ALIGN_CONTENT,
    OVERFLOW$1 = _enums$STYLE_KEY$a.OVERFLOW,
    FONT_SIZE$8 = _enums$STYLE_KEY$a.FONT_SIZE,
    _enums$NODE_KEY$5 = enums.NODE_KEY,
    NODE_CURRENT_STYLE$4 = _enums$NODE_KEY$5.NODE_CURRENT_STYLE,
    NODE_STYLE$3 = _enums$NODE_KEY$5.NODE_STYLE,
    NODE_STRUCT$2 = _enums$NODE_KEY$5.NODE_STRUCT,
    NODE_DOM_PARENT$3 = _enums$NODE_KEY$5.NODE_DOM_PARENT,
    NODE_IS_INLINE = _enums$NODE_KEY$5.NODE_IS_INLINE,
    _enums$UPDATE_KEY$2 = enums.UPDATE_KEY,
    UPDATE_NODE$2 = _enums$UPDATE_KEY$2.UPDATE_NODE,
    UPDATE_FOCUS$2 = _enums$UPDATE_KEY$2.UPDATE_FOCUS,
    UPDATE_ADD_DOM$1 = _enums$UPDATE_KEY$2.UPDATE_ADD_DOM,
    UPDATE_CONFIG$2 = _enums$UPDATE_KEY$2.UPDATE_CONFIG,
    UPDATE_MEASURE$1 = _enums$UPDATE_KEY$2.UPDATE_MEASURE,
    _enums$STRUCT_KEY$2 = enums.STRUCT_KEY,
    STRUCT_NUM = _enums$STRUCT_KEY$2.STRUCT_NUM,
    STRUCT_LV$1 = _enums$STRUCT_KEY$2.STRUCT_LV,
    STRUCT_TOTAL$2 = _enums$STRUCT_KEY$2.STRUCT_TOTAL,
    STRUCT_CHILD_INDEX = _enums$STRUCT_KEY$2.STRUCT_CHILD_INDEX,
    STRUCT_INDEX$1 = _enums$STRUCT_KEY$2.STRUCT_INDEX;
var AUTO$2 = o$4.AUTO,
    PX$3 = o$4.PX,
    PERCENT$3 = o$4.PERCENT,
    REM$8 = o$4.REM,
    VW$8 = o$4.VW,
    VH$8 = o$4.VH;
var calAbsolute = css.calAbsolute,
    isRelativeOrAbsolute$1 = css.isRelativeOrAbsolute;

function genZIndexChildren(dom) {
  var normal = [];
  var hasMc;
  var mcHash = {};
  var lastMaskIndex;
  var children = dom.children;
  children.forEach(function (item, i) {
    var child = item;

    if (item instanceof Component) {
      item = item.shadowRoot;
    } // 遮罩单独保存后特殊排序


    if (item instanceof Xom && item.isMask) {
      // 开头的mc忽略，后续的连续mc以第一次出现为准
      if (lastMaskIndex !== undefined) {
        mcHash[lastMaskIndex].push(item);
      } else if (i) {
        lastMaskIndex = i - 1;
        children[lastMaskIndex].__iIndex = lastMaskIndex;
        mcHash[lastMaskIndex] = [item];
        hasMc = true;
      }
    } else {
      lastMaskIndex = undefined;

      if (item instanceof Xom) {
        child.__zIndex = item.currentStyle[Z_INDEX$1];

        if (isRelativeOrAbsolute$1(item)) {
          // 临时变量为排序使用
          child.__aIndex = true;
          normal.push(child);
        } else {
          normal.push(child);
        }
      } else {
        child.__zIndex = 0;
        normal.push(child);
      }

      child.__iIndex = i;
    }
  });
  normal.sort(function (a, b) {
    if (a.__zIndex !== b.__zIndex) {
      return a.__zIndex - b.__zIndex;
    } // zIndex相等时abs优先flow


    if (a.__aIndex !== b.__aIndex) {
      if (a.__aIndex) {
        return 1;
      }

      return -1;
    } // 都相等看索引


    return a.__iIndex - b.__iIndex;
  }); // 将遮罩插入到对应顺序上

  if (hasMc) {
    for (var i = normal.length - 1; i >= 0; i--) {
      var idx = normal[i].__iIndex;

      if (mcHash.hasOwnProperty(idx)) {
        normal.splice.apply(normal, [i + 1, 0].concat(_toConsumableArray(mcHash[idx])));
      }
    }
  }

  return normal;
} // flex布局阶段顺序，不是渲染也和struct结构无关，可以无视mask


function genOrderChildren(flowChildren) {
  var normal = [];
  flowChildren.forEach(function (item, i) {
    var child = item;

    if (item instanceof Component) {
      item = item.shadowRoot;
    }

    if (item instanceof Xom) {
      child.__order = item.currentStyle[ORDER];
    } else {
      child.__order = 0;
    }

    normal.push(child);
    child.__iIndex = i;
  });
  normal.sort(function (a, b) {
    if (a.__order !== b.__order) {
      return a.__order - b.__order;
    } // order相等时看节点索引


    return a.__iIndex - b.__iIndex;
  });
  return normal;
}

var Dom = /*#__PURE__*/function (_Xom) {
  _inherits(Dom, _Xom);

  var _super = _createSuper(Dom);

  function Dom(tagName, props, children) {
    var _this;

    _classCallCheck(this, Dom);

    _this = _super.call(this, tagName, props);

    var _assertThisInitialize = _assertThisInitialized(_this),
        style = _assertThisInitialize.style;

    if (!style.display || !{
      flex: true,
      block: true,
      inline: true,
      inlineBlock: true,
      'inline-block': true,
      none: true
    }.hasOwnProperty(style.display)) {
      if (tag.INLINE.hasOwnProperty(_this.tagName)) {
        style.display = 'inline';
      } else {
        style.display = 'block';
      }
    }

    if (!style[FONT_WEIGHT] && tag.BOLD.hasOwnProperty(tagName)) {
      style.fontWeight = 700;
    }

    _this.__style = css.normalize(style, reset.DOM_ENTRY_SET); // currentStyle/currentProps不深度clone，继承一层即可，动画时也是extend这样只改一层引用不动原始静态style

    _this.__currentStyle = util.extend({}, _this.__style);
    _this.__children = children || [];
    _this.__flexLine = []; // flex布局多行模式时存储行

    var config = _this.__config;
    config[NODE_CURRENT_STYLE$4] = _this.__currentStyle;
    config[NODE_STYLE$3] = _this.__style;
    return _this;
  }

  _createClass(Dom, [{
    key: "__structure",
    value: function __structure(i, lv, j) {
      var res = _get(_getPrototypeOf(Dom.prototype), "__structure", this).call(this, i++, lv, j);

      var arr = [res];
      var zIndexChildren = this.__zIndexChildren = this.__zIndexChildren || genZIndexChildren(this);
      zIndexChildren.forEach(function (child, j) {
        var temp = child.__structure(i, lv + 1, j);

        if (Array.isArray(temp)) {
          i += temp.length;
          arr = arr.concat(temp);
        } else {
          i++;
          arr.push(temp);
        }
      });
      var total = arr.length - 1;
      res[STRUCT_NUM] = zIndexChildren.length;
      res[STRUCT_TOTAL$2] = total;
      return arr;
    }
  }, {
    key: "__modifyStruct",
    value: function __modifyStruct(root) {
      var _root$__structs;

      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var __config = this.__config;
      var struct = __config[NODE_STRUCT$2];
      var total = struct[STRUCT_TOTAL$2] || 0; // 新生成了struct，引用也变了

      var nss = this.__structure(struct[STRUCT_INDEX$1], struct[STRUCT_LV$1], struct[STRUCT_CHILD_INDEX]);

      (_root$__structs = root.__structs).splice.apply(_root$__structs, [struct[STRUCT_INDEX$1] + offset, total + 1].concat(_toConsumableArray(nss)));

      var d = 0;

      if (this !== root) {
        struct = __config[NODE_STRUCT$2];
        d = (struct[STRUCT_TOTAL$2] || 0) - total;
        var ps = __config[NODE_DOM_PARENT$3].__config[NODE_STRUCT$2];
        ps[STRUCT_TOTAL$2] = ps[STRUCT_TOTAL$2] || 0;
        ps[STRUCT_TOTAL$2] += d;
      }

      return [struct, d];
    }
    /**
     * 因为zIndex/abs的变化造成的更新，只需重排这一段顺序即可
     * 即便包含component造成的dom变化也不影响，component作为子节点reflow会再执行，这里重排老的vd
     * @param structs
     * @private
     */

  }, {
    key: "__updateStruct",
    value: function __updateStruct(structs) {
      var _this$__config$NODE_S = this.__config[NODE_STRUCT$2],
          index = _this$__config$NODE_S[STRUCT_INDEX$1],
          _this$__config$NODE_S2 = _this$__config$NODE_S[STRUCT_TOTAL$2],
          total = _this$__config$NODE_S2 === void 0 ? 0 : _this$__config$NODE_S2;
      var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);
      var length = zIndexChildren.length;

      if (length === 1) {
        return;
      }

      zIndexChildren.forEach(function (child, i) {
        child.__config[NODE_STRUCT$2][STRUCT_CHILD_INDEX] = i;
      }); // 按直接子节点划分为相同数量的若干段进行排序

      var arr = [];
      var source = [];

      for (var i = index + 1; i <= index + total; i++) {
        var child = structs[i];
        var o = {
          child: child,
          list: structs.slice(child[STRUCT_INDEX$1], child[STRUCT_INDEX$1] + child[STRUCT_TOTAL$2] + 1)
        };
        arr.push(o);
        source.push(o);
        i += child[STRUCT_TOTAL$2] || 0;
      }

      arr.sort(function (a, b) {
        return a.child[STRUCT_CHILD_INDEX] - b.child[STRUCT_CHILD_INDEX];
      }); // 是否有变更，有才进行重新计算

      var needSort;

      for (var _i = 0, len = source.length; _i < len; _i++) {
        if (source[_i] !== arr[_i]) {
          needSort = true;
          break;
        }
      }

      if (needSort) {
        var list = [];
        arr.forEach(function (item) {
          list = list.concat(item.list);
        });
        list.forEach(function (struct, i) {
          struct[STRUCT_INDEX$1] = index + i + 1;
        });
        structs.splice.apply(structs, [index + 1, total].concat(_toConsumableArray(list)));
      }
    }
    /**
     * 给定父宽度情况下，尝试行内放下后的剩余宽度，为负数即放不下，这里只会出现行内级即inline(Block)
     * 调用前提是非行开头的inline尝试计算是否放得下，开头无需且禁止判断，防止出现永远放不下一个字符卡死
     * 返回非负数就是放得下，这样一些尺寸为0的也算
     * @param w 剩余宽度
     * @param total 容器尺寸
     * @returns {number|*}
     * @private
     */

  }, {
    key: "__tryLayInline",
    value: function __tryLayInline(w, total) {
      var flowChildren = this.flowChildren,
          _this$currentStyle = this.currentStyle,
          display = _this$currentStyle[DISPLAY$4],
          width = _this$currentStyle[WIDTH$3],
          marginLeft = _this$currentStyle[MARGIN_LEFT$3],
          marginRight = _this$currentStyle[MARGIN_RIGHT$2],
          paddingLeft = _this$currentStyle[PADDING_LEFT$3],
          paddingRight = _this$currentStyle[PADDING_RIGHT$2],
          borderLeftWidth = _this$currentStyle[BORDER_LEFT_WIDTH$3],
          borderRightWidth = _this$currentStyle[BORDER_RIGHT_WIDTH$2]; // inline没w/h，并且尝试孩子第一个能放下即可，如果是文字就是第一个字符

      if (display === 'inline') {
        if (flowChildren.length) {
          var first = flowChildren[0];

          if (first instanceof Component) {
            first = first.shadowRoot;
          }

          if (first instanceof Xom) {
            w = first.__tryLayInline(w, total);
          } else {
            w -= first.firstCharWidth;
          }
        }
      } // inlineBlock尝试所有孩子在一行上
      else {
        if (width[1] === PX$3) {
          w -= width[0];
        } else if (width[1] === PERCENT$3) {
          w -= total * width[0] * 0.01;
        } else if (width[1] === REM$8) {
          w -= width[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (width[1] === VW$8) {
          w -= width[0] * this.root.width * 0.01;
        } else if (width[1] === VH$8) {
          w -= width[0] * this.root.height * 0.01;
        } else {
          for (var i = 0; i < flowChildren.length; i++) {
            // 当放不下时直接返回，无需继续多余的尝试计算
            if (w < 0) {
              return w;
            }

            var item = flowChildren[i];

            if (item instanceof Component) {
              item = item.shadowRoot;
            }

            if (item instanceof Xom) {
              w = item.__tryLayInline(w, total);
            } // text强制一行，否则非头就是放不下，需从头开始
            else {
              w -= item.textWidth;
            }
          }
        } // ib要减去末尾mpb


        if (marginRight[1] === PX$3) {
          w -= marginRight[0];
        } else if (marginRight[1] === PERCENT$3) {
          w -= marginRight[0] * total * 0.01;
        } else if (marginRight[1] === REM$8) {
          w -= marginRight[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (marginRight[1] === VW$8) {
          w -= marginRight[0] * this.root.width * 0.01;
        } else if (marginRight[1] === VH$8) {
          w -= marginRight[0] * this.root.height * 0.01;
        }

        if (paddingRight[1] === PX$3) {
          w -= paddingRight[0];
        } else if (paddingRight[1] === PERCENT$3) {
          w -= paddingRight[0] * total * 0.01;
        } else if (paddingRight[1] === REM$8) {
          w -= paddingRight[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (paddingRight[1] === VW$8) {
          w -= paddingRight[0] * this.root.width * 0.01;
        } else if (paddingRight[1] === VH$8) {
          w -= paddingRight[0] * this.root.height * 0.01;
        }

        if (borderRightWidth[1] === PX$3) {
          w -= borderRightWidth[0];
        } else if (borderRightWidth[1] === REM$8) {
          w -= borderRightWidth[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (borderRightWidth[1] === VW$8) {
          w -= borderRightWidth[0] * this.root.width * 0.01;
        } else if (borderRightWidth[1] === VH$8) {
          w -= borderRightWidth[0] * this.root.height * 0.01;
        }
      } // 还要减去开头的mpb


      if (marginLeft[1] === PX$3) {
        w -= marginLeft[0];
      } else if (marginLeft[1] === PERCENT$3) {
        w -= marginLeft[0] * total * 0.01;
      } else if (marginLeft[1] === REM$8) {
        w -= marginLeft[0] * this.root.computedStyle[FONT_SIZE$8];
      } else if (marginLeft[1] === VW$8) {
        w -= marginLeft[0] * this.root.width * 0.01;
      } else if (marginLeft[1] === VH$8) {
        w -= marginLeft[0] * this.root.height * 0.01;
      }

      if (paddingLeft[1] === PX$3) {
        w -= paddingLeft[0];
      } else if (paddingLeft[1] === PERCENT$3) {
        w -= paddingLeft[0] * total * 0.01;
      } else if (paddingLeft[1] === REM$8) {
        w -= paddingLeft[0] * this.root.computedStyle[FONT_SIZE$8];
      } else if (paddingLeft[1] === VW$8) {
        w -= paddingLeft[0] * this.root.width * 0.01;
      } else if (paddingLeft[1] === VH$8) {
        w -= paddingLeft[0] * this.root.height * 0.01;
      }

      if (borderLeftWidth[1] === PX$3) {
        w -= borderLeftWidth[0];
      } else if (borderLeftWidth[1] === REM$8) {
        w -= borderLeftWidth[0] * this.root.computedStyle[FONT_SIZE$8];
      } else if (borderLeftWidth[1] === VW$8) {
        w -= borderLeftWidth[0] * this.root.width * 0.01;
      } else if (borderLeftWidth[1] === VH$8) {
        w -= borderLeftWidth[0] * this.root.height * 0.01;
      }

      return w;
    } // 设置y偏移值，递归包括children，此举在justify-content/margin-auto等对齐用

  }, {
    key: "__offsetX",
    value: function __offsetX(diff, isLayout, lv) {
      _get(_getPrototypeOf(Dom.prototype), "__offsetX", this).call(this, diff, isLayout, lv); // 记得偏移LineBox


      if (isLayout && !this.__config[NODE_IS_INLINE] && this.lineBoxManager) {
        this.lineBoxManager.__offsetX(diff);
      }

      this.flowChildren.forEach(function (item) {
        if (item) {
          item.__offsetX(diff, isLayout, lv);
        }
      });
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff, isLayout, lv) {
      _get(_getPrototypeOf(Dom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

      if (isLayout && !this.__config[NODE_IS_INLINE] && this.lineBoxManager) {
        this.lineBoxManager.__offsetY(diff);
      }

      this.flowChildren.forEach(function (item) {
        if (item) {
          item.__offsetY(diff, isLayout, lv);
        }
      });
    } // item的递归子节点求min/max，只考虑固定值单位，忽略百分比，同时按方向和display

  }, {
    key: "__calMinMax",
    value: function __calMinMax(isDirectionRow, data) {
      css.computeReflow(this, this.isShadowRoot);
      var min = 0;
      var max = 0;
      var flowChildren = this.flowChildren,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle;
      var x = data.x,
          y = data.y,
          w = data.w,
          h = data.h,
          lineBoxManager = data.lineBoxManager; // 计算需考虑style的属性

      var display = currentStyle[DISPLAY$4],
          flexDirection = currentStyle[FLEX_DIRECTION],
          width = currentStyle[WIDTH$3],
          height = currentStyle[HEIGHT$3];
      var lineHeight = computedStyle[LINE_HEIGHT];
      var main = isDirectionRow ? width : height; // 只绝对值生效，%不生效，依旧要判断

      if (main[1] === PX$3) {
        min = max = main[0];
      } else if (main[1] === REM$8) {
        min = max = main[0] * this.root.computedStyle[FONT_SIZE$8];
      } else if (main[1] === VW$8) {
        min = max = main[0] * this.root.width * 0.01;
      } else if (main[1] === VH$8) {
        min = max = main[0] * this.root.height * 0.01;
      } else {
        if (display === 'flex') {
          var isRow = flexDirection !== 'column';
          flowChildren = genOrderChildren(flowChildren);
          flowChildren.forEach(function (item) {
            if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
              var _currentStyle = item.currentStyle,
                  _computedStyle = item.computedStyle; // flex的child如果是inline，变为block，在计算autoBasis前就要

              if (_currentStyle[DISPLAY$4] !== 'block' && _currentStyle[DISPLAY$4] !== 'flex') {
                _currentStyle[DISPLAY$4] = _computedStyle[DISPLAY$4] = 'block';
              }

              var _item$__calMinMax = item.__calMinMax(isDirectionRow, {
                x: x,
                y: y,
                w: w,
                h: h
              }),
                  _item$__calMinMax2 = _slicedToArray(_item$__calMinMax, 2),
                  _item$__calMinMax2$ = _slicedToArray(_item$__calMinMax2[1], 2),
                  min2 = _item$__calMinMax2$[0],
                  max2 = _item$__calMinMax2$[1];

              if (isDirectionRow) {
                if (isRow) {
                  min += min2;
                  max += max2;
                } else {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                }
              } else {
                if (isRow) {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                } else {
                  min += min2;
                  max += max2;
                }
              }
            } else if (isDirectionRow) {
              if (isRow) {
                min += item.charWidth;
                max += item.textWidth;
              } else {
                min = Math.max(min, item.charWidth);
                max = Math.max(max, item.textWidth);
              }
            } else {
              var _lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));

              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: _lineBoxManager
              });

              if (isRow) {
                min = Math.max(min, item.height);
                max = Math.max(max, item.height);
              } else {
                min += item.height;
                max += item.height;
              }
            }
          });
        } else if (display === 'block') {
          var countMin = 0,
              countMax = 0;

          var _lineBoxManager2 = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));

          var length = flowChildren.length;
          flowChildren.forEach(function (item, i) {
            if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
              var _item$__calMinMax3 = item.__calMinMax(isDirectionRow, {
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: _lineBoxManager2
              }),
                  _item$__calMinMax4 = _slicedToArray(_item$__calMinMax3, 2),
                  _display = _item$__calMinMax4[0],
                  _item$__calMinMax4$ = _slicedToArray(_item$__calMinMax4[1], 2),
                  min2 = _item$__calMinMax4$[0],
                  max2 = _item$__calMinMax4$[1]; // 块级查看之前是否有行内元素，设置换行


              if ((_display === 'block' || _display === 'flex') && _lineBoxManager2.isEnd) {
                _lineBoxManager2.setNotEnd();

                _lineBoxManager2.setNewLine();
              }

              if (isDirectionRow) {
                if (_display === 'block' || _display === 'flex') {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                  countMin = countMax = 0;
                } else {
                  countMin += min2;
                  countMax += max2;
                  min = Math.max(min, countMin);
                  max = Math.max(max, countMax);
                }
              } else {
                if (_display === 'block' || _display === 'flex') {
                  // 之前行积累的极值，并清空
                  min += countMin;
                  max += countMax;
                  countMin = countMax = 0; // 本身的

                  min += min2;
                  max += max2;
                } else {
                  // 行内取极值，最后一个记得应用
                  countMin = Math.max(countMin, min2);
                  countMax = Math.max(countMax, max2);

                  if (i === length - 1) {
                    min += countMin;
                    max += countMax;
                  }
                }
              }
            } else if (isDirectionRow) {
              countMin += item.charWidth;
              countMax += item.textWidth;
              min = Math.max(min, countMin);
              max = Math.max(max, countMax);
            } else {
              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: _lineBoxManager2
              }); // 行内取极值，最后一个记得应用


              countMin = Math.max(countMin, item.height);
              countMax = Math.max(countMax, item.height);

              if (i === length - 1) {
                min += countMin;
                max += countMax;
              }
            }
          });
        } else {
          if (display === 'inlineBlock' || display === 'inline-block') {
            lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));
          }

          flowChildren.forEach(function (item) {
            if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
              var _item$__calMinMax5 = item.__calMinMax(isDirectionRow, {
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: lineBoxManager
              }),
                  _item$__calMinMax6 = _slicedToArray(_item$__calMinMax5, 2),
                  _item$__calMinMax6$ = _slicedToArray(_item$__calMinMax6[1], 2),
                  min2 = _item$__calMinMax6$[0],
                  max2 = _item$__calMinMax6$[1];

              if (isDirectionRow) {
                min += min2;
                max += max2;
              } else {
                min = Math.max(min, min2);
                max = Math.max(max, max2);
              }
            } else if (isDirectionRow) {
              min += item.charWidth;
              max += item.textWidth;
            } else {
              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: lineBoxManager
              });

              min = Math.max(min, item.height);
              max = Math.max(max, item.height);
            }
          });
        }
      }

      return [display, this.__addMp(isDirectionRow, w, currentStyle, [min, max])];
    }
    /**
     * flex布局时，计算basis尺寸，如果有固定声明则以其为标准，content为内容最大尺寸，auto依赖w/h或降级content
     * basis要考虑相加直接item的mpb，非绝对值单位以container为基准，basis为内容时为max值
     * item的孩子为孙子节点需递归，不参与basis计算，只参与min/max，尺寸和mpb均只考虑绝对值
     * 自动计算时影响尺寸的只有换行的text，以及一组inline，均按其中最大尺寸的一个计算
     * auto自动计算递归进行，如果是普通row方向，按最大text的charWidth为准
     * 如果是column方向，则虚拟布局后看text的height
     * 在abs下时进入特殊状态，无论是row/column，都会按row方向尝试最大尺寸，直到舞台边缘或容器声明的w折行
     * 返回b，声明则按css值，否则是auto/content
     * 返回min为最小宽度，遇到字符/inline则单列排版后需要的最大宽度
     * 返回max为最大宽度，理想情况一排最大值，在abs时isVirtual状态参与计算，文本抵达边界才进行换行
     * @param isDirectionRow
     * @param data
     * @param isVirtual abs非固定尺寸时先进行虚拟布局标识
     * @private
     */

  }, {
    key: "__calBasis",
    value: function __calBasis(isDirectionRow, data, isVirtual) {
      css.computeReflow(this, this.isShadowRoot);
      var b = 0;
      var min = 0;
      var max = 0;
      var flowChildren = this.flowChildren,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle;
      var x = data.x,
          y = data.y,
          w = data.w,
          h = data.h; // 计算需考虑style的属性

      var display = currentStyle[DISPLAY$4],
          flexDirection = currentStyle[FLEX_DIRECTION],
          width = currentStyle[WIDTH$3],
          height = currentStyle[HEIGHT$3],
          flexBasis = currentStyle[FLEX_BASIS$2];
      var lineHeight = computedStyle[LINE_HEIGHT];
      var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content

      var isAuto = flexBasis[1] === AUTO$2;
      var isFixed = [PX$3, PERCENT$3, REM$8, VW$8, VH$8].indexOf(flexBasis[1]) > -1;
      var isContent = !isAuto && !isFixed;
      var fixedSize; // flex的item固定basis计算

      if (isFixed) {
        if (flexBasis[1] === PX$3) {
          b = fixedSize = flexBasis[0];
        } else if (flexBasis[1] === PERCENT$3) {
          b = fixedSize = (isDirectionRow ? w : h) * flexBasis[0] * 0.01;
        } else if (flexBasis[1] === REM$8) {
          b = fixedSize = flexBasis[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (flexBasis[1] === VW$8) {
          b = fixedSize = flexBasis[0] * this.root.width * 0.01;
        } else if (flexBasis[1] === VH$8) {
          b = fixedSize = flexBasis[0] * this.root.height * 0.01;
        }
      } // 已声明主轴尺寸的，当basis是auto时为值
      else if ([PX$3, PERCENT$3, REM$8, VW$8, VH$8].indexOf(main[1]) > -1 && isAuto) {
        if (main[1] === PX$3) {
          b = fixedSize = main[0];
        } else if (main[1] === PERCENT$3) {
          b = fixedSize = main[0] * 0.01 * (isDirectionRow ? w : h);
        } else if (main[1] === REM$8) {
          b = fixedSize = main[0] * this.root.computedStyle[FONT_SIZE$8];
        } else if (main[1] === VW$8) {
          b = fixedSize = main[0] * this.root.width * 0.01;
        } else if (main[1] === VH$8) {
          b = fixedSize = main[0] * this.root.height * 0.01;
        }
      } // 非固定尺寸的basis为auto时降级为content
      else if (isAuto) {
        isContent = true;
      } // flex的item还是flex时


      if (display === 'flex') {
        var isRow = flexDirection !== 'column';
        flowChildren = genOrderChildren(flowChildren);
        flowChildren.forEach(function (item) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            var _currentStyle2 = item.currentStyle,
                _computedStyle2 = item.computedStyle; // flex的child如果是inline，变为block，在计算autoBasis前就要

            if (_currentStyle2[DISPLAY$4] !== 'block' && _currentStyle2[DISPLAY$4] !== 'flex') {
              _currentStyle2[DISPLAY$4] = _computedStyle2[DISPLAY$4] = 'block';
            }

            var _item$__calMinMax7 = item.__calMinMax(isDirectionRow, {
              x: x,
              y: y,
              w: w,
              h: h
            }),
                _item$__calMinMax8 = _slicedToArray(_item$__calMinMax7, 2),
                _item$__calMinMax8$ = _slicedToArray(_item$__calMinMax8[1], 2),
                min2 = _item$__calMinMax8$[0],
                max2 = _item$__calMinMax8$[1];

            if (isDirectionRow) {
              if (isRow) {
                min += min2;
                max += max2;
              } else {
                min = Math.max(min, min2);
                max = Math.max(max, max2);
              }
            } else {
              if (isRow) {
                min = Math.max(min, min2);
                max = Math.max(max, max2);
              } else {
                min += min2;
                max += max2;
              }
            }
          } else if (isDirectionRow) {
            if (isRow) {
              min += item.charWidth;
              max += item.textWidth;
            } else {
              min = Math.max(min, item.charWidth);
              max = Math.max(max, item.textWidth);
            }
          } else {
            var lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));

            item.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager
            });

            if (isRow) {
              min = Math.max(min, item.height);
              max = Math.max(max, item.height);
            } else {
              min += item.height;
              max += item.height;
            }
          }
        });
      } // flex的item是block/inline时，inline也会变成block统一对待
      else {
        var countMin = 0,
            countMax = 0;
        var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));
        var length = flowChildren.length;
        flowChildren.forEach(function (item, i) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            var _item$__calMinMax9 = item.__calMinMax(isDirectionRow, {
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager
            }),
                _item$__calMinMax10 = _slicedToArray(_item$__calMinMax9, 2),
                _display2 = _item$__calMinMax10[0],
                _item$__calMinMax10$ = _slicedToArray(_item$__calMinMax10[1], 2),
                min2 = _item$__calMinMax10$[0],
                max2 = _item$__calMinMax10$[1]; // 块级查看之前是否有行内元素，设置换行


            if ((_display2 === 'block' || _display2 === 'flex') && lineBoxManager.isEnd) {
              lineBoxManager.setNotEnd();
              lineBoxManager.setNewLine();
            }

            if (isDirectionRow) {
              if (_display2 === 'block' || _display2 === 'flex') {
                min = Math.max(min, min2);
                max = Math.max(max, max2);
                countMin = countMax = 0;
              } else {
                countMin += min2;
                countMax += max2;
                min = Math.max(min, countMin);
                max = Math.max(max, countMax);
              }
            } else {
              if (_display2 === 'block' || _display2 === 'flex') {
                // 之前行积累的极值，并清空
                min += countMin;
                max += countMax;
                countMin = countMax = 0; // 本身的

                min += min2;
                max += max2;
              } else {
                // 行内取极值，最后一个记得应用
                countMin = Math.max(countMin, min2);
                countMax = Math.max(countMax, max2);

                if (i === length - 1) {
                  min += countMin;
                  max += countMax;
                }
              }
            }
          } else if (isDirectionRow) {
            countMin += item.charWidth;
            countMax += item.textWidth;
            min = Math.max(min, countMin);
            max = Math.max(max, countMax);
          } else {
            item.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager
            }); // 行内取极值，最后一个记得应用


            countMin = Math.max(countMin, item.height);
            countMax = Math.max(countMax, item.height);

            if (i === length - 1) {
              min += countMin;
              max += countMax;
            }
          }
        });
      }

      if (fixedSize) {
        max = Math.max(fixedSize, max);
      }

      if (isContent) {
        b = max;
      } // 直接item的mpb影响basis


      return this.__addMp(isDirectionRow, w, currentStyle, [b, min, max], true);
    }
  }, {
    key: "__layoutNone",
    value: function __layoutNone() {
      _get(_getPrototypeOf(Dom.prototype), "__layoutNone", this).call(this);

      var children = this.children;
      children.forEach(function (item) {
        if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
          item.__layoutNone();
        }
      });
    }
    /**
     * block布局，本身固定尺寸优先，否则看内容从上往下从左往右flow流排布
     * 内部inline和inlineBlock组成LineBox，通过LineBoxManager来管理混排的现象
     * LineBoxManager只有block和inlineBlock内部生成，inline会复用最近父级的
     * 内部的block在垂直方向要考虑margin合并的问题，强制所有节点为bfc，精简逻辑
     * @param data
     * @param isVirtual abs无尺寸时提前虚拟布局计算尺寸
     * @private
     */

  }, {
    key: "__layoutBlock",
    value: function __layoutBlock(data, isVirtual) {
      var flowChildren = this.flowChildren,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle;

      var _this$__preLayout = this.__preLayout(data),
          fixedWidth = _this$__preLayout.fixedWidth,
          fixedHeight = _this$__preLayout.fixedHeight,
          x = _this$__preLayout.x,
          y = _this$__preLayout.y,
          w = _this$__preLayout.w,
          h = _this$__preLayout.h; // abs虚拟布局需预知width，固定可提前返回


      if (fixedWidth && isVirtual) {
        this.__width = w;

        this.__ioSize(w, this.height);

        return;
      }

      var textAlign = computedStyle[TEXT_ALIGN],
          whiteSpace = computedStyle[WHITE_SPACE],
          lineClamp = computedStyle[LINE_CLAMP],
          lineHeight = computedStyle[LINE_HEIGHT]; // 只有>=1的正整数才有效

      lineClamp = lineClamp || 0;
      var lineClampCount = 0; // 虚线管理一个block内部的LineBox列表，使得inline的元素可以中途衔接处理折行
      // 内部维护inline结束的各种坐标来达到目的，遇到block时中断并处理换行坐标

      var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle)); // 因精度问题，统计宽度均从0开始累加每行，最后取最大值，仅在abs布局时isVirtual生效

      var maxW = 0;
      var cw = 0; // 连续block（flex相同，下面都是）的上下margin合并值记录，合并时从列表中取

      var mergeMarginBottomList = [],
          mergeMarginTopList = [];
      var length = flowChildren.length;
      flowChildren.forEach(function (item, i) {
        var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;
        var isInline = isXom && item.currentStyle[DISPLAY$4] === 'inline';
        var isInlineBlock = isXom && ['inlineBlock', 'inline-block'].indexOf(item.currentStyle[DISPLAY$4]) > -1;
        var isImg = item.tagName === 'img'; // 每次循环开始前，这次不是block的话，看之前遗留待合并margin，并重置

        if (!isXom || isInline || isInlineBlock) {
          if (mergeMarginBottomList.length && mergeMarginTopList.length) {
            var diff = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList);

            if (diff) {
              y += diff;
            }
          }

          mergeMarginTopList = [];
          mergeMarginBottomList = [];
        }

        if (isXom) {
          // inline和inlineBlock的细节不同之处，ib除了w/h之外，更想像block一样占据一行
          // 比如2个inline前面占一半后面比一半多但还是会从一半开始然后第2行换行继续，但ib放不下则重开一行
          // inline和ib能互相嵌套，形成的LineBox中则是TextBox和节点混合
          if (isInlineBlock || isInline) {
            // x开头，不用考虑是否放得下直接放
            if (x === data.x || isInline && whiteSpace === 'nowrap') {
              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: data.x,
                lineBoxManager: lineBoxManager,
                // ib内部新生成会内部判断，这里不管统一传入
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual); // inlineBlock的特殊之处，一旦w为auto且内部产生折行时，整个变成block独占一块区域，坐标计算和block一样


              if (item.__isIbFull) {
                x = data.x;
                y += item.outerHeight;
                lineBoxManager.setNotEnd();
              } // inline和不折行的ib，其中ib需要手动存入当前lb中
              else {
                (isInlineBlock || isImg) && lineBoxManager.addItem(item);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              } // abs统计宽度


              if (isVirtual) {
                maxW = Math.max(maxW, cw);
                cw = item.outerWidth;
                maxW = Math.max(maxW, cw);
              }
            } else {
              // 非开头先尝试是否放得下，内部判断了inline/ib，ib要考虑是否有width
              var fw = item.__tryLayInline(w + data.x - x, w); // 放得下继续，奇怪的精度问题，加上阈值


              if (fw >= -1e-10) {
                item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: data.x,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount
                }, isVirtual); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb


                (isInlineBlock || isImg) && lineBoxManager.addItem(item);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;
                x = data.x;
                y = lineBoxManager.endY;
                lineBoxManager.setNewLine();
                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: data.x,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount
                }, isVirtual); // 重新开头的ib和上面开头处一样逻辑

                if (item.__isIbFull) {
                  x = data.x;
                  y += item.outerHeight;
                  lineBoxManager.setNotEnd();
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock || isImg) && lineBoxManager.addItem(item);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                }

                if (isVirtual) {
                  maxW = Math.max(maxW, cw);
                  cw = 0;
                }
              }

              if (isVirtual) {
                cw += item.outerWidth;
                maxW = Math.max(maxW, cw);
              }
            }
          } // block/flex先处理之前可能遗留的最后一行LineBox，然后递归时不传lineBoxManager，其内部生成新的
          else {
            // 非开头，说明之前的text未换行，需要增加行数
            if (x !== data.x && flowChildren[i - 1] instanceof Text) {
              lineClampCount++;
            }

            x = data.x;

            if (lineBoxManager.isEnd) {
              y = lineBoxManager.endY;
              lineBoxManager.setNotEnd();
              lineBoxManager.setNewLine();
            }

            item.__layout({
              x: x,
              y: y,
              w: w,
              h: h
            }, isVirtual);

            var isNone = item.currentStyle[DISPLAY$4] === 'none'; // 自身无内容

            var isEmptyBlock;

            if (!isNone && item.flowChildren && item.flowChildren.length === 0) {
              var _item$computedStyle = item.computedStyle,
                  marginTop = _item$computedStyle[MARGIN_TOP$3],
                  marginBottom = _item$computedStyle[MARGIN_BOTTOM$3],
                  paddingTop = _item$computedStyle[PADDING_TOP$3],
                  paddingBottom = _item$computedStyle[PADDING_BOTTOM$3],
                  height = _item$computedStyle[HEIGHT$3],
                  borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH$3],
                  borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH$3]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

              if (paddingTop <= 0 && paddingBottom <= 0 && height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                mergeMarginBottomList.push(marginBottom);
                mergeMarginTopList.push(marginTop);
                isEmptyBlock = true;
              }
            }

            y += item.outerHeight;
            lineBoxManager.__lastY = y; // absolute/flex前置虚拟计算

            if (isVirtual) {
              maxW = Math.max(maxW, item.outerWidth);
              cw = 0;
            } // 空block要留下轮循环看，除非是最后一个，此处非空本轮处理掉看是否要合并


            if (!isNone && !isEmptyBlock) {
              var _item$computedStyle2 = item.computedStyle,
                  _marginTop = _item$computedStyle2[MARGIN_TOP$3],
                  _marginBottom = _item$computedStyle2[MARGIN_BOTTOM$3]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
              // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

              if (mergeMarginBottomList.length) {
                mergeMarginTopList.push(_marginTop);

                var _diff = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList);

                if (_diff) {
                  item.__offsetY(_diff, true);

                  y += _diff;
                }
              } // 同时自己保存bottom，为后续block准备


              mergeMarginTopList = [];
              mergeMarginBottomList = [_marginBottom];
            } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0
            else if (i === length - 1) {
              var _diff2 = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList);

              if (_diff2) {
                y += _diff2;
              }
            }
          }
        } // 文字和inline类似
        else {
          // lineClamp作用域为block下的inline（同LineBox上下文）
          if (lineClamp && lineClampCount >= lineClamp) {
            return;
          } // x开头，不用考虑是否放得下直接放


          if (x === data.x || whiteSpace === 'nowrap') {
            lineClampCount = item.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lx: data.x,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount
            }, isVirtual);
            x = lineBoxManager.lastX;
            y = lineBoxManager.lastY;

            if (isVirtual) {
              maxW = Math.max(maxW, cw);
              cw = item.width;
              maxW = Math.max(maxW, cw);
            }
          } else {
            // 非开头先尝试是否放得下
            var _fw = item.__tryLayInline(w - x + data.x); // 放得下继续


            if (_fw >= -1e-10) {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: data.x,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY;
            } // 放不下处理之前的lineBox，并重新开头
            else {
              lineClampCount++;
              x = data.x;
              y = lineBoxManager.endY;
              lineBoxManager.setNewLine();
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: data.x,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY;

              if (isVirtual) {
                maxW = Math.max(maxW, item.width);
                cw = 0;
              }
            }

            if (isVirtual) {
              cw += item.width;
              maxW = Math.max(maxW, cw);
            }
          }
        }
      }); // 结束后如果是以LineBox结尾，则需要设置y到这里，否则流布局中block会设置
      // 当以block换行时，新行是true，否则是false即结尾

      if (lineBoxManager.isEnd) {
        y = lineBoxManager.endY;
      }

      var tw = this.__width = fixedWidth || !isVirtual ? w : maxW;
      var th = this.__height = fixedHeight ? h : y - data.y;

      this.__ioSize(tw, th); // 非abs提前的虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐


      if (!isVirtual) {
        lineBoxManager.verticalAlign();

        if (['center', 'right'].indexOf(textAlign) > -1) {
          lineBoxManager.horizonAlign(tw, textAlign); // 直接text需计算size

          flowChildren.forEach(function (item) {
            if (item instanceof Component) {
              item = item.shadowRoot;
            }

            if (item instanceof Text) {
              item.__inlineSize();
            }
          });
        } // 所有inline计算size


        lineBoxManager.domList.forEach(function (item) {
          item.__inlineSize(tw, textAlign);
        });

        this.__marginAuto(currentStyle, data);
      }
    } // 弹性布局时的计算位置

  }, {
    key: "__layoutFlex",
    value: function __layoutFlex(data, isVirtual) {
      var _this2 = this;

      var flowChildren = this.flowChildren,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle,
          __flexLine = this.__flexLine;

      var _this$__preLayout2 = this.__preLayout(data),
          fixedWidth = _this$__preLayout2.fixedWidth,
          fixedHeight = _this$__preLayout2.fixedHeight,
          x = _this$__preLayout2.x,
          y = _this$__preLayout2.y,
          w = _this$__preLayout2.w,
          h = _this$__preLayout2.h;

      if (fixedWidth && isVirtual) {
        this.__width = w;

        this.__ioSize(w, this.height);

        return;
      } // 每次布局情况多行内容


      __flexLine.splice(0);

      var flexDirection = computedStyle[FLEX_DIRECTION],
          justifyContent = computedStyle[JUSTIFY_CONTENT],
          alignItems = computedStyle[ALIGN_ITEMS],
          lineClamp = computedStyle[LINE_CLAMP],
          flexWrap = computedStyle[FLEX_WRAP],
          alignContent = computedStyle[ALIGN_CONTENT],
          lineHeight = computedStyle[LINE_HEIGHT],
          textAlign = computedStyle[TEXT_ALIGN]; // 只有>=1的正整数才有效

      lineClamp = lineClamp || 0;
      var lineClampCount = 0;
      var maxX = 0;
      var isDirectionRow = ['column', 'column-reverse', 'columnReverse'].indexOf(flexDirection) === -1; // 计算伸缩基数

      var growList = [];
      var shrinkList = [];
      var basisList = [];
      var maxList = [];
      var minList = [];
      var orderChildren = genOrderChildren(flowChildren);
      orderChildren.forEach(function (item) {
        if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
          var _currentStyle3 = item.currentStyle,
              _computedStyle3 = item.computedStyle; // flex的child如果是inline，变为block，在计算autoBasis前就要

          if (_currentStyle3[DISPLAY$4] !== 'block' && _currentStyle3[DISPLAY$4] !== 'flex') {
            _currentStyle3[DISPLAY$4] = _computedStyle3[DISPLAY$4] = 'block';
          } // abs虚拟布局计算时纵向也是看横向宽度


          var _item$__calBasis = item.__calBasis(isVirtual ? true : isDirectionRow, {
            x: x,
            y: y,
            w: w,
            h: h
          }, isVirtual),
              _item$__calBasis2 = _slicedToArray(_item$__calBasis, 3),
              b = _item$__calBasis2[0],
              min = _item$__calBasis2[1],
              max = _item$__calBasis2[2];

          if (isVirtual) {
            if (isDirectionRow) {
              maxX += max;
            } else {
              maxX = Math.max(maxX, max);
            }

            return;
          }

          var flexGrow = _currentStyle3[FLEX_GROW],
              flexShrink = _currentStyle3[FLEX_SHRINK];
          _computedStyle3[FLEX_BASIS$2] = b;
          growList.push(flexGrow);
          shrinkList.push(flexShrink); // 根据basis不同，计算方式不同

          basisList.push(b);
          maxList.push(max);
          minList.push(min);
        } // 文本
        else {
          if (isVirtual) {
            if (isDirectionRow) {
              maxX += item.textWidth;
            } else {
              maxX = Math.max(maxX, item.textWidth);
            }

            return;
          }

          growList.push(0);
          shrinkList.push(1);

          if (isDirectionRow) {
            var cw = item.charWidth;
            var _tw = item.textWidth;
            basisList.push(_tw);
            maxList.push(_tw);
            minList.push(cw);
          } else {
            var lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));

            item.__layout({
              x: x,
              y: y,
              w: w,
              h: _h,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount
            });

            var _h = item.height;
            basisList.push(_h);
            minList.push(_h);
          }
        }
      }); // abs时，只需关注宽度即可，无需真正布局

      if (isVirtual) {
        var _tw2 = this.__width = Math.min(maxX, w);

        this.__ioSize(_tw2, this.height);

        return;
      }

      var containerSize = isDirectionRow ? w : h;
      var isMultiLine = flexWrap === 'wrap' || ['wrap-reverse', 'wrapReverse'].indexOf(flexWrap) > -1;
      /**
       * 判断是否需要分行，根据假设主尺寸来统计尺寸和计算，假设主尺寸是clamp(min_main_size, flex_base_size, max_main_size)
       * 当多行时，由于每行一定有最小限制，所以每行一般情况都不是shrink状态，
       * 但也有极端情况，比如一行只能放下1个元素时，且此元素比容器小，会是shrink
       */

      var line = [],
          sum = 0,
          hypotheticalList = [];
      basisList.forEach(function (item, i) {
        var min = minList[i],
            max = maxList[i];
        var hypothetical;

        if (item < min) {
          hypothetical = min;
        } else if (item > max) {
          hypothetical = max;
        } else {
          hypothetical = item;
        }

        hypotheticalList.push(hypothetical);

        if (isMultiLine) {
          // 超过尺寸时，要防止sum为0即1个也会超过尺寸
          if (sum + hypothetical > containerSize) {
            if (sum) {
              __flexLine.push(line);

              line = [orderChildren[i]];
              sum = hypothetical;
            } else {
              line.push(orderChildren[i]);

              __flexLine.push(line);

              line = [];
              sum = 0;
            }
          } else {
            line.push(orderChildren[i]);
            sum += hypothetical;
          }
        } else {
          line.push(orderChildren[i]);
        }
      });

      if (line.length) {
        __flexLine.push(line);
      }

      var offset = 0,
          clone = {
        x: x,
        y: y,
        w: w,
        h: h
      };
      var maxCrossList = [];

      __flexLine.forEach(function (item) {
        var length = item.length;
        var end = offset + length;

        var _this2$__layoutFlexLi = _this2.__layoutFlexLine(clone, isDirectionRow, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren.slice(offset, end), item, textAlign, growList.slice(offset, end), shrinkList.slice(offset, end), basisList.slice(offset, end), hypotheticalList.slice(offset, end), minList.slice(offset, end)),
            _this2$__layoutFlexLi2 = _slicedToArray(_this2$__layoutFlexLi, 3),
            x1 = _this2$__layoutFlexLi2[0],
            y1 = _this2$__layoutFlexLi2[1],
            maxCross = _this2$__layoutFlexLi2[2]; // 下一行/列更新坐标


        if (isDirectionRow) {
          clone.y = y1;
        } else {
          clone.x = x1;
        }

        x = Math.max(x, x1);
        y = Math.max(y, y1);
        maxCrossList.push(maxCross);
        offset += length;
      });

      var tw = this.__width = w;
      var th = this.__height = fixedHeight ? h : y - data.y;

      this.__ioSize(tw, th); // flexDirection当有reverse时交换每line的主轴序


      if (flexDirection === 'row-reverse' || flexDirection === 'rowReverse') {
        __flexLine.forEach(function (line) {
          line.forEach(function (item) {
            // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
            var diff = tw - item.outerWidth - (item.x - data.x) * 2;

            if (diff) {
              item.__offsetX(diff, true);
            }
          });
        });
      } else if (flexDirection === 'column-reverse' || flexDirection === 'columnReverse') {
        __flexLine.forEach(function (line) {
          line.forEach(function (item) {
            // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
            var diff = th - item.outerHeight - (item.y - data.y) * 2;

            if (diff) {
              item.__offsetY(diff, true);
            }
          });
        });
      } // wrap-reverse且多轴线时交换轴线序，需要2行及以上才行


      var length = __flexLine.length;

      if (['wrapReverse', 'wrap-reverse'].indexOf(flexWrap) > -1 && length > 1) {
        var crossSum = 0,
            crossSumList = [];
        maxCrossList.forEach(function (item) {
          crossSumList.push(crossSum);
          crossSum += item;
        });
        var count = 0;

        var _loop = function _loop(i) {
          var line = __flexLine[i];
          var source = crossSumList[i];
          var diff = count - source;

          if (diff) {
            line.forEach(function (item) {
              if (isDirectionRow) {
                item.__offsetY(diff, true);
              } else {
                item.__offsetX(diff, true);
              }
            });
          }

          count += maxCrossList[i];
        };

        for (var i = length - 1; i >= 0; i--) {
          _loop(i);
        }

        __flexLine.reverse();
      } // 侧轴对齐分flexLine做，要考虑整体的alignContent的stretch和每行的alignItems的stretch
      // 先做整体的，得出交叉轴空白再均分给每一行做单行的，整体的只有1行忽略


      var per;

      if (!isVirtual && length > 1 && (fixedHeight && isDirectionRow || !isDirectionRow)) {
        var diff = isDirectionRow ? th - (y - data.y) : tw - (x - data.x); // 有空余时才进行对齐

        if (diff > 0) {
          if (alignContent === 'center') {
            var _per = diff * 0.5;

            orderChildren.forEach(function (item) {
              if (isDirectionRow) {
                item.__offsetY(_per, true);
              } else {
                item.__offsetX(_per, true);
              }
            });
          } else if (alignContent === 'flex-start' || alignContent === 'flexStart') ; else if (alignContent === 'flex-end' || alignContent === 'flexEnd') {
            orderChildren.forEach(function (item) {
              if (isDirectionRow) {
                item.__offsetY(diff, true);
              } else {
                item.__offsetX(diff, true);
              }
            });
          } else if (alignContent === 'space-between' || alignContent === 'spaceBetween') {
            var between = diff / (length - 1); // 除了第1行其它进行偏移

            __flexLine.forEach(function (item, i) {
              if (i) {
                item.forEach(function (item) {
                  if (isDirectionRow) {
                    item.__offsetY(between, true);
                  } else {
                    item.__offsetX(between, true);
                  }
                });
              }
            });
          } else if (alignContent === 'space-around' || alignContent === 'spaceAround') {
            var around = diff / (length + 1);

            __flexLine.forEach(function (item, i) {
              item.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(around * (i + 1), true);
                } else {
                  item.__offsetX(around * (i + 1), true);
                }
              });
            });
          } // 默认stretch
          else {
            per = diff / length; // 除了第1行其它进行偏移

            __flexLine.forEach(function (item, i) {
              if (i) {
                item.forEach(function (item) {
                  if (isDirectionRow) {
                    item.__offsetY(per * i, true);
                  } else {
                    item.__offsetX(per * i, true);
                  }
                });
              }
            });
          }
        }
      } // 每行再进行cross对齐，在alignContent为stretch时计算每行的高度


      if (!isVirtual) {
        if (length > 1) {
          __flexLine.forEach(function (item, i) {
            var maxCross = maxCrossList[i];

            if (per) {
              maxCross += per;
            }

            _this2.__crossAlign(item, alignItems, isDirectionRow, maxCross);
          });
        } else if (length) {
          var maxCross = maxCrossList[0];

          if (isDirectionRow) {
            if (fixedHeight) {
              maxCross = h;
            }
          } else {
            maxCross = w;
          }

          this.__crossAlign(__flexLine[0], alignItems, isDirectionRow, maxCross);
        }
      }

      this.__marginAuto(currentStyle, data);
    }
    /**
     * 计算获取子元素的b/min/max完毕后，尝试进行flex每行布局
     * https://www.w3.org/TR/css-flexbox-1/#layout-algorithm
     * 假想主尺寸，其为clamp(min_main_size, flex_base_size, max_main_size)
     * 随后按算法一步步来 https://zhuanlan.zhihu.com/p/354567655
     * 规范没提到mpb，item的要计算，孙子的只考虑绝对值
     * 先收集basis和假设主尺寸
     */

  }, {
    key: "__layoutFlexLine",
    value: function __layoutFlexLine(data, isDirectionRow, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren, flexLine, textAlign, growList, shrinkList, basisList, hypotheticalList, minList) {
      var _this3 = this;

      var x = data.x,
          y = data.y,
          w = data.w,
          h = data.h;
      var hypotheticalSum = 0;
      hypotheticalList.forEach(function (item) {
        hypotheticalSum += item;
      }); // 根据假设尺寸确定使用grow还是shrink，冻结非弹性项并设置target尺寸，确定剩余未冻结数量

      var isOverflow = hypotheticalSum >= containerSize;
      var targetMainList = [];
      basisList.forEach(function (item, i) {
        if (isOverflow) {
          if (!shrinkList[i] || basisList[i] < hypotheticalList[i]) {
            targetMainList[i] = hypotheticalList[i];
          }
        } else {
          if (!growList[i] || basisList[i] > hypotheticalList[i]) {
            targetMainList[i] = hypotheticalList[i];
          }
        }
      }); // 初始可用空间，冻结使用确定的target尺寸，未冻结使用假想

      var free = 0;
      basisList.forEach(function (item, i) {
        if (targetMainList[i] !== undefined) {
          free += targetMainList[i];
        } else {
          free += item;
        }
      });
      var total = Infinity;

      if (isDirectionRow) {
        total = w;
      } else if (fixedHeight) {
        total = h;
      } else {
        total = free;
      }

      free = Math.abs(total - free); // 循环，文档算法不够简练，其合并了grow和shrink，实际拆开写更简单

      var factorSum = 0;

      if (isOverflow) {
        (function () {
          // 计算真正的因子占比，同时得出缩小尺寸数值
          // 还需判断每个item收缩不能<min值，小于的话将无法缩小的这部分按比例分配到其它几项上
          // 于是写成一个循环，每轮先处理一遍，如果产生收缩超限的情况，将超限的设为最小值并剔除
          // 剩下的重新分配因子占比继续从头循环重来一遍
          var factorList = shrinkList.map(function (item, i) {
            if (targetMainList[i] === undefined) {
              var n = item * basisList[i];
              factorSum += n;
              return n;
            }
          });

          while (true) {
            if (factorSum < 1) {
              free *= factorSum;
            }

            var needReset = void 0,
                factorSum2 = 0;
            factorList.forEach(function (item, i) {
              if (item) {
                var r = item / factorSum;
                var s = r * free; // 需要收缩的尺寸

                var n = basisList[i] - s; // 实际尺寸
                // 比min还小设置为min，同时设0剔除

                if (n < minList[i]) {
                  targetMainList[i] = minList[i];
                  factorList[i] = 0;
                  needReset = true;
                  free -= basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸
                } // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                else {
                  targetMainList[i] = n;
                  factorSum2 += item;
                }
              }
            });

            if (!needReset) {
              break;
            }

            factorSum = factorSum2;
          }
        })();
      } else {
        (function () {
          var factorList = growList.map(function (item, i) {
            if (targetMainList[i] === undefined) {
              factorSum += item;
              return item;
            }
          });

          while (true) {
            if (factorSum < 1) {
              free *= factorSum;
            }

            var needReset = void 0,
                factorSum2 = 0;
            factorList.forEach(function (item, i) {
              if (item) {
                var r = item / factorSum;
                var s = r * free; // 需要扩展的尺寸

                var n = basisList[i] + s; // 实际尺寸
                // 比min还小设置为min，同时设0剔除

                if (n < minList[i]) {
                  targetMainList[i] = minList[i];
                  factorList[i] = 0;
                  needReset = true;
                  free -= basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸
                } // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                else {
                  targetMainList[i] = n;
                  factorSum2 += item;
                }
              }
            });

            if (!needReset) {
              break;
            }

            factorSum = factorSum2;
          }
        })();
      }

      var maxCross = 0;
      var lbmList = [];
      orderChildren.forEach(function (item, i) {
        var main = targetMainList[i];

        if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
          if (isDirectionRow) {
            item.__layout({
              x: x,
              y: y,
              w: main,
              h: h,
              w3: main // w3假设固定宽度，忽略原始style中的设置

            });
          } else {
            item.__layout({
              x: x,
              y: y,
              w: w,
              h: main,
              h3: main // 同w2

            });
          }
        } else {
          var lineBoxManager = _this3.__lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));
          lbmList.push(lineBoxManager);

          item.__layout({
            x: x,
            y: y,
            w: isDirectionRow ? main : w,
            h: isDirectionRow ? h : main,
            lineBoxManager: lineBoxManager,
            lineClamp: lineClamp,
            lineClampCount: lineClampCount
          });
        }

        if (isDirectionRow) {
          x += item.outerWidth;
          maxCross = Math.max(maxCross, item.outerHeight);
        } else {
          y += item.outerHeight;
          maxCross = Math.max(maxCross, item.outerWidth);
        }
      }); // 计算主轴剩余时要用真实剩余空间而不能用伸缩剩余空间

      var diff = isDirectionRow ? w - x + data.x : h - y + data.y; // 主轴对齐方式

      if (diff > 0) {
        var len = orderChildren.length;

        if (justifyContent === 'flexEnd' || justifyContent === 'flex-end') {
          for (var i = 0; i < len; i++) {
            var child = orderChildren[i];
            isDirectionRow ? child.__offsetX(diff, true) : child.__offsetY(diff, true);
          }
        } else if (justifyContent === 'center') {
          var center = diff * 0.5;

          for (var _i2 = 0; _i2 < len; _i2++) {
            var _child = orderChildren[_i2];
            isDirectionRow ? _child.__offsetX(center, true) : _child.__offsetY(center, true);
          }
        } else if (justifyContent === 'spaceBetween' || justifyContent === 'space-between') {
          var between = diff / (len - 1);

          for (var _i3 = 1; _i3 < len; _i3++) {
            var _child2 = orderChildren[_i3];
            isDirectionRow ? _child2.__offsetX(between * _i3, true) : _child2.__offsetY(between * _i3, true);
          }
        } else if (justifyContent === 'spaceAround' || justifyContent === 'space-around') {
          var around = diff / (len + 1);

          for (var _i4 = 0; _i4 < len; _i4++) {
            var _child3 = orderChildren[_i4];
            isDirectionRow ? _child3.__offsetX(around * (_i4 + 1), true) : _child3.__offsetY(around * (_i4 + 1), true);
          }
        }
      }

      if (isDirectionRow) {
        y += maxCross;
      } else {
        x += maxCross;
      } // flex的直接text对齐比较特殊


      if (['center', 'right'].indexOf(textAlign) > -1) {
        lbmList.forEach(function (item) {
          item.horizonAlign(item.width, textAlign);
        });
      }

      return [x, y, maxCross];
    } // 每个flexLine的侧轴对齐，单行时就是一行对齐

  }, {
    key: "__crossAlign",
    value: function __crossAlign(line, alignItems, isDirectionRow, maxCross) {
      var baseLine = 0;
      line.forEach(function (item) {
        baseLine = Math.max(baseLine, item.firstBaseLine);
      });
      line.forEach(function (item) {
        var alignSelf = item.currentStyle[ALIGN_SELF];

        if (isDirectionRow) {
          if (alignSelf === 'flexStart' || alignSelf === 'flex-start') ; else if (alignSelf === 'flexEnd' || alignSelf === 'flex-end') {
            var diff = maxCross - item.outerHeight;

            if (diff !== 0) {
              item.__offsetY(diff, true);
            }
          } else if (alignSelf === 'center') {
            var _diff3 = maxCross - item.outerHeight;

            if (_diff3 !== 0) {
              item.__offsetY(_diff3 * 0.5, true);
            }
          } else if (alignSelf === 'stretch') {
            var computedStyle = item.computedStyle,
                height = item.currentStyle[HEIGHT$3];
            var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
                borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$3],
                marginTop = computedStyle[MARGIN_TOP$3],
                marginBottom = computedStyle[MARGIN_BOTTOM$3],
                paddingTop = computedStyle[PADDING_TOP$3],
                paddingBottom = computedStyle[PADDING_BOTTOM$3];

            if (height[1] === AUTO$2) {
              var old = item.height;
              var v = item.__height = computedStyle[HEIGHT$3] = maxCross - marginTop - marginBottom - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth;
              var d = v - old;
              item.__sy4 += d;
              item.__sy5 += d;
              item.__sy6 += d;
              item.__height += d;
              item.__clientHeight += d;
              item.__offsetHeight += d;
              item.__outerHeight += d;
            }
          } else if (alignSelf === 'baseline') {
            var _diff4 = baseLine - item.firstBaseLine;

            if (_diff4 !== 0) {
              item.__offsetY(_diff4, true);
            }
          } // 默认auto，取alignItems
          else {
            if (alignItems === 'flexStart' || alignSelf === 'flex-start') ; else if (alignItems === 'center') {
              var _diff5 = maxCross - item.outerHeight;

              if (_diff5 !== 0) {
                item.__offsetY(_diff5 * 0.5, true);
              }
            } else if (alignItems === 'flexEnd' || alignItems === 'flex-end') {
              var _diff6 = maxCross - item.outerHeight;

              if (_diff6 !== 0) {
                item.__offsetY(_diff6, true);
              }
            } else if (alignItems === 'baseline') {
              var _diff7 = baseLine - item.firstBaseLine;

              if (_diff7 !== 0) {
                item.__offsetY(_diff7, true);
              }
            } // 默认stretch
            else {
              var _computedStyle4 = item.computedStyle,
                  _item$currentStyle = item.currentStyle,
                  display = _item$currentStyle[DISPLAY$4],
                  flexDirection = _item$currentStyle[FLEX_DIRECTION],
                  _height = _item$currentStyle[HEIGHT$3]; // row的孩子还是flex且column且不定高时，如果高度<侧轴拉伸高度则重新布局

              if (isDirectionRow && display === 'flex' && flexDirection === 'column' && _height[1] === AUTO$2 && item.outerHeight < maxCross) {
                item.__layout(Object.assign(item.__layoutData, {
                  h3: maxCross
                }));
              }

              var _borderTopWidth = _computedStyle4[BORDER_TOP_WIDTH$3],
                  _borderBottomWidth = _computedStyle4[BORDER_BOTTOM_WIDTH$3],
                  _marginTop2 = _computedStyle4[MARGIN_TOP$3],
                  _marginBottom2 = _computedStyle4[MARGIN_BOTTOM$3],
                  _paddingTop = _computedStyle4[PADDING_TOP$3],
                  _paddingBottom = _computedStyle4[PADDING_BOTTOM$3];

              if (_height[1] === AUTO$2) {
                var _old = item.height;

                var _v = maxCross - _marginTop2 - _marginBottom2 - _paddingTop - _paddingBottom - _borderTopWidth - _borderBottomWidth;

                var _d = _v - _old;

                item.__sy4 += _d;
                item.__sy5 += _d;
                item.__sy6 += _d;
                item.__height += _d;
                item.__clientHeight += _d;
                item.__offsetHeight += _d;
                item.__outerHeight += _d;
              }
            }
          }
        } // column
        else {
          if (alignSelf === 'flexStart' || alignSelf === 'flex-start') ; else if (alignSelf === 'flexEnd' || alignSelf === 'flex-end') {
            var _diff8 = maxCross - item.outerWidth;

            if (_diff8 !== 0) {
              item.__offsetX(_diff8, true);
            }
          } else if (alignSelf === 'center') {
            var _diff9 = maxCross - item.outerWidth;

            if (_diff9 !== 0) {
              item.__offsetX(_diff9 * 0.5, true);
            }
          } else if (alignSelf === 'stretch') {
            var _computedStyle5 = item.computedStyle,
                width = item.currentStyle[WIDTH$3];
            var borderRightWidth = _computedStyle5[BORDER_RIGHT_WIDTH$2],
                borderLeftWidth = _computedStyle5[BORDER_LEFT_WIDTH$3],
                marginRight = _computedStyle5[MARGIN_RIGHT$2],
                marginLeft = _computedStyle5[MARGIN_LEFT$3],
                paddingRight = _computedStyle5[PADDING_RIGHT$2],
                paddingLeft = _computedStyle5[PADDING_LEFT$3];

            if (width[1] === AUTO$2) {
              var _old2 = item.width;

              var _v2 = item.__width = _computedStyle5[WIDTH$3] = maxCross - marginLeft - marginRight - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth;

              var _d2 = _v2 - _old2;

              item.__sx4 += _d2;
              item.__sx5 += _d2;
              item.__sx6 += _d2;
              item.__width += _d2;
              item.__clientWidth += _d2;
              item.__offsetWidth += _d2;
              item.__outerWidth += _d2;
            }
          } else if (alignItems === 'baseline') {
            var _diff10 = baseLine - item.firstBaseLine;

            if (_diff10 !== 0) {
              item.__offsetX(_diff10, true);
            }
          } // 默认auto，取alignItems
          else {
            if (alignItems === 'flexStart' || alignSelf === 'flex-start') ; else if (alignItems === 'center') {
              var _diff11 = maxCross - item.outerWidth;

              if (_diff11 !== 0) {
                item.__offsetX(_diff11 * 0.5, true);
              }
            } else if (alignItems === 'flexEnd' || alignItems === 'flex-end') {
              var _diff12 = maxCross - item.outerWidth;

              if (_diff12 !== 0) {
                item.__offsetX(_diff12, true);
              }
            } else if (alignItems === 'baseline') {
              var _diff13 = baseLine - item.firstBaseLine;

              if (_diff13 !== 0) {
                item.__offsetX(_diff13, true);
              }
            } // 默认stretch
            else {
              var _computedStyle6 = item.computedStyle,
                  _width = item.currentStyle[WIDTH$3];
              var _borderRightWidth = _computedStyle6[BORDER_RIGHT_WIDTH$2],
                  _borderLeftWidth = _computedStyle6[BORDER_LEFT_WIDTH$3],
                  _marginRight = _computedStyle6[MARGIN_RIGHT$2],
                  _marginLeft = _computedStyle6[MARGIN_LEFT$3],
                  _paddingRight = _computedStyle6[PADDING_RIGHT$2],
                  _paddingLeft = _computedStyle6[PADDING_LEFT$3];

              if (_width[1] === AUTO$2) {
                var _old3 = item.width;

                var _v3 = item.__width = _computedStyle6[WIDTH$3] = maxCross - _marginLeft - _marginRight - _paddingLeft - _paddingRight - _borderRightWidth - _borderLeftWidth;

                var _d3 = _v3 - _old3;

                item.__sx4 += _d3;
                item.__sx5 += _d3;
                item.__sx6 += _d3;
                item.__width += _d3;
                item.__clientWidth += _d3;
                item.__offsetWidth += _d3;
                item.__outerWidth += _d3;
              }
            }
          }
        }
      });
    }
    /**
     * inline比较特殊，先简单顶部对其，后续还需根据vertical和lineHeight计算y偏移
     * inlineBlock复用逻辑，可以设置w/h，在混排时表现不同，inlineBlock换行限制在规定的矩形内，
     * 且ib会在没设置width且换行的时候撑满上一行，即便内部尺寸没抵达边界
     * 而inline换行则会从父容器start处开始，且首尾可能占用矩形不同
     * 嵌套inline情况十分复杂，尾部mpb空白可能产生叠加情况，因此endSpace表示自身，
     * 然后根据是否在最后一个元素进行叠加父元素的，多层嵌套则多层尾部叠加，均以最后一个元素为依据判断
     * Text获取这个叠加的endSpace值即可，无需感知是否最后一个，外层（此处）进行逻辑封装
     * @param data
     * @param isVirtual
     * @param isInline
     * @private
     */

  }, {
    key: "__layoutInline",
    value: function __layoutInline(data, isVirtual, isInline) {
      var flowChildren = this.flowChildren,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle;

      var _this$__preLayout3 = this.__preLayout(data, isInline),
          fixedWidth = _this$__preLayout3.fixedWidth,
          fixedHeight = _this$__preLayout3.fixedHeight,
          x = _this$__preLayout3.x,
          y = _this$__preLayout3.y,
          w = _this$__preLayout3.w,
          h = _this$__preLayout3.h,
          lx = _this$__preLayout3.lx,
          lineBoxManager = _this$__preLayout3.lineBoxManager,
          nowrap = _this$__preLayout3.nowrap,
          endSpace = _this$__preLayout3.endSpace,
          selfEndSpace = _this$__preLayout3.selfEndSpace; // abs虚拟布局需预知width，固定可提前返回


      if (fixedWidth && isVirtual) {
        this.__width = w;

        this.__ioSize(w, this.height);

        return;
      }

      var width = currentStyle[WIDTH$3];
      var textAlign = computedStyle[TEXT_ALIGN],
          whiteSpace = computedStyle[WHITE_SPACE],
          lineClamp = computedStyle[LINE_CLAMP],
          lineHeight = computedStyle[LINE_HEIGHT],
          marginLeft = computedStyle[MARGIN_LEFT$3],
          marginRight = computedStyle[MARGIN_RIGHT$2],
          borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3],
          borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$2],
          paddingLeft = computedStyle[PADDING_LEFT$3],
          paddingRight = computedStyle[PADDING_RIGHT$2];
      var lineClampCount = data.lineClampCount || 0;

      if (isInline && !this.__isRealInline()) {
        isInline = false;
      } // 只有inline的孩子需要考虑换行后从行首开始，而ib不需要，因此重置行首标识lx为x，末尾空白为0
      // 而inline的LineBoxManager复用最近非inline父dom的，ib需要重新生成，末尾空白叠加


      if (isInline) {
        this.__config[NODE_IS_INLINE] = true;
        this.__lineBoxManager = lineBoxManager;
        var baseLine = css.getBaseLine(computedStyle); // 特殊inline调用，有内容的话（如左右mbp），默认生成一个lineBox，即便是空，也要形成占位，只有开头时需要

        if (marginLeft || marginRight || paddingLeft || paddingRight || borderLeftWidth || borderRightWidth) {
          if (lineBoxManager.isNewLine) {
            lineBoxManager.genLineBoxByInlineIfNewLine(x, y, lineHeight, baseLine);
          } else {
            lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseLine);
          }
        } else {
          lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseLine);
        }

        lineClamp = data.lineClamp || 0;
      } else {
        lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, css.getBaseLine(computedStyle));
        lx = x;
        endSpace = selfEndSpace = lineClampCount = 0;
      } // 存LineBox里的内容列表专用，布局过程中由lineBoxManager存入，递归情况每个inline节点都保存contentBox

      if (isInline) {
        this.__contentBoxList = [];
        lineBoxManager.pushContentBoxList(this);
      }

      var isIbFull = false; // ib时不限定w情况下发生折行则撑满行，即便内容没有撑满边界

      var length = flowChildren.length;
      flowChildren.forEach(function (item, i) {
        var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;
        var isInline2 = isXom && item.currentStyle[DISPLAY$4] === 'inline';
        var isInlineBlock2 = isXom && ['inlineBlock', 'inline-block'].indexOf(item.currentStyle[DISPLAY$4]) > -1;

        var isRealInline = isXom && item.__isRealInline(); // 最后一个元素会产生最后一行，叠加父元素的尾部mpb


        var isEnd = isInline && i === length - 1;

        if (isEnd) {
          endSpace += selfEndSpace;
        }

        if (isXom) {
          if (!isInline2 && !isInlineBlock2) {
            item.currentStyle[DISPLAY$4] = item.computedStyle[DISPLAY$4] = 'inlineBlock';
            isInlineBlock2 = true;
            inject.warn('Inline can not contain block/flex');
          } // x开头，不用考虑是否放得下直接放，i为0强制不换行


          if (x === lx || !i || isInline2 && whiteSpace === 'nowrap') {
            lineClampCount = item.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lx: lx,
              lineBoxManager: lineBoxManager,
              endSpace: endSpace,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount
            }, isVirtual); // inlineBlock的特殊之处，一旦w为auto且内部产生折行时，整个变成block独占一块区域，坐标计算和block一样

            if (item.__isIbFull) {
              isInlineBlock2 && w[1] === AUTO$2 && (isIbFull = true);
              lineBoxManager.addItem(item);
              x = lx;
              y += item.outerHeight;
              lineBoxManager.setNotEnd();
            } // inline和不折行的ib，其中ib需要手动存入当前lb中，以计算宽度
            else {
              (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY;
            }
          } else {
            // 不换行继续排，换行非开头先尝试是否放得下，结尾要考虑mpb因此减去endSpace
            var fw = whiteSpace === 'nowrap' ? 0 : item.__tryLayInline(w - x + lx, w - (isEnd ? endSpace : 0)); // 放得下继续

            if (fw >= -1e-10) {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                nowrap: whiteSpace === 'nowrap',
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

              (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY;
            } // 放不下处理之前的lineBox，并重新开头
            else {
              isInline2 && lineClampCount++;
              x = lx;
              y = lineBoxManager.endY;
              lineBoxManager.setNewLine();
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual); // 重新开头的ib和上面开头处一样逻辑

              if (item.__isIbFull) {
                lineBoxManager.addItem(item);
                x = lx;
                y += item.outerHeight;
                lineBoxManager.setNotEnd();
              } // inline和不折行的ib，其中ib需要手动存入当前lb中
              else {
                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              }
            }
          }
        } // inline里的其它只有文本，可能开始紧跟着之前的x，也可能换行后从lx行头开始
        // 紧跟着x可能出现在前面有节点换行后第2行，此时不一定放得下，因此不能作为判断依据，开头仅有lx
        else {
          var n = lineBoxManager.size; // i为0时强制不换行

          if (x === lx || !i || whiteSpace === 'nowrap') {
            lineClampCount = item.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lx: lx,
              lineBoxManager: lineBoxManager,
              endSpace: endSpace,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount
            }, isVirtual);
            x = lineBoxManager.lastX;
            y = lineBoxManager.lastY; // ib情况发生折行，且非定宽

            if (!isInline && lineBoxManager.size - n > 1 && width[1] === AUTO$2) {
              isIbFull = true;
            }
          } else {
            // 非开头先尝试是否放得下，如果放得下再看是否end，加end且只有1个字时放不下要换行，否则可以放，换行由text内部做
            // 第一个Text且父元素声明了nowrap也强制不换行，非第一个则看本身whiteSpace声明
            var focusNoWrap = !i && nowrap || whiteSpace === 'nowrap';

            var _fw2 = focusNoWrap ? 0 : item.__tryLayInline(w + lx - x);

            if (!focusNoWrap && _fw2 >= 0 && isEnd && endSpace && item.content.length === 1) {
              var fw2 = _fw2 - endSpace;

              if (fw2 < 0) {
                _fw2 = fw2;
              }
            } // 放得下继续


            if (_fw2 >= -1e-10) {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // 这里ib放得下一定是要么没换行要么固定宽度，所以无需判断isIbFull
            } // 放不下处理之前的lineBox，并重新开头
            else {
              lineClampCount++;
              x = lx;
              y = lineBoxManager.endY;
              lineBoxManager.setNewLine();
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount
              }, isVirtual);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // ib情况发生折行

              if (!isInline && lineBoxManager.size - n > 1 && width[1] === AUTO$2) {
                isIbFull = true;
              }
            }
          }
        }
      }); // 同block结尾，不过这里一定是lineBox结束，无需判断

      y = lineBoxManager.endY; // 标识ib情况同block一样占满行

      this.__isIbFull = isIbFull; // 元素的width在固定情况或者ibFull情况已被计算出来，否则为最大延展尺寸，inline没有固定尺寸概念

      var tw, th;

      if (isInline) {
        // inline最后的x要算上右侧mpb，为next行元素提供x坐标基准，同时其尺寸计算比较特殊
        if (selfEndSpace) {
          lineBoxManager.addX(selfEndSpace);
        } // 如果没有内容，空白还要加上开头即左侧mpb


        if (!flowChildren.length) {
          var _marginLeft2 = computedStyle[MARGIN_LEFT$3],
              _paddingLeft2 = computedStyle[PADDING_LEFT$3],
              _borderLeftWidth2 = computedStyle[BORDER_LEFT_WIDTH$3];
          lineBoxManager.addX(_marginLeft2 + _paddingLeft2 + _borderLeftWidth2);
        } // 结束出栈contentBox，递归情况结束子inline获取contentBox，父inline继续


        lineBoxManager.popContentBoxList(); // abs非固定w时预计算，本来是最近非inline父层统一计算，但在abs时不算，

        if (isVirtual) {
          this.__inlineSize();
        }
      } else {
        // ib在满时很特殊，取最大值，可能w本身很小不足排下1个字符，此时要用maxW
        var maxW = lineBoxManager.__maxX - data.x;
        tw = this.__width = fixedWidth ? w : isIbFull ? Math.max(w, maxW) : maxW;
        th = this.__height = fixedHeight ? h : y - data.y;

        this.__ioSize(tw, th);
      } // 非abs提前虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐，inline会被父级调用这里只看ib


      if (!isVirtual && !isInline) {
        lineBoxManager.verticalAlign();

        if (['center', 'right'].indexOf(textAlign) > -1) {
          lineBoxManager.horizonAlign(tw, textAlign); // 直接text需计算size

          flowChildren.forEach(function (item) {
            if (item instanceof Component) {
              item = item.shadowRoot;
            }

            if (item instanceof Text) {
              item.__inlineSize();
            }
          });
        } // block的所有inline计算size


        lineBoxManager.domList.forEach(function (item) {
          item.__inlineSize(tw, textAlign);
        });
      } // inlineBlock新开上下文，但父级block遇到要处理换行


      return isInline ? lineClampCount : 0;
    }
    /**
     * inline的尺寸计算非常特殊，并非一个矩形区域，而是由字体行高结合节点下多个LineBox中的内容决定，
     * 且这个尺寸又并非真实LineBox中的内容直接合并计算而来，比如包含了个更大尺寸的ib却不会计入
     * 具体方法为遍历持有的LineBox下的内容，x取两侧极值，同时首尾要考虑mpb，y值取上下极值，同样首尾考虑mpb
     * 首尾行LineBox可能不是不是占满一行，比如前后都有同行inline的情况，非首尾行则肯定占满
     * 绘制内容（如背景色）的区域也很特殊，每行LineBox根据lineHeight对齐baseLine得来，并非LineBox全部
     * 当LineBox只有直属Text时如果font没有lineGap则等价于全部，如有则需减去
     * 另外其client/offset/outer的w/h尺寸计算也很特殊，皆因首尾x方向的mpb导致
     * @private
     */

  }, {
    key: "__inlineSize",
    value: function __inlineSize(tw, textAlign) {
      var contentBoxList = this.contentBoxList,
          computedStyle = this.computedStyle,
          __ox = this.__ox,
          __oy = this.__oy;
      var marginTop = computedStyle[MARGIN_TOP$3],
          marginRight = computedStyle[MARGIN_RIGHT$2],
          marginBottom = computedStyle[MARGIN_BOTTOM$3],
          marginLeft = computedStyle[MARGIN_LEFT$3],
          paddingTop = computedStyle[PADDING_TOP$3],
          paddingRight = computedStyle[PADDING_RIGHT$2],
          paddingBottom = computedStyle[PADDING_BOTTOM$3],
          paddingLeft = computedStyle[PADDING_LEFT$3],
          borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
          borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$2],
          borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$3],
          borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3],
          lineHeight = computedStyle[LINE_HEIGHT]; // x/clientX/offsetX/outerX

      var maxX, maxY, minX, minY, maxCX, maxCY, minCX, minCY, maxFX, maxFY, minFX, minFY, maxOX, maxOY, minOX, minOY;
      var length = contentBoxList.length;

      if (length) {
        // 遍历contentBox，里面存的是LineBox内容，根据父LineBox引用判断是否换行
        contentBoxList.forEach(function (item, i) {
          // 非第一个除了minY不用看其它都要，minX是换行导致，而maxX在最后一个要考虑右侧mpb，中间的无需考虑嵌套inline的mpb
          if (i) {
            minX = Math.min(minX, item.x);
            minCX = Math.min(minCX, item.x);
            minFX = Math.min(minFX, item.x);
            minOX = Math.min(minOX, item.x);

            if (i === length - 1) {
              maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
              maxY = maxCY = maxFY = maxOY = Math.max(maxY, item.y + item.outerHeight);
              maxCX += paddingRight;
              maxCY += paddingBottom;
              maxFX += paddingRight + borderRightWidth;
              maxFY += paddingBottom + borderBottomWidth;
              maxOX += borderRightWidth + paddingRight + marginRight;
              maxOY += borderBottomWidth + paddingBottom + marginBottom;
            } else {
              maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
            }
          } // 第一个初始化
          else {
            minX = item.x;
            minY = item.y;
            minCX = minX - paddingLeft;
            minCY = minY - paddingTop;
            minFX = minCX - borderLeftWidth;
            minFY = minCY - borderTopWidth;
            minOX = minFX - marginLeft;
            minOY = minFY - marginTop;
            maxX = maxCX = maxFX = maxOX = item.x + item.outerWidth;
            maxY = maxCY = maxFY = maxOY = item.y + item.outerHeight;

            if (i === length - 1) {
              maxCX += paddingRight;
              maxCY += paddingBottom;
              maxFX += paddingRight + borderRightWidth;
              maxFY += paddingBottom + borderBottomWidth;
              maxOX += borderRightWidth + paddingRight + marginRight;
              maxOY += borderBottomWidth + paddingBottom + marginBottom;
            }
          }
        });
        this.__x = minOX;
        this.__y = minOY;
        this.__width = computedStyle[WIDTH$3] = maxX - minX; // 防止比自己最小高度lineHeight还小，比如内容是个小字体

        this.__height = computedStyle[HEIGHT$3] = Math.max(lineHeight, maxY - minY);
        this.__clientWidth = maxCX - minCX;
        this.__clientHeight = maxCY - minCY;
        this.__offsetWidth = maxFX - minFX;
        this.__offsetHeight = maxFY - minFY;
        this.__outerWidth = maxOX - minOX;
        this.__outerHeight = maxOY - minOY;
        this.__sx = minOX + __ox;
        this.__sy = minOY + __oy;
        this.__sx1 = minFX + __ox;
        this.__sy1 = minFY + __oy;
        this.__sx2 = minCX + __ox;
        this.__sy2 = minCY + __oy;
        this.__sx3 = minX + __ox;
        this.__sy3 = minY + __oy;
        this.__sx4 = maxX + __ox;
        this.__sy4 = maxY + __oy;
        this.__sx5 = maxCX + __ox;
        this.__sy5 = maxCY + __oy;
        this.__sx6 = maxFX + __ox;
        this.__sy6 = maxFY + __oy; // inline的text整体设置相同

        if (['center', 'right'].indexOf(textAlign) > -1) {
          this.children.forEach(function (item) {
            if (item instanceof Text) {
              item.__inlineSize();
            }
          });
        }
      } // 如果没有内容，宽度为0高度为lineHeight，对齐也特殊处理，lineBoxManager不会处理
      else {
        if (['center', 'right'].indexOf(textAlign) > -1) {
          var diff = tw;

          if (textAlign === 'center') {
            diff *= 0.5;
          }

          if (diff) {
            this.__offsetX(diff, true);
          }
        }

        this.__width = computedStyle[WIDTH$3] = 0;
        var th = this.__height = computedStyle[HEIGHT$3] = lineHeight;

        this.__ioSize(0, th);

        this.__sy -= marginTop + paddingTop + borderTopWidth;
        this.__sx1 = this.sx + marginLeft;
        this.__sy1 = this.sy + marginTop;
        this.__sx2 = this.__sx1 + borderLeftWidth;
        this.__sy2 = this.__sy1 + borderTopWidth;
        this.__sx4 = this.__sx3 = this.__sx2 + paddingLeft;
        this.__sy4 = this.__sy3 = this.__sy2 + paddingTop;
        this.__sx5 = this.__sx4 + paddingRight;
        this.__sy5 = this.__sy4 + th + paddingBottom;
        this.__sx6 = this.__sx5 + borderRightWidth;
        this.__sy6 = this.__sy5 + borderBottomWidth;
        this.__clientWidth = this.__sx5 - this.__sx2;
        this.__clientHeight = this.__sy5 - this.__sy2;
        this.__offsetWidth = this.__sx6 - this.__sx1;
        this.__offsetHeight = this.__sy6 - this.__sy1;
        this.__outerWidth = this.__offsetWidth + marginLeft + marginRight;
        this.__outerHeight = this.__offsetHeight + marginTop + marginBottom;
      }
    }
    /**
     * 只针对绝对定位children布局
     * @param container
     * @param data
     * @param target 可选，只针对某个abs的child特定布局，在局部更新时用
     * @private
     */

  }, {
    key: "__layoutAbs",
    value: function __layoutAbs(container, data, target) {
      var _this4 = this;

      var x = container.sx,
          y = container.sy,
          clientWidth = container.clientWidth,
          clientHeight = container.clientHeight,
          computedStyle = container.computedStyle;
      var isDestroyed = this.isDestroyed,
          children = this.children,
          absChildren = this.absChildren;
      var display = computedStyle[DISPLAY$4],
          borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
          borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3],
          marginTop = computedStyle[MARGIN_TOP$3],
          marginLeft = computedStyle[MARGIN_LEFT$3],
          paddingLeft = computedStyle[PADDING_LEFT$3],
          paddingTop = computedStyle[PADDING_TOP$3];

      if (isDestroyed || display === 'none') {
        this.__layoutNone();

        return;
      }

      x += marginLeft + borderLeftWidth;
      y += marginTop + borderTopWidth; // 对absolute的元素进行相对容器布局

      absChildren.forEach(function (item) {
        if (target) {
          // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
          var node = item;

          if (node instanceof Component) {
            node = item.shadowRoot;
          } // 所以得2个都对比


          if (target !== node && target !== item) {
            return;
          }
        }

        var currentStyle = item.currentStyle,
            computedStyle = item.computedStyle;

        if (currentStyle[DISPLAY$4] === 'none') {
          item.__layoutNone();

          return;
        } // 先根据容器宽度计算margin/padding


        item.__mp(currentStyle, computedStyle, clientWidth);

        if (currentStyle[DISPLAY$4] !== 'block' && currentStyle[DISPLAY$4] !== 'flex') {
          currentStyle[DISPLAY$4] = computedStyle[DISPLAY$4] = 'block';
        }

        var left = currentStyle[LEFT$1],
            top = currentStyle[TOP$1],
            right = currentStyle[RIGHT$1],
            bottom = currentStyle[BOTTOM$1],
            width = currentStyle[WIDTH$3],
            height = currentStyle[HEIGHT$3],
            display = currentStyle[DISPLAY$4],
            flexDirection = currentStyle[FLEX_DIRECTION];
        var x2, y2, w2, h2;
        var onlyRight;
        var onlyBottom;
        var fixedTop;
        var fixedRight;
        var fixedBottom;
        var fixedLeft; // 判断何种方式的定位，比如左+宽度，左+右之类

        if (left[1] !== AUTO$2) {
          fixedLeft = true;
          computedStyle[LEFT$1] = calAbsolute(currentStyle, 'left', left, clientWidth, _this4.root);
        } else {
          computedStyle[LEFT$1] = 'auto';
        }

        if (right[1] !== AUTO$2) {
          fixedRight = true;
          computedStyle[RIGHT$1] = calAbsolute(currentStyle, 'right', right, clientWidth, _this4.root);
        } else {
          computedStyle[RIGHT$1] = 'auto';
        }

        if (top[1] !== AUTO$2) {
          fixedTop = true;
          computedStyle[TOP$1] = calAbsolute(currentStyle, 'top', top, clientHeight, _this4.root);
        } else {
          computedStyle[TOP$1] = 'auto';
        }

        if (bottom[1] !== AUTO$2) {
          fixedBottom = true;
          computedStyle[BOTTOM$1] = calAbsolute(currentStyle, 'bottom', bottom, clientHeight, _this4.root);
        } else {
          computedStyle[BOTTOM$1] = 'auto';
        } // 优先级最高left+right，其次left+width，再次right+width，再次仅申明单个，最次全部auto


        if (fixedLeft && fixedRight) {
          x2 = x + computedStyle[LEFT$1];
          w2 = x + clientWidth - computedStyle[RIGHT$1] - x2;
        } else if (fixedLeft) {
          x2 = x + computedStyle[LEFT$1];

          if (width[1] !== AUTO$2) {
            if (width[1] === PERCENT$3) {
              w2 = width[0] * clientWidth * 0.01;
            } else if (width[1] === REM$8) {
              w2 = width[0] * _this4.root.computedStyle[FONT_SIZE$8];
            } else if (width[1] === VW$8) {
              w2 = width[0] * _this4.root.width * 0.01;
            } else if (width[1] === VH$8) {
              w2 = width[0] * _this4.root.height * 0.01;
            } else {
              w2 = width[0];
            }
          }
        } else if (fixedRight) {
          if (width[1] !== AUTO$2) {
            if (width[1] === PERCENT$3) {
              w2 = width[0] * clientWidth * 0.01;
            } else if (width[1] === REM$8) {
              w2 = width[0] * _this4.root.computedStyle[FONT_SIZE$8];
            } else if (width[1] === VW$8) {
              w2 = width[0] * _this4.root.width * 0.01;
            } else if (width[1] === VH$8) {
              w2 = width[0] * _this4.root.height * 0.01;
            } else {
              w2 = width[0];
            }
          } else {
            onlyRight = true;
          }

          x2 = x + clientWidth - computedStyle[RIGHT$1] - (w2 || 0); // 右对齐有尺寸时还需减去margin/border/padding的

          x2 -= computedStyle[MARGIN_LEFT$3];
          x2 -= computedStyle[MARGIN_RIGHT$2];
          x2 -= computedStyle[PADDING_LEFT$3];
          x2 -= computedStyle[PADDING_RIGHT$2];
          x2 -= currentStyle[BORDER_LEFT_WIDTH$3][0];
          x2 -= currentStyle[BORDER_RIGHT_WIDTH$2][0];
        } else {
          x2 = x + paddingLeft;

          if (width[1] !== AUTO$2) {
            if (width[1] === PERCENT$3) {
              w2 = width[0] * clientWidth * 0.01;
            } else if (width[1] === REM$8) {
              w2 = width[0] * _this4.root.computedStyle[FONT_SIZE$8];
            } else if (width[1] === VW$8) {
              w2 = width[0] * _this4.root.width * 0.01;
            } else if (width[1] === VH$8) {
              w2 = width[0] * _this4.root.height * 0.01;
            } else {
              w2 = width[0];
            }
          }
        } // top/bottom/height优先级同上


        if (fixedTop && fixedBottom) {
          y2 = y + computedStyle[TOP$1];
          h2 = y + clientHeight - computedStyle[BOTTOM$1] - y2;
        } else if (fixedTop) {
          y2 = y + computedStyle[TOP$1];

          if (height[1] !== AUTO$2) {
            if (height[1] === PERCENT$3) {
              h2 = height[0] * clientHeight * 0.01;
            } else if (height[1] === REM$8) {
              h2 = height[0] * _this4.root.computedStyle[FONT_SIZE$8];
            } else if (height[1] === VW$8) {
              h2 = height[0] * _this4.root.width * 0.01;
            } else if (height[1] === VH$8) {
              h2 = height[0] * _this4.root.height * 0.01;
            } else {
              h2 = height[0];
            }
          }
        } else if (fixedBottom) {
          if (height[1] !== AUTO$2) {
            if (height[1] === PERCENT$3) {
              h2 = height[0] * clientHeight * 0.01;
            } else if (height[1] === REM$8) {
              h2 = height[0] * _this4.root.computedStyle[FONT_SIZE$8];
            } else if (height[1] === VW$8) {
              h2 = height[0] * _this4.root.width * 0.01;
            } else if (height[1] === VH$8) {
              h2 = height[0] * _this4.root.height * 0.01;
            } else {
              h2 = height[0];
            }
          } else {
            onlyBottom = true;
          }

          y2 = y + clientHeight - computedStyle[BOTTOM$1] - (h2 || 0); // 底对齐有尺寸时y值还需减去margin/border/padding的

          y2 -= computedStyle[MARGIN_TOP$3];
          y2 -= computedStyle[MARGIN_BOTTOM$3];
          y2 -= computedStyle[PADDING_TOP$3];
          y2 -= computedStyle[PADDING_BOTTOM$3];
          y2 -= currentStyle[BORDER_TOP_WIDTH$3][0];
          y2 -= currentStyle[BORDER_BOTTOM_WIDTH$3][0];
        } // 未声明y的找到之前的流布局child，紧随其下
        else {
          y2 = y + paddingTop;
          var prev = item.prev;

          while (prev) {
            // 目前不考虑margin合并，直接以前面的flow的最近的prev末尾为准
            if (prev instanceof Text || prev.computedStyle[POSITION$2] !== 'absolute') {
              y2 = prev.y + prev.outerHeight;
              break;
            }

            prev = prev.prev;
          }

          if (height[1] === PERCENT$3) {
            h2 = height[0] * clientHeight * 0.01;
          } else if (height[1] === REM$8) {
            h2 = height[0] * _this4.root.computedStyle[FONT_SIZE$8];
          } else if (height[1] === VW$8) {
            h2 = height[0] * _this4.root.width * 0.01;
          } else if (height[1] === VH$8) {
            h2 = height[0] * _this4.root.height * 0.01;
          } else if (height[1] === PX$3) {
            h2 = height[0];
          }
        } // 没设宽高，需手动计算获取最大宽高后，赋给样式再布局


        var needCalWidth;

        if ((display === 'block' || ['inlineBlock', 'inline-block'].indexOf(display) > -1) && w2 === undefined) {
          needCalWidth = true;
        } else if (display === 'flex') {
          if (w2 === undefined) {
            needCalWidth = true;
          } else if (flexDirection === 'column' && h2 === undefined) {
            needCalWidth = true;
          }
        } // onlyRight时做的布局其实是以那个点位为left/top布局然后offset，limit要特殊计算，从本点向左侧为边界


        var wl = onlyRight ? x2 - x : clientWidth + x - x2; // onlyBottom相同，正常情况是左上到右下的尺寸限制

        var hl = onlyBottom ? y2 - y : clientHeight + y - y2; // 未直接或间接定义尺寸，取孩子宽度最大值

        if (needCalWidth) {
          item.__layout({
            x: x2,
            y: y2,
            w: wl,
            h: hl
          }, true, true);

          wl = item.outerWidth;
        } // needCalWidth传入，因为自适应尺寸上面已经计算过一次margin/padding了


        item.__layout({
          x: x2,
          y: y2,
          w: wl,
          h: hl,
          w2: w2,
          // left+right这种等于有宽度，但不能修改style，继续传入到__preLayout中特殊对待
          h2: h2
        }, false, true);

        if (onlyRight) {
          item.__offsetX(-item.outerWidth, true);
        }

        if (onlyBottom) {
          item.__offsetY(-item.outerHeight, true);
        }
      }); // 递归进行，遇到absolute/relative/component的设置新容器

      children.forEach(function (item) {
        if (target) {
          // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
          var node = item;

          if (node instanceof Component) {
            node = item.shadowRoot;
          } // 所以得2个都对比


          if (target !== node && target !== item) {
            return;
          }
        }

        if (item instanceof Dom) {
          item.__layoutAbs(isRelativeOrAbsolute$1(item) ? item : container, data);
        } else if (item instanceof Component) {
          var sr = item.shadowRoot;

          if (sr instanceof Dom) {
            sr.__layoutAbs(sr, data);
          }
        }
      });

      this.__execAr();
    }
    /**
     * 布局前检查继承的样式以及统计字体测量信息
     * 首次检查为整树遍历，后续检查是节点自发局部检查，不再进入
     * @param renderMode
     * @param ctx
     * @param cb
     * @private
     */

  }, {
    key: "__computeMeasure",
    value: function __computeMeasure(renderMode, ctx, cb) {
      _get(_getPrototypeOf(Dom.prototype), "__computeMeasure", this).call(this, renderMode, ctx, cb); // 即便自己不需要计算，但children还要继续递归检查


      this.children.forEach(function (item) {
        item.__computeMeasure(renderMode, ctx, cb);
      });
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Dom.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (renderMode === mode.SVG) {
        this.virtualDom.type = 'dom';
      }

      return res;
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      if (this.isDestroyed) {
        return;
      }

      this.children.forEach(function (child) {
        // 有可能为空，因为diff过程中相同的cp被移到新的vd中，老的防止destroy设null
        if (child) {
          child.__destroy();
        }
      });

      _get(_getPrototypeOf(Dom.prototype), "__destroy", this).call(this);
    }
  }, {
    key: "__emitEvent",
    value: function __emitEvent(e, force) {
      if (force) {
        return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, force);
      }

      var isDestroyed = this.isDestroyed,
          computedStyle = this.computedStyle,
          isMask = this.isMask;

      if (isDestroyed || computedStyle[DISPLAY$4] === 'none' || e.__stopPropagation || isMask) {
        return;
      } // 检查perspective嵌套状态，自身有perspective则设置10位，自身有transform的p矩阵则设置01位
      // if(computedStyle[PERSPECTIVE]) {
      //   perspectiveNest++;
      // }
      // if(tf.isPerspectiveMatrix(computedStyle[TRANSFORM])) {
      //   perspectiveTfNest++;
      // }
      // overflow:hidden时还需要判断是否超出范围外，如果是则无效


      if (computedStyle[OVERFLOW$1] === 'hidden' && !this.willResponseEvent(e, true)) {
        return;
      } // 找到对应的callback


      var type = e.event.type;
      var listener = this.listener,
          zIndexChildren = this.zIndexChildren;
      var cb;

      if (listener.hasOwnProperty(type)) {
        cb = listener[type];
      } // child触发则parent一定触发


      for (var i = zIndexChildren.length - 1; i >= 0; i--) {
        var child = zIndexChildren[i];

        if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
          if (child.__emitEvent(e)) {
            // 孩子阻止冒泡
            if (e.__stopPropagation) {
              return;
            }

            if (util.isFunction(cb) && !e.__stopImmediatePropagation) {
              cb.call(this, e);
            }

            return true;
          }
        }
      } // child不触发再看自己


      return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e);
    } // 深度遍历执行所有子节点，包含自己，如果cb返回true，提前跳出不继续深度遍历

  }, {
    key: "__deepScan",
    value: function __deepScan(cb, options) {
      if (_get(_getPrototypeOf(Dom.prototype), "__deepScan", this).call(this, cb, options)) {
        return;
      }

      this.children.forEach(function (node) {
        node.__deepScan(cb, options);
      });
    }
  }, {
    key: "appendChild",
    value: function appendChild(json, cb) {
      var self = this;

      if (!util.isNil(json) && !self.isDestroyed) {
        var root = self.root,
            host = self.host;

        if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
          if (json.vd) {
            root.delRefreshTask(json.vd.__task);
            json.vd.remove();
          }

          var vd;

          if ($$type.TYPE_CP === json.$$type) {
            vd = builder.initCp2(json, root, host, self);
          } else {
            vd = builder.initDom(json, root, host, self);
          }

          root.addRefreshTask(vd.__task = {
            __before: function __before() {
              vd.__task = null; // 清除在before，防止after的回调增加新的task误删

              self.__json.children.push(json);

              var len = self.children.length;

              if (len) {
                var last = self.children[len - 1];
                last.__next = vd;
                vd.__prev = last;
              }

              self.children.push(vd);
              self.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

              var res = {};
              res[UPDATE_NODE$2] = vd;
              res[UPDATE_FOCUS$2] = o$1.REFLOW;
              res[UPDATE_ADD_DOM$1] = true;
              res[UPDATE_MEASURE$1] = true;
              res[UPDATE_CONFIG$2] = vd.__config;

              root.__addUpdate(vd, vd.__config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (util.isFunction(cb)) {
                cb.call(vd, diff);
              }
            }
          });
        } else {
          throw new Error('Invalid parameter in appendChild.');
        }
      }
    }
  }, {
    key: "prependChild",
    value: function prependChild(json, cb) {
      var self = this;

      if (!util.isNil(json) && !self.isDestroyed) {
        var root = self.root,
            host = self.host;

        if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
          if (json.vd) {
            root.delRefreshTask(json.vd.__task);
            json.vd.remove();
          }

          var vd;

          if ($$type.TYPE_CP === json.$$type) {
            vd = builder.initCp2(json, root, host, self);
          } else {
            vd = builder.initDom(json, root, host, self);
          }

          root.addRefreshTask(vd.__task = {
            __before: function __before() {
              vd.__task = null;

              self.__json.children.unshift(json);

              var len = self.children.length;

              if (len) {
                var first = self.children[0];
                first.__prev = vd;
                vd.__next = first;
              }

              self.children.unshift(vd);
              self.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

              var res = {};
              res[UPDATE_NODE$2] = vd;
              res[UPDATE_FOCUS$2] = o$1.REFLOW;
              res[UPDATE_ADD_DOM$1] = true;
              res[UPDATE_MEASURE$1] = true;
              res[UPDATE_CONFIG$2] = vd.__config;

              root.__addUpdate(vd, vd.__config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (util.isFunction(cb)) {
                cb.call(vd, diff);
              }
            }
          });
        } else {
          throw new Error('Invalid parameter in prependChild.');
        }
      }
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(json, cb) {
      var self = this;

      if (!util.isNil(json) && !self.isDestroyed && self.domParent) {
        var root = self.root,
            domParent = self.domParent;
        var host = domParent.hostRoot;

        if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
          if (json.vd) {
            root.delRefreshTask(json.vd.__task);
            json.vd.remove();
          }

          var vd;

          if ($$type.TYPE_CP === json.$$type) {
            vd = builder.initCp2(json, root, host, domParent);
          } else {
            vd = builder.initDom(json, root, host, domParent);
          }

          root.addRefreshTask(vd.__task = {
            __before: function __before() {
              vd.__task = null;
              var i = 0,
                  has,
                  __json = domParent.__json,
                  children = __json.children,
                  len = children.length;
              var pJson = self.isShadowRoot ? self.hostRoot.__json : self.__json;

              for (; i < len; i++) {
                if (children[i] === pJson) {
                  has = true;
                  break;
                }
              }

              if (!has) {
                throw new Error('InsertBefore exception.');
              } // 插入注意开头位置处理


              if (i) {
                children.splice(i, 0, json);
                vd.__next = self;
                vd.__prev = self.__prev;
                self.__prev = vd;
                domParent.children.splice(i, 0, vd);
              } else {
                if (len) {
                  var first = domParent.children[0];
                  first.__prev = vd;
                  vd.__next = first;
                }

                children.unshift(json);
                domParent.children.unshift(vd);
              }

              domParent.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

              var res = {};
              res[UPDATE_NODE$2] = vd;
              res[UPDATE_FOCUS$2] = o$1.REFLOW;
              res[UPDATE_ADD_DOM$1] = true;
              res[UPDATE_MEASURE$1] = true;
              res[UPDATE_CONFIG$2] = vd.__config;

              root.__addUpdate(vd, vd.__config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (util.isFunction(cb)) {
                cb.call(vd, diff);
              }
            }
          });
        } else {
          throw new Error('Invalid parameter in insertBefore.');
        }
      }
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(json, cb) {
      var self = this;

      if (!util.isNil(json) && !self.isDestroyed && self.domParent) {
        var root = self.root,
            domParent = self.domParent;
        var host = domParent.hostRoot;

        if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
          if (json.vd) {
            root.delRefreshTask(json.vd.__task);
            json.vd.remove();
          }

          var vd;

          if ($$type.TYPE_CP === json.$$type) {
            vd = builder.initCp2(json, root, host, domParent);
          } else {
            vd = builder.initDom(json, root, host, domParent);
          }

          root.addRefreshTask(vd.__task = {
            __before: function __before() {
              vd.__task = null;
              var i = 0,
                  has,
                  __json = domParent.__json,
                  children = __json.children,
                  len = children.length;
              var pJson = self.isShadowRoot ? self.hostRoot.__json : self.__json;

              for (; i < len; i++) {
                if (children[i] === pJson) {
                  has = true;
                  break;
                }
              }

              if (!has) {
                throw new Error('insertAfter exception.');
              } // 插入注意末尾位置处理


              if (i < len - 1) {
                children.splice(i + 1, 0, json);
                vd.__prev = self;
                vd.__next = self.__next;
                self.__next = vd;
                domParent.children.splice(i + 1, 0, vd);
              } else {
                if (len) {
                  var last = domParent.children[len - 1];
                  last.__next = vd;
                  vd.__prev = last;
                }

                children.push(json);
                domParent.children.push(vd);
              }

              domParent.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

              var res = {};
              res[UPDATE_NODE$2] = vd;
              res[UPDATE_FOCUS$2] = o$1.REFLOW;
              res[UPDATE_ADD_DOM$1] = true;
              res[UPDATE_MEASURE$1] = true;
              res[UPDATE_CONFIG$2] = vd.__config;

              root.__addUpdate(vd, vd.__config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (util.isFunction(cb)) {
                cb.call(vd, diff);
              }
            }
          });
        } else {
          throw new Error('Invalid parameter in insertAfter.');
        }
      }
    }
  }, {
    key: "removeChild",
    value: function removeChild(target, cb) {
      if (target.parent === this && (target instanceof Xom || target instanceof Component)) {
        if (this.isDestroyed) {
          inject.warn('Remove parent is destroyed.');

          if (util.isFunction(cb)) {
            cb();
          }

          return;
        }

        target.remove(cb);
      } else {
        throw new Error('Invalid parameter in removeChild.');
      }
    }
  }, {
    key: "children",
    get: function get() {
      return this.__children;
    }
  }, {
    key: "flowChildren",
    get: function get() {
      return this.children.filter(function (item) {
        if (item instanceof Component) {
          item = item.shadowRoot;
        }

        return item instanceof Text || item.currentStyle[POSITION$2] !== 'absolute';
      });
    }
  }, {
    key: "absChildren",
    get: function get() {
      return this.children.filter(function (item) {
        if (item instanceof Component) {
          item = item.shadowRoot;
        }

        return item instanceof Xom && item.currentStyle[POSITION$2] === 'absolute';
      });
    }
  }, {
    key: "zIndexChildren",
    get: function get() {
      return this.__zIndexChildren;
    }
  }, {
    key: "lineBoxManager",
    get: function get() {
      return this.__lineBoxManager;
    }
  }, {
    key: "baseLine",
    get: function get() {
      if (!this.lineBoxManager || !this.lineBoxManager.size) {
        return this.offsetHeight;
      }

      var _this$computedStyle = this.computedStyle,
          marginTop = _this$computedStyle[MARGIN_TOP$3],
          borderTopWidth = _this$computedStyle[BORDER_TOP_WIDTH$3],
          paddingTop = _this$computedStyle[PADDING_TOP$3];
      return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.baseLine;
    }
  }, {
    key: "firstBaseLine",
    get: function get() {
      if (!this.lineBoxManager || !this.lineBoxManager.size) {
        return this.offsetHeight;
      }

      var _this$computedStyle2 = this.computedStyle,
          marginTop = _this$computedStyle2[MARGIN_TOP$3],
          borderTopWidth = _this$computedStyle2[BORDER_TOP_WIDTH$3],
          paddingTop = _this$computedStyle2[PADDING_TOP$3];
      return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.firstBaseLine;
    }
  }, {
    key: "parentLineBox",
    get: function get() {
      return this.__parentLineBox;
    }
  }]);

  return Dom;
}(Xom);

var _enums$STYLE_KEY$9 = enums.STYLE_KEY,
    WIDTH$2 = _enums$STYLE_KEY$9.WIDTH,
    HEIGHT$2 = _enums$STYLE_KEY$9.HEIGHT,
    DISPLAY$3 = _enums$STYLE_KEY$9.DISPLAY,
    BORDER_TOP_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_TOP_WIDTH,
    BORDER_RIGHT_WIDTH$1 = _enums$STYLE_KEY$9.BORDER_RIGHT_WIDTH,
    BORDER_LEFT_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_LEFT_WIDTH,
    BORDER_BOTTOM_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_BOTTOM_WIDTH,
    BORDER_TOP_LEFT_RADIUS = _enums$STYLE_KEY$9.BORDER_TOP_LEFT_RADIUS,
    BORDER_TOP_RIGHT_RADIUS = _enums$STYLE_KEY$9.BORDER_TOP_RIGHT_RADIUS,
    BORDER_BOTTOM_RIGHT_RADIUS = _enums$STYLE_KEY$9.BORDER_BOTTOM_RIGHT_RADIUS,
    BORDER_BOTTOM_LEFT_RADIUS = _enums$STYLE_KEY$9.BORDER_BOTTOM_LEFT_RADIUS,
    VISIBILITY$3 = _enums$STYLE_KEY$9.VISIBILITY,
    BACKGROUND_IMAGE = _enums$STYLE_KEY$9.BACKGROUND_IMAGE,
    BACKGROUND_COLOR = _enums$STYLE_KEY$9.BACKGROUND_COLOR,
    BOX_SHADOW$6 = _enums$STYLE_KEY$9.BOX_SHADOW,
    MIX_BLEND_MODE$2 = _enums$STYLE_KEY$9.MIX_BLEND_MODE,
    MARGIN_TOP$2 = _enums$STYLE_KEY$9.MARGIN_TOP,
    MARGIN_RIGHT$1 = _enums$STYLE_KEY$9.MARGIN_RIGHT,
    MARGIN_BOTTOM$2 = _enums$STYLE_KEY$9.MARGIN_BOTTOM,
    MARGIN_LEFT$2 = _enums$STYLE_KEY$9.MARGIN_LEFT,
    PADDING_TOP$2 = _enums$STYLE_KEY$9.PADDING_TOP,
    PADDING_RIGHT$1 = _enums$STYLE_KEY$9.PADDING_RIGHT,
    PADDING_BOTTOM$2 = _enums$STYLE_KEY$9.PADDING_BOTTOM,
    PADDING_LEFT$2 = _enums$STYLE_KEY$9.PADDING_LEFT,
    FONT_SIZE$7 = _enums$STYLE_KEY$9.FONT_SIZE,
    FLEX_BASIS$1 = _enums$STYLE_KEY$9.FLEX_BASIS,
    _enums$UPDATE_KEY$1 = enums.UPDATE_KEY,
    UPDATE_NODE$1 = _enums$UPDATE_KEY$1.UPDATE_NODE,
    UPDATE_FOCUS$1 = _enums$UPDATE_KEY$1.UPDATE_FOCUS,
    UPDATE_CONFIG$1 = _enums$UPDATE_KEY$1.UPDATE_CONFIG,
    _enums$NODE_KEY$4 = enums.NODE_KEY,
    NODE_CACHE$2 = _enums$NODE_KEY$4.NODE_CACHE,
    NODE_DEFS_CACHE$2 = _enums$NODE_KEY$4.NODE_DEFS_CACHE,
    NODE_IS_MASK$2 = _enums$NODE_KEY$4.NODE_IS_MASK;
var AUTO$1 = o$4.AUTO,
    PX$2 = o$4.PX,
    PERCENT$2 = o$4.PERCENT,
    REM$7 = o$4.REM,
    VW$7 = o$4.VW,
    VH$7 = o$4.VH,
    RGBA = o$4.RGBA;
var canvasPolygon$2 = painter.canvasPolygon,
    svgPolygon$1 = painter.svgPolygon;
var isFunction$3 = util.isFunction;

var Img = /*#__PURE__*/function (_Dom) {
  _inherits(Img, _Dom);

  var _super = _createSuper(Img);

  function Img(tagName, props) {
    var _this;

    _classCallCheck(this, Img);

    _this = _super.call(this, tagName, props);
    var src = _this.props.src;
    var loadImg = _this.__loadImg = {
      src: src
    }; // 空url用错误图代替

    if (!src) {
      loadImg.error = true;
    }

    var config = _this.__config;

    if (config[NODE_IS_MASK$2]) {
      var _assertThisInitialize = _assertThisInitialized(_this),
          style = _assertThisInitialize.style,
          currentStyle = _assertThisInitialize.currentStyle;

      style[BACKGROUND_IMAGE] = currentStyle[BACKGROUND_IMAGE] = [null];
      style[BACKGROUND_COLOR] = currentStyle[BACKGROUND_COLOR] = [[0, 0, 0, 0], RGBA];
      style[BORDER_TOP_WIDTH$2] = currentStyle[BORDER_TOP_WIDTH$2] = [0, PX$2];
      style[BORDER_RIGHT_WIDTH$1] = currentStyle[BORDER_RIGHT_WIDTH$1] = [0, PX$2];
      style[BORDER_LEFT_WIDTH$2] = currentStyle[BORDER_LEFT_WIDTH$2] = [0, PX$2];
      style[BORDER_BOTTOM_WIDTH$2] = currentStyle[BORDER_BOTTOM_WIDTH$2] = [0, PX$2];
      style[BOX_SHADOW$6] = currentStyle[BOX_SHADOW$6] = null;
      style[MIX_BLEND_MODE$2] = currentStyle[MIX_BLEND_MODE$2] = 'normal';
    }

    return _this;
  }
  /**
   * 覆盖xom的方法，在__layout3个分支中会首先被调用
   * 当样式中固定宽高时，图片按样式尺寸，加载后重新绘制即可
   * 只固定宽高一个时，加载完要计算缩放比，重新布局绘制
   * 都没有固定，按照图片尺寸，重新布局绘制
   * 这里计算非固定的情况，将其改为固定供布局渲染使用，未加载完成为0
   * @param data
   * @returns {{fixedWidth: boolean, w: *, x: *, h: *, y: *, fixedHeight: boolean}}
   * @private
   */


  _createClass(Img, [{
    key: "__preLayout",
    value: function __preLayout(data) {
      var res = _get(_getPrototypeOf(Img.prototype), "__preLayout", this).call(this, data);

      var loadImg = this.__loadImg; // 可能已提前加载好了，或有缓存，为减少刷新直接使用

      if (!loadImg.error) {
        var src = loadImg.src;
        var cache = inject.IMG[src];

        if (cache && cache.state === inject.LOADED) {
          loadImg.source = cache.source;
          loadImg.width = cache.width;
          loadImg.height = cache.height;
        }

        loadImg.cache = false;
      }

      if (res.fixedWidth && res.fixedHeight) {
        return res;
      }

      if (loadImg.error && !this.props.placeholder) {
        if (res.fixedWidth) {
          res.h = res.w;
        } else if (res.fixedHeight) {
          res.w = res.h;
        } else {
          res.w = res.h = 32;
        }
      } else if (loadImg.source) {
        if (res.fixedWidth) {
          res.h = res.w * loadImg.height / loadImg.width;
        } else if (res.fixedHeight) {
          res.w = res.h * loadImg.width / loadImg.height;
        } else {
          res.w = loadImg.width;
          res.h = loadImg.height;
        }
      } else {
        res.w = res.h = 0;
      }

      res.fixedWidth = true;
      res.fixedHeight = true;
      return res;
    }
  }, {
    key: "__addGeom",
    value: function __addGeom(tagName, props) {
      props = util.hash2arr(props);
      this.virtualDom.children.push({
        type: 'item',
        tagName: tagName,
        props: props
      });
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      this.root.delRefreshTask(this.__task);

      _get(_getPrototypeOf(Img.prototype), "__destroy", this).call(this);

      this.__task = null;
    } // img根据加载情况更新__hasContent

  }, {
    key: "__calContent",
    value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
      var res = _get(_getPrototypeOf(Img.prototype), "__calContent", this).call(this, renderMode, lv, currentStyle, computedStyle);

      if (!res) {
        var loadImg = this.__loadImg;

        if (computedStyle[VISIBILITY$3] !== 'hidden' && (computedStyle[WIDTH$2] || computedStyle[HEIGHT$2]) && loadImg.source) {
          res = true;
        }
      }

      return res;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Img.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      var offscreenBlend = res.offscreenBlend,
          offscreenMask = res.offscreenMask,
          offscreenFilter = res.offscreenFilter,
          offscreenOverflow = res.offscreenOverflow;
      var width = this.width,
          height = this.height,
          isDestroyed = this.isDestroyed,
          placeholder = this.props.placeholder,
          computedStyle = this.computedStyle,
          _this$computedStyle = this.computedStyle,
          display = _this$computedStyle[DISPLAY$3],
          borderTopLeftRadius = _this$computedStyle[BORDER_TOP_LEFT_RADIUS],
          borderTopRightRadius = _this$computedStyle[BORDER_TOP_RIGHT_RADIUS],
          borderBottomRightRadius = _this$computedStyle[BORDER_BOTTOM_RIGHT_RADIUS],
          borderBottomLeftRadius = _this$computedStyle[BORDER_BOTTOM_LEFT_RADIUS],
          visibility = _this$computedStyle[VISIBILITY$3],
          virtualDom = this.virtualDom,
          __config = this.__config,
          loadImg = this.__loadImg,
          root = this.root;

      if (offscreenBlend) {
        ctx = offscreenBlend.target.ctx;
      }

      if (offscreenMask) {
        ctx = offscreenMask.target.ctx;
      }

      if (offscreenFilter) {
        ctx = offscreenFilter.target.ctx;
      }

      if (offscreenOverflow) {
        ctx = offscreenOverflow.target.ctx;
      } // 没source且不error时加载图片


      if (!loadImg.source && !loadImg.error && !loadImg.loading) {
        this.__loadAndRefresh(loadImg, root, ctx, placeholder, computedStyle, width, height);
      }

      if (isDestroyed || display === 'none' || visibility === 'hidden') {
        return res;
      }

      var __cache = __config[NODE_CACHE$2];

      if (cache && __cache && __cache.enabled) {
        ctx = __cache.ctx;
      }

      var originX, originY;
      originX = res.x3;
      originY = res.y3; // 根据配置以及占位图显示error

      var source = loadImg.source;

      if (loadImg.error && !placeholder && Img.showError) {
        var strokeWidth = Math.min(width, height) * 0.02;
        var stroke = '#CCC';
        var fill = '#DDD';
        var cx = originX + width * 0.7;
        var cy = originY + height * 0.3;
        var r = strokeWidth * 5;
        var pts = [[originX + width * 0.15, originY + height * 0.7], [originX + width * 0.3, originY + height * 0.4], [originX + width * 0.5, originY + height * 0.6], [originX + width * 0.6, originY + height * 0.5], [originX + width * 0.9, originY + height * 0.8], [originX + width * 0.15, originY + height * 0.8]];

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          ctx.strokeStyle = stroke;
          ctx.lineWidth = strokeWidth;
          ctx.fillStyle = fill;
          ctx.beginPath();
          ctx.moveTo(originX, originY);
          ctx.lineTo(originX + width, originY);
          ctx.lineTo(originX + width, originY + height);
          ctx.lineTo(originX, originY + height);
          ctx.lineTo(originX, originY);
          ctx.stroke();
          ctx.closePath();
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, 2 * Math.PI);
          ctx.fill();
          ctx.closePath();
          ctx.beginPath();
          ctx.moveTo(pts[0][0], pts[0][1]);

          for (var i = 1, len = pts.length; i < len; i++) {
            var point = pts[i];
            ctx.lineTo(point[0], point[1]);
          }

          ctx.lineTo(pts[0][0], pts[0][1]);
          ctx.fill();
          ctx.closePath();
        } else if (renderMode === mode.SVG) {
          this.__addGeom('rect', [['x', originX], ['y', originY], ['width', width], ['height', height], ['stroke', stroke], ['stroke-width', strokeWidth], ['fill', 'rgba(0,0,0,0)']]);

          this.__addGeom('circle', [['cx', cx], ['cy', cy], ['r', r], ['fill', fill]]);

          var s = '';

          for (var _i = 0, _len = pts.length; _i < _len; _i++) {
            var _point = pts[_i];

            if (_i) {
              s += ' ';
            }

            s += _point[0] + ',' + _point[1];
          }

          this.__addGeom('polygon', [['points', s], ['fill', fill]]);
        }
      } else if (source) {
        // 圆角需要生成一个mask
        var list = border.calRadius(originX, originY, width, height, borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius);

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          // 有border-radius需模拟遮罩裁剪
          if (list) {
            ctx.save();
            ctx.beginPath();
            canvasPolygon$2(ctx, list);
            ctx.clip();
            ctx.closePath();
            ctx.drawImage(source, originX, originY, width, height);
            ctx.restore();
          } else {
            ctx.drawImage(source, originX, originY, width, height);
          }
        } else if (renderMode === mode.SVG) {
          // img没有变化无需diff，直接用上次的vd
          if (loadImg.cache) {
            loadImg.cache.cache = true;
            virtualDom.children = [loadImg.cache]; // 但是还是要校验是否有borderRadius变化，引发img的圆角遮罩

            if (!virtualDom.cache && list) {
              var d = svgPolygon$1(list);
              var v = {
                tagName: 'clipPath',
                props: [],
                children: [{
                  type: 'item',
                  tagName: 'path',
                  props: [['d', d], ['fill', '#FFF']]
                }]
              };
              var id = ctx.add(v);

              __config[NODE_DEFS_CACHE$2].push(v);

              virtualDom.conClip = 'url(#' + id + ')';
            }

            return;
          } // 缩放图片，无需考虑原先矩阵，xom里对父层<g>已经变换过了


          var matrix;

          if (width !== loadImg.width || height !== loadImg.height) {
            matrix = image.matrixResize(loadImg.width, loadImg.height, width, height, originX, originY, width, height);
          }

          var props = [['xlink:href', loadImg.error ? placeholder : loadImg.src], ['x', originX], ['y', originY], ['width', loadImg.width], ['height', loadImg.height]];

          if (list) {
            var _d = svgPolygon$1(list);

            var _v = {
              tagName: 'clipPath',
              props: [],
              children: [{
                type: 'item',
                tagName: 'path',
                props: [['d', _d], ['fill', '#FFF']]
              }]
            };

            var _id = ctx.add(_v);

            __config[NODE_DEFS_CACHE$2].push(_v);

            virtualDom.conClip = 'url(#' + _id + ')';
            delete virtualDom.cache;
          }

          if (matrix && !mx.isE(matrix)) {
            props.push(['transform', 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')']);
          }

          var vd = {
            type: 'img',
            tagName: 'image',
            props: props
          };
          virtualDom.children = [vd];
          loadImg.cache = vd;
        }
      }

      return res;
    } // img没加载时，清空，这样Xom就认为没内容不生成cache，防止img先绘制cache再绘制主屏，重复

  }, {
    key: "__releaseWhenEmpty",
    value: function __releaseWhenEmpty(__cache) {
      if (!this.__loadImg.error && !this.__loadImg.source) {
        return _get(_getPrototypeOf(Img.prototype), "__releaseWhenEmpty", this).call(this, __cache);
      }
    }
  }, {
    key: "__isRealInline",
    value: function __isRealInline() {
      return false;
    } // overwrite

  }, {
    key: "__tryLayInline",
    value: function __tryLayInline(w, total) {
      var _this$currentStyle = this.currentStyle,
          width = _this$currentStyle[WIDTH$2],
          height = _this$currentStyle[HEIGHT$2],
          marginLeft = _this$currentStyle[MARGIN_LEFT$2],
          marginRight = _this$currentStyle[MARGIN_RIGHT$1],
          paddingLeft = _this$currentStyle[PADDING_LEFT$2],
          paddingRight = _this$currentStyle[PADDING_RIGHT$1],
          borderLeftWidth = _this$currentStyle[BORDER_LEFT_WIDTH$2],
          borderRightWidth = _this$currentStyle[BORDER_RIGHT_WIDTH$1];

      if (width[1] === PX$2) {
        w -= width[0];
      } else if (width[1] === PERCENT$2) {
        w -= total * width[0] * 0.01;
      } else if (width[1] === REM$7) {
        w -= width[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (width[1] === VW$7) {
        w -= width[0] * this.root.width * 0.01;
      } else if (width[1] === VH$7) {
        w -= width[0] * this.root.height * 0.01;
      } else {
        var loadImg = this.__loadImg; // 加载成功计算缩放后的宽度

        if (loadImg.source) {
          if (height[1] === PX$2) {
            w -= loadImg.width * height[0] / loadImg.height;
          } else if (height[1] === PERCENT$2) {
            w -= loadImg.width * height[0] * total * 0.01 / loadImg.height;
          } else if (height[1] === REM$7) {
            w -= loadImg.width * height[0] * this.root.computedStyle[FONT_SIZE$7] / loadImg.height;
          } else if (height[1] === VW$7) {
            w -= loadImg.width * height[0] * this.root.width * 0.01 / loadImg.height;
          } else if (height[1] === VH$7) {
            w -= loadImg.width * height[0] * this.root.height * 0.01 / loadImg.height;
          } else {
            w -= loadImg.width;
          }
        }
      } // 减去水平mbp


      if (marginLeft[1] === PX$2) {
        w -= marginLeft[0];
      } else if (marginLeft[1] === PERCENT$2) {
        w -= marginLeft[0] * total * 0.01;
      } else if (marginLeft[1] === REM$7) {
        w -= marginLeft[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (marginLeft[1] === VW$7) {
        w -= marginLeft[0] * this.root.width * 0.01;
      } else if (marginLeft[1] === VH$7) {
        w -= marginLeft[0] * this.root.height * 0.01;
      }

      if (paddingLeft[1] === PX$2) {
        w -= paddingLeft[0];
      } else if (paddingLeft[1] === PERCENT$2) {
        w -= paddingLeft[0] * total * 0.01;
      } else if (paddingLeft[1] === REM$7) {
        w -= paddingLeft[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (paddingLeft[1] === VW$7) {
        w -= paddingLeft[0] * this.root.width * 0.01;
      } else if (paddingLeft[1] === VH$7) {
        w -= paddingLeft[0] * this.root.height * 0.01;
      }

      if (borderLeftWidth[1] === PX$2) {
        w -= borderLeftWidth[0];
      } else if (borderLeftWidth[1] === REM$7) {
        w -= borderLeftWidth[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (borderLeftWidth[1] === VW$7) {
        w -= borderLeftWidth[0] * this.root.width * 0.01;
      } else if (borderLeftWidth[1] === VH$7) {
        w -= borderLeftWidth[0] * this.root.height * 0.01;
      }

      if (marginRight[1] === PX$2) {
        w -= marginRight[0];
      } else if (marginRight[1] === PERCENT$2) {
        w -= marginRight[0] * total * 0.01;
      } else if (marginRight[1] === REM$7) {
        w -= marginRight[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (marginRight[1] === VW$7) {
        w -= marginRight[0] * this.root.width * 0.01;
      } else if (marginRight[1] === VH$7) {
        w -= marginRight[0] * this.root.height * 0.01;
      }

      if (paddingRight[1] === PX$2) {
        w -= paddingRight[0];
      } else if (paddingRight[1] === PERCENT$2) {
        w -= paddingRight[0] * total * 0.01;
      } else if (paddingRight[1] === REM$7) {
        w -= paddingRight[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (paddingRight[1] === VW$7) {
        w -= paddingRight[0] * this.root.width * 0.01;
      } else if (paddingRight[1] === VH$7) {
        w -= paddingRight[0] * this.root.height * 0.01;
      }

      if (borderRightWidth[1] === PX$2) {
        w -= borderRightWidth[0];
      } else if (borderRightWidth[1] === REM$7) {
        w -= borderRightWidth[0] * this.root.computedStyle[FONT_SIZE$7];
      } else if (borderRightWidth[1] === VW$7) {
        w -= borderRightWidth[0] * this.root.width * 0.01;
      } else if (borderRightWidth[1] === VH$7) {
        w -= borderRightWidth[0] * this.root.height * 0.01;
      }

      return w;
    }
  }, {
    key: "__calBasis",
    value: function __calBasis(isDirectionRow, data) {
      var b = 0;
      var min = 0;
      var max = 0;
      var currentStyle = this.currentStyle,
          __loadImg = this.__loadImg;
      var w = data.w,
          h = data.h; // 计算需考虑style的属性

      var flexBasis = currentStyle[FLEX_BASIS$1],
          width = currentStyle[WIDTH$2],
          height = currentStyle[HEIGHT$2],
          marginLeft = currentStyle[MARGIN_LEFT$2],
          marginTop = currentStyle[MARGIN_TOP$2],
          marginRight = currentStyle[MARGIN_RIGHT$1],
          marginBottom = currentStyle[MARGIN_BOTTOM$2],
          paddingLeft = currentStyle[PADDING_LEFT$2],
          paddingTop = currentStyle[PADDING_TOP$2],
          paddingRight = currentStyle[PADDING_RIGHT$1],
          paddingBottom = currentStyle[PADDING_BOTTOM$2],
          borderTopWidth = currentStyle[BORDER_TOP_WIDTH$2],
          borderRightWidth = currentStyle[BORDER_RIGHT_WIDTH$1],
          borderBottomWidth = currentStyle[BORDER_BOTTOM_WIDTH$2],
          borderLeftWidth = currentStyle[BORDER_LEFT_WIDTH$2];
      var main = isDirectionRow ? width : height;
      var cross = isDirectionRow ? height : width; // basis3种情况：auto、固定、content，只区分固定和其它

      var isFixed = [PX$2, PERCENT$2, REM$7, VW$7, VH$7].indexOf(flexBasis[1]) > -1;

      if (isFixed) {
        if (flexBasis[1] === PX$2) {
          b = max = min = flexBasis[0];
        } else if (flexBasis[1] === PERCENT$2) {
          b = max = min = flexBasis[0] * 0.01 * (isDirectionRow ? w : h);
        } else if (flexBasis[1] === REM$7) {
          b = max = min = flexBasis[0] * this.root.computedStyle[FONT_SIZE$7];
        } else if (flexBasis[1] === VW$7) {
          b = max = min = flexBasis[0] * this.root.width * 0.01;
        } else if (flexBasis[1] === VH$7) {
          b = max = min = flexBasis[0] * this.root.height * 0.01;
        }
      } else if ([PX$2, PERCENT$2, REM$7, VW$7, VH$7].indexOf(main[1]) > -1) {
        if (main[1] === PX$2) {
          b = max = min = main[0];
        } else if (main[1] === PERCENT$2) {
          b = max = min = main[0] * 0.01 * (isDirectionRow ? w : h);
        } else if (main[1] === REM$7) {
          b = max = min = main[0] * this.root.computedStyle[FONT_SIZE$7];
        } else if (main[1] === VW$7) {
          b = max = min = main[0] * this.root.width * 0.01;
        } else if (main[1] === VH$7) {
          b = max = min = main[0] * this.root.height * 0.01;
        }
      } // auto和content固定尺寸比例计算
      else if (__loadImg.source || __loadImg.error) {
        if (cross[1] !== AUTO$1) {
          if (cross[1] === PX$2) {
            cross = cross[0];
          } else if (cross[1] === PERCENT$2) {
            cross = cross[0] * 0.01 * (isDirectionRow ? h : w);
          } else if (cross[1] === REM$7) {
            cross = cross[0] * this.root.computedStyle[FONT_SIZE$7];
          } else if (cross[1] === VW$7) {
            cross = cross[0] * this.root.width * 0.01;
          } else if (cross[1] === VH$7) {
            cross = cross[0] * this.root.height * 0.01;
          }

          var ratio = __loadImg.width / __loadImg.height;
          b = max = min = isDirectionRow ? cross * ratio : cross / ratio;
        } else {
          b = max = min = isDirectionRow ? __loadImg.width : __loadImg.height;
        }
      } // border也得计算在内


      if (isDirectionRow) {
        var mp = this.__calMp(marginLeft, w) + this.__calMp(marginRight, w) + this.__calMp(paddingLeft, w) + this.__calMp(paddingRight, w);

        var w2 = borderLeftWidth[0] + borderRightWidth[0] + mp;
        b += w2;
        max += w2;
        min += w2;
      } else {
        var _mp = this.__calMp(marginTop, w) + this.__calMp(marginBottom, w) + this.__calMp(paddingTop, w) + this.__calMp(paddingBottom, w);

        var h2 = borderTopWidth[0] + borderBottomWidth[0] + _mp;
        b += h2;
        max += h2;
        min += h2;
      }

      return [b, min, max];
    }
  }, {
    key: "__loadAndRefresh",
    value: function __loadAndRefresh(loadImg, root, ctx, placeholder, computedStyle, width, height, cb) {
      var self = this; // 先清空之前可能的

      if (loadImg.source || loadImg.error) {
        root.delRefreshTask(self.__task);
        root.addRefreshTask(self.__task = {
          __before: function __before() {
            self.__task = null; // 清除在before，防止after的回调增加新的task误删

            if (self.isDestroyed) {
              return;
            } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


            var res = {};
            res[UPDATE_NODE$1] = self;
            res[UPDATE_FOCUS$1] = o$1.REFLOW; // 没有样式变化但内容尺寸发生了变化强制执行

            res[UPDATE_CONFIG$1] = self.__config;

            root.__addUpdate(self, self.__config, root, root.__config, res);
          }
        });
        loadImg.source = null;
      }

      loadImg.loading = true; // 再测量，可能瞬间完成替换掉上面的

      inject.measureImg(loadImg.src, function (data) {
        // 还需判断url，防止重复加载时老的替换新的，失败走error绘制
        if (data.url === loadImg.src && !self.isDestroyed) {
          var reload = function reload() {
            var _self$currentStyle = self.currentStyle,
                width = _self$currentStyle[WIDTH$2],
                height = _self$currentStyle[HEIGHT$2];
            root.delRefreshTask(self.__task);

            if (width[1] !== AUTO$1 && height[1] !== AUTO$1) {
              root.addRefreshTask(self.__task = {
                __before: function __before() {
                  self.__task = null;

                  if (self.isDestroyed) {
                    return;
                  } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


                  var res = {};
                  res[UPDATE_NODE$1] = self;
                  res[UPDATE_FOCUS$1] = o$1.REPAINT;
                  res[UPDATE_CONFIG$1] = self.__config;

                  root.__addUpdate(self, self.__config, root, root.__config, res);
                },
                __after: function __after() {
                  if (isFunction$3(cb)) {
                    cb.call(self);
                  }
                }
              });
            } else {
              root.addRefreshTask(self.__task = {
                __before: function __before() {
                  self.__task = null;

                  if (self.isDestroyed) {
                    return;
                  } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


                  var res = {};
                  res[UPDATE_NODE$1] = self;
                  res[UPDATE_FOCUS$1] = o$1.REFLOW; // 没有样式变化但内容尺寸发生了变化强制执行

                  res[UPDATE_CONFIG$1] = self.__config;

                  root.__addUpdate(self, self.__config, root, root.__config, res);
                },
                __after: function __after() {
                  if (isFunction$3(cb)) {
                    cb.call(self);
                  }
                }
              });
            }
          };

          loadImg.cache && (loadImg.cache.cache = false);
          loadImg.loading = false;

          if (data.success) {
            loadImg.source = data.source;
            loadImg.width = data.width;
            loadImg.height = data.height;
          } else if (placeholder) {
            inject.measureImg(placeholder, function (data) {
              if (data.success) {
                loadImg.error = true;
                loadImg.source = data.source;
                loadImg.width = data.width;
                loadImg.height = data.height;
                reload();
              }
            }, {
              ctx: ctx,
              root: root,
              width: width,
              height: height
            });
            return;
          } else {
            loadImg.error = true;
          } // 可见状态进行刷新操作，visibility某些情况需要刷新，可能宽高未定义要重新布局


          if (computedStyle[DISPLAY$3] !== 'none') {
            reload();
          }
        }
      }, {
        ctx: ctx,
        root: root,
        width: width,
        height: height
      });
    }
  }, {
    key: "updateSrc",
    value: function updateSrc(v, cb) {
      var self = this;
      var loadImg = self.__loadImg;
      var root = this.root; // 相等或空且当前error直接返回

      if (v === loadImg.src || !v && loadImg.error) {
        if (isFunction$3(cb)) {
          cb(-1);
        }
      } else if (v) {
        loadImg.src = v;

        self.__loadAndRefresh(loadImg, root, root.ctx, self.props.placeholder, self.computedStyle, self.width, self.height, cb);
      } else {
        loadImg.src = v;
        loadImg.source = null;
        loadImg.error = true;
        root.delRefreshTask(self.__task);
        root.addRefreshTask(self.__task = {
          __before: function __before() {
            self.__task = null;

            if (self.isDestroyed) {
              return;
            }

            var res = {};
            res[UPDATE_NODE$1] = self;
            res[UPDATE_FOCUS$1] = o$1.REFLOW;
            res[UPDATE_CONFIG$1] = self.__config;

            root.__addUpdate(self, self.__config, root, self.__config, res);
          },
          __after: function __after(diff) {
            if (isFunction$3(cb)) {
              cb(diff);
            }
          }
        });
      }
    }
  }, {
    key: "appendChild",
    value: function appendChild() {
      inject.error('Img can not appendChild.');
    }
  }, {
    key: "src",
    get: function get() {
      return this.__loadImg.src;
    }
  }]);

  return Img;
}(Dom);

_defineProperty(Img, "showError", true);

var Defs = /*#__PURE__*/function () {
  function Defs(uuid) {
    _classCallCheck(this, Defs);

    this.id = uuid;
    this.count = 0;
    this.list = [];
    this.cacheHash = {}; // 每次svg渲染前重置，存储前次渲染不变的缓存id
  }

  _createClass(Defs, [{
    key: "add",
    value: function add(data) {
      var uuid = this.count;
      var hash = this.cacheHash;

      while (hash.hasOwnProperty(uuid)) {
        uuid++;
      }

      this.count = uuid + 1;
      data.id = uuid;
      data.uuid = 'karas-defs-' + this.id + '-' + uuid;
      data.index = this.list.length;
      this.list.push(data);
      return data.uuid;
    }
  }, {
    key: "addCache",
    value: function addCache(data) {
      data.index = this.list.length;
      this.list.push(data);
      this.cacheHash[data.id] = true;
      return data.uuid;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.list = [];
      this.count = 0;
      this.cacheHash = {};
    }
  }, {
    key: "removeCache",
    value: function removeCache(data) {
      var list = this.list;
      var i = data.index; // 一般情况index即位置，但每次渲染过程中，可能会删掉一些，此时位置会往前，但index不变，因此遍历

      for (; i >= 0; i--) {
        if (list[i] === data) {
          list.splice(i, 1);
          return;
        }
      }
    }
  }, {
    key: "value",
    get: function get() {
      return this.list;
    }
  }], [{
    key: "getInstance",
    value: function getInstance(uuid) {
      return new Defs(uuid);
    }
  }]);

  return Defs;
}();

var _enums$STYLE_KEY$8 = enums.STYLE_KEY,
    DISPLAY$2 = _enums$STYLE_KEY$8.DISPLAY,
    MARGIN_TOP$1 = _enums$STYLE_KEY$8.MARGIN_TOP,
    MARGIN_RIGHT = _enums$STYLE_KEY$8.MARGIN_RIGHT,
    MARGIN_BOTTOM$1 = _enums$STYLE_KEY$8.MARGIN_BOTTOM,
    MARGIN_LEFT$1 = _enums$STYLE_KEY$8.MARGIN_LEFT,
    PADDING_TOP$1 = _enums$STYLE_KEY$8.PADDING_TOP,
    PADDING_RIGHT = _enums$STYLE_KEY$8.PADDING_RIGHT,
    PADDING_BOTTOM$1 = _enums$STYLE_KEY$8.PADDING_BOTTOM,
    PADDING_LEFT$1 = _enums$STYLE_KEY$8.PADDING_LEFT,
    WIDTH$1 = _enums$STYLE_KEY$8.WIDTH,
    HEIGHT$1 = _enums$STYLE_KEY$8.HEIGHT,
    BORDER_TOP_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_TOP_WIDTH,
    BORDER_RIGHT_WIDTH = _enums$STYLE_KEY$8.BORDER_RIGHT_WIDTH,
    BORDER_BOTTOM_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_WIDTH,
    BORDER_LEFT_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_LEFT_WIDTH,
    FILL$1 = _enums$STYLE_KEY$8.FILL,
    STROKE = _enums$STYLE_KEY$8.STROKE,
    STROKE_MITERLIMIT = _enums$STYLE_KEY$8.STROKE_MITERLIMIT,
    STROKE_WIDTH$6 = _enums$STYLE_KEY$8.STROKE_WIDTH,
    STROKE_LINECAP = _enums$STYLE_KEY$8.STROKE_LINECAP,
    STROKE_LINEJOIN = _enums$STYLE_KEY$8.STROKE_LINEJOIN,
    STROKE_DASHARRAY = _enums$STYLE_KEY$8.STROKE_DASHARRAY,
    STROKE_DASHARRAY_STR = _enums$STYLE_KEY$8.STROKE_DASHARRAY_STR,
    FILL_RULE = _enums$STYLE_KEY$8.FILL_RULE,
    VISIBILITY$2 = _enums$STYLE_KEY$8.VISIBILITY,
    FONT_SIZE$6 = _enums$STYLE_KEY$8.FONT_SIZE,
    FLEX_BASIS = _enums$STYLE_KEY$8.FLEX_BASIS,
    _enums$NODE_KEY$3 = enums.NODE_KEY,
    NODE_CACHE_PROPS$1 = _enums$NODE_KEY$3.NODE_CACHE_PROPS,
    NODE_CURRENT_PROPS$1 = _enums$NODE_KEY$3.NODE_CURRENT_PROPS,
    NODE_CURRENT_STYLE$3 = _enums$NODE_KEY$3.NODE_CURRENT_STYLE,
    NODE_STYLE$2 = _enums$NODE_KEY$3.NODE_STYLE,
    NODE_DEFS_CACHE$1 = _enums$NODE_KEY$3.NODE_DEFS_CACHE;
var PX$1 = o$4.PX,
    PERCENT$1 = o$4.PERCENT,
    REM$6 = o$4.REM,
    VW$6 = o$4.VW,
    VH$6 = o$4.VH;
var int2rgba = util.int2rgba,
    isNil$8 = util.isNil,
    joinArr = util.joinArr;
var canvasPolygon$1 = painter.canvasPolygon,
    svgPolygon = painter.svgPolygon;
var REGISTER = {};

var Geom = /*#__PURE__*/function (_Xom) {
  _inherits(Geom, _Xom);

  var _super = _createSuper(Geom);

  function Geom(tagName, props) {
    var _this;

    _classCallCheck(this, Geom);

    _this = _super.call(this, tagName, props);
    _this.__isMulti = !!_this.props.multi;
    _this.__style = css.normalize(_this.style, reset.DOM_ENTRY_SET.concat(reset.GEOM_ENTRY_SET));
    _this.__currentStyle = util.extend({}, _this.__style);
    _this.__currentProps = util.clone(_this.props);
    var config = _this.__config;
    config[NODE_CACHE_PROPS$1] = _this.__cacheProps = {};
    config[NODE_CURRENT_PROPS$1] = _this.__currentProps;
    config[NODE_CURRENT_STYLE$3] = _this.__currentStyle;
    config[NODE_STYLE$2] = _this.__style;
    return _this;
  }

  _createClass(Geom, [{
    key: "__tryLayInline",
    value: function __tryLayInline(w, total) {
      // 无children，直接以style的width为宽度，不定义则为0
      var _this$currentStyle = this.currentStyle,
          width = _this$currentStyle[WIDTH$1],
          marginLeft = _this$currentStyle[MARGIN_LEFT$1],
          marginRight = _this$currentStyle[MARGIN_RIGHT],
          paddingLeft = _this$currentStyle[PADDING_LEFT$1],
          paddingRight = _this$currentStyle[PADDING_RIGHT],
          borderLeftWidth = _this$currentStyle[BORDER_LEFT_WIDTH$1],
          borderRightWidth = _this$currentStyle[BORDER_RIGHT_WIDTH];

      if (width[1] === PX$1) {
        w -= width[0];
      } else if (width[1] === PERCENT$1) {
        w -= total * width[0] * 0.01;
      } else if (width[1] === REM$6) {
        w -= width[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (width[1] === VW$6) {
        w -= width[0] * this.root.width * 0.01;
      } else if (width[1] === VH$6) {
        w -= width[0] * this.root.height * 0.01;
      } // 减去水平mbp


      if (marginLeft[1] === PX$1) {
        w -= marginLeft[0];
      } else if (marginLeft[1] === PERCENT$1) {
        w -= marginLeft[0] * total * 0.01;
      } else if (marginLeft[1] === REM$6) {
        w -= marginLeft[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (marginLeft[1] === VW$6) {
        w -= marginLeft[0] * this.root.width * 0.01;
      } else if (marginLeft[1] === VH$6) {
        w -= marginLeft[0] * this.root.height * 0.01;
      }

      if (paddingLeft[1] === PX$1) {
        w -= paddingLeft[0];
      } else if (paddingLeft[1] === PERCENT$1) {
        w -= paddingLeft[0] * total * 0.01;
      } else if (paddingLeft[1] === REM$6) {
        w -= paddingLeft[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (paddingLeft[1] === VW$6) {
        w -= paddingLeft[0] * this.root.width * 0.01;
      } else if (paddingLeft[1] === VH$6) {
        w -= paddingLeft[0] * this.root.height * 0.01;
      }

      if (borderLeftWidth[1] === PX$1) {
        w -= borderLeftWidth[0];
      } else if (borderLeftWidth[1] === REM$6) {
        w -= borderLeftWidth[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (borderLeftWidth[1] === VW$6) {
        w -= borderLeftWidth[0] * this.root.width * 0.01;
      } else if (borderLeftWidth[1] === VH$6) {
        w -= borderLeftWidth[0] * this.root.height * 0.01;
      }

      if (marginRight[1] === PX$1) {
        w -= marginRight[0];
      } else if (marginRight[1] === PERCENT$1) {
        w -= marginRight[0] * total * 0.01;
      } else if (marginRight[1] === REM$6) {
        w -= marginRight[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (marginRight[1] === VW$6) {
        w -= marginRight[0] * this.root.width * 0.01;
      } else if (marginRight[1] === VH$6) {
        w -= marginRight[0] * this.root.height * 0.01;
      }

      if (paddingRight[1] === PX$1) {
        w -= paddingRight[0];
      } else if (paddingRight[1] === PERCENT$1) {
        w -= paddingRight[0] * total * 0.01;
      } else if (paddingRight[1] === REM$6) {
        w -= paddingRight[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (paddingRight[1] === VW$6) {
        w -= paddingRight[0] * this.root.width * 0.01;
      } else if (paddingRight[1] === VH$6) {
        w -= paddingRight[0] * this.root.height * 0.01;
      }

      if (borderRightWidth[1] === PX$1) {
        w -= borderRightWidth[0];
      } else if (borderRightWidth[1] === REM$6) {
        w -= borderRightWidth[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (borderRightWidth[1] === VW$6) {
        w -= borderRightWidth[0] * this.root.width * 0.01;
      } else if (borderRightWidth[1] === VH$6) {
        w -= borderRightWidth[0] * this.root.height * 0.01;
      }

      return w;
    }
  }, {
    key: "__calMinMax",
    value: function __calMinMax(isDirectionRow, data) {
      css.computeReflow(this, this.isShadowRoot);
      var min = 0;
      var max = 0;
      var currentStyle = this.currentStyle; // 计算需考虑style的属性

      var width = currentStyle[WIDTH$1],
          height = currentStyle[HEIGHT$1],
          display = currentStyle[DISPLAY$2];
      var main = isDirectionRow ? width : height; // 只绝对值生效，%不生效，依旧要判断

      if (main[1] === PX$1) {
        min = max = main[0];
      } else if (main[1] === REM$6) {
        min = max = main[0] * this.root.computedStyle[FONT_SIZE$6];
      } else if (main[1] === VW$6) {
        min = max = main[0] * this.root.width * 0.01;
      } else if (main[1] === VH$6) {
        min = max = main[0] * this.root.height * 0.01;
      }

      return [display, this.__addMp(isDirectionRow, data.w, currentStyle, [min, max])];
    }
  }, {
    key: "__calBasis",
    value: function __calBasis(isDirectionRow, data) {
      var b = 0;
      var min = 0;
      var max = 0;
      var currentStyle = this.currentStyle;
      var w = data.w,
          h = data.h; // 计算需考虑style的属性

      var flexBasis = currentStyle[FLEX_BASIS],
          width = currentStyle[WIDTH$1],
          height = currentStyle[HEIGHT$1],
          marginLeft = currentStyle[MARGIN_LEFT$1],
          marginTop = currentStyle[MARGIN_TOP$1],
          marginRight = currentStyle[MARGIN_RIGHT],
          marginBottom = currentStyle[MARGIN_BOTTOM$1],
          paddingLeft = currentStyle[PADDING_LEFT$1],
          paddingTop = currentStyle[PADDING_TOP$1],
          paddingRight = currentStyle[PADDING_RIGHT],
          paddingBottom = currentStyle[PADDING_BOTTOM$1],
          borderTopWidth = currentStyle[BORDER_TOP_WIDTH$1],
          borderRightWidth = currentStyle[BORDER_RIGHT_WIDTH],
          borderBottomWidth = currentStyle[BORDER_BOTTOM_WIDTH$1],
          borderLeftWidth = currentStyle[BORDER_LEFT_WIDTH$1];
      var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content，只区分固定和其它

      var isFixed = [PX$1, PERCENT$1, REM$6, VW$6, VH$6].indexOf(flexBasis[1]) > -1;

      if (isFixed) {
        if (flexBasis[1] === PX$1) {
          b = max = min = flexBasis[0];
        } else if (flexBasis[1] === PERCENT$1) {
          b = max = min = flexBasis[0] * 0.01 * (isDirectionRow ? w : h);
        } else if (flexBasis[1] === REM$6) {
          b = max = min = flexBasis[0] * this.root.computedStyle[FONT_SIZE$6];
        } else if (flexBasis[1] === VW$6) {
          b = max = min = flexBasis[0] * this.root.width * 0.01;
        } else if (flexBasis[1] === VH$6) {
          b = max = min = flexBasis[0] * this.root.height * 0.01;
        }
      } else if ([PX$1, PERCENT$1, REM$6, VW$6, VH$6].indexOf(main[1]) > -1) {
        if (main[1] === PX$1) {
          b = max = min = main[0];
        } else if (main[1] === PERCENT$1) {
          b = max = min = main[0] * 0.01 * (isDirectionRow ? w : h);
        } else if (main[1] === REM$6) {
          b = max = min = main[0] * this.root.computedStyle[FONT_SIZE$6];
        } else if (main[1] === VW$6) {
          b = max = min = main[0] * this.root.width * 0.01;
        } else if (main[1] === VH$6) {
          b = max = min = main[0] * this.root.height * 0.01;
        }
      } // border也得计算在内


      if (isDirectionRow) {
        var mp = this.__calMp(marginLeft, w) + this.__calMp(marginRight, w) + this.__calMp(paddingLeft, w) + this.__calMp(paddingRight, w);

        var w2 = borderLeftWidth[0] + borderRightWidth[0] + mp;
        b += w2;
        max += w2;
        min += w2;
      } else {
        var _mp = this.__calMp(marginTop, w) + this.__calMp(marginBottom, w) + this.__calMp(paddingTop, w) + this.__calMp(paddingBottom, w);

        var h2 = borderTopWidth[0] + borderBottomWidth[0] + _mp;
        b += h2;
        max += h2;
        min += h2;
      }

      return [b, min, max];
    }
  }, {
    key: "__layoutBlock",
    value: function __layoutBlock(data, isVirtual) {
      var _this$__preLayout = this.__preLayout(data),
          fixedWidth = _this$__preLayout.fixedWidth,
          fixedHeight = _this$__preLayout.fixedHeight,
          w = _this$__preLayout.w,
          h = _this$__preLayout.h;

      this.__height = fixedHeight ? h : 0;

      if (isVirtual) {
        this.__width = fixedWidth ? w : 0;
        return;
      }

      this.__width = w;

      this.__ioSize(w, this.height);

      this.__marginAuto(this.currentStyle, data);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "__layoutFlex",
    value: function __layoutFlex(data) {
      // 无children所以等同于block
      this.__layoutBlock(data);
    }
  }, {
    key: "__layoutInline",
    value: function __layoutInline(data) {
      var _this$__preLayout2 = this.__preLayout(data),
          fixedWidth = _this$__preLayout2.fixedWidth,
          fixedHeight = _this$__preLayout2.fixedHeight,
          x = _this$__preLayout2.x,
          y = _this$__preLayout2.y,
          w = _this$__preLayout2.w,
          h = _this$__preLayout2.h; // 元素的width不能超过父元素w


      var tw = this.__width = fixedWidth ? w : x - data.x;
      var th = this.__height = fixedHeight ? h : y - data.y;

      this.__ioSize(tw, th);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "__calCache",
    value: function __calCache(renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6) {
      var _this2 = this;

      var res = _get(_getPrototypeOf(Geom.prototype), "__calCache", this).call(this, renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6);

      if (isNil$8(__cacheStyle[STROKE_WIDTH$6])) {
        __cacheStyle[STROKE_WIDTH$6] = true;
        var strokeWidth = currentStyle[STROKE_WIDTH$6] || [];
        var w = this.width;
        computedStyle[STROKE_WIDTH$6] = strokeWidth.map(function (item) {
          if (item[1] === PX$1) {
            return item[0];
          } else if (item[1] === PERCENT$1) {
            return item[0] * w * 0.01;
          } else if (item[1] === REM$6) {
            return item[0] * _this2.root.computedStyle[FONT_SIZE$6];
          } else if (item[1] === VW$6) {
            return item[0] * _this2.root.width * 0.01;
          } else if (item[1] === VH$6) {
            return item[0] * _this2.root.height * 0.01;
          } else {
            return 0;
          }
        });
      }

      if (isNil$8(__cacheStyle[STROKE_DASHARRAY])) {
        __cacheStyle[STROKE_DASHARRAY] = true;
        computedStyle[STROKE_DASHARRAY] = currentStyle[STROKE_DASHARRAY] || [];
        __cacheStyle[STROKE_DASHARRAY_STR] = computedStyle[STROKE_DASHARRAY].map(function (item) {
          return joinArr(item, ',');
        });
      } // 直接赋值的


      [STROKE_LINECAP, STROKE_LINEJOIN, STROKE_MITERLIMIT, FILL_RULE].forEach(function (k) {
        computedStyle[k] = currentStyle[k];
      }); // stroke/fll移至render里处理，因为cache涉及渐变坐标偏移

      [STROKE, FILL$1].forEach(function (k) {
        if (isNil$8(__cacheStyle[k])) {
          var v = currentStyle[k];
          computedStyle[k] = v;
          var _res = [];

          if (Array.isArray(v)) {
            v.forEach(function (item) {
              if (item && (item.k === 'linear' || item.k === 'radial' || item.k === 'conic')) {
                _res.push(_this2.__gradient(renderMode, ctx, x3, y3, x4, y4, item));
              } else if (item[3] > 0) {
                _res.push(int2rgba(item));
              } else {
                _res.push('none');
              }
            });
          }

          __cacheStyle[k] = _res;
        }
      });
      return res;
    }
  }, {
    key: "__calContent",
    value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
      // Geom强制有内容
      return computedStyle[VISIBILITY$2] !== 'hidden';
    }
  }, {
    key: "__preSet",
    value: function __preSet(res) {
      var width = this.width,
          height = this.height,
          __cacheStyle = this.__cacheStyle,
          computedStyle = this.computedStyle;
      var cx = res.sx3 + width * 0.5;
      var cy = res.sy3 + height * 0.5;
      var fill = __cacheStyle[FILL$1],
          stroke = __cacheStyle[STROKE],
          strokeDasharrayStr = __cacheStyle[STROKE_DASHARRAY_STR];
      var strokeWidth = computedStyle[STROKE_WIDTH$6],
          strokeLinecap = computedStyle[STROKE_LINECAP],
          strokeLinejoin = computedStyle[STROKE_LINEJOIN],
          strokeMiterlimit = computedStyle[STROKE_MITERLIMIT],
          strokeDasharray = computedStyle[STROKE_DASHARRAY],
          fillRule = computedStyle[FILL_RULE];
      return {
        cx: cx,
        cy: cy,
        stroke: stroke,
        strokeWidth: strokeWidth,
        strokeDasharray: strokeDasharray,
        strokeDasharrayStr: strokeDasharrayStr,
        strokeLinecap: strokeLinecap,
        strokeLinejoin: strokeLinejoin,
        strokeMiterlimit: strokeMiterlimit,
        fill: fill,
        fillRule: fillRule
      };
    }
  }, {
    key: "__preSetCanvas",
    value: function __preSetCanvas(renderMode, ctx, res) {
      var stroke = res.stroke,
          strokeWidth = res.strokeWidth,
          strokeDasharray = res.strokeDasharray,
          strokeLinecap = res.strokeLinecap,
          strokeLinejoin = res.strokeLinejoin,
          strokeMiterlimit = res.strokeMiterlimit,
          fill = res.fill;

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (fill) {
          if (fill.k === 'linear') {
            ctx.fillStyle = fill.v;
          } else if (fill.k === 'radial' && !Array.isArray(fill.v)) {
            ctx.fillStyle = fill.v;
          } else if (fill.k === 'conic') ; else if (!fill.k && ctx.fillStyle !== fill) {
            ctx.fillStyle = fill;
          }
        }

        if (stroke) {
          if (stroke.k === 'linear') {
            ctx.strokeStyle = stroke.v;
          } else if (stroke.k === 'radial' && !Array.isArray(stroke.v)) {
            ctx.strokeStyle = stroke.v;
          } else if (stroke.k === 'conic') ; else if (!stroke.k && ctx.strokeStyle !== stroke) {
            ctx.strokeStyle = stroke;
          }
        }

        if (strokeWidth !== undefined && ctx.lineWidth !== strokeWidth) {
          ctx.lineWidth = strokeWidth;
        }

        if (strokeLinecap !== undefined && ctx.lineCap !== strokeLinecap) {
          ctx.lineCap = strokeLinecap;
        }

        if (strokeLinejoin !== undefined && ctx.lineJoin !== strokeLinejoin) {
          ctx.lineJoin = strokeLinejoin;
        }

        if (strokeMiterlimit !== undefined && ctx.miterLimit !== strokeMiterlimit) {
          ctx.miterLimit = strokeMiterlimit;
        } // 小程序没这个方法


        if (util.isFunction(ctx.getLineDash)) {
          if (strokeDasharray && !util.equalArr(ctx.getLineDash(), strokeDasharray)) {
            ctx.setLineDash(strokeDasharray);
          }
        } else if (strokeDasharray) {
          ctx.setLineDash(strokeDasharray);
        }
      }
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Geom.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (renderMode === mode.SVG) {
        this.virtualDom.type = 'geom';
      } // 无论canvas/svg，break可提前跳出省略计算


      if (res["break"]) {
        return res;
      } // data在无cache时没有提前设置


      var preData = this.__preSet(res);

      return Object.assign(res, preData);
    }
  }, {
    key: "__renderPolygon",
    value: function __renderPolygon(renderMode, ctx, res) {
      var fills = res.fill,
          fillRules = res.fillRule,
          strokes = res.stroke,
          strokeWidths = res.strokeWidth,
          strokeDasharrays = res.strokeDasharray,
          strokeDasharrayStrs = res.strokeDasharrayStr,
          strokeLinecaps = res.strokeLinecap,
          strokeLinejoins = res.strokeLinejoin,
          strokeMiterlimits = res.strokeMiterlimit,
          dx = res.dx,
          dy = res.dy;
      var list = this.__cacheProps.list,
          isMulti = this.isMulti,
          bbox = this.bbox; // 普通情况下只有1个，按普通情况走

      if (fills.length <= 1 && strokes.length <= 1) {
        var o = {
          fill: fills[0],
          fillRule: fillRules[0],
          stroke: strokes[0],
          strokeWidth: strokeWidths[0],
          strokeDasharray: strokeDasharrays[0],
          strokeDasharrayStr: strokeDasharrayStrs[0],
          strokeLinecap: strokeLinecaps[0],
          strokeLinejoin: strokeLinejoins[0],
          strokeMiterlimit: strokeMiterlimits[0],
          dx: dx,
          dy: dy,
          bbox: bbox
        };

        this.__renderOnePolygon(renderMode, ctx, isMulti, list, o);
      } // 多个需要fill在下面，stroke在上面，依次循环
      else {
        for (var i = 0, len = fills.length; i < len; i++) {
          var fill = fills[i];

          if (fill) {
            var _o = {
              fill: fill,
              fillRule: fillRules[i],
              dx: dx,
              dy: dy,
              bbox: bbox
            };

            this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o);
          }
        }

        for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
          var stroke = strokes[_i];

          if (stroke) {
            var _o2 = {
              stroke: stroke,
              strokeWidth: strokeWidths[_i],
              strokeDasharray: strokeDasharrays[_i],
              strokeDasharrayStr: strokeDasharrayStrs[_i],
              strokeLinecap: strokeLinecaps[_i],
              strokeLinejoin: strokeLinejoins[_i],
              strokeMiterlimit: strokeMiterlimits[_i],
              dx: dx,
              dy: dy,
              bbox: bbox
            };

            this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o2);
          }
        }
      }
    }
  }, {
    key: "__renderOnePolygon",
    value: function __renderOnePolygon(renderMode, ctx, isMulti, list, res) {
      var fill = res.fill,
          stroke = res.stroke,
          strokeWidth = res.strokeWidth;
      var isFillCE = fill && fill.k === 'conic';
      var isStrokeCE = stroke && stroke.k === 'conic'; // 椭圆是array

      var isFillRE = fill && fill.k === 'radial' && Array.isArray(fill.v);
      var isStrokeRE = strokeWidth && strokeWidth > 0 && stroke && stroke.k === 'radial' && Array.isArray(stroke.v);

      if (isFillCE || isStrokeCE) {
        if (isFillCE) {
          this.__conicGradient(renderMode, ctx, list, isMulti, res);
        } else if (fill !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
        }

        if (strokeWidth && strokeWidth > 0 && isStrokeCE) {
          inject.warn('Stroke style can not use conic-gradient');
        } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
        }
      } else if (isFillRE || isStrokeRE) {
        if (isFillRE) {
          this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
        } else if (fill !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
        } // stroke椭圆渐变matrix会变形，降级为圆


        if (strokeWidth && strokeWidth > 0 && isStrokeRE) {
          inject.warn('Stroke style can not use radial-gradient for ellipse');
          res.stroke.v = res.stroke.v[0];

          this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
        } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
        }
      } else {
        this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, true);
      }
    }
  }, {
    key: "__drawPolygon",
    value: function __drawPolygon(renderMode, ctx, isMulti, list, res, isFill, isStroke) {
      var fill = res.fill,
          stroke = res.stroke,
          strokeWidth = res.strokeWidth,
          fillRule = res.fillRule,
          strokeDasharrayStr = res.strokeDasharrayStr,
          strokeLinecap = res.strokeLinecap,
          strokeLinejoin = res.strokeLinejoin,
          strokeMiterlimit = res.strokeMiterlimit,
          dx = res.dx,
          dy = res.dy;

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        this.__preSetCanvas(renderMode, ctx, res);

        ctx.beginPath();

        if (isMulti) {
          list.forEach(function (item) {
            return canvasPolygon$1(ctx, item, dx, dy);
          });
        } else {
          canvasPolygon$1(ctx, list, dx, dy);
        }

        if (isFill && fill && fill !== 'none') {
          ctx.fill(fillRule);
        }

        if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
          ctx.stroke();
        }

        ctx.closePath();
      } else if (renderMode === mode.SVG) {
        var d = '';

        if (isMulti) {
          list.forEach(function (item) {
            return d += svgPolygon(item);
          });
        } else {
          d = svgPolygon(list);
        }

        var props = [['d', d]]; // 2个都没有常出现在多fill/stroke时，也有可能特殊单个故意这样写的

        if ((!fill || fill === 'none') && (!stroke || stroke === 'none')) {
          return;
        }

        if (isFill && fill && fill !== 'none') {
          props.push(['fill', fill.v || fill]);

          if (fillRule && fillRule !== 'nonzero') {
            props.push(['fill-rule', fillRule]);
          }
        } else {
          props.push(['fill', 'none']);
        }

        if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
          props.push(['stroke', stroke.v || stroke]);
          props.push(['stroke-width', strokeWidth]);

          this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
        } else {
          props.push(['stroke-width', 0]);
        }

        this.addGeom('path', props);
      }
    }
  }, {
    key: "__inversePtList",
    value: function __inversePtList(list, isMulti, t) {
      if (isMulti) {
        return list.map(function (item) {
          if (!item || !item.length) {
            return null;
          }

          return item.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            var arr = [];

            for (var i = 0, len = item.length; i < len; i += 2) {
              var p = mx.calPoint([item[i], item[i + 1]], t);
              arr.push(p[0]);
              arr.push(p[1]);
            }

            return arr;
          });
        });
      } else {
        return list.map(function (item) {
          if (!item || !item.length) {
            return null;
          }

          var arr = [];

          for (var i = 0, len = item.length; i < len; i += 2) {
            var p = mx.calPoint([item[i], item[i + 1]], t);
            arr.push(p[0]);
            arr.push(p[1]);
          }

          return arr;
        });
      }
    }
  }, {
    key: "__radialEllipse",
    value: function __radialEllipse(renderMode, ctx, list, isMulti, res, method) {
      var strokeWidth = res.strokeWidth,
          strokeDasharrayStr = res.strokeDasharrayStr,
          strokeLinecap = res.strokeLinecap,
          strokeLinejoin = res.strokeLinejoin,
          strokeMiterlimit = res.strokeMiterlimit,
          dx = res.dx,
          dy = res.dy;

      var _res$method$v = _slicedToArray(res[method].v, 4),
          color = _res$method$v[0],
          matrix = _res$method$v[1],
          cx = _res$method$v[2],
          cy = _res$method$v[3]; // 椭圆渐变的转换，顶点逆矩阵变换


      var tfo = [cx, cy];
      matrix = tf.calMatrixByOrigin(matrix, tfo);
      var t = mx.inverse(matrix);
      list = this.__inversePtList(list, isMulti, t); // 用正向matrix渲染

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (matrix) {
          ctx.save();
          var me = this.matrixEvent;
          matrix = mx.multiply(me, matrix);
          ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        }

        ctx.beginPath();

        if (ctx[method + 'Style'] !== color) {
          ctx[method + 'Style'] = color;
        }

        if (isMulti) {
          list.forEach(function (item) {
            return painter.canvasPolygon(ctx, item, dx, dy);
          });
        } else {
          canvasPolygon$1(ctx, list, dx, dy);
        }

        ctx[method]();
        ctx.closePath();

        if (matrix) {
          ctx.restore();
        }
      } else if (renderMode === mode.SVG) {
        var d = '';

        if (isMulti) {
          list.forEach(function (item) {
            return d += svgPolygon(item);
          });
        } else {
          d = svgPolygon(list);
        }

        var props = [['d', d]];

        if (method === 'fill') {
          props.push(['fill', color]);
          props.push(['strokeWidth', 0]);
        } else if (method === 'stroke') {
          props.push(['fill', 'none']);
          props.push(['stroke', color]);
          props.push(['stroke-width', strokeWidth]);

          this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
        }

        props.push(['transform', "matrix(".concat(joinArr(mx.m2m6(matrix), ','), ")")]);
        this.addGeom('path', props);
      }
    }
  }, {
    key: "__conicGradient",
    value: function __conicGradient(renderMode, ctx, list, isMulti, res) {
      var _this3 = this;

      var fill = res.fill,
          bbox = res.bbox,
          _res$dx = res.dx,
          dx = _res$dx === void 0 ? 0 : _res$dx,
          _res$dy = res.dy,
          dy = _res$dy === void 0 ? 0 : _res$dy;
      var color = fill.v;

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        var _bbox = _slicedToArray(bbox, 4),
            x1 = _bbox[0],
            y1 = _bbox[1],
            x2 = _bbox[2],
            y2 = _bbox[3];

        var w = x2 - x1,
            h = y2 - y1;
        var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
        var imgData = offscreen.ctx.getImageData(0, 0, w, h);
        gradient$1.getConicGradientImage(w * 0.5, h * 0.5, w, h, fill.v.stop, imgData.data);
        offscreen.ctx.putImageData(imgData, 0, 0);

        if (isMulti) {
          list.forEach(function (item) {
            ctx.save();
            ctx.beginPath();
            canvasPolygon$1(ctx, item, dx, dy);
            ctx.clip();
            ctx.closePath();
            ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
            ctx.restore();
          });
        } else {
          ctx.save();
          ctx.beginPath();
          canvasPolygon$1(ctx, list, dx, dy);
          ctx.clip();
          ctx.closePath();
          ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
          ctx.restore();
        }

        offscreen.ctx.clearRect(0, 0, w, h);
      } else if (renderMode === mode.SVG) {
        if (isMulti) {
          list.forEach(function (item) {
            var v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon(item)]]
              }]
            };
            var clip = ctx.add(v);

            _this3.__config[NODE_DEFS_CACHE$1].push(v);

            color.forEach(function (item) {
              _this3.virtualDom.bb.push({
                type: 'item',
                tagName: 'path',
                props: [['d', svgPolygon(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
              });
            });
          });
        } else {
          var v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', svgPolygon(list)]]
            }]
          };
          var clip = ctx.add(v);

          this.__config[NODE_DEFS_CACHE$1].push(v);

          color.forEach(function (item) {
            _this3.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
            });
          });
        }
      }
    }
  }, {
    key: "__propsStrokeStyle",
    value: function __propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
      if (strokeDasharrayStr) {
        props.push(['stroke-dasharray', strokeDasharrayStr]);
      }

      if (strokeLinecap && strokeLinecap !== 'butt') {
        props.push(['stroke-linecap', strokeLinecap]);
      }

      if (strokeLinejoin && strokeLinejoin !== 'miter') {
        props.push(['stroke-linejoin', strokeLinejoin]);
      }

      if (strokeMiterlimit && strokeMiterlimit !== 4) {
        props.push(['stroke-miterlimit', strokeMiterlimit]);
      }
    } // geom的cache无内容也不清除

  }, {
    key: "__releaseWhenEmpty",
    value: function __releaseWhenEmpty() {} // offset/resize时要多一步清空props上记录的缓存

  }, {
    key: "__offsetX",
    value: function __offsetX(diff, isLayout, lv) {
      _get(_getPrototypeOf(Geom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "__offsetY",
    value: function __offsetY(diff, isLayout, lv) {
      _get(_getPrototypeOf(Geom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "__resizeX",
    value: function __resizeX(diff, lv) {
      _get(_getPrototypeOf(Geom.prototype), "__resizeX", this).call(this, diff, lv);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "__resizeY",
    value: function __resizeY(diff, lv) {
      _get(_getPrototypeOf(Geom.prototype), "__resizeY", this).call(this, diff, lv);

      this.__config[NODE_CACHE_PROPS$1] = this.__cacheProps = {};
    }
  }, {
    key: "addGeom",
    value: function addGeom(tagName, props) {
      props = util.hash2arr(props);
      this.virtualDom.children.push({
        type: 'item',
        tagName: tagName,
        props: props
      });
    }
  }, {
    key: "getProps",
    value: function getProps(k) {
      var v = this.currentProps[k];

      if (!isNil$8(v)) {
        return v;
      }

      return this['__' + k];
    }
  }, {
    key: "__isRealInline",
    value: function __isRealInline() {
      return false;
    }
  }, {
    key: "isMulti",
    get: function get() {
      return this.__isMulti;
    }
  }, {
    key: "currentProps",
    get: function get() {
      return this.__currentProps;
    }
  }], [{
    key: "REGISTER",
    get: function get() {
      return REGISTER;
    }
  }, {
    key: "getRegister",
    value: function getRegister(name) {
      if (!name || !util.isString(name) || name.charAt(0) !== '$') {
        throw new Error('Invalid param');
      }

      if (!REGISTER.hasOwnProperty(name)) {
        throw new Error("Geom has not register: ".concat(name));
      }

      return REGISTER[name];
    }
  }, {
    key: "register",
    value: function register(name, obj) {
      if (!name || !util.isString(name) || name.charAt(0) !== '$' || !obj.prototype || !(obj.prototype instanceof Geom)) {
        throw new Error('Invalid param');
      }

      if (Geom.hasRegister(name)) {
        throw new Error("Geom has already register: ".concat(name));
      }

      REGISTER[name] = obj;
    }
  }, {
    key: "hasRegister",
    value: function hasRegister(name) {
      return name && REGISTER.hasOwnProperty(name);
    }
  }, {
    key: "delRegister",
    value: function delRegister(name) {
      if (Geom.hasRegister(name)) {
        delete REGISTER[name];
      }
    }
  }]);

  return Geom;
}(Xom);

var _enums$NODE_KEY$2 = enums.NODE_KEY,
    NODE_STYLE$1 = _enums$NODE_KEY$2.NODE_STYLE,
    NODE_CURRENT_STYLE$2 = _enums$NODE_KEY$2.NODE_CURRENT_STYLE,
    NODE_COMPUTED_STYLE$2 = _enums$NODE_KEY$2.NODE_COMPUTED_STYLE,
    NODE_DOM_PARENT$2 = _enums$NODE_KEY$2.NODE_DOM_PARENT,
    NODE_MATRIX$1 = _enums$NODE_KEY$2.NODE_MATRIX,
    NODE_MATRIX_EVENT$1 = _enums$NODE_KEY$2.NODE_MATRIX_EVENT,
    NODE_STRUCT$1 = _enums$NODE_KEY$2.NODE_STRUCT;
var TYPE_VD$1 = $$type.TYPE_VD,
    TYPE_GM$1 = $$type.TYPE_GM,
    TYPE_CP$1 = $$type.TYPE_CP;
var updateList = [];
var removeList = [];
var KEY_FLAG = {};
/**
 * setState后刷新前先根遍历检查组件开始进行shouldComponentUpdate判断
 */

function check(vd) {
  if (vd instanceof Dom) {
    vd.children.forEach(function (child) {
      if (child instanceof Dom) {
        check(child);
      } // 当组件有setState更新时，从叶子到根链路会标识__hasUpdate，以便节约遍历成本忽略那些没变化的链路
      else if (child instanceof Component && child.__hasUpdate) {
        child.__hasUpdate = false;
        checkCp(child, child.props);
      }
    });
  } // 高阶组件会进入此分支，被父组件调用
  else if (vd instanceof Component && vd.__hasUpdate) {
    vd.__hasUpdate = false;
    checkCp(vd, vd.props);
  }
}
/**
 * 检查cp是否有state变更，注意递归检查时需要看shadow不能看shadowRoot，
 * 否则高阶组件会被跳过，其更新无法触发update生命周期
 * @param cp
 * @param nextProps
 * @param forceCheckUpdate，被render()后的json的二级组件，发现props有变更强制检查更新，否则可以跳过
 */


function checkCp(cp, nextProps, forceCheckUpdate) {
  if (cp.__nextState || forceCheckUpdate) {
    var shouldUpdate;

    if (util.isFunction(cp.shouldComponentUpdate)) {
      shouldUpdate = cp.shouldComponentUpdate(nextProps, cp.__nextState || cp.state);
    } else {
      // 没有默认更新
      shouldUpdate = true;
    }

    if (shouldUpdate) {
      updateCp(cp, nextProps, cp.__nextState || cp.state);
    } // 不更新则递归检查子tree的cp
    else {
      cp.props = nextProps;
      cp.state = cp.__nextState || cp.state;
      check(cp.shadow);
    }
  } else {
    check(cp.shadow);
  }
}
/**
 * 更新组件的props和state，清空__nextState
 * @param cp
 * @param props
 * @param state
 */


function updateCp(cp, props, state) {
  cp.props = props;
  cp.state = state;
  cp.__nextState = null; // 同步在refresh前清除component的新state标识，这样frame动画在after回调中可以新设

  var oldS = cp.shadow;
  var oldSr = cp.shadowRoot;
  var oldJson = cp.__cd;
  var json = flattenJson(cp.render()); // 对比新老render()返回的内容，更新后重新生成sr

  diffSr(oldS, oldJson, json);

  cp.__init(json); // 为了局部dom布局需要知道老的css信息


  var sr = cp.shadowRoot;

  if (sr instanceof Xom) {
    ['__outerWidth', '__outerHeight', '__sx', '__sy', '__sx2', '__sx3', '__sx4', '__sx5', '__sx6', '__sy2', '__sy3', '__sy4', '__sy5', '__sy6'].forEach(function (k) {
      sr[k] = oldSr[k];
    });
    sr.__computedStyle = sr.__config[NODE_COMPUTED_STYLE$2] = oldSr.computedStyle;
  } else {
    var domParent = cp.domParent;
    [NODE_STYLE$1, NODE_CURRENT_STYLE$2, NODE_COMPUTED_STYLE$2, NODE_MATRIX$1, NODE_MATRIX_EVENT$1].forEach(function (k) {
      sr.__config[k] = domParent.__config[k];
    });
  }

  ['__x', '__y', '__width', '__height', '__sx1', // text和xom
  '__sy1', '__layoutData', '__parent', '__domParent'].forEach(function (k) {
    sr[k] = oldSr[k];
  });
  sr.__config[NODE_DOM_PARENT$2] = oldSr.domParent;
  sr.__config[NODE_STRUCT$1] = oldSr.__config[NODE_STRUCT$1];
  updateList.push(cp); // 老的需回收，diff会生成新的dom，唯一列外是cp直接返回一个没变化的cp

  if (!util.isObject(json) || !json.__placeholder) {
    removeList.push(oldS);
  } // 子组件使用老的json时标识，更新后删除，render()返回空会没json对象


  if (json && json.__placeholder) {
    delete json.__placeholder;
  }

  if (json && json.__inheritAnimate) {
    delete json.__inheritAnimate;
  }

  if (json && json.__animateRecords) {
    delete json.__animateRecords;
  } // 高阶组件时需判断，子组件更新后生成新的sr，父组件的sr/host需要同时更新引用


  var host = cp.host;

  while (host) {
    if (host.shadow === cp) {
      host.__shadowRoot = sr;
      sr.__hostRoot = host;
      cp = host;
      host = host.host;
    } else {
      break;
    }
  }
}
/**
 * 非一级组件sr进行对比，key相同的无需重新生成且继承动画
 * @param vd
 * @param oj oldJson
 * @param nj
 */


function diffSr(vd, oj, nj) {
  // 先遍历检查key相同的，将没有变化的key暂存下来，深度优先，这样叶子节点出现在前面，当key的叶子也有key时，确保叶子先对比
  var ojk = getKeyHash(oj, {}, vd);
  var njk = getKeyHash(nj, {});
  var keyList = [];
  var cpList = []; // 先对比key对应的节点，如果新老有一方对不上则落空

  Object.keys(ojk).forEach(function (k) {
    var o = ojk[k];
    var n = njk[k];

    if (!n) {
      o.json.key = KEY_FLAG;
    }
  });
  Object.keys(njk).forEach(function (k) {
    var o = ojk[k];
    var n = njk[k]; // 有可能老的没有这个key，新key落空

    if (!o) {
      n.json.key = KEY_FLAG;
      return;
    }

    var oj = o.json;
    var nj = n.json;
    var vd = o.vd; // 相同class的组件进行对比替换

    if (oj.$$type === TYPE_CP$1 && nj.$$type === TYPE_CP$1) {
      if (oj.klass === nj.klass) {
        // 对比props和children看是否全等，是则直接替换新json类型为占位符，引用老vd，否则强制更新
        diffCp(oj, nj, vd); // 标识对比过了

        oj.key = nj.key = KEY_FLAG; // 老的sr里需删除这个vd，因为老sr会回收

        cpList.push(vd);
      }
    } // 相同类型的vd进行对比继承动画
    else if (oj.$$type === nj.$$type && oj.tagName === nj.tagName) {
      // 需判断矢量标签mutil是否相等
      if (nj.$$type !== TYPE_GM$1 || oj.props.multi === nj.props.multi) {
        nj.__inheritAnimate = vd;
      }

      oj.key = nj.key = KEY_FLAG; // key相同的dom暂存下来

      if (nj.$$type === TYPE_VD$1) {
        keyList.push({
          vd: vd,
          oj: oj,
          nj: nj
        });
      }
    }
  }); // key相同的dom对比children，下面非key逻辑就不做了

  keyList.forEach(function (item) {
    diffChildren(item.vd, item.oj, item.nj);
  }); // 整体tree进行对比

  diffChild$1(vd, oj, nj); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收，这里处理key的

  cpList.forEach(function (vd) {
    removeCpFromOldTree(vd);
  });
}
/**
 * 递归检查dom的children，相同的无需重新生成，用PL类型占位符代替直接返回老vd
 * @param vd
 * @param oj
 * @param nj
 */


function diffChild$1(vd, oj, nj) {
  if (util.isObject(nj)) {
    if (nj.$$type === TYPE_CP$1) {
      // key对比过了忽略
      if (nj.key === KEY_FLAG) {
        return;
      } // 相同class的组件处理


      if (oj && oj.$$type === nj.$$type && oj.klass === nj.klass) {
        diffCp(oj, nj, vd); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收

        removeCpFromOldTree(vd);
      }
    } else if (nj.$$type === TYPE_GM$1 && oj && oj.$$type === TYPE_GM$1) {
      // $geom的multi必须一致
      if (oj.tagName === nj.tagName && oj.props.multi === nj.props.multi) {
        nj.__inheritAnimate = vd;
      }
    } // dom类型递归children
    else if (nj.$$type === TYPE_VD$1 && oj && oj.$$type === TYPE_VD$1) {
      if (oj.tagName === nj.tagName) {
        nj.__inheritAnimate = vd;
      }

      diffChildren(vd, oj, nj);
    }
  }
}
/**
 * dom类型的vd对比children
 * @param vd
 * @param oj
 * @param nj
 */


function diffChildren(vd, oj, nj) {
  var oc = oj.children;
  var nc = nj.children;
  var ol = oc.length;
  var nl = nc.length;
  var children = vd.children;

  for (var i = 0, of = 0, nf = 0, len = Math.min(ol, nl); i < len; i++) {
    var o = oc[i + of];
    var n = nc[i + nf]; // 新老都是key直接跳过

    if (o.key === KEY_FLAG && n.key === KEY_FLAG) ; // 其中一个是key对比过了调整索引和长度
    else if (o.key === KEY_FLAG) {
      of++;
      i--;
      ol--;
      len = Math.min(ol, nl);
    } else if (n.key === KEY_FLAG) {
      nf++;
      i--;
      nl--;
      len = Math.min(ol, nl);
    } else {
      diffChild$1(children[i + of], o, n);
    }
  } // 长度不同增减的无需关注，新json创建cp有didMount，老vd会调用cp的destroy

}
/**
 * 根据json对比看cp如何更新，被render()后的json的二级组件对比才会出现
 * @param oj
 * @param nj
 * @param vd
 */


function diffCp(oj, nj, vd) {
  // props全等，直接替换新json类型为占位符，引用老vd内容，无需重新创建，暂时存在json的placeholder上
  // 否则需要强制触发组件更新，包含setState内容
  nj.__placeholder = vd;
  var sr = vd.shadowRoot; // 对比需忽略on开头的事件，直接改老的引用到新的上，这样只变了on的话无需更新

  var exist = {};
  Object.keys(oj.props).forEach(function (k) {
    var v = oj.props[k];
    exist[k] = v;
  });
  Object.keys(nj.props).forEach(function (k) {
    var v = nj.props[k];

    if (/^on[a-zA-Z]/.test(k)) {
      oj.props[k] = v;
      var ex = exist[k];

      if (ex) {
        delete exist[k];

        if (ex !== v) {
          k = k.slice(2).toLowerCase();
          sr.listener[k] = v;
        }
      } else {
        k = k.slice(2).toLowerCase();
        sr.listener[k] = v;
      }
    } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
      oj.props[k] = v;
      var _ex = exist[k];

      if (_ex) {
        delete exist[k];

        if (_ex !== v) {
          k = k.slice(2).toLowerCase();
          vd.off(k, exist[k]);
          vd.on(k, v);
        }

        delete exist[k];
      } else {
        k = k.slice(2).toLowerCase();
        vd.on(k, v);
      }
    }
  }); // 新的少的事件取消

  Object.keys(exist).forEach(function (k) {
    var v = exist[k];

    if (/^on[a-zA-Z]/.test(k)) {
      nj.props[k] = v;
      k = k.slice(2).toLowerCase();
      delete sr.listener[k];
    } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
      nj.props[k] = v;
      k = k.slice(2).toLowerCase();
      vd.off(k, v);
    }
  });
  checkCp(vd, nj.props, !util.equal(oj.props, nj.props));
}
/**
 * 深度优先遍历json，将有key的记录在hash中，如果传入根vd，同步递归保存对应位置的vd
 * @param json
 * @param hash
 * @param vd
 * @returns {*}
 */


function getKeyHash(json, hash, vd) {
  if (Array.isArray(json)) {
    json.forEach(function (item, i) {
      return getKeyHash(item, hash, vd && vd[i]);
    });
  } else if (util.isObject(json)) {
    if (json.$$type === TYPE_VD$1 || json.$$type === TYPE_GM$1 || json.$$type === TYPE_CP$1) {
      // 深度优先
      if (json.$$type === TYPE_VD$1) {
        getKeyHash(json.children, hash, vd && vd.children);
      }

      var key = json.props.key;

      if (!util.isNil(key) && key !== '') {
        // 重复key错误警告
        if (hash.hasOwnProperty(key)) {
          inject.warn('Component ' + vd.tagName + ' has duplicate key: ' + key);
        }

        hash[key] = {
          json: json,
          vd: vd
        };
      }
    }
  }

  return hash;
}
/**
 * 非一级组件diff发生更新时，其需要从sr的tree中移除，因为sr会销毁
 */


function removeCpFromOldTree(vd) {
  // root下的一级组件不会发生回收情况，忽略
  if (!vd.host) {
    return;
  }

  var parent = vd.parent;

  if (parent) {
    var i = parent.children.indexOf(vd);

    if (i > -1) {
      parent.children[i] = null;
    } else {
      throw new Error('Can not find child: ' + vd.tagName);
    }
  }
}
/**
 * 执行componentDidUpdate/destroy
 */


function did() {
  updateList.forEach(function (item) {
    if (util.isFunction(item.componentDidUpdate)) {
      item.componentDidUpdate();
    }
  });
  updateList.splice(0);
  removeList.forEach(function (item) {
    item.__destroy();
  });
  removeList = [];
}

var updater = {
  updateList: updateList,
  check: check,
  did: did
};

var joinVd = util.joinVd,
    joinDef = util.joinDef;
var contain$2 = o$1.contain,
    NONE$2 = o$1.NONE,
    TRANSFORM_ALL$1 = o$1.TRANSFORM_ALL,
    OPACITY$1 = o$1.OPACITY,
    FILTER$2 = o$1.FILTER,
    MIX_BLEND_MODE$1 = o$1.MIX_BLEND_MODE;

function diff(elem, ovd, nvd) {
  var cns = elem.childNodes;
  diffDefs(cns[0], ovd.defs, nvd.defs); // <REPAINT不会有lv属性，无需对比

  if (!nvd.hasOwnProperty('lv')) {
    diffBb(cns[1], ovd.bb, nvd.bb);
  }

  diffD2D(elem, ovd, nvd, true);
}

function diffDefs(elem, od, nd) {
  var ol = od.length;
  var nl = nd.length;
  var i = 0;
  var cns = elem.childNodes;

  for (; i < Math.min(ol, nl); i++) {
    diffDef(cns[i], od[i], nd[i]);
  }

  if (i < ol) {
    for (var j = ol - 1; j >= i; j--) {
      removeAt(elem, cns, j);
    }
  } else if (i < nl) {
    for (; i < nl; i++) {
      insertAt(elem, cns, i, joinDef(nd[i]));
    }
  }
}

function diffDef(elem, od, nd) {
  if (od.tagName !== nd.tagName) {
    insertAdjacentHTML(elem, 'beforebegin', joinDef(nd)); // elem.insertAdjacentHTML('beforebegin', joinDef(nd));

    elem.parentNode.removeChild(elem);
  } else {
    if (od.uuid !== nd.uuid) {
      elem.setAttribute('id', nd.uuid);
    }

    var op = {};

    for (var _i = 0, len = (od.props || []).length; _i < len; _i++) {
      var prop = od.props[_i];

      var _prop = _slicedToArray(prop, 2),
          k = _prop[0],
          v = _prop[1];

      op[k] = v;
    }

    for (var _i2 = 0, _len = (nd.props || []).length; _i2 < _len; _i2++) {
      var _prop2 = nd.props[_i2];

      var _prop3 = _slicedToArray(_prop2, 2),
          _k = _prop3[0],
          _v = _prop3[1]; // 已有不等更新，没有添加


      if (op.hasOwnProperty(_k)) {
        if (op[_k] !== _v) {
          elem.setAttribute(_k, _v);
        }

        delete op[_k];
      } else {
        elem.setAttribute(_k, _v);
      }
    } // 多余的删除


    Object.keys(op).forEach(function (i) {
      elem.removeAttribute(i);
    });
    var cns = elem.childNodes;
    var ol = od.children.length;
    var nl = nd.children.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, od.children[i], nd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd(nd.children[i]));
      }
    }
  }
}

function diffChild(elem, ovd, nvd) {
  if (ovd.type === 'dom') {
    if (nvd.type === 'dom') {
      diffD2D(elem, ovd, nvd);
    } else if (nvd.type === 'geom') {
      diffD2G(elem, ovd, nvd);
    } else {
      replaceWith(elem, nvd);
    }
  } else if (ovd.type === 'text') {
    if (nvd.type === 'text') {
      diffT2T(elem, ovd, nvd);
    } else {
      replaceWith(elem, nvd);
    }
  } else if (ovd.type === 'geom') {
    if (nvd.type === 'dom') {
      diffG2D(elem, ovd, nvd);
    } else if (nvd.type === 'geom') {
      diffG2G(elem, ovd, nvd);
    } else {
      replaceWith(elem, nvd);
    }
  } else if (ovd.type === 'img') {
    if (nvd.type === 'img') {
      diffItemSelf(elem, ovd, nvd);
    } else {
      replaceWith(elem, nvd);
    }
  }
}

function diffX2X(elem, ovd, nvd) {
  var transform = nvd.transform,
      opacity = nvd.opacity,
      visibility = nvd.visibility,
      mask = nvd.mask,
      overflow = nvd.overflow,
      filter = nvd.filter,
      mixBlendMode = nvd.mixBlendMode,
      conClip = nvd.conClip;

  if (ovd.transform !== transform) {
    if (transform) {
      elem.setAttribute('transform', transform);
    } else {
      elem.removeAttribute('transform');
    }
  }

  if (ovd.opacity !== opacity) {
    if (opacity !== 1 && opacity !== undefined) {
      elem.setAttribute('opacity', opacity);
    } else {
      elem.removeAttribute('opacity');
    }
  }

  if (ovd.visibility !== visibility) {
    elem.setAttribute('visibility', visibility);
  }

  if (ovd.mask !== mask) {
    if (mask) {
      elem.setAttribute('mask', mask);
    } else {
      elem.removeAttribute('mask');
    }
  }

  if (ovd.filter !== filter || ovd.mixBlendMode !== mixBlendMode) {
    var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

    if (s) {
      elem.setAttribute('style', s);
    } else {
      elem.removeAttribute('filter');
    }
  } // if(ovd.filter !== filter) {
  //   if(filter) {
  //     elem.setAttribute('filter', filter);
  //   }
  //   else {
  //     elem.removeAttribute('filter');
  //   }
  // }


  if (ovd.overflow !== overflow) {
    if (overflow) {
      elem.setAttribute('clipPath', overflow);
    } else {
      elem.removeAttribute('overflow');
    }
  }

  if (ovd.conClip !== conClip) {
    if (conClip) {
      elem.childNodes[1].setAttribute('clip-path', conClip);
    } else {
      elem.childNodes[1].removeAttribute('clip-path');
    }
  }
}

function diffByLessLv(elem, ovd, nvd, lv) {
  var transform = nvd.transform,
      opacity = nvd.opacity,
      mask = nvd.mask,
      filter = nvd.filter,
      mixBlendMode = nvd.mixBlendMode;

  if (mask) {
    elem.setAttribute('mask', mask);
  } else {
    elem.removeAttribute('mask');
  }

  if (lv === NONE$2) {
    return;
  }

  if (contain$2(lv, TRANSFORM_ALL$1)) {
    if (transform) {
      elem.setAttribute('transform', transform);
    } else {
      elem.removeAttribute('transform');
    }
  }

  if (contain$2(lv, OPACITY$1)) {
    if (opacity !== 1 && opacity !== undefined) {
      elem.setAttribute('opacity', opacity);
    } else {
      elem.removeAttribute('opacity');
    }
  }

  if (contain$2(lv, FILTER$2) || contain$2(lv, MIX_BLEND_MODE$1)) {
    var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

    if (s) {
      elem.setAttribute('style', s);
    } else {
      elem.removeAttribute('style');
    }
  }
}

function diffD2D(elem, ovd, nvd, root) {
  // cache表明children无变化缓存，一定是REPAINT以下的，只需看自身的lv以及mask
  if (nvd.cache) {
    diffByLessLv(elem, ovd, nvd, nvd.lv);
    return;
  } // 无cache且<REPAINT的情况快速对比且继续对比children


  if (nvd.hasOwnProperty('lv')) {
    diffByLessLv(elem, ovd, nvd, nvd.lv);
  } else {
    diffX2X(elem, ovd, nvd);

    if (!root) {
      diffBb(elem.firstChild, ovd.bb, nvd.bb);
    }
  }

  var ol = ovd.children.length;
  var nl = nvd.children.length;
  var i = 0;
  var lastChild = elem.lastChild;
  var cns = lastChild.childNodes;

  for (; i < Math.min(ol, nl); i++) {
    diffChild(cns[i], ovd.children[i], nvd.children[i]);
  }

  if (i < ol) {
    for (var j = ol - 1; j >= i; j--) {
      removeAt(lastChild, cns, j);
    }
  } else if (i < nl) {
    for (; i < nl; i++) {
      insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
    }
  }
}

function diffD2G(elem, ovd, nvd) {
  diffX2X(elem, ovd, nvd);
  diffBb(elem.firstChild, ovd.bb, nvd.bb);
  var ol = ovd.children.length;
  var nl = nvd.children.length;
  var i = 0;
  var lastChild = elem.lastChild;
  var cns = lastChild.childNodes;

  for (; i < Math.min(ol, nl); i++) {
    replaceWith(cns[i], nvd.children[i]);
  }

  if (i < ol) {
    for (var j = ol - 1; j >= i; j--) {
      removeAt(lastChild, cns, j);
    }
  } else if (i < nl) {
    for (; i < nl; i++) {
      insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
    }
  }
}

function diffT2T(elem, ovd, nvd) {
  if (nvd.cache) {
    return;
  }

  var ol = ovd.children.length;
  var nl = nvd.children.length;
  var i = 0;

  for (; i < Math.min(ol, nl); i++) {
    diffItem(elem, i, ovd.children[i], nvd.children[i], true);
  }

  var cns = elem.childNodes;

  if (i < ol) {
    for (var j = ol - 1; j >= i; j--) {
      removeAt(elem, cns, j);
    }
  } else if (i < nl) {
    for (; i < nl; i++) {
      insertAt(elem, cns, i, joinVd(nvd.children[i]));
    }
  }
}

function diffG2D(elem, ovd, nvd) {
  diffD2G(elem, ovd, nvd);
}

function diffG2G(elem, ovd, nvd) {
  if (nvd.cache) {
    diffByLessLv(elem, ovd, nvd, nvd.lv);
    return;
  } // 无cache且<REPAINT的情况快速对比且继续对比children


  if (nvd.hasOwnProperty('lv')) {
    diffByLessLv(elem, ovd, nvd, nvd.lv);
  } else {
    diffX2X(elem, ovd, nvd);
    diffBb(elem.firstChild, ovd.bb, nvd.bb);
    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(lastChild, i, ovd.children[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
      }
    }
  }
}

function diffBb(elem, obb, nbb) {
  var ol = obb.length;
  var nl = nbb.length;
  var i = 0;

  for (; i < Math.min(ol, nl); i++) {
    diffItem(elem, i, obb[i], nbb[i]);
  }

  var cns = elem.childNodes;

  if (i < ol) {
    for (var j = ol - 1; j >= i; j--) {
      removeAt(elem, cns, j);
    }
  } else if (i < nl) {
    for (; i < nl; i++) {
      insertAt(elem, cns, i, joinVd(nbb[i]));
    }
  }
}

function diffItem(elem, i, ovd, nvd, isText) {
  var cns = elem.childNodes;

  if (ovd.tagName !== nvd.tagName) {
    replaceWith(cns[i], nvd);
  } else {
    diffItemSelf(cns[i], ovd, nvd);

    if (isText && ovd.content !== nvd.content) {
      cns[i].innerHTML = nvd.content;
    }
  }
}

function diffItemSelf(elem, ovd, nvd) {
  if (nvd.cache) {
    return;
  }

  var op = {};

  for (var i = 0, len = (ovd.props || []).length; i < len; i++) {
    var prop = ovd.props[i];

    var _prop4 = _slicedToArray(prop, 2),
        k = _prop4[0],
        v = _prop4[1];

    op[k] = v;
  }

  for (var _i3 = 0, _len2 = (nvd.props || []).length; _i3 < _len2; _i3++) {
    var _prop5 = nvd.props[_i3];

    var _prop6 = _slicedToArray(_prop5, 2),
        _k2 = _prop6[0],
        _v2 = _prop6[1]; // 已有不等更新，没有添加


    if (op.hasOwnProperty(_k2)) {
      if (op[_k2] !== _v2) {
        elem.setAttribute(_k2, _v2);
      }

      delete op[_k2];
    } else {
      elem.setAttribute(_k2, _v2);
    }
  } // 多余的删除


  Object.keys(op).forEach(function (i) {
    elem.removeAttribute(i);
  });
}

function replaceWith(elem, vd) {
  var res;

  if (Array.isArray(vd)) {
    res = '';
    vd.forEach(function (item) {
      res += joinVd(item);
    });
  } else {
    res = joinVd(vd);
  }

  insertAdjacentHTML(elem, 'beforebegin', res); // elem.insertAdjacentHTML('beforebegin', res);

  elem.parentNode.removeChild(elem);
}

function insertAt(elem, cns, index, html) {
  if (index >= cns.length) {
    insertAdjacentHTML(elem, 'beforeend', html); // elem.insertAdjacentHTML('beforeend', html);
  } else {
    insertAdjacentHTML(cns[index], 'beforebegin', html); // cns[index].insertAdjacentHTML('beforebegin', html);
  }
}

function removeAt(elem, cns, index) {
  if (cns[index]) {
    elem.removeChild(cns[index]);
  }
}

var svg;

function insertAdjacentHTML(elem, where, content) {
  if (elem.insertAdjacentHTML) {
    elem.insertAdjacentHTML(where, content);
  } else {
    switch (where) {
      case 'beforeend':
        elem.innerHTML += content;
        break;

      case 'beforebegin':
        svg = svg || document.createElement('svg');
        svg.innerHTML = content;
        elem.parentNode.insertBefore(svg.childNodes[0], elem);
        break;
    }
  }
}

var isFunction$2 = util.isFunction;

var Controller = /*#__PURE__*/function () {
  function Controller() {
    _classCallCheck(this, Controller);

    this.__records = []; // 默认记录和自动记录

    this.__records2 = []; // 非自动播放的动画记录

    this.__list = []; // 默认初始化播放列表，自动播放也存这里

    this.__list2 = []; // json中autoPlay为false的初始化存入这里

    this.__onList = []; // list中已存在的侦听事件，list2初始化时也需要增加上

    this.__lastTime = {}; // 每个类型的上次触发时间，防止重复emit
  }

  _createClass(Controller, [{
    key: "add",
    value: function add(v) {
      var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

      if (list.indexOf(v) === -1) {
        list.push(v);
      }
    }
  }, {
    key: "remove",
    value: function remove(v) {
      var i = this.list.indexOf(v);

      if (i > -1) {
        this.list.splice(i, 1);
      }
    }
  }, {
    key: "__destroy",
    value: function __destroy() {
      this.__records = [];
      this.__records2 = [];
      this.__list = [];
      this.__list2 = [];
    }
  }, {
    key: "__action",
    value: function __action(k, args) {
      this.list.forEach(function (item) {
        item[k].apply(item, args);
      });
    }
  }, {
    key: "init",
    value: function init() {
      var _this = this;

      var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__records;
      var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

      // 检查尚未初始化的record，并初始化，后面才能调用各种控制方法
      if (records.length) {
        // 清除防止重复调用，并且新的json还会进入整体逻辑
        records.splice(0).forEach(function (item) {
          var target = item.target,
              animate = item.animate;

          if (target.isDestroyed) {
            return;
          }

          if (Array.isArray(animate)) {
            animate.forEach(function (animate) {
              var value = animate.value,
                  options = animate.options;
              options.autoPlay = false;
              var o = target.animate(value, options);

              _this.add(o, list);
            });
          } else {
            var value = animate.value,
                options = animate.options;
            options.autoPlay = false;
            var o = target.animate(value, options);

            _this.add(o, list);
          }
        });
      } // 非自动播放后初始化需检测事件，给非自动播放添加上，并清空本次


      if (records === this.__records2) {
        var onList = this.__onList;
        var list2 = this.list2;

        if (list2.length && onList.length) {
          list2.forEach(function (item) {
            onList.forEach(function (arr) {
              item.off(arr[0], arr[1]);
              item.on(arr[0], arr[1]);
            });
          });
        }
      }
    }
  }, {
    key: "__playAuto",
    value: function __playAuto() {
      this.init();

      this.__action('play');
    }
  }, {
    key: "play",
    value: function play(cb) {
      this.__mergeAuto();

      this.__onList = [];
      var once = true;

      this.__action('play', [cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "pause",
    value: function pause() {
      this.__action('pause');
    }
  }, {
    key: "resume",
    value: function resume(cb) {
      var once = true;

      this.__action('resume', [cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "__mergeAuto",
    value: function __mergeAuto() {
      this.init();
      this.init(this.__records2);

      if (this.__list2.length) {
        this.__list = this.__list.concat(this.__list2);
        this.__list2 = [];
      }
    }
  }, {
    key: "cancel",
    value: function cancel(cb) {
      this.__mergeAuto();

      this.__onList = [];
      var once = true;

      this.__action('cancel', [cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "finish",
    value: function finish(cb) {
      this.__mergeAuto();

      this.__onList = [];
      var once = true;

      this.__action('finish', [cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "gotoAndStop",
    value: function gotoAndStop(v, options, cb) {
      this.__mergeAuto();

      this.__onList = [];
      var once = true;

      this.__action('gotoAndStop', [v, options, cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "gotoAndPlay",
    value: function gotoAndPlay(v, options, cb) {
      this.__mergeAuto();

      this.__onList = [];
      var once = true;

      this.__action('gotoAndPlay', [v, options, cb && function (diff) {
        if (once) {
          once = false;

          if (isFunction$2(cb)) {
            cb(diff);
          }
        }
      }]);
    }
  }, {
    key: "on",
    value: function on(id, handle) {
      if (!isFunction$2(handle)) {
        return;
      }

      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          this.__on(id[i], handle);
        }

        this.__onList.push([id, handle]);
      } else {
        this.__on(id, handle);

        this.__onList.push([id, handle]);
      }
    }
  }, {
    key: "__on",
    value: function __on(id, handle) {
      var _this2 = this;

      this.list.forEach(function (item) {
        var cb = function cb() {
          var time = item.timestamp;

          if (time !== _this2.__lastTime[id]) {
            _this2.__lastTime[id] = time;
            handle();
          }
        };

        cb.__karasEventCb = handle;
        item.on(id, cb);
      });
    }
  }, {
    key: "off",
    value: function off(id, handle) {
      if (Array.isArray(id)) {
        for (var i = 0, len = id.length; i < len; i++) {
          this.off(id[i], handle);
        }
      } else {
        this.list.forEach(function (item) {
          item.off(id, handle);
        });
      }
    }
  }, {
    key: "list",
    get: function get() {
      return this.__list;
    }
  }, {
    key: "list2",
    get: function get() {
      return this.__list2;
    }
  }, {
    key: "__set",
    value: function __set(key, value) {
      this.list.forEach(function (item) {
        item[key] = value;
      });
    }
  }, {
    key: "playbackRate",
    set: function set(v) {
      this.__set('playbackRate', v);
    }
  }, {
    key: "iterations",
    set: function set(v) {
      this.__set('iterations', v);
    }
  }, {
    key: "playCount",
    set: function set(v) {
      this.__set('playCount', v);
    }
  }, {
    key: "fps",
    set: function set(v) {
      this.__set('fps', v);
    }
  }, {
    key: "currentTime",
    set: function set(v) {
      this.__set('currentTime', v);
    }
  }, {
    key: "spfLimit",
    set: function set(v) {
      this.__set('spfLimit', v);
    }
  }, {
    key: "delay",
    set: function set(v) {
      this.__set('delay', v);
    }
  }, {
    key: "endDelay",
    set: function set(v) {
      this.__set('endDelay', v);
    }
  }, {
    key: "fill",
    set: function set(v) {
      this.__set('fill', v);
    }
  }, {
    key: "direction",
    set: function set(v) {
      this.__set('direction', v);
    }
  }]);

  return Controller;
}();

var MockPage = /*#__PURE__*/_createClass(function MockPage(texture, width, height) {
  _classCallCheck(this, MockPage);

  this.uuid = Page.genUuid();
  this.time = inject.now();
  this.texture = texture;
  this.width = width;
  this.height = height;
});

/**
 * 一个fbo离屏纹理，mock成cache，当webgl需要局部根节点汇总时生成，即cacheTotal，
 * 基于此纹理进行filter、mask等后处理渲染
 */

var MockCache = /*#__PURE__*/function () {
  function MockCache(gl, texture, sx1, sy1, width, height, bbox) {
    _classCallCheck(this, MockCache);

    this.gl = gl;
    this.x = 0;
    this.y = 0;
    this.sx1 = sx1;
    this.sy1 = sy1;
    this.width = width;
    this.height = height;
    this.bbox = bbox;
    this.available = true;
    this.__page = new MockPage(texture, width, height);
    this.dx = -bbox[0];
    this.dy = -bbox[1];
    this.dbx = sx1 - bbox[0];
    this.dby = sy1 - bbox[1];
  }

  _createClass(MockCache, [{
    key: "release",
    value: function release() {
      this.available = false;
      this.gl.deleteTexture(this.page.texture);
    }
  }, {
    key: "page",
    get: function get() {
      return this.__page;
    }
  }]);

  return MockCache;
}();

var vertexBlur = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoordsBlur[3];uniform vec2 u_direction;void main(){gl_Position=a_position;}"; // eslint-disable-line

var fragmentBlur = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoordsBlur[3];uniform sampler2D u_texture;void main(){gl_FragColor=vec4(0.0);}"; // eslint-disable-line

var vertexMbm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

var fragmentMultiply = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return((1.0-a2/a3)*c1*255.0+a2/a3*((1.0-a1)*c2*255.0+a1*c3*255.0))/255.0;}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=bottom*top;float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentScreen = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentOverlay = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(top.r,bottom.r),op(top.g,bottom.g),op(top.b,bottom.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentDarken = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return min(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentLighten = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return max(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentColorDodge = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==1.0){return a==0.0 ? a : 1.0;}return min(1.0,a/(1.0-b));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentColorBurn = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==0.0){return a==1.0 ? a : 0.0;}return 1.0-min(1.0,(1.0-a)/b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentHardLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentSoftLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5? a-(1.0-2.0*b)*a*(1.0-a): a+(2.0*b-1.0)*(a<=0.25?((16.0*a-12.0)*a+4.0)*a: sqrt(a)-a);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentDifference = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return abs(a-b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentExclusion = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-2.0*a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentHue = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(a);float l=getLuminosity(a);return setLuminosity(setSaturation(b,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentSaturation = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(b);float l=getLuminosity(a);return setLuminosity(setSaturation(a,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentColor = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(a);return setLuminosity(b,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var fragmentLuminosity = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(b);return setLuminosity(a,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

var canvasPolygon = painter.canvasPolygon;
var _enums$STYLE_KEY$7 = enums.STYLE_KEY,
    POSITION$1 = _enums$STYLE_KEY$7.POSITION,
    DISPLAY$1 = _enums$STYLE_KEY$7.DISPLAY,
    OPACITY = _enums$STYLE_KEY$7.OPACITY,
    VISIBILITY$1 = _enums$STYLE_KEY$7.VISIBILITY,
    FILTER$1 = _enums$STYLE_KEY$7.FILTER,
    OVERFLOW = _enums$STYLE_KEY$7.OVERFLOW,
    MIX_BLEND_MODE = _enums$STYLE_KEY$7.MIX_BLEND_MODE,
    FILL = _enums$STYLE_KEY$7.FILL,
    TRANSFORM = _enums$STYLE_KEY$7.TRANSFORM,
    TRANSFORM_ORIGIN = _enums$STYLE_KEY$7.TRANSFORM_ORIGIN,
    PERSPECTIVE$1 = _enums$STYLE_KEY$7.PERSPECTIVE,
    PERSPECTIVE_ORIGIN = _enums$STYLE_KEY$7.PERSPECTIVE_ORIGIN,
    _enums$NODE_KEY$1 = enums.NODE_KEY,
    NODE_CACHE$1 = _enums$NODE_KEY$1.NODE_CACHE,
    NODE_CACHE_TOTAL$1 = _enums$NODE_KEY$1.NODE_CACHE_TOTAL,
    NODE_CACHE_OVERFLOW$1 = _enums$NODE_KEY$1.NODE_CACHE_OVERFLOW,
    NODE_CACHE_MASK$1 = _enums$NODE_KEY$1.NODE_CACHE_MASK,
    NODE_CACHE_FILTER$1 = _enums$NODE_KEY$1.NODE_CACHE_FILTER,
    NODE_MATRIX = _enums$NODE_KEY$1.NODE_MATRIX,
    NODE_MATRIX_EVENT = _enums$NODE_KEY$1.NODE_MATRIX_EVENT,
    NODE_OPACITY = _enums$NODE_KEY$1.NODE_OPACITY,
    NODE_COMPUTED_STYLE$1 = _enums$NODE_KEY$1.NODE_COMPUTED_STYLE,
    NODE_CURRENT_STYLE$1 = _enums$NODE_KEY$1.NODE_CURRENT_STYLE,
    NODE_LIMIT_CACHE = _enums$NODE_KEY$1.NODE_LIMIT_CACHE,
    NODE_REFRESH_LV$1 = _enums$NODE_KEY$1.NODE_REFRESH_LV,
    NODE_CACHE_STYLE$1 = _enums$NODE_KEY$1.NODE_CACHE_STYLE,
    NODE_DEFS_CACHE = _enums$NODE_KEY$1.NODE_DEFS_CACHE,
    NODE_IS_MASK$1 = _enums$NODE_KEY$1.NODE_IS_MASK,
    NODE_DOM_PARENT$1 = _enums$NODE_KEY$1.NODE_DOM_PARENT,
    NODE_PERSPECTIVE_MATRIX = _enums$NODE_KEY$1.NODE_PERSPECTIVE_MATRIX,
    NODE_VIRTUAL_DOM = _enums$NODE_KEY$1.NODE_VIRTUAL_DOM,
    _enums$STRUCT_KEY$1 = enums.STRUCT_KEY,
    STRUCT_NODE$1 = _enums$STRUCT_KEY$1.STRUCT_NODE,
    STRUCT_TOTAL$1 = _enums$STRUCT_KEY$1.STRUCT_TOTAL,
    STRUCT_HAS_MASK = _enums$STRUCT_KEY$1.STRUCT_HAS_MASK,
    STRUCT_LV = _enums$STRUCT_KEY$1.STRUCT_LV;
var NONE$1 = o$1.NONE,
    TRANSFORM_ALL = o$1.TRANSFORM_ALL,
    OP = o$1.OPACITY,
    FT = o$1.FILTER,
    REPAINT$1 = o$1.REPAINT,
    contain$1 = o$1.contain,
    MBM = o$1.MIX_BLEND_MODE,
    PPT = o$1.PERSPECTIVE;
var isE = mx.isE,
    inverse = mx.inverse,
    multiply = mx.multiply;
var mbmName = mbm.mbmName,
    isValidMbm = mbm.isValidMbm; // 无cache时应用离屏时的优先级，从小到大，OFFSCREEN_MASK2是个特殊的

var OFFSCREEN_OVERFLOW = 0;
var OFFSCREEN_FILTER = 1;
var OFFSCREEN_MASK = 2;
var OFFSCREEN_BLEND = 3;
var OFFSCREEN_MASK2 = 4; // 依次从list获取首个available可用的cache

function getCache(list) {
  for (var i = 0, len = list.length; i < len; i++) {
    var item = list[i];

    if (item && item.available) {
      return item;
    }
  }
}
/**
 * 生成一个节点及其子节点所包含的矩形范围盒，canvas和webgl的最大尺寸限制不一样，由外部传入
 * 如果某个子节点超限，则视为整个超限，超限返回空
 * @param node
 * @param __structs
 * @param index
 * @param total
 * @param parentIndexHash
 * @param opacityHash
 * @param MAX
 * @param includeLimitCache webgl时即便超限也要强制生成total，所以标识不能跳出
 * @returns {*}
 */


function genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, MAX, includeLimitCache) {
  var sx1 = node.__sx1,
      sy1 = node.__sy1,
      __config = node.__config;
  var cache = __config[NODE_CACHE$1],
      _config$NODE_COMPUTE = __config[NODE_COMPUTED_STYLE$1],
      filter = _config$NODE_COMPUTE[FILTER$1],
      perspective = _config$NODE_COMPUTE[PERSPECTIVE$1],
      perspectiveOrigin = _config$NODE_COMPUTE[PERSPECTIVE_ORIGIN]; // 先将局部根节点的bbox算好，可能没内容是空

  var bboxTotal;

  if (cache && cache.available) {
    bboxTotal = cache.bbox.slice(0);
  } else {
    bboxTotal = node.bbox;
  } // 局部根节点如有perspective，则计算pm，这里不会出现嵌套，因为每个出现都会生成局部根节点


  var pm;

  if (perspective) {
    pm = tf.calPerspectiveMatrix(perspective, perspectiveOrigin);
  } // 广度遍历，不断一层层循环下去，用2个hash暂存每层的父matrix和opacity，blur只需记住顶层，因为子的如果有一定是cacheFilter


  var list = [index];
  var d = 0;
  filter.forEach(function (item) {
    var _item = _slicedToArray(item, 2),
        k = _item[0],
        v = _item[1];

    if (k === 'blur') {
      d = blur.outerSize(v);
    }
  });
  opacityHash[index] = 1; // opacity可以保存下来层级相乘结果供外部使用，但matrix不可以，因为这里按画布原点为坐标系计算，外部合并局部根节点以bbox左上角为原点

  var matrixHash = {};

  while (list.length) {
    var arr = list.splice(0);

    for (var i = 0, len = arr.length; i < len; i++) {
      var parentIndex = arr[i];

      var _total = __structs[parentIndex][STRUCT_TOTAL$1] || 0;

      for (var _i = parentIndex + 1, _len = parentIndex + _total + 1; _i < _len; _i++) {
        var _structs$_i = __structs[_i],
            node2 = _structs$_i[STRUCT_NODE$1],
            _total2 = _structs$_i[STRUCT_TOTAL$1]; // mask也不占bbox位置

        if (node2.isMask) {
          continue;
        }

        var __sx1 = node2.__sx1,
            __sy1 = node2.__sy1,
            _node2$__config = node2.__config,
            limitCache = _node2$__config[NODE_LIMIT_CACHE],
            __cache = _node2$__config[NODE_CACHE$1],
            __cacheTotal = _node2$__config[NODE_CACHE_TOTAL$1],
            __cacheFilter = _node2$__config[NODE_CACHE_FILTER$1],
            __cacheMask = _node2$__config[NODE_CACHE_MASK$1],
            __cacheOverflow = _node2$__config[NODE_CACHE_OVERFLOW$1],
            _node2$__config$NODE_ = _node2$__config[NODE_COMPUTED_STYLE$1],
            display = _node2$__config$NODE_[DISPLAY$1],
            visibility = _node2$__config$NODE_[VISIBILITY$1],
            transform = _node2$__config$NODE_[TRANSFORM],
            transformOrigin = _node2$__config$NODE_[TRANSFORM_ORIGIN],
            opacity = _node2$__config$NODE_[OPACITY]; // webgl不能跳过超限

        if (limitCache && !includeLimitCache) {
          return;
        } // display:none跳过整个节点树，visibility只跳过自身


        if (display === 'none') {
          _i += _total2 || 0;
          continue;
        }

        if (visibility === 'hidden') {
          continue;
        }

        parentIndexHash[_i] = parentIndex;
        opacityHash[_i] = opacityHash[parentIndex] * opacity; // 防止text的情况，其一定属于某个node，其bbox被计算过，text不应该计算

        if (node2 instanceof Text) {
          continue;
        }

        var bbox = void 0,
            dx = 0,
            dy = 0,
            hasTotal = void 0;
        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal]);

        if (target) {
          bbox = target.bbox.slice(0);
          dx = target.dbx;
          dy = target.dby;
          _i += _total2 || 0;
          hasTotal = true;
        } else if (__cache && __cache.available) {
          bbox = __cache.bbox.slice(0);
          dx = __cache.dbx;
          dy = __cache.dby;
        } else {
          bbox = node2.bbox;
        } // 可能Xom没有内容


        if (bbox) {
          bbox[0] -= sx1;
          bbox[1] -= sy1;
          bbox[2] -= sx1;
          bbox[3] -= sy1;
          var matrix = matrixHash[parentIndex]; // 父级matrix初始化E为null，自身不为E时才运算，可以加速

          if (transform && !isE(transform)) {
            var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

            tfo[0] += __sx1 - sx1 + dx;
            tfo[1] += __sy1 - sy1 + dy;
            var m = tf.calMatrixByOrigin(transform, tfo);

            if (matrix) {
              matrix = multiply(matrix, m);
            } else {
              matrix = m;
            }
          }

          if (matrix) {
            matrixHash[_i] = matrix;
          }

          if (pm) {
            matrix = multiply(pm, matrix);
          }

          bbox = util.transformBbox(bbox, matrix, d, d); // 有孩子才继续存入下层级广度运算

          if (_total2 && !hasTotal) {
            list.push(_i);
          }

          mergeBbox(bboxTotal, bbox, sx1, sy1);
        }
      }
    }
  }

  return [bboxTotal, pm];
}

function mergeBbox(bbox, t, sx1, sy1) {
  bbox[0] = Math.min(bbox[0], sx1 + t[0]);
  bbox[1] = Math.min(bbox[1], sy1 + t[1]);
  bbox[2] = Math.max(bbox[2], sx1 + t[2]);
  bbox[3] = Math.max(bbox[3], sy1 + t[3]);
}
/**
 * 生成局部根节点离屏缓存，当超限时返回空
 * @param renderMode
 * @param node
 * @param __config
 * @param index
 * @param total
 * @param __structs
 * @param cacheTop
 * @param cache
 * @returns {{enabled}|Cache|*}
 */


function genTotal(renderMode, node, __config, index, total, __structs, cacheTop, cache) {
  if (total === 0) {
    return cache;
  } // 存每层父亲的matrix和opacity和index，bbox计算过程中生成，缓存给下面渲染过程用


  var parentIndexHash = {};
  var opacityHash = {};

  var _genBboxTotal = genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, Cache.MAX),
      _genBboxTotal2 = _slicedToArray(_genBboxTotal, 1),
      bboxTotal = _genBboxTotal2[0];

  if (!bboxTotal) {
    return;
  }

  var sx1 = node.__sx1,
      sy1 = node.__sy1;

  if (cacheTop) {
    cacheTop.reset(bboxTotal, sx1, sy1);
  } else {
    cacheTop = Cache.getInstance(bboxTotal, sx1, sy1);
  } // 创建失败，再次降级


  if (!cacheTop || !cacheTop.enabled) {
    return;
  }

  cacheTop.__available = true;
  var _cacheTop = cacheTop,
      tx = _cacheTop.x,
      ty = _cacheTop.y,
      ctx = _cacheTop.ctx,
      dbx = _cacheTop.dbx,
      dby = _cacheTop.dby; // 先绘制自己的cache，起点所以matrix视作E为空，opacity固定1

  if (cache && cache.available) {
    ctx.globalAlpha = 1;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    Cache.drawCache(cache, cacheTop);
  } // 因为cacheTotal不总是以左上角原点为开始，所以必须每个节点重算matrix，合并box时计算的无法用到


  var matrixHash = {}; // 先序遍历汇总到total

  for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
    var _structs$i = __structs[i],
        _node = _structs$i[STRUCT_NODE$1],
        _total3 = _structs$i[STRUCT_TOTAL$1],
        hasMask = _structs$i[STRUCT_HAS_MASK];
    var _config = _node.__config;
    var parentIndex = parentIndexHash[i];
    var matrix = matrixHash[parentIndex]; // 父节点的在每个节点计算后保存，第一个为top的默认为E（空）

    var opacity = opacityHash[i]; // opacity在合并box时已经计算可以直接用
    // 先看text，visibility会在内部判断，display会被parent判断

    if (_node instanceof Text) {
      ctx.globalAlpha = opacity;
      var m = matrix || mx.identity();
      ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

      _node.render(renderMode, 0, ctx, true, tx - sx1 + dbx, ty - sy1 + dby);
    } // 再看total缓存/cache，都没有的是无内容的Xom节点
    else {
      var __cache = _config[NODE_CACHE$1],
          __cacheTotal = _config[NODE_CACHE_TOTAL$1],
          __cacheFilter = _config[NODE_CACHE_FILTER$1],
          __cacheMask = _config[NODE_CACHE_MASK$1],
          __cacheOverflow = _config[NODE_CACHE_OVERFLOW$1],
          isMask = _config[NODE_IS_MASK$1],
          _config$NODE_COMPUTED = _config[NODE_COMPUTED_STYLE$1],
          display = _config$NODE_COMPUTED[DISPLAY$1],
          visibility = _config$NODE_COMPUTED[VISIBILITY$1],
          transform = _config$NODE_COMPUTED[TRANSFORM],
          transformOrigin = _config$NODE_COMPUTED[TRANSFORM_ORIGIN],
          mixBlendMode = _config$NODE_COMPUTED[MIX_BLEND_MODE];

      if (display === 'none') {
        i += _total3 || 0;

        if (hasMask) {
          i += hasMask;
        }

        continue;
      } // mask和不可见不能被汇总到top上


      if (visibility === 'hidden' || isMask) {
        continue;
      }

      if (transform && !isE(transform)) {
        var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

        if (__cache && __cache.available) {
          tfo[0] += __cache.sx1;
          tfo[1] += __cache.sy1;
        } else {
          tfo[0] += _node.__sx1;
          tfo[1] += _node.__sy1;
        }

        var dx = -sx1 + dbx + tx;
        var dy = -sy1 + dby + ty;
        tfo[0] += dx;
        tfo[1] += dy;

        var _m = tf.calMatrixByOrigin(transform, tfo);

        if (matrix) {
          matrix = multiply(matrix, _m);
        } else {
          matrix = _m;
        }
      }

      if (matrix) {
        matrixHash[i] = matrix;
      }

      var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, __cache]);

      if (target) {
        if (isValidMbm(mixBlendMode)) {
          ctx.globalCompositeOperation = mbmName(mixBlendMode);
        } else {
          ctx.globalCompositeOperation = 'source-over';
        }

        ctx.globalAlpha = opacity;

        if (matrix) {
          ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        } else {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        Cache.drawCache(target, cacheTop);

        if (target !== __cache) {
          i += _total3 || 0;
          i += hasMask || 0;
        }
      }
    }
  }

  return cacheTop;
}

function genFilter(node, cache, v) {
  return Cache.genFilter(cache, v);
}

function genMask(node, cache) {
  var _node$computedStyle = node.computedStyle,
      transform = _node$computedStyle[TRANSFORM],
      transformOrigin = _node$computedStyle[TRANSFORM_ORIGIN];
  var isClip = node.next.isClip;
  return Cache.genMask(cache, node.next, isClip, transform, transformOrigin);
}

function genOverflow(node, cache) {
  var sbox = node.bbox;
  var bbox = cache.bbox; // 没超过无需生成

  if (bbox[0] >= sbox[0] && bbox[1] >= sbox[1] && bbox[2] <= sbox[2] && bbox[3] <= sbox[3]) {
    return;
  }

  return Cache.genOverflow(cache, node);
} // webgl不太一样，使用fbo离屏绘制到一个纹理上进行汇总


function genFrameBufferWithTexture(gl, texCache, width, height) {
  var n = texCache.lockOneChannel();
  var texture = webgl.createTexture(gl, null, n, width, height);
  var frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  if (check !== gl.FRAMEBUFFER_COMPLETE) {
    inject.error('Framebuffer object is incomplete: ' + check.toString());
  } // 离屏窗口0开始


  gl.viewport(0, 0, width, height);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  return [n, frameBuffer, texture];
}
/**
 * 局部根节点复合图层生成，汇总所有子节点到一颗局部树上的位图缓存，包含超限特殊情况
 * 即便只有自己一个也要返回，因为webgl生成total的原因是有类似filter/mask等必须离屏处理的东西
 * @param gl
 * @param texCache
 * @param node
 * @param __config
 * @param index
 * @param total
 * @param __structs
 * @param cache
 * @param limitCache
 * @param W
 * @param H
 * @returns {*}
 */


function genTotalWebgl(gl, texCache, node, __config, index, total, __structs, cache, limitCache, W, H) {
  // 存每层父亲的matrix和opacity和index，bbox计算过程中生成，缓存给下面渲染过程用
  var parentIndexHash = {};
  var opacityHash = {};

  var _genBboxTotal3 = genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, gl.getParameter(gl.MAX_TEXTURE_SIZE), limitCache),
      _genBboxTotal4 = _slicedToArray(_genBboxTotal3, 2),
      bboxTotal = _genBboxTotal4[0],
      parentPm = _genBboxTotal4[1]; // 可能局部根节点合成过程中发现整体超限


  var totalLimitCache;

  if (!bboxTotal) {
    totalLimitCache = true;
  } // 超限情况生成画布大小的特殊纹理


  if (limitCache || totalLimitCache) {
    bboxTotal = [0, 0, W, H];
  }

  var width = bboxTotal[2] - bboxTotal[0];
  var height = bboxTotal[3] - bboxTotal[1];

  var _genFrameBufferWithTe = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe2 = _slicedToArray(_genFrameBufferWithTe, 3),
      n = _genFrameBufferWithTe2[0],
      frameBuffer = _genFrameBufferWithTe2[1],
      texture = _genFrameBufferWithTe2[2]; // 以bboxTotal的左上角为原点生成离屏texture


  var sx1 = node.__sx1,
      sy1 = node.__sy1;
  var cx = width * 0.5,
      cy = height * 0.5;
  var dx = -bboxTotal[0],
      dy = -bboxTotal[1];
  var dbx = sx1 - bboxTotal[0],
      dby = sy1 - bboxTotal[1]; // 先绘制自己的cache，起点所以matrix视作E为空，opacity固定1

  if (cache && cache.available) {
    texCache.addTexAndDrawWhenLimit(gl, cache, 1, null, cx, cy, dx, dy);
  } // limitCache无cache需先绘制到统一的离屏画布上
  else if (limitCache) {
    var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');
    node.render(mode.WEBGL, 0, gl);
    var j = texCache.lockOneChannel();

    var _texture = webgl.createTexture(gl, c.canvas, j);

    var _mockCache = new MockCache(gl, _texture, 0, 0, width, height, [0, 0, width, height]);

    texCache.addTexAndDrawWhenLimit(gl, _mockCache, 1, null, cx, cy, 0, 0);
    texCache.refresh(gl, cx, cy);
    c.ctx.setTransform(1, 0, 0, 1, 0, 0);
    c.ctx.globalAlpha = 1;
    c.ctx.clearRect(0, 0, width, height);

    _mockCache.release();

    texCache.releaseLockChannel(j);
  } // 因为cacheTotal不总是以左上角原点为开始，所以必须每个节点重算matrix，合并box时计算的无法用到


  var matrixHash = {}; // 先序遍历汇总到total

  for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
    var _structs$i2 = __structs[i],
        _node2 = _structs$i2[STRUCT_NODE$1],
        _total4 = _structs$i2[STRUCT_TOTAL$1],
        hasMask = _structs$i2[STRUCT_HAS_MASK];
    var _config2 = _node2.__config;
    var parentIndex = parentIndexHash[i];
    var matrix = matrixHash[parentIndex]; // 父节点的在每个节点计算后保存，第一个为top的默认为E（空）

    var opacity = opacityHash[i]; // opacity在合并box时已经计算可以直接用
    // 先看text，visibility会在内部判断，display会被parent判断

    if (_node2 instanceof Text) {
      if (parentPm) {
        matrix = multiply(parentPm, matrix);
      }

      texCache.addTexAndDrawWhenLimit(gl, _config2[NODE_CACHE$1], opacity, matrix, cx, cy, dx, dy);
    } // 再看total缓存/cache，都没有的是无内容的Xom节点
    else {
      var __cache = _config2[NODE_CACHE$1],
          __cacheTotal = _config2[NODE_CACHE_TOTAL$1],
          __cacheFilter = _config2[NODE_CACHE_FILTER$1],
          __cacheMask = _config2[NODE_CACHE_MASK$1],
          __cacheOverflow = _config2[NODE_CACHE_OVERFLOW$1],
          isMask = _config2[NODE_IS_MASK$1],
          _config2$NODE_COMPUTE = _config2[NODE_COMPUTED_STYLE$1],
          display = _config2$NODE_COMPUTE[DISPLAY$1],
          visibility = _config2$NODE_COMPUTE[VISIBILITY$1],
          transform = _config2$NODE_COMPUTE[TRANSFORM],
          transformOrigin = _config2$NODE_COMPUTE[TRANSFORM_ORIGIN],
          mixBlendMode = _config2$NODE_COMPUTE[MIX_BLEND_MODE];

      if (display === 'none') {
        i += _total4 || 0;

        if (hasMask) {
          i += hasMask;
        }

        continue;
      } // mask和不可见不能被汇总到top上


      if (visibility === 'hidden' || isMask) {
        continue;
      }

      if (transform && !isE(transform)) {
        var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

        if (__cache && __cache.available) {
          tfo[0] += __cache.sx1;
          tfo[1] += __cache.sy1;
        } else {
          tfo[0] += _node2.__sx1;
          tfo[1] += _node2.__sy1;
        }

        var _dx = -sx1 + dbx;

        var _dy = -sy1 + dby;

        tfo[0] += _dx;
        tfo[1] += _dy;
        var m = tf.calMatrixByOrigin(transform, tfo);

        if (matrix) {
          matrix = multiply(matrix, m);
        } else {
          matrix = m;
        }
      }

      if (matrix) {
        matrixHash[i] = matrix;
      }

      if (parentPm) {
        matrix = multiply(parentPm, matrix);
      }

      var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, __cache]);

      if (target) {
        // 局部的mbm和主画布一样，先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
        if (isValidMbm(mixBlendMode)) {
          texCache.refresh(gl, cx, cy);

          var _genFrameBufferWithTe3 = genFrameBufferWithTexture(gl, texCache, width, height),
              _genFrameBufferWithTe4 = _slicedToArray(_genFrameBufferWithTe3, 3),
              n2 = _genFrameBufferWithTe4[0],
              frameBuffer2 = _genFrameBufferWithTe4[1],
              texture2 = _genFrameBufferWithTe4[2];

          texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy);
          texCache.refresh(gl, cx, cy); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前fbo作为绘制对象

          var _genMbmWebgl = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName(mixBlendMode), width, height);

          var _genMbmWebgl2 = _slicedToArray(_genMbmWebgl, 3);

          n = _genMbmWebgl2[0];
          frameBuffer = _genMbmWebgl2[1];
          texture = _genMbmWebgl2[2];
          gl.deleteFramebuffer(frameBuffer2);
          gl.deleteTexture(texture2);
        } else {
          texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy);
        }

        if (target !== __cache) {
          i += (_total4 || 0) + (hasMask || 0);
        }
      }
    }
  } // 绘制到fbo的纹理对象上并删除fbo恢复


  texCache.refresh(gl, cx, cy);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, W, H);
  gl.deleteFramebuffer(frameBuffer); // 生成的纹理对象本身已绑定一个纹理单元了，释放lock的同时可以给texCache的channel缓存，避免重复上传

  var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bboxTotal);
  texCache.releaseLockChannel(n, mockCache.page);
  return [limitCache || totalLimitCache, mockCache];
}

function genFilterWebgl(gl, texCache, node, cache, filter, W, H) {
  var sx1 = cache.sx1,
      sy1 = cache.sy1,
      width = cache.width,
      height = cache.height,
      bbox = cache.bbox;
  var mockCache = cache;
  filter.forEach(function (item) {
    var _item2 = _slicedToArray(item, 2),
        k = _item2[0],
        v = _item2[1];

    if (k === 'blur' && v > 0) {
      var res = genBlurWebgl(gl, texCache, mockCache, v, width, height, sx1, sy1, bbox);

      if (res) {
        var _res = _slicedToArray(res, 4);

        mockCache = _res[0];
        width = _res[1];
        height = _res[2];
        bbox = _res[3];
      }
    } else if (k === 'hue-rotate') {
      var rotation = geom$1.d2r(v % 360);
      var cosR = Math.cos(rotation);
      var sinR = Math.sin(rotation);

      var _res2 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + cosR * 0.787 - sinR * 0.213, 0.715 - cosR * 0.715 - sinR * 0.715, 0.072 - cosR * 0.072 + sinR * 0.928, 0, 0, 0.213 - cosR * 0.213 + sinR * 0.143, 0.715 + cosR * 0.285 + sinR * 0.140, 0.072 - cosR * 0.072 - sinR * 0.283, 0, 0, 0.213 - cosR * 0.213 - sinR * 0.787, 0.715 - cosR * 0.715 + sinR * 0.715, 0.072 + cosR * 0.928 + sinR * 0.072, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

      if (_res2) {
        var _res3 = _slicedToArray(_res2, 4);

        mockCache = _res3[0];
        width = _res3[1];
        height = _res3[2];
        bbox = _res3[3];
      }
    } else if (k === 'saturate' && v !== 100) {
      var amount = v * 0.01;

      var _res4 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + 0.787 * amount, 0.715 - 0.715 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 + 0.285 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 - 0.715 * amount, 0.072 + 0.928 * amount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

      if (_res4) {
        var _res5 = _slicedToArray(_res4, 4);

        mockCache = _res5[0];
        width = _res5[1];
        height = _res5[2];
        bbox = _res5[3];
      }
    } else if (k === 'brightness' && v !== 100) {
      var b = v * 0.01;

      var _res6 = genColorMatrixWebgl(gl, texCache, mockCache, [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

      if (_res6) {
        var _res7 = _slicedToArray(_res6, 4);

        mockCache = _res7[0];
        width = _res7[1];
        height = _res7[2];
        bbox = _res7[3];
      }
    } else if (k === 'grayscale' && v > 0) {
      var oneMinusAmount = 1 - v * 0.01;

      if (oneMinusAmount < 0) {
        oneMinusAmount = 0;
      } else if (oneMinusAmount > 1) {
        oneMinusAmount = 1;
      }

      var _res8 = genColorMatrixWebgl(gl, texCache, mockCache, [0.2126 + 0.7874 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 + 0.2848 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 + 0.9278 * oneMinusAmount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

      if (_res8) {
        var _res9 = _slicedToArray(_res8, 4);

        mockCache = _res9[0];
        width = _res9[1];
        height = _res9[2];
        bbox = _res9[3];
      }
    } else if (k === 'contrast' && v !== 100) {
      var _amount = v * 0.01;

      var o = -0.5 * _amount;

      var _res10 = genColorMatrixWebgl(gl, texCache, mockCache, [_amount, 0, 0, 0, o, 0, _amount, 0, 0, o, 0, 0, _amount, 0, o, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

      if (_res10) {
        var _res11 = _slicedToArray(_res10, 4);

        mockCache = _res11[0];
        width = _res11[1];
        height = _res11[2];
        bbox = _res11[3];
      }
    }
  }); // 切换回主程序

  gl.useProgram(gl.program);
  gl.viewport(0, 0, W, H);
  return mockCache;
}
/**
 * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
 * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核d扩大3倍性能慢
 * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
 * 先动态生成gl程序，默认3核源码示例已注释，根据sigma获得d（一定奇数），再计算权重
 * 然后将d尺寸和权重拼接成真正程序并编译成program，再开始绘制
 */


function genBlurWebgl(gl, texCache, cache, sigma, width, height, sx1, sy1, bbox) {
  var d = blur.kernelSize(sigma);
  var max = Math.max(15, gl.getParameter(gl.MAX_VARYING_VECTORS));

  while (d > max) {
    d -= 2;
  }

  var spread = blur.outerSizeByD(d);
  width += spread * 2;
  height += spread * 2; // 防止超限，webgl最大纹理尺寸限制

  var limit = gl.getParameter(gl.MAX_TEXTURE_SIZE);

  if (width > limit || height > limit) {
    return;
  }

  bbox = bbox.slice(0);
  bbox[0] -= spread;
  bbox[1] -= spread;
  bbox[2] += spread;
  bbox[3] += spread;
  var cx = width * 0.5,
      cy = height * 0.5;
  var weights = blur.gaussianWeight(sigma, d);
  var vert = '';
  var frag = '';
  var r = Math.floor(d * 0.5);

  for (var _i2 = 0; _i2 < r; _i2++) {
    var c = (r - _i2) * 0.01;
    vert += "\nv_texCoordsBlur[".concat(_i2, "] = a_texCoords + vec2(-").concat(c, ", -").concat(c, ") * u_direction;");
    frag += "\ngl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i2, "]) * ").concat(weights[_i2], ";");
  }

  vert += "\nv_texCoordsBlur[".concat(r, "] = a_texCoords;");
  frag += "\ngl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(r, "]) * ").concat(weights[r], ";");

  for (var _i3 = 0; _i3 < r; _i3++) {
    var _c = (_i3 + 1) * 0.01;

    vert += "\nv_texCoordsBlur[".concat(_i3 + r + 1, "] = a_texCoords + vec2(").concat(_c, ", ").concat(_c, ") * u_direction;");
    frag += "\ngl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i3 + r + 1, "]) * ").concat(weights[_i3 + r + 1], ";");
  }

  vert = vertexBlur.replace('[3]', '[' + d + ']').replace(/}$/, vert + '}');
  frag = fragmentBlur.replace('[3]', '[' + d + ']').replace(/}$/, frag + '}');
  var program = webgl.initShaders(gl, vert, frag);
  gl.useProgram(program);

  var _genFrameBufferWithTe5 = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe6 = _slicedToArray(_genFrameBufferWithTe5, 3),
      i = _genFrameBufferWithTe6[0],
      frameBuffer = _genFrameBufferWithTe6[1],
      texture = _genFrameBufferWithTe6[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


  var j = texCache.findExistTexChannel(cache.page);

  if (j === -1) {
    // 直接绑定，因为一定是个mockCache
    j = texCache.lockOneChannel();
    webgl.bindTexture(gl, cache.page.texture, j);
  } else {
    texCache.lockChannel(j);
  }

  texture = webgl.drawBlur(gl, program, frameBuffer, texCache, texture, cache.page.texture, i, j, width, height, cx, cy, spread, d, sigma); // 销毁这个临时program

  gl.deleteShader(program.vertexShader);
  gl.deleteShader(program.fragmentShader);
  gl.deleteProgram(program);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(frameBuffer);
  texCache.releaseLockChannel(j);
  var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox);
  texCache.releaseLockChannel(i, mockCache.page);
  return [mockCache, width, height, bbox];
}

function genColorMatrixWebgl(gl, texCache, cache, m, width, height, sx1, sy1, bbox) {
  // 生成最终纹理，尺寸为被遮罩节点大小
  var _genFrameBufferWithTe7 = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe8 = _slicedToArray(_genFrameBufferWithTe7, 3),
      i = _genFrameBufferWithTe8[0],
      frameBuffer = _genFrameBufferWithTe8[1],
      texture = _genFrameBufferWithTe8[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


  var j = texCache.findExistTexChannel(cache.page);

  if (j === -1) {
    // 直接绑定，因为一定是个mockCache
    j = texCache.lockOneChannel();
    webgl.bindTexture(gl, cache.page.texture, j);
  } else {
    texCache.lockChannel(j);
  }

  gl.useProgram(gl.programCm);
  webgl.drawCm(gl, gl.programCm, j, m);
  texCache.releaseLockChannel(j); // 切回

  gl.useProgram(gl.program);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

  var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox.slice(0));
  texCache.releaseLockChannel(i, mockCache.page);
  return [mockCache, width, height, bbox];
}

function genOverflowWebgl(gl, texCache, node, cache, W, H) {
  var sbox = node.bbox.slice(0);
  var bbox = cache.bbox; // 没超过无需生成

  if (bbox[0] >= sbox[0] && bbox[1] >= sbox[1] && bbox[2] <= sbox[2] && bbox[3] <= sbox[3]) {
    return;
  }

  var width = sbox[2] - sbox[0],
      height = sbox[3] - sbox[1]; // 生成最终纹理，尺寸为被遮罩节点大小

  var _genFrameBufferWithTe9 = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe10 = _slicedToArray(_genFrameBufferWithTe9, 3),
      i = _genFrameBufferWithTe10[0],
      frameBuffer = _genFrameBufferWithTe10[1],
      texture = _genFrameBufferWithTe10[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


  var j = texCache.findExistTexChannel(cache.page);

  if (j === -1) {
    // 直接绑定，因为一定是个mockCache
    j = texCache.lockOneChannel();
    webgl.bindTexture(gl, cache.page.texture, j);
  } else {
    texCache.lockChannel(j);
  } // 绘制，根据坐标裁剪使用原本纹理的一部分


  gl.useProgram(gl.programOverflow);
  webgl.drawOverflow(gl, j, sbox[0] - bbox[0], sbox[1] - bbox[1], width, height, cache.width, cache.height);
  texCache.releaseLockChannel(j); // 切回

  gl.useProgram(gl.program);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, W, H);
  gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

  var overflowCache = new MockCache(gl, texture, cache.sx1, cache.sy1, width, height, sbox);
  texCache.releaseLockChannel(i, overflowCache.page);
  return overflowCache;
}

function genMaskWebgl(gl, texCache, node, __config, cache, W, H) {
  var sx1 = cache.sx1,
      sy1 = cache.sy1,
      width = cache.width,
      height = cache.height,
      bbox = cache.bbox; // cache一定是mockCache，可能是total/filter/overflow一种

  var cx = width * 0.5,
      cy = height * 0.5;
  var dx = -bbox[0],
      dy = -bbox[1]; // 先求得被遮罩的matrix，用作inverse给mask计算

  var _config$NODE_COMPUTE2 = __config[NODE_COMPUTED_STYLE$1],
      transform = _config$NODE_COMPUTE2[TRANSFORM],
      transformOrigin = _config$NODE_COMPUTE2[TRANSFORM_ORIGIN];
  var inverse;

  if (isE(transform)) {
    inverse = mx.identity();
  } else {
    var tfo = transformOrigin.slice(0);
    tfo[0] += sx1 + dx;
    tfo[1] += sy1 + dy;
    inverse = tf.calMatrixByOrigin(transform, tfo);
  }

  inverse = mx.inverse(inverse); // 将所有mask绘入一个单独纹理中，尺寸和原点与被遮罩total相同，才能做到顶点坐标一致

  var _genFrameBufferWithTe11 = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe12 = _slicedToArray(_genFrameBufferWithTe11, 3),
      i = _genFrameBufferWithTe12[0],
      frameBuffer = _genFrameBufferWithTe12[1],
      texture = _genFrameBufferWithTe12[2];

  var next = node.next;

  while (next && next.isMask) {
    var _config3 = next.__config;
    var __cache = _config3[NODE_CACHE$1],
        __cacheFilter = _config3[NODE_CACHE_FILTER$1],
        __cacheOverflow = _config3[NODE_CACHE_OVERFLOW$1],
        _config3$NODE_COMPUTE = _config3[NODE_COMPUTED_STYLE$1],
        display = _config3$NODE_COMPUTE[DISPLAY$1],
        visibility = _config3$NODE_COMPUTE[VISIBILITY$1],
        opacity = _config3$NODE_COMPUTE[OPACITY],
        _transform = _config3$NODE_COMPUTE[TRANSFORM],
        _transformOrigin = _config3$NODE_COMPUTE[TRANSFORM_ORIGIN];

    if (display === 'none' || visibility === 'hidden') {
      continue;
    } // total无用，都是单节点


    var target = getCache([__cacheFilter, __cacheOverflow, __cache]);

    if (target) {
      var m = void 0;

      if (isE(_transform)) {
        m = mx.identity();
      } else {
        var tfo = _transformOrigin.slice(0);

        tfo[0] += target.bbox[0] + dx;
        tfo[1] += target.bbox[1] + dy;
        m = tf.calMatrixByOrigin(_transform, tfo);
      }

      m = mx.multiply(inverse, m); // m = mx.m2Mat4(m, cx, cy);

      texCache.addTexAndDrawWhenLimit(gl, target, opacity, m, cx, cy, dx, dy);
    } // 异常情况超限
    else if (_config3[NODE_LIMIT_CACHE]) {
      return;
    }

    next = next.next;
  }

  texCache.refresh(gl, cx, cy);
  gl.deleteFramebuffer(frameBuffer); // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况mask变更引发的可能不在

  var j = texCache.findExistTexChannel(cache.page);

  if (j === -1) {
    // 直接绑定，因为一定是个mockCache
    j = texCache.lockOneChannel();
    webgl.bindTexture(gl, cache.page.texture, j);
  } else {
    texCache.lockChannel(j);
  } // 生成最终纹理，汇总total和maskCache


  var _genFrameBufferWithTe13 = genFrameBufferWithTexture(gl, texCache, width, height),
      _genFrameBufferWithTe14 = _slicedToArray(_genFrameBufferWithTe13, 3),
      n = _genFrameBufferWithTe14[0],
      frameBuffer2 = _genFrameBufferWithTe14[1],
      texture2 = _genFrameBufferWithTe14[2];

  var isClip = node.next.isClip;
  var program;

  if (isClip) {
    program = gl.programClip;
  } else {
    program = gl.programMask;
  }

  gl.useProgram(program);
  webgl.drawMask(gl, i, j, program);
  gl.deleteTexture(texture);
  texCache.releaseLockChannel(i);
  texCache.releaseLockChannel(j); // 切换回主程序

  gl.useProgram(gl.program);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, W, H);
  gl.deleteFramebuffer(frameBuffer2); // 同total一样生成一个mockCache

  var maskCache = new MockCache(gl, texture2, sx1, sy1, width, height, bbox);
  texCache.releaseLockChannel(n, maskCache.page);
  return maskCache;
}
/**
 * 生成blendMode混合fbo纹理结果，原本是所有元素向一个fbo记A进行绘制，当出现mbm时，进入到这里，
 * 先生成一个新的fbo记B，将A和待混合节点进行对应的mbm模式混合，结果绘制到B中，然后返回B来替换A，包括纹理单元
 * @param gl
 * @param texCache
 * @param i 之前已有的fbo和纹理单元
 * @param j 当前节点绘制的fbo和纹理单元
 * @param mbm
 * @param fbo 之前舞台绑定的fbo和纹理
 * @param tex
 * @param W
 * @param H
 * @returns {number|*}
 */


function genMbmWebgl(gl, texCache, i, j, fbo, tex, mbm, W, H) {
  var frag;
  mbm = mbmName(mbm);

  if (mbm === 'multiply') {
    frag = fragmentMultiply;
  } else if (mbm === 'screen') {
    frag = fragmentScreen;
  } else if (mbm === 'overlay') {
    frag = fragmentOverlay;
  } else if (mbm === 'darken') {
    frag = fragmentDarken;
  } else if (mbm === 'lighten') {
    frag = fragmentLighten;
  } else if (mbm === 'color-dodge') {
    frag = fragmentColorDodge;
  } else if (mbm === 'color-burn') {
    frag = fragmentColorBurn;
  } else if (mbm === 'hard-light') {
    frag = fragmentHardLight;
  } else if (mbm === 'soft-light') {
    frag = fragmentSoftLight;
  } else if (mbm === 'difference') {
    frag = fragmentDifference;
  } else if (mbm === 'exclusion') {
    frag = fragmentExclusion;
  } else if (mbm === 'hue') {
    frag = fragmentHue;
  } else if (mbm === 'saturation') {
    frag = fragmentSaturation;
  } else if (mbm === 'color') {
    frag = fragmentColor;
  } else if (mbm === 'luminosity') {
    frag = fragmentLuminosity;
  }

  var program = webgl.initShaders(gl, vertexMbm, frag);
  gl.useProgram(program); // 生成新的fbo，将混合结果绘入

  var _genFrameBufferWithTe15 = genFrameBufferWithTexture(gl, texCache, W, H),
      _genFrameBufferWithTe16 = _slicedToArray(_genFrameBufferWithTe15, 3),
      n = _genFrameBufferWithTe16[0],
      frameBuffer = _genFrameBufferWithTe16[1],
      texture = _genFrameBufferWithTe16[2];

  webgl.drawMbm(gl, program, i, j, W, H); // 切换回主程序并销毁这个临时program

  gl.useProgram(gl.program);
  gl.deleteShader(program.vertexShader);
  gl.deleteShader(program.fragmentShader);
  gl.deleteProgram(program);
  gl.deleteFramebuffer(fbo);
  gl.deleteTexture(tex);
  texCache.releaseLockChannel(i);
  texCache.releaseLockChannel(j);
  return [n, frameBuffer, texture];
}

function applyOffscreen(ctx, list, width, height) {
  list.sort(function (a, b) {
    if (a[1] === b[1]) {
      if (a[0] === b[0]) {
        return a[2] - b[2];
      }

      return b[0] - a[0];
    }

    return b[1] - a[1];
  });
  list.forEach(function (item) {
    var _item3 = _slicedToArray(item, 4),
        type = _item3[2],
        offscreen = _item3[3];

    if (type === OFFSCREEN_OVERFLOW) {
      var matrix = offscreen.matrix,
          target = offscreen.target,
          origin = offscreen.ctx,
          x = offscreen.x,
          y = offscreen.y,
          offsetWidth = offscreen.offsetWidth,
          offsetHeight = offscreen.offsetHeight,
          _list = offscreen.list;
      ctx.globalCompositeOperation = 'destination-in';
      ctx.globalAlpha = 1;
      ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      ctx.fillStyle = '#FFF';
      ctx.beginPath();

      if (_list) {
        canvasPolygon(ctx, _list);
      } else {
        ctx.rect(x, y, offsetWidth, offsetHeight);
      }

      ctx.fill();
      ctx.closePath();
      ctx.globalCompositeOperation = 'source-over';
      target.draw();
      ctx = origin;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalAlpha = 1;
      ctx.drawImage(target.canvas, 0, 0, width, height, 0, 0, width, height);
      ctx.draw && ctx.draw(true);
      target.ctx.setTransform(1, 0, 0, 1, 0, 0);
      target.ctx.clearRect(0, 0, width, height);
      target.draw();
      inject.releaseCacheCanvas(target.canvas);
    } else if (type === OFFSCREEN_FILTER) {
      var _target = offscreen.target,
          _origin = offscreen.ctx,
          filter = offscreen.filter; // 申请一个新的离屏，应用blur并绘制，如没有则降级，默认ctx.filter为'none'

      if (ctx.filter) {
        var apply = inject.getCacheCanvas(width, height, null, 'filter2');
        apply.ctx.filter = painter.canvasFilter(filter);
        apply.ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
        apply.ctx.filter = 'none';
        apply.draw();
        _target.ctx.globalAlpha = 1;

        _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target.ctx.clearRect(0, 0, width, height);

        _target.ctx.drawImage(apply.canvas, 0, 0, width, height, 0, 0, width, height);

        _target.draw();

        apply.ctx.setTransform(1, 0, 0, 1, 0, 0);
        apply.ctx.clearRect(0, 0, width, height);
        apply.draw();
        inject.releaseCacheCanvas(apply.canvas);
      } // 绘制回主画布，如果不支持则等同无filter原样绘制


      ctx = _origin;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalAlpha = 1;
      ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
      ctx.draw && ctx.draw(true);

      _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

      _target.ctx.globalAlpha = 1;

      _target.ctx.clearRect(0, 0, width, height);

      _target.draw();

      inject.releaseCacheCanvas(_target.canvas);
    } else if (type === OFFSCREEN_MASK) {
      var mask = offscreen.mask,
          isClip = offscreen.isClip;

      if (isClip) {
        offscreen.target.draw();
        ctx = mask.ctx;
        ctx.globalCompositeOperation = 'source-out';
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(offscreen.target.canvas, 0, 0, width, height, 0, 0, width, height);
        mask.draw();
        ctx.globalCompositeOperation = 'source-over';
        offscreen.target.ctx.setTransform(1, 0, 0, 1, 0, 0);
        offscreen.target.ctx.clearRect(0, 0, width, height);
        offscreen.target.draw();
        inject.releaseCacheCanvas(offscreen.target.canvas);
        ctx = offscreen.ctx;
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
        ctx.draw && ctx.draw(true);
        mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
        mask.ctx.clearRect(0, 0, width, height);
        mask.draw();
        inject.releaseCacheCanvas(mask.canvas);
      } else {
        mask.draw();
        var _target2 = offscreen.target;
        ctx = _target2.ctx;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
        ctx.globalCompositeOperation = 'source-over';

        _target2.draw();

        mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
        mask.ctx.clearRect(0, 0, width, height);
        mask.draw();
        inject.releaseCacheCanvas(mask.canvas);
        ctx = offscreen.ctx;
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(_target2.canvas, 0, 0, width, height, 0, 0, width, height);
        ctx.draw && ctx.draw(true);

        _target2.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target2.ctx.clearRect(0, 0, width, height);

        _target2.draw();

        inject.releaseCacheCanvas(_target2.canvas);
      }
    } else if (type === OFFSCREEN_BLEND) {
      var _target3 = offscreen.target;
      ctx = offscreen.ctx;
      ctx.globalCompositeOperation = offscreen.mixBlendMode;

      _target3.draw();

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.globalAlpha = 1;
      ctx.drawImage(_target3.canvas, 0, 0, width, height, 0, 0, width, height);
      ctx.globalCompositeOperation = 'source-over';
      ctx.draw && ctx.draw(true);
      _target3.ctx.globalAlpha = 1;

      _target3.ctx.setTransform(1, 0, 0, 1, 0, 0);

      _target3.ctx.clearRect(0, 0, width, height);

      _target3.draw();

      inject.releaseCacheCanvas(_target3.canvas);
    } // 特殊的mask节点汇总结束，还原ctx
    else if (type === OFFSCREEN_MASK2) {
      ctx = offscreen.ctx;
    }
  });
  return ctx;
}

function renderCacheCanvas(renderMode, ctx, root) {
  var __structs = root.__structs,
      width = root.width,
      height = root.height; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

  var matrixList = [];
  var parentMatrix;
  var opacityList = [];
  var parentOpacity = 1;
  var lastConfig;
  var lastLv = 0;
  var mergeList = [];
  /**
   * 先一遍先序遍历每个节点绘制到自己__cache上，排除Text和已有的缓存以及局部根缓存，
   * 根据refreshLevel进行等级区分，可能是<REPAINT或>=REPAINT，REFLOW布局已前置处理完。
   * 首次绘制没有catchTotal等，后续则可能会有，在<REPAINT可据此跳过所有子节点加快循环，布局过程会提前删除它们。
   * lv的变化根据大小相等进行出入栈parent操作，实现获取节点parent数据的方式，
   * 同时过程中计算出哪些节点要生成局部根，存下来
   */

  for (var i = 0, len = __structs.length; i < len; i++) {
    var _structs$i3 = __structs[i],
        node = _structs$i3[STRUCT_NODE$1],
        lv = _structs$i3[STRUCT_LV],
        total = _structs$i3[STRUCT_TOTAL$1],
        hasMask = _structs$i3[STRUCT_HAS_MASK]; // 排除Text，要么根节点直接绘制，要么被局部根节点汇总，自身并不缓存（fillText比位图更快）

    if (node instanceof Text) {
      continue;
    }

    var __config = node.__config; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点是第一个特殊处理

    if (i === 0) ; else if (lv > lastLv) {
      parentMatrix = lastConfig[NODE_MATRIX_EVENT];

      if (isE(parentMatrix)) {
        parentMatrix = null;
      }

      matrixList.push(parentMatrix);
      parentOpacity = lastConfig[NODE_OPACITY];
      opacityList.push(parentOpacity);
    } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
    else if (lv < lastLv) {
      var diff = lastLv - lv;
      matrixList.splice(-diff);
      parentMatrix = matrixList[lv - 1];
      opacityList.splice(-diff);
      parentOpacity = opacityList[lv - 1];
    } // 不变是同级兄弟，无需特殊处理
    else ;

    lastConfig = __config;
    lastLv = lv;
    var refreshLevel = __config[NODE_REFRESH_LV$1],
        __cacheTotal = __config[NODE_CACHE_TOTAL$1],
        computedStyle = __config[NODE_COMPUTED_STYLE$1]; // 跳过display:none元素和它的所有子节点

    if (computedStyle[DISPLAY$1] === 'none') {
      i += total || 0; // 只跳过自身不能跳过后面的mask，mask要渲染自身并进行缓存cache，以备对象切换display用

      continue;
    }

    var hasRecordAsMask = void 0;
    /**
     * lv<REPAINT，一般会有__cache，跳过渲染过程，快速运算，没有cache则是自身超限或无内容，目前不感知
     * 可能有cacheTotal，为之前生成的局部根，清除逻辑在更新检查是否>=REPAINT那里，小变化不动
     * 当有遮罩时，如果被遮罩节点本身无变更，需要检查其next的遮罩节点有无变更，
     * 但其实不用检查，因为next变更一定会清空cacheMask，只要检查cacheMask即可
     * 如果没有或无效，直接添加，无视节点本身变化，后面防重即可
     */

    if (refreshLevel < REPAINT$1) {
      __config[NODE_REFRESH_LV$1] = NONE$1;

      if (hasMask) {
        var cacheMask = __config[NODE_CACHE_MASK$1];

        if (!cacheMask || !cacheMask.available) {
          hasRecordAsMask = [i, lv, total, node, __config, hasMask];
          mergeList.push(hasRecordAsMask);
        }
      }

      var currentStyle = __config[NODE_CURRENT_STYLE$1],
          __cacheStyle = __config[NODE_CACHE_STYLE$1],
          matrixEvent = __config[NODE_MATRIX_EVENT];
      var matrix = void 0;

      if (contain$1(refreshLevel, TRANSFORM_ALL)) {
        matrix = node.__calMatrix(refreshLevel, __cacheStyle, currentStyle, computedStyle, __config); // 恶心的v8性能优化

        var m = __config[NODE_MATRIX];
        util.assignMatrix(m, matrix);
      } else {
        matrix = __config[NODE_MATRIX];
      } // 父不为E时要点乘继承父的


      if (parentMatrix) {
        matrix = multiply(parentMatrix, matrix);
      } // 恶心的v8性能优化


      util.assignMatrix(matrixEvent, matrix);
      var opacity = void 0;

      if (contain$1(refreshLevel, OP)) {
        opacity = computedStyle[OPACITY] = currentStyle[OPACITY];
      } else {
        opacity = computedStyle[OPACITY];
      }

      __config[NODE_OPACITY] = parentOpacity * opacity; // filter会改变bbox范围

      if (contain$1(refreshLevel, FT)) {
        node.__bbox = null;

        var _filter = node.__calFilter(currentStyle, computedStyle);

        var __cacheFilter = __config[NODE_CACHE_FILTER$1];

        if (__cacheFilter) {
          __cacheFilter.release();
        } // 防重


        if (hasRecordAsMask) {
          hasRecordAsMask[6] = _filter;
        } else {
          // 强制存hasMask，因为filter改变影响mask
          hasRecordAsMask = [i, lv, total, node, __config, hasMask, _filter];
          mergeList.push(hasRecordAsMask);
        }
      }

      if (contain$1(refreshLevel, MBM)) {
        computedStyle[MIX_BLEND_MODE] = currentStyle[MIX_BLEND_MODE];
      } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


      if (__cacheTotal && __cacheTotal.available) {
        i += total || 0;
        continue;
      }
    }
    /**
     * >=REPAINT重新渲染，并根据结果判断是否离屏限制limitCache
     * Geom没有子节点无需汇总局部根，Dom中Img也是，它们的局部根等于自身的cache，其它符合条件的Dom需要生成
     */
    else {
      node.render(renderMode, refreshLevel, ctx, true);
    } // 每个元素检查cacheTotal生成，已有的上面会continue跳过


    var limitCache = __config[NODE_LIMIT_CACHE];
    var position = computedStyle[POSITION$1],
        overflow = computedStyle[OVERFLOW],
        filter = computedStyle[FILTER$1],
        mixBlendMode = computedStyle[MIX_BLEND_MODE];

    if (!limitCache && (hasMask || position === 'absolute' || filter.length || overflow === 'hidden' && total || isValidMbm(mixBlendMode))) {
      if (hasRecordAsMask) {
        hasRecordAsMask[6] = filter;
        hasRecordAsMask[7] = overflow;
      } else {
        mergeList.push([i, lv, total, node, __config, hasMask, filter, overflow]);
      }
    }
  } // 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
  // 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩


  if (mergeList.length) {
    mergeList.sort(function (a, b) {
      if (a[1] === b[1]) {
        return b[0] - a[0];
      }

      return b[1] - a[1];
    });
    mergeList.forEach(function (item) {
      var _item4 = _slicedToArray(item, 8),
          i = _item4[0],
          total = _item4[2],
          node = _item4[3],
          __config = _item4[4],
          hasMask = _item4[5],
          filter = _item4[6],
          overflow = _item4[7];

      var __cache = __config[NODE_CACHE$1],
          __cacheTotal = __config[NODE_CACHE_TOTAL$1],
          __cacheFilter = __config[NODE_CACHE_FILTER$1],
          __cacheMask = __config[NODE_CACHE_MASK$1],
          __cacheOverflow = __config[NODE_CACHE_OVERFLOW$1];
      var needGen; // 可能没变化，比如被遮罩节点、filter变更等

      if (!__cacheTotal || !__cacheTotal.available) {
        __cacheTotal = genTotal(renderMode, node, __config, i, total || 0, __structs, __cacheTotal, __cache);

        if (__cacheTotal && __cacheTotal !== __cache) {
          __config[NODE_CACHE_TOTAL$1] = __cacheTotal;
        }

        needGen = true;
      } // 防止失败超限，必须有total结果


      if (__cacheTotal && __cacheTotal.available) {
        var target = __cacheTotal;

        if (overflow === 'hidden') {
          if (!__cacheOverflow || !__cacheOverflow.available || needGen) {
            __config[NODE_CACHE_OVERFLOW$1] = genOverflow(node, target);
            needGen = true;
          }

          target = __config[NODE_CACHE_OVERFLOW$1] || target;
        }

        if (filter && filter.length) {
          if (!__cacheFilter || !__cacheFilter.available || needGen) {
            __config[NODE_CACHE_FILTER$1] = genFilter(node, target, filter);
            needGen = true;
          }

          target = __config[NODE_CACHE_FILTER$1] || target;
        }

        if (hasMask && (!__cacheMask || !__cacheMask.available || needGen)) {
          __config[NODE_CACHE_MASK$1] = genMask(node, target);
        }
      }
    });
  }
  /**
   * 最后先序遍历一次应用__cacheTotal即可，没有的用__cache，以及剩下的超尺寸的和Text
   * 超尺寸的依旧要走无cache逻辑render，这部分和无cache渲染很像
   */


  var maskStartHash = {};
  var offscreenHash = {};

  for (var _i4 = 0, _len2 = __structs.length; _i4 < _len2; _i4++) {
    var _structs$_i2 = __structs[_i4],
        _node3 = _structs$_i2[STRUCT_NODE$1],
        _lv = _structs$_i2[STRUCT_LV],
        _total5 = _structs$_i2[STRUCT_TOTAL$1],
        _hasMask = _structs$_i2[STRUCT_HAS_MASK];
    var _config4 = _node3.__config; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

    if (_node3 instanceof Text) {
      var _config4$NODE_DOM_PAR = _config4[NODE_DOM_PARENT$1].__config,
          _opacity = _config4$NODE_DOM_PAR[NODE_OPACITY],
          _matrixEvent = _config4$NODE_DOM_PAR[NODE_MATRIX_EVENT];
      ctx.globalAlpha = _opacity;
      ctx.setTransform(_matrixEvent[0], _matrixEvent[1], _matrixEvent[4], _matrixEvent[5], _matrixEvent[12], _matrixEvent[13]);

      _node3.render(renderMode, 0, ctx);

      if (offscreenHash.hasOwnProperty(_i4)) {
        ctx = applyOffscreen(ctx, offscreenHash[_i4], width, height);
      }
    } else {
      var _opacity2 = _config4[NODE_OPACITY],
          _matrixEvent2 = _config4[NODE_MATRIX_EVENT],
          _limitCache = _config4[NODE_LIMIT_CACHE],
          __cache = _config4[NODE_CACHE$1],
          _cacheTotal = _config4[NODE_CACHE_TOTAL$1],
          _cacheFilter = _config4[NODE_CACHE_FILTER$1],
          __cacheMask = _config4[NODE_CACHE_MASK$1],
          __cacheOverflow = _config4[NODE_CACHE_OVERFLOW$1],
          _refreshLevel = _config4[NODE_REFRESH_LV$1],
          _config4$NODE_COMPUTE = _config4[NODE_COMPUTED_STYLE$1],
          display = _config4$NODE_COMPUTE[DISPLAY$1],
          visibility = _config4$NODE_COMPUTE[VISIBILITY$1],
          _overflow = _config4$NODE_COMPUTE[OVERFLOW],
          _filter2 = _config4$NODE_COMPUTE[FILTER$1],
          _mixBlendMode = _config4$NODE_COMPUTE[MIX_BLEND_MODE]; // 有total的可以直接绘制并跳过子节点索引

      var target = getCache([__cacheMask, _cacheFilter, __cacheOverflow, _cacheTotal]); // total的尝试

      if (target) {
        _i4 += (_total5 || 0) + (_hasMask || 0); // total的none直接跳过

        if (display === 'none') {
          continue;
        }

        if (isValidMbm(_mixBlendMode)) {
          ctx.globalCompositeOperation = mbmName(_mixBlendMode);
        } else {
          ctx.globalCompositeOperation = 'source-over';
        }

        Cache.draw(ctx, _opacity2, _matrixEvent2, target); // total应用后记得设置回来

        ctx.globalCompositeOperation = 'source-over'; // 父超限但子有total的时候，i此时已经增加到了末尾，也需要检查

        if (offscreenHash.hasOwnProperty(_i4)) {
          ctx = applyOffscreen(ctx, offscreenHash[_i4], width, height);
        }
      } // 自身cache尝试
      else {
        if (maskStartHash.hasOwnProperty(_i4)) {
          var _maskStartHash$_i = _slicedToArray(maskStartHash[_i4], 3),
              idx = _maskStartHash$_i[0],
              n = _maskStartHash$_i[1],
              _offscreenMask = _maskStartHash$_i[2];

          var _target4 = inject.getCacheCanvas(width, height, null, 'mask2');

          _offscreenMask.mask = _target4; // 应用mask用到

          _offscreenMask.isClip = _node3.isClip; // 定位到最后一个mask元素上的末尾

          var j = _i4 + (_total5 || 0) + 1;

          while (--n) {
            var _total6 = __structs[j][STRUCT_TOTAL$1];
            j += (_total6 || 0) + 1;
          }

          j--;
          var list = offscreenHash[j] = offscreenHash[j] || [];
          list.push([idx, _lv, OFFSCREEN_MASK, _offscreenMask]);
          list.push([j, _lv, OFFSCREEN_MASK2, {
            ctx: ctx,
            // 保存等待OFFSCREEN_MASK2时还原
            target: _target4
          }]);
          ctx = _target4.ctx;
        }

        var offscreenBlend = void 0,
            offscreenMask = void 0,
            offscreenFilter = void 0,
            offscreenOverflow = void 0; // 这里比较特殊，可能会有__cache但超限没被汇聚到total上，需mock出离屏对象数据，还有可能本身就超限

        if (__cache && __cache.available || _limitCache) {
          if (__cache && __cache.available) {
            // 有cache但没生成total的都在这
            if (isValidMbm(_mixBlendMode)) {
              var c = inject.getCacheCanvas(width, height, null, 'blend');
              offscreenBlend = {
                ctx: ctx,
                target: c,
                mixBlendMode: mbmName(_mixBlendMode),
                matrix: _matrixEvent2
              };
              ctx = c.ctx;
            }

            if (_hasMask) {
              var _c2 = inject.getCacheCanvas(width, height, null, 'mask1');

              offscreenMask = {
                ctx: ctx,
                target: _c2,
                matrix: _matrixEvent2
              };
              ctx = _c2.ctx;
            }

            if (_filter2 && _filter2.length) {
              var _c3 = inject.getCacheCanvas(width, height, null, 'filter1');

              offscreenFilter = {
                ctx: ctx,
                filter: _filter2,
                target: _c3,
                matrix: _matrixEvent2
              };
              ctx = _c3.ctx;
            }

            if (_overflow === 'hidden' && display !== 'inline') {
              var _c4 = inject.getCacheCanvas(width, height, null, 'overflow');

              offscreenOverflow = {
                ctx: ctx,
                target: _c4,
                matrix: _matrixEvent2,
                x: __cache.sx1,
                y: __cache.sy1,
                offsetWidth: _node3.offsetWidth,
                offsetHeight: _node3.offsetHeight
              };
              ctx = _c4.ctx;
            }

            if (visibility !== 'hidden') {
              Cache.draw(ctx, _opacity2, _matrixEvent2, __cache);
            }
          } else {
            // 连cache都没生成的超限
            var res = _node3.render(renderMode, _refreshLevel, ctx) || {};
            offscreenBlend = res.offscreenBlend;
            offscreenMask = res.offscreenMask;
            offscreenFilter = res.offscreenFilter;
            offscreenOverflow = res.offscreenOverflow;
          } // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


          if (offscreenBlend) {
            var _j = _i4 + (_total5 || 0) + (_hasMask || 0);

            var _list2 = offscreenHash[_j] = offscreenHash[_j] || [];

            _list2.push([_i4, _lv, OFFSCREEN_BLEND, offscreenBlend]);

            ctx = offscreenBlend.target.ctx;
          } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个


          if (offscreenMask) {
            var _j2 = _i4 + (_total5 || 0);

            maskStartHash[_j2 + 1] = [_i4, _hasMask, offscreenMask];
            ctx = offscreenMask.target.ctx;
          } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


          if (offscreenFilter) {
            var _j3 = _i4 + (_total5 || 0) + (_hasMask || 0);

            var _list3 = offscreenHash[_j3] = offscreenHash[_j3] || [];

            _list3.push([_i4, _lv, OFFSCREEN_FILTER, offscreenFilter]);

            ctx = offscreenFilter.target.ctx;
          } // overflow:hidden的离屏，最后孩子进行截取


          if (offscreenOverflow) {
            var _j4 = _i4 + (_total5 || 0) + (_hasMask || 0);

            var _list4 = offscreenHash[_j4] = offscreenHash[_j4] || [];

            _list4.push([_i4, _lv, OFFSCREEN_OVERFLOW, offscreenOverflow]);

            ctx = offscreenOverflow.target.ctx;
          }

          if (_limitCache && _node3 instanceof Geom) {
            _node3.render(renderMode, _refreshLevel, ctx);
          }
        } // 没内容的遮罩跳过，比如未加载的img，否则会将遮罩绘制出来
        else if (_hasMask) {
          _i4 += (_total5 || 0) + _hasMask;
        } // 同无cache一样的离屏应用


        if (offscreenHash.hasOwnProperty(_i4)) {
          ctx = applyOffscreen(ctx, offscreenHash[_i4], width, height);
        }

        if (display === 'none') {
          _i4 += (_total5 || 0) + (_hasMask || 0);
        }
      }
    }
  }
}
/**
 * 无缓存模式canvas渲染，O(n)一次循环完成
 * @param renderMode
 * @param ctx
 * @param root
 */


function renderCanvas(renderMode, ctx, root) {
  var __structs = root.__structs,
      width = root.width,
      height = root.height;
  /**
   * 离屏功能的数据结构和算法逻辑非常复杂，需用到下面2个hash，来完成一些filter、mask等离屏才能完成的绘制
   * 其中overflow、filter、mix-blend-mode是对自身及子节点，mask则是对自身和后续next遮罩节点
   * 一个节点在Xom渲染中申请离屏canvas，是按照一定顺序来的，且多个离屏后面的有前面的ctx引用，第一个则引用最初非离屏的ctx
   * 这个顺序在应用离屏时以反向顺序开始，这样最后ctx被还原到最初的ctx
   * mask是个十分特殊的离屏，因为除了自身外，next节点也需要汇总到另外一个离屏上，为了逻辑一致性，
   * 所有离屏应用的索引都以最后一个节点的索引为准，即有mask时以最后一个mask，无mask则以自身节点的最后一个（+total)为索引
   */

  var maskStartHash = {};
  var offscreenHash = {};

  for (var i = 0, len = __structs.length; i < len; i++) {
    var _structs$i4 = __structs[i],
        node = _structs$i4[STRUCT_NODE$1],
        lv = _structs$i4[STRUCT_LV],
        total = _structs$i4[STRUCT_TOTAL$1],
        hasMask = _structs$i4[STRUCT_HAS_MASK];
    var _node$__config = node.__config,
        computedStyle = _node$__config[NODE_COMPUTED_STYLE$1],
        refreshLevel = _node$__config[NODE_REFRESH_LV$1]; // 遮罩对象申请了个离屏，其第一个mask申请另外一个离屏mask2，开始聚集所有mask元素的绘制，
    // 这是一个十分特殊的逻辑，保存的index是最后一个节点的索引，OFFSCREEN_MASK2是最低优先级，
    // 这样当mask本身有filter时优先自身，然后才是OFFSCREEN_MASK2

    if (maskStartHash.hasOwnProperty(i)) {
      var _maskStartHash$i = _slicedToArray(maskStartHash[i], 3),
          idx = _maskStartHash$i[0],
          n = _maskStartHash$i[1],
          _offscreenMask2 = _maskStartHash$i[2];

      var target = inject.getCacheCanvas(width, height, null, 'mask2');
      _offscreenMask2.mask = target; // 应用mask用到

      _offscreenMask2.isClip = node.isClip; // 定位到最后一个mask元素上的末尾

      var j = i + (total || 0) + 1;

      while (--n) {
        var _total7 = __structs[j][STRUCT_TOTAL$1];
        j += (_total7 || 0) + 1;
      }

      j--;
      var list = offscreenHash[j] = offscreenHash[j] || [];
      list.push([idx, lv, OFFSCREEN_MASK, _offscreenMask2]);
      list.push([j, lv, OFFSCREEN_MASK2, {
        ctx: ctx,
        // 保存等待OFFSCREEN_MASK2时还原
        target: target
      }]);
      ctx = target.ctx;
    }

    var res = node.render(renderMode, refreshLevel, ctx);

    var _ref = res || {},
        offscreenBlend = _ref.offscreenBlend,
        offscreenMask = _ref.offscreenMask,
        offscreenFilter = _ref.offscreenFilter,
        offscreenOverflow = _ref.offscreenOverflow; // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


    if (offscreenBlend) {
      var _j5 = i + (total || 0) + (hasMask || 0);

      var _list5 = offscreenHash[_j5] = offscreenHash[_j5] || [];

      _list5.push([i, lv, OFFSCREEN_BLEND, offscreenBlend]);

      ctx = offscreenBlend.target.ctx;
    } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
    // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


    if (offscreenMask) {
      var _j6 = i + (total || 0);

      maskStartHash[_j6 + 1] = [i, hasMask, offscreenMask];
      ctx = offscreenMask.target.ctx;
    } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


    if (offscreenFilter) {
      var _j7 = i + (total || 0) + (hasMask || 0);

      var _list6 = offscreenHash[_j7] = offscreenHash[_j7] || [];

      _list6.push([i, lv, OFFSCREEN_FILTER, offscreenFilter]);

      ctx = offscreenFilter.target.ctx;
    } // overflow:hidden的离屏，最后孩子进行截取


    if (offscreenOverflow) {
      var _j8 = i + (total || 0) + (hasMask || 0);

      var _list7 = offscreenHash[_j8] = offscreenHash[_j8] || [];

      _list7.push([i, lv, OFFSCREEN_OVERFLOW, offscreenOverflow]);

      ctx = offscreenOverflow.target.ctx;
    } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
    // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


    if (offscreenHash.hasOwnProperty(i)) {
      ctx = applyOffscreen(ctx, offscreenHash[i], width, height);
    } // render后判断可见状态，此时computedStyle才有值，以及svg的virtualDom也要生成


    if (computedStyle[DISPLAY$1] === 'none') {
      i += (total || 0) + (hasMask || 0);
    }
  }
}

function renderSvg(renderMode, ctx, root, isFirst) {
  var __structs = root.__structs,
      width = root.width,
      height = root.height; // mask节点很特殊，本身有matrix会影响，本身没改变但对象节点有改变也需要计算逆矩阵应用顶点

  var maskEffectHash = {};

  if (!isFirst) {
    // 先遍历一遍收集完全不变的defs，缓存起来id，随后再执行遍历渲染生成新的，避免掉重复的id
    for (var i = 0, len = __structs.length; i < len; i++) {
      var _structs$i5 = __structs[i],
          node = _structs$i5[STRUCT_NODE$1],
          total = _structs$i5[STRUCT_TOTAL$1],
          hasMask = _structs$i5[STRUCT_HAS_MASK];
      var _node$__config2 = node.__config,
          refreshLevel = _node$__config2[NODE_REFRESH_LV$1],
          defsCache = _node$__config2[NODE_DEFS_CACHE]; // 只要涉及到matrix和opacity就影响mask

      var hasEffectMask = hasMask && (refreshLevel >= REPAINT$1 || contain$1(refreshLevel, TRANSFORM_ALL | OP));

      if (hasEffectMask) {
        var start = i + (total || 0) + 1;
        var end = start + hasMask; // mask索引遍历时处理，暂存遮罩对象的刷新lv

        maskEffectHash[end - 1] = refreshLevel;
      } // >=REPAINT重绘生成走render()跳过这里


      if (refreshLevel < REPAINT$1) {
        // 特殊的mask判断，遮罩对象影响这个mask了，除去filter、遮罩对象无TRANSFORM变化外都可缓存
        if (maskEffectHash.hasOwnProperty(i)) {
          var v = maskEffectHash[i];

          if (!contain$1(refreshLevel, TRANSFORM_ALL) && v < REPAINT$1 && !contain$1(v, TRANSFORM_ALL)) {
            defsCache.forEach(function (item) {
              ctx.addCache(item);
            });
          }
        } // 去除特殊的filter，普通节点或不影响的mask在<REPAINT下defs的其它都可缓存
        else {
          defsCache.forEach(function (item) {
            ctx.addCache(item);
          });
        }
      }
    }
  }

  var maskHash = {}; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

  var matrixList = [];
  var parentMatrix;
  var vdList = [];
  var parentVd;
  var lastLv = 0;
  var lastConfig;

  for (var _i5 = 0, _len3 = __structs.length; _i5 < _len3; _i5++) {
    var _structs$_i3 = __structs[_i5],
        _node4 = _structs$_i3[STRUCT_NODE$1],
        _total8 = _structs$_i3[STRUCT_TOTAL$1],
        _hasMask2 = _structs$_i3[STRUCT_HAS_MASK],
        lv = _structs$_i3[STRUCT_LV];
    var __config = _node4.__config;
    var __cacheTotal = __config[NODE_CACHE_TOTAL$1],
        _refreshLevel2 = __config[NODE_REFRESH_LV$1],
        _defsCache = __config[NODE_DEFS_CACHE],
        computedStyle = __config[NODE_COMPUTED_STYLE$1];
    var display = computedStyle[DISPLAY$1]; // 将随后的若干个mask节点范围存下来

    if (_hasMask2 && display !== 'none') {
      var _start = _i5 + (_total8 || 0) + 1;

      var _end = _start + _hasMask2; // svg限制了只能Geom单节点，不可能是Dom，所以end只有唯一


      maskHash[_end - 1] = {
        index: _i5,
        start: _start,
        end: _end,
        isClip: __structs[_start][STRUCT_NODE$1].isClip // 第一个节点是clip为准

      };
    } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点第一个特殊处理


    if (lv < lastLv) {
      var diff = lastLv - lv;
      matrixList.splice(-diff);
      parentMatrix = matrixList[lv - 1];
      vdList.splice(-diff);
      parentVd = vdList[lv - 1];
    } else if (lv > lastLv) {
      matrixList.push(lastConfig[NODE_MATRIX]);
      var vd = lastConfig[NODE_VIRTUAL_DOM];
      vdList.push(vd);
      parentVd = vd;
    }

    lastConfig = __config;
    var virtualDom = void 0; // svg小刷新等级时直接修改vd，这样Geom不再感知

    if (_refreshLevel2 < REPAINT$1 && !(_node4 instanceof Text)) {
      __config[NODE_REFRESH_LV$1] = NONE$1;
      virtualDom = __config[NODE_VIRTUAL_DOM]; // total可以跳过所有孩子节点省略循环

      if (__cacheTotal && __cacheTotal.available) {
        _i5 += _total8 || 0;
        virtualDom.cache = true;
      } else {
        __cacheTotal && (__cacheTotal.available = true);
        virtualDom = __config[NODE_VIRTUAL_DOM] = _node4.__virtualDom = util.extend({}, virtualDom); // dom要清除children缓存，geom和img无需

        if (_node4 instanceof Dom && !(_node4 instanceof Img)) {
          virtualDom.children = [];
        } // 还得判断，和img加载混在一起时，触发刷新如果display:none，则还有cacheTotal


        if (display === 'none') {
          _i5 += _total8 || 0;

          if (_hasMask2) {
            _i5 += _hasMask2;
          }
        } else {
          delete virtualDom.cache;
        }
      }

      var currentStyle = __config[NODE_CURRENT_STYLE$1],
          _computedStyle = __config[NODE_COMPUTED_STYLE$1],
          __cacheStyle = __config[NODE_CACHE_STYLE$1];

      if (contain$1(_refreshLevel2, TRANSFORM_ALL)) {
        var matrix = _node4.__calMatrix(_refreshLevel2, __cacheStyle, currentStyle, _computedStyle, __config); // 恶心的v8性能优化


        var m = __config[NODE_MATRIX];
        util.assignMatrix(m, matrix);

        if (!matrix || isE(matrix)) {
          delete virtualDom.transform;
        } else {
          virtualDom.transform = 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')';
        }

        if (parentMatrix && matrix) {
          matrix = multiply(parentMatrix, matrix);
        } // 恶心的v8性能优化


        m = __config[NODE_MATRIX_EVENT];
        util.assignMatrix(m, matrix);
      }

      if (contain$1(_refreshLevel2, OP)) {
        var opacity = _computedStyle[OPACITY] = currentStyle[OPACITY];

        if (opacity === 1) {
          delete virtualDom.opacity;
        } else {
          virtualDom.opacity = opacity;
        }
      }

      if (contain$1(_refreshLevel2, FT)) {
        var filter = _node4.__calFilter(currentStyle, _computedStyle);

        var s = painter.svgFilter(filter);

        if (s) {
          virtualDom.filter = s;
        } else {
          delete virtualDom.filter;
        }
      }

      if (contain$1(_refreshLevel2, MBM)) {
        var mixBlendMode = _computedStyle[MIX_BLEND_MODE] = currentStyle[MIX_BLEND_MODE];

        if (isValidMbm(mixBlendMode)) {
          virtualDom.mixBlendMode = mbmName(mixBlendMode);
        } else {
          delete virtualDom.mixBlendMode;
        }
      }

      virtualDom.lv = _refreshLevel2;
    } else {
      // >=REPAINT会调用render，重新生成defsCache，text没有这个东西
      __config[NODE_DEFS_CACHE] && __config[NODE_DEFS_CACHE].splice(0);

      _node4.render(renderMode, _refreshLevel2, ctx);

      virtualDom = __config[NODE_VIRTUAL_DOM]; // 渲染后更新取值

      display = computedStyle[DISPLAY$1];

      if (display === 'none') {
        _i5 += _total8 || 0;

        if (_hasMask2) {
          _i5 += _hasMask2;
        }
      }
    }
    /**
     * mask会在join时过滤掉，这里将假设正常渲染的vd的内容获取出来组成defs的mask内容
     * 另外最初遍历时记录了会影响的mask，在<REPAINT时比较，>=REPAINT始终重新设置
     * 本身有matrix也需要重设
     */


    if (maskHash.hasOwnProperty(_i5) && (maskEffectHash.hasOwnProperty(_i5) || _refreshLevel2 >= REPAINT$1 || contain$1(_refreshLevel2, TRANSFORM_ALL | OP))) {
      var _maskHash$_i = maskHash[_i5],
          index = _maskHash$_i.index,
          _start2 = _maskHash$_i.start,
          _end2 = _maskHash$_i.end,
          isClip = _maskHash$_i.isClip;
      var target = __structs[index];
      var dom = target[STRUCT_NODE$1];
      var mChildren = []; // clip模式时，先添加兜底整个白色使得全部都可见，mask本身变反色（黑色）

      if (isClip) {
        mChildren.push({
          type: 'item',
          tagName: 'path',
          props: [['d', "M0,0L".concat(width, ",0L").concat(width, ",").concat(height, "L0,").concat(height, "L0,0")], ['fill', 'rgba(255,255,255,1)'], ['stroke-width', 0]]
        });
      }

      for (var j = _start2; j < _end2; j++) {
        var _node5 = __structs[j][STRUCT_NODE$1];
        var _node5$computedStyle = _node5.computedStyle,
            _display = _node5$computedStyle[DISPLAY$1],
            visibility = _node5$computedStyle[VISIBILITY$1],
            fill = _node5$computedStyle[FILL],
            _node5$virtualDom = _node5.virtualDom,
            children = _node5$virtualDom.children,
            _opacity3 = _node5$virtualDom.opacity;

        if (_display !== 'none' && visibility !== 'hidden') {
          // 引用相同无法diff，需要clone
          children = util.clone(children);
          mChildren = mChildren.concat(children);

          for (var k = 0, _len4 = children.length; k < _len4; k++) {
            var _children$k = children[k],
                tagName = _children$k.tagName,
                props = _children$k.props;

            if (tagName === 'path') {
              if (isClip) {
                for (var _j9 = 0, _len5 = props.length; _j9 < _len5; _j9++) {
                  var item = props[_j9];

                  if (item[0] === 'fill') {
                    item[1] = util.int2invert(fill[0]);
                  }
                }
              }

              var _matrix = _node5.matrix;
              var ivs = inverse(dom.matrix);
              _matrix = multiply(ivs, _matrix); // path没有transform属性，在vd上，需要弥补

              props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_matrix), ','), ")")]); // path没有opacity属性，在vd上，需要弥补

              if (!util.isNil(_opacity3) && _opacity3 !== 1) {
                props.push(['opacity', _opacity3]);
              }
            } // img可能有matrix属性，需判断
            else if (tagName === 'image') {
              var hasTransform = -1;

              for (var _m2 = 0, _len6 = props.length; _m2 < _len6; _m2++) {
                if (props[_m2][0] === 'transform') {
                  hasTransform = _m2;
                  break;
                }
              }

              if (hasTransform === -1) {
                var _ivs = inverse(dom.matrix);

                if (!isE(_ivs)) {
                  props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_ivs), ','), ")")]);
                }
              } else {
                var _matrix2 = props[hasTransform][1].match(/[\d.]+/g).map(function (i) {
                  return parseFloat(i);
                });

                var _ivs2 = inverse(dom.matrix);

                _matrix2 = multiply(_ivs2, _matrix2);
                props[hasTransform][1] = "matrix(".concat(util.joinArr(mx.m2m6(_matrix2), ','), ")");
              }
            }
          }
        }
      } // 清掉上次的


      for (var _i6 = _defsCache.length - 1; _i6 >= 0; _i6--) {
        var _item5 = _defsCache[_i6];

        if (_item5.tagName === 'mask') {
          _defsCache.splice(_i6, 1);
        }
      }

      var o = {
        tagName: 'mask',
        props: [],
        children: mChildren
      };
      var id = ctx.add(o);

      _defsCache.push(o);

      id = 'url(#' + id + ')';
      dom.virtualDom.mask = id;
    } // mask不入children


    if (parentVd && !_node4.isMask) {
      parentVd.children.push(virtualDom);
    }

    if (_i5 === 0) {
      parentMatrix = __config[NODE_MATRIX];
      parentVd = virtualDom;
    }

    lastLv = lv;
  }
}

function renderWebgl(renderMode, gl, root) {
  var __structs = root.__structs,
      width = root.width,
      height = root.height,
      texCache = root.texCache;
  var cx = width * 0.5,
      cy = height * 0.5; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

  var matrixList = [];
  var parentMatrix;
  var opacityList = [];
  var parentOpacity = 1;
  var pmList = [];
  var parentPm;
  var lastRefreshLevel;
  var lastConfig;
  var lastLv = 0;
  var mergeList = [];
  var hasMbm; // 是否有混合模式出现

  /**
   * 先一遍先序遍历每个节点绘制到自己__cache上，排除Text和已有的缓存以及局部根缓存，
   * 根据refreshLevel进行等级区分，可能是<REPAINT或>=REPAINT，REFLOW布局已前置处理完。
   * 首次绘制没有catchTotal等，后续则可能会有，在<REPAINT可据此跳过所有子节点加快循环，布局过程会提前删除它们。
   * lv的变化根据大小相等进行出入栈parent操作，实现获取节点parent数据的方式，
   * 同时过程中计算出哪些节点要生成局部根，存下来
   */

  for (var i = 0, len = __structs.length; i < len; i++) {
    var _structs$i6 = __structs[i],
        node = _structs$i6[STRUCT_NODE$1],
        lv = _structs$i6[STRUCT_LV],
        total = _structs$i6[STRUCT_TOTAL$1],
        hasMask = _structs$i6[STRUCT_HAS_MASK]; // Text特殊处理，webgl中先渲染为bitmap，再作为贴图绘制，缓存交由text内部判断，直接调用渲染纹理方法

    if (node instanceof Text) {
      if (lastRefreshLevel >= REPAINT$1) {
        node.render(renderMode, 0, gl, true);
      }

      continue;
    }

    var __config = node.__config;
    var refreshLevel = __config[NODE_REFRESH_LV$1]; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点是第一个特殊处理

    if (i === 0) ; else if (lv > lastLv) {
      parentMatrix = lastConfig[NODE_MATRIX_EVENT];

      if (isE(parentMatrix)) {
        parentMatrix = null;
      }

      matrixList.push(parentMatrix);
      parentOpacity = lastConfig[NODE_OPACITY];
      opacityList.push(parentOpacity);
      parentPm = lastConfig[NODE_PERSPECTIVE_MATRIX];

      if (isE(parentPm)) {
        parentPm = null;
      }

      pmList.push(parentPm);
    } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
    else if (lv < lastLv) {
      var diff = lastLv - lv;
      matrixList.splice(-diff);
      parentMatrix = matrixList[lv - 1];
      opacityList.splice(-diff);
      parentOpacity = opacityList[lv - 1];
      pmList.splice(-diff);
      parentPm = pmList[lv - 1];
    } // 不变是同级兄弟，无需特殊处理
    else ;

    lastRefreshLevel = refreshLevel;
    lastConfig = __config;
    lastLv = lv;
    var __cacheTotal = __config[NODE_CACHE_TOTAL$1],
        computedStyle = __config[NODE_COMPUTED_STYLE$1]; // 跳过display:none元素和它的所有子节点

    if (computedStyle[DISPLAY$1] === 'none') {
      i += total || 0; // 只跳过自身不能跳过后面的mask，mask要渲染自身并进行缓存cache，以备对象切换display用

      continue;
    }

    var hasRecordAsMask = void 0;
    /**
     * lv<REPAINT，一般会有__cache，跳过渲染过程，快速运算，没有cache则是自身超限或无内容，目前不感知
     * 可能有cacheTotal，为之前生成的局部根，清除逻辑在更新检查是否>=REPAINT那里，小变化不动
     * 当有遮罩时，如果被遮罩节点本身无变更，需要检查其next的遮罩节点有无变更，
     * 但其实不用检查，因为next变更一定会清空cacheMask，只要检查cacheMask即可
     * 如果没有或无效，直接添加，无视节点本身变化，后面防重即可
     */

    if (refreshLevel < REPAINT$1) {
      __config[NODE_REFRESH_LV$1] = NONE$1;

      if (hasMask) {
        var cacheMask = __config[NODE_CACHE_MASK$1];

        if (!cacheMask || !cacheMask.available) {
          hasRecordAsMask = [i, lv, total, node, __config, null, hasMask];
          mergeList.push(hasRecordAsMask);
        }
      }

      var currentStyle = __config[NODE_CURRENT_STYLE$1],
          __cacheStyle = __config[NODE_CACHE_STYLE$1],
          matrixEvent = __config[NODE_MATRIX_EVENT];

      if (contain$1(refreshLevel, PPT)) {
        node.__calPerspective(__cacheStyle, currentStyle, computedStyle, __config);
      } // transform变化，父元素的perspective变化也会在Root特殊处理重新计算


      var matrix = void 0;

      if (contain$1(refreshLevel, TRANSFORM_ALL)) {
        matrix = node.__calMatrix(refreshLevel, __cacheStyle, currentStyle, computedStyle, __config); // 恶心的v8性能优化

        var m = __config[NODE_MATRIX];
        util.assignMatrix(m, matrix);
      } else {
        matrix = __config[NODE_MATRIX];
      } // node本身有或者父有perspective都认为需要生成3d渲染上下文


      if (tf.isPerspectiveMatrix(matrix) || parentPm) {
        if (hasRecordAsMask) {
          hasRecordAsMask[9] = true;
        } else {
          hasRecordAsMask = [i, lv, total, node, __config, null, null, null, null, true];
        }
      } // 先左乘perspective的矩阵，再左乘父级的总矩阵


      if (parentPm) {
        matrix = multiply(parentPm, matrix);
      }

      if (parentMatrix) {
        matrix = multiply(parentMatrix, matrix);
      } // 恶心的v8性能优化


      util.assignMatrix(matrixEvent, matrix);
      var opacity = void 0;

      if (contain$1(refreshLevel, OP)) {
        opacity = computedStyle[OPACITY] = currentStyle[OPACITY];
      } else {
        opacity = computedStyle[OPACITY];
      }

      __config[NODE_OPACITY] = parentOpacity * opacity; // filter会改变bbox范围

      if (contain$1(refreshLevel, FT)) {
        node.__bbox = null;

        var _filter3 = node.__calFilter(currentStyle, computedStyle);

        var __cacheFilter = __config[NODE_CACHE_FILTER$1];

        if (__cacheFilter) {
          __cacheFilter.release();
        } // 防重


        if (hasRecordAsMask) {
          hasRecordAsMask[7] = _filter3;
        } else {
          // 强制存hasMask，因为filter改变影响mask
          hasRecordAsMask = [i, lv, total, node, __config, null, hasMask, _filter3];
          mergeList.push(hasRecordAsMask);
        }
      }

      if (contain$1(refreshLevel, MBM)) {
        computedStyle[MIX_BLEND_MODE] = currentStyle[MIX_BLEND_MODE];
      } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


      if (__cacheTotal && __cacheTotal.available) {
        i += total || 0;
        continue;
      }
    }
    /**
     * >=REPAINT重新渲染，并根据结果判断是否离屏限制错误
     * Geom没有子节点无需汇总局部根，Dom中Img也是，它们的局部根等于自身的cache，其它符合条件的Dom需要生成
     */
    else {
      var res = node.render(renderMode, refreshLevel, gl, true); // geom可返回texture纹理，替代原有xom的__cache纹理

      if (res && inject.isWebGLTexture(res.texture)) {
        var sx1 = node.__sx1,
            sy1 = node.__sy1,
            w = node.offsetWidth,
            h = node.offsetHeight,
            bbox = node.bbox;
        __config[NODE_CACHE$1] = new MockCache(gl, res.texture, sx1, sy1, w, h, bbox);
        gl.viewport(0, 0, width, height);
        gl.useProgram(gl.program);
      }
    } // 每个元素检查cacheTotal生成，已有的上面会continue跳过


    var limitCache = __config[NODE_LIMIT_CACHE];
    var overflow = computedStyle[OVERFLOW],
        filter = computedStyle[FILTER$1],
        mixBlendMode = computedStyle[MIX_BLEND_MODE],
        transform = computedStyle[TRANSFORM];
    var validMbm = isValidMbm(mixBlendMode); // 3d渲染上下文

    var isPerspective = tf.isPerspectiveMatrix(transform) || parentPm;

    if (hasMask || filter.length || overflow === 'hidden' && total || validMbm || isPerspective) {
      if (validMbm) {
        hasMbm = true;
      }

      if (hasRecordAsMask) {
        hasRecordAsMask[5] = limitCache;
        hasRecordAsMask[7] = filter;
        hasRecordAsMask[8] = overflow;
        hasRecordAsMask[9] = isPerspective;
      } else {
        mergeList.push([i, lv, total, node, __config, limitCache, hasMask, filter, overflow, isPerspective]);
      }
    }
  }

  var limitHash = {}; // 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
  // 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩

  if (mergeList.length) {
    mergeList.sort(function (a, b) {
      if (a[1] === b[1]) {
        return b[0] - a[0];
      }

      return b[1] - a[1];
    });
    mergeList.forEach(function (item) {
      var _item6 = _slicedToArray(item, 9),
          i = _item6[0],
          total = _item6[2],
          node = _item6[3],
          __config = _item6[4],
          limitCache = _item6[5],
          hasMask = _item6[6],
          filter = _item6[7],
          overflow = _item6[8];

      var __cache = __config[NODE_CACHE$1],
          __cacheTotal = __config[NODE_CACHE_TOTAL$1],
          __cacheFilter = __config[NODE_CACHE_FILTER$1],
          __cacheMask = __config[NODE_CACHE_MASK$1],
          __cacheOverflow = __config[NODE_CACHE_OVERFLOW$1];
      var needGen; // 可能没变化，比如被遮罩节点、filter变更等

      if (!__cacheTotal || !__cacheTotal.available) {
        var _genTotalWebgl = genTotalWebgl(gl, texCache, node, __config, i, total || 0, __structs, __cache, limitCache, width, height),
            _genTotalWebgl2 = _slicedToArray(_genTotalWebgl, 2),
            limit = _genTotalWebgl2[0],
            _res12 = _genTotalWebgl2[1];

        __cacheTotal = _res12;
        needGen = true;
        limitCache = limit; // 返回的limit包含各种情况超限，一旦超限，只能生成临时cacheTotal不能保存

        if (!limitCache) {
          __config[NODE_CACHE_TOTAL$1] = _res12;
        }
      } // 即使超限，也有total结果


      var target = __cacheTotal;

      if (overflow === 'hidden') {
        if (!__cacheOverflow || !__cacheOverflow.available || needGen) {
          target = genOverflowWebgl(gl, texCache, node, target, width, height);
          needGen = true;

          if (!limitCache) {
            __config[NODE_CACHE_FILTER$1] = target;
          }
        }
      }

      if (filter.length) {
        if (!__cacheFilter || !__cacheFilter.available || needGen) {
          var old = target;
          target = genFilterWebgl(gl, texCache, node, target, filter, width, height);

          if (target !== old) {
            needGen = true;

            if (!limitCache) {
              __config[NODE_CACHE_FILTER$1] = target;
            }
          }
        }
      }

      if (hasMask && (!__cacheMask || !__cacheMask.available || needGen)) {
        target = genMaskWebgl(gl, texCache, node, __config, target, width, height);

        if (!limitCache) {
          __config[NODE_CACHE_MASK$1] = target;
        }
      } // 保存临时的局部根节点


      if (limitCache) {
        limitHash[i] = target;
      }
    });
  }
  /**
   * 最后先序遍历一次应用__cacheTotal即可，没有的用__cache，以及剩下的超尺寸的和Text
   * 由于mixBlendMode的存在，需先申请个fbo纹理，所有绘制默认向该纹理绘制，最后fbo纹理再进入主画布
   * 前面循环时有记录是否出现mbm，只有出现才申请，否则不浪费直接输出到主画布
   * 超尺寸的要走无cache逻辑render，和canvas很像，除了离屏canvas超限，汇总total也会纹理超限
   */


  var n, frameBuffer, texture;

  if (hasMbm) {
    var _genFrameBufferWithTe17 = genFrameBufferWithTexture(gl, texCache, width, height);

    var _genFrameBufferWithTe18 = _slicedToArray(_genFrameBufferWithTe17, 3);

    n = _genFrameBufferWithTe18[0];
    frameBuffer = _genFrameBufferWithTe18[1];
    texture = _genFrameBufferWithTe18[2];
  }

  for (var _i7 = 0, _len7 = __structs.length; _i7 < _len7; _i7++) {
    var _structs$_i4 = __structs[_i7],
        _node6 = _structs$_i4[STRUCT_NODE$1],
        _total9 = _structs$_i4[STRUCT_TOTAL$1],
        _hasMask3 = _structs$_i4[STRUCT_HAS_MASK];
    var _config5 = _node6.__config; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

    if (_node6 instanceof Text) {
      // text特殊之处，__config部分是复用parent的
      var __cache = _config5[NODE_CACHE$1],
          _limitCache2 = _config5[NODE_LIMIT_CACHE],
          _config5$NODE_DOM_PAR = _config5[NODE_DOM_PARENT$1].__config,
          _matrixEvent3 = _config5$NODE_DOM_PAR[NODE_MATRIX_EVENT],
          _opacity4 = _config5$NODE_DOM_PAR[NODE_OPACITY];

      if (__cache && __cache.available) {
        texCache.addTexAndDrawWhenLimit(gl, __cache, _opacity4, _matrixEvent3, cx, cy, 0, 0, true);
      } // 超限特殊处理，先生成画布尺寸大小的纹理然后原始位置绘制
      else if (_limitCache2) {
        var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

        _node6.render(renderMode, 0, gl);

        var j = texCache.lockOneChannel();

        var _texture2 = webgl.createTexture(gl, c.canvas, j);

        var mockCache = new MockCache(gl, _texture2, 0, 0, width, height, [0, 0, width, height]);
        texCache.addTexAndDrawWhenLimit(gl, mockCache, _opacity4, _matrixEvent3, cx, cy, 0, 0, true);
        texCache.refresh(gl, cx, cy, true);
        c.ctx.setTransform(1, 0, 0, 1, 0, 0);
        c.ctx.globalAlpha = 1;
        c.ctx.clearRect(0, 0, width, height);
        mockCache.release();
        texCache.releaseLockChannel(j);
      }
    } else {
      var _opacity5 = _config5[NODE_OPACITY],
          _matrixEvent4 = _config5[NODE_MATRIX_EVENT],
          _limitCache3 = _config5[NODE_LIMIT_CACHE],
          _cache = _config5[NODE_CACHE$1],
          _cacheTotal2 = _config5[NODE_CACHE_TOTAL$1],
          _cacheFilter2 = _config5[NODE_CACHE_FILTER$1],
          __cacheMask = _config5[NODE_CACHE_MASK$1],
          __cacheOverflow = _config5[NODE_CACHE_OVERFLOW$1],
          _refreshLevel3 = _config5[NODE_REFRESH_LV$1],
          _config5$NODE_COMPUTE = _config5[NODE_COMPUTED_STYLE$1],
          display = _config5$NODE_COMPUTE[DISPLAY$1],
          visibility = _config5$NODE_COMPUTE[VISIBILITY$1],
          _mixBlendMode2 = _config5$NODE_COMPUTE[MIX_BLEND_MODE];

      if (display === 'none') {
        _i7 += (_total9 || 0) + (_hasMask3 || 0);
        continue;
      } // 有total的可以直接绘制并跳过子节点索引，忽略total本身，其独占用纹理单元，注意特殊不取cacheTotal，
      // 这种情况发生在只有overflow:hidden声明但无效没有生成__cacheOverflow的情况，
      // 因为webgl纹理单元缓存原因，所以不用cacheTotal防止切换性能损耗
      // 已取消，因为perspective需要进行独立上下文渲染


      var target = getCache([__cacheMask, _cacheFilter2, __cacheOverflow, _cacheTotal2, _cache]); // total和自身cache的尝试

      if (target) {
        // 有mbm先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
        if (hasMbm && isValidMbm(_mixBlendMode2)) {
          texCache.refresh(gl, cx, cy, true);

          var _genFrameBufferWithTe19 = genFrameBufferWithTexture(gl, texCache, width, height),
              _genFrameBufferWithTe20 = _slicedToArray(_genFrameBufferWithTe19, 3),
              n2 = _genFrameBufferWithTe20[0],
              frameBuffer2 = _genFrameBufferWithTe20[1],
              texture2 = _genFrameBufferWithTe20[2];

          texCache.addTexAndDrawWhenLimit(gl, target, _opacity5, _matrixEvent4, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

          var _genMbmWebgl3 = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName(_mixBlendMode2), width, height);

          var _genMbmWebgl4 = _slicedToArray(_genMbmWebgl3, 3);

          n = _genMbmWebgl4[0];
          frameBuffer = _genMbmWebgl4[1];
          texture = _genMbmWebgl4[2];
          gl.deleteFramebuffer(frameBuffer2);
          gl.deleteTexture(texture2);
        } else {
          texCache.addTexAndDrawWhenLimit(gl, target, _opacity5, _matrixEvent4, cx, cy, 0, 0, true);
        }

        if (target !== _cache) {
          _i7 += (_total9 || 0) + (_hasMask3 || 0);
        }
      } else if (limitHash.hasOwnProperty(_i7)) {
        var _target5 = limitHash[_i7];

        if (hasMbm && isValidMbm(_mixBlendMode2)) {
          texCache.refresh(gl, cx, cy, true);

          var _genFrameBufferWithTe21 = genFrameBufferWithTexture(gl, texCache, width, height),
              _genFrameBufferWithTe22 = _slicedToArray(_genFrameBufferWithTe21, 3),
              _n = _genFrameBufferWithTe22[0],
              _frameBuffer = _genFrameBufferWithTe22[1],
              _texture3 = _genFrameBufferWithTe22[2];

          texCache.addTexAndDrawWhenLimit(gl, _target5, _opacity5, _matrixEvent4, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

          var _genMbmWebgl5 = genMbmWebgl(gl, texCache, n, _n, frameBuffer, texture, mbmName(_mixBlendMode2), width, height);

          var _genMbmWebgl6 = _slicedToArray(_genMbmWebgl5, 3);

          n = _genMbmWebgl6[0];
          frameBuffer = _genMbmWebgl6[1];
          texture = _genMbmWebgl6[2];
          gl.deleteFramebuffer(_frameBuffer);
          gl.deleteTexture(_texture3);
        } else {
          texCache.addTexAndDrawWhenLimit(gl, _target5, _opacity5, _matrixEvent4, cx, cy, 0, 0, true);
        }

        _i7 += (_total9 || 0) + (_hasMask3 || 0);
      } // 超限的情况，这里是普通单节点超限，没有合成total后再合成特殊cache如filter/mask/mbm之类的，
      // 直接按原始位置绘制到离屏canvas，再作为纹理绘制即可，特殊的在total那做过降级了
      else if (_limitCache3 && display !== 'none' && visibility !== 'hidden') {
        // let m = mx.m2Mat4(matrixEvent, cx, cy);
        var _c5 = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

        _node6.render(renderMode, _refreshLevel3, gl);

        var _j10 = texCache.lockOneChannel();

        var _texture4 = webgl.createTexture(gl, _c5.canvas, _j10);

        var _mockCache2 = new MockCache(gl, _texture4, 0, 0, width, height, [0, 0, width, height]);

        texCache.addTexAndDrawWhenLimit(gl, _mockCache2, _opacity5, _matrixEvent4, cx, cy, 0, 0, true);
        texCache.refresh(gl, cx, cy, true);

        _c5.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _c5.ctx.globalAlpha = 1;

        _c5.ctx.clearRect(0, 0, width, height);

        _mockCache2.release();

        texCache.releaseLockChannel(_j10);
      }
    }
  }

  texCache.refresh(gl, cx, cy, true); // 有mbm时将汇总的fbo绘入主画布，否则本身就是到主画布无需多余操作

  if (hasMbm) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    texCache.releaseLockChannel(n);
    gl.deleteFramebuffer(frameBuffer); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
    gl.uniform1i(u_texture, n);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.deleteTexture(texture);
  }
}

var struct = {
  renderCacheCanvas: renderCacheCanvas,
  renderCanvas: renderCanvas,
  renderSvg: renderSvg,
  renderWebgl: renderWebgl
};

var vertex = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;attribute float a_opacity;varying float v_opacity;void main(){gl_Position=a_position;v_texCoords=a_texCoords;v_opacity=a_opacity;}"; // eslint-disable-line

var fragment = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;varying float v_opacity;uniform sampler2D u_texture;void main(){float opacity=v_opacity;if(opacity<=0.0){discard;}opacity=clamp(opacity,0.0,1.0);vec4 color=texture2D(u_texture,v_texCoords);gl_FragColor=color*opacity;}"; // eslint-disable-line

var vertexMask = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

var fragmentMask = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*color2.a;gl_FragColor=vec4(color1.rgb*color2.a,a);}"; // eslint-disable-line

var fragmentClip = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*(1.0-color2.a);gl_FragColor=vec4(color1.rgb*(1.0-color2.a),a);}"; // eslint-disable-line

var fragmentOverflow = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_texCoords);}"; // eslint-disable-line

var vertexCm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

var fragmentCm = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_m[20];void main(){vec4 c=texture2D(u_texture,v_texCoords);if(c.a>0.0){c.rgb/=c.a;}vec4 result;result.r=(u_m[0]*c.r);result.r+=(u_m[1]*c.g);result.r+=(u_m[2]*c.b);result.r+=(u_m[3]*c.a);result.r+=u_m[4];result.g=(u_m[5]*c.r);result.g+=(u_m[6]*c.g);result.g+=(u_m[7]*c.b);result.g+=(u_m[8]*c.a);result.g+=u_m[9];result.b=(u_m[10]*c.r);result.b+=(u_m[11]*c.g);result.b+=(u_m[12]*c.b);result.b+=(u_m[13]*c.a);result.b+=u_m[14];result.a=(u_m[15]*c.r);result.a+=(u_m[16]*c.g);result.a+=(u_m[17]*c.b);result.a+=(u_m[18]*c.a);result.a+=u_m[19];gl_FragColor=vec4(result.rgb*result.a,result.a);}"; // eslint-disable-line

var TexCache = /*#__PURE__*/function () {
  function TexCache(units) {
    _classCallCheck(this, TexCache);

    this.__units = units; // 通道数量限制，8~16

    this.__pages = []; // 存当前page列表，通道数量8~16，缓存收留尽可能多的page

    this.__list = []; // 本次渲染暂存的数据，[cache, opacity, matrix, dx, dy]

    this.__channels = []; // 每个纹理通道记录还是个数组，下标即纹理单元，内容为Page

    this.__locks = []; // 锁定纹理单元列表，下标即纹理单元，内容true为锁定

    this.__lockUnits = 0;
  }
  /**
   * webgl每次绘制为添加纹理并绘制，此处尝试尽可能收集所有纹理贴图，以达到尽可能多的共享纹理，再一次性绘制
   * 收集的是Page对象（从cache中取得），里面包含了若干个节点的贴图，canvas本身是2的幂次方大小
   * webgl最少有8个纹理单元最多16个，因此存了一个列表来放这些Page的canvas，刷新后清空，但纹理通道映射记录保留
   * 当8个纹理单元全部满了，进行绘制并清空这个队列，外部主循环结束时也会检查队列是否还有余留并绘制
   * 初始调用队列为空，存入Page对象，后续调用先查看是否存在以便复用，再决定是否存入Page，直到8个满了
   * Page上存有update表示是否更新，每次cache绘制时会变true，以此表示是否有贴图更新，删除可以忽视
   * 还需要一个记录上次纹理通道使用哪个Page的canvas的地方，即映射，清空后队列再次添加时，如果Page之前被添加过，
   * 此次又被添加且没有变更update，可以直接复用上次的纹理单元号且无需再次上传纹理，节省性能
   * 后续接入局部纹理更新也是复用单元号，如果update变更可以选择局部上传纹理而非整个重新上传
   * 判断上传的逻辑在收集满8个后绘制前进行，因为添加队列过程中可能会变更Page及其update
   * @param gl
   * @param cache
   * @param opacity
   * @param matrix
   * @param cx
   * @param cy
   * @param dx
   * @param dy
   * @param revertY
   */


  _createClass(TexCache, [{
    key: "addTexAndDrawWhenLimit",
    value: function addTexAndDrawWhenLimit(gl, cache, opacity, matrix, cx, cy) {
      var dx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var dy = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var revertY = arguments.length > 8 ? arguments[8] : undefined;
      var pages = this.__pages;
      var list = this.__list;
      var page = cache.page;
      var i = pages.indexOf(page); // 找到说明已有page在此索引的通道中，记录下来info

      if (i > -1) {
        list.push([cache, opacity, matrix, dx, dy]);
      } // 找不到说明是新的纹理贴图，此时看是否超过纹理单元限制，超过则刷新绘制并清空，然后/否则 存入纹理列表
      else {
        i = pages.length;

        if (i >= this.__units - this.__lockUnits) {
          // 绘制且清空，队列索引重新为0
          this.refresh(gl, cx, cy, revertY);
        }

        pages.push(page);
        list.push([cache, opacity, matrix, dx, dy]);
      }
    }
    /**
     * 刷新
     * @param gl
     * @param cx
     * @param cy
     * @param revertY
     */

  }, {
    key: "refresh",
    value: function refresh(gl, cx, cy, revertY) {
      var pages = this.__pages;
      var list = this.__list; // 防止空调用刷新，struct循环结尾会强制调用一次防止有未渲染的

      if (pages.length) {
        var channels = this.channels;
        var locks = this.locks; // 先将上次渲染的纹理单元使用的Page形成一个hash，键为page的uuid，值为纹理单元

        var lastHash = {};
        channels.forEach(function (item, i) {
          if (item) {
            var uuid = item.uuid;
            lastHash[uuid] = i;
          }
        });
        var units = this.__units; // 再遍历，查找相同的Page并保持其使用的纹理单元不变，存入相同索引下标oldList，不同的按顺序收集放newList

        var oldList = new Array(units),
            newList = [];
        pages.forEach(function (page) {
          var uuid = page.uuid;

          if (lastHash.hasOwnProperty(uuid)) {
            var index = lastHash[uuid];
            oldList[index] = page;
          } else {
            newList.push(page);
          }
        });
        /**
         * 以oldList为基准，将newList依次存入oldList中
         * 优先使用未用过的纹理单元，以便用过的可能下次用到无需重新上传
         * 找不到未用过的后，尝试NRU算法，优先淘汰最近未使用的Page，相等则尺寸小的
         */

        if (newList.length) {
          // 先循环找空的，oldList空且channels空且locks空
          for (var i = 0; i < units; i++) {
            if (!oldList[i] && !channels[i] && !locks[i]) {
              oldList[i] = newList.shift();

              if (!newList.length) {
                break;
              }
            }
          }

          var len = newList.length;

          if (len) {
            // 按时间排序已使用channel且未被当前占用的，以便淘汰最久未使用的
            var cl = [];

            for (var _i = 0; _i < units; _i++) {
              if (!oldList[_i] && !locks[_i]) {
                cl.push([_i, channels[_i]]);
              }
            }

            cl.sort(function (a, b) {
              if (a[1].time !== b[1].time) {
                return (a[1].time || 0) - (b[1].time || 0);
              }

              if (a[1].fullSize !== b[1].fullSize) {
                return a[1].fullSize - b[1].fullSize;
              }

              return a[0] - b[0];
            }); // cl靠前是时间小尺寸小的，优先使用替换

            for (var _i2 = 0; _i2 < len; _i2++) {
              oldList[cl[_i2][0]] = newList[_i2];
            }
          }
        }
        /**
         * 对比上帧渲染的和这次纹理单元情况，Page相同且!update可以省略更新，其它均重新赋值纹理
         * 后续局部更新Page相同但有update，会出现没有上帧的情况如初始渲染，此时先创建纹理单元再更新
         * 将新的数据赋给老的，可能新的一帧使用的少于上一帧，老的没用到的需继续保留
         */


        var hash = {};

        for (var _i3 = 0, _len = oldList.length; _i3 < _len; _i3++) {
          var page = oldList[_i3]; // 可能为空，不满的情况下前面单元保留老tex先用的后面的单元

          if (!page) {
            continue;
          }

          var last = channels[_i3];

          if (!last || last[0] !== page || page.update) {
            // page可能为一个已有纹理，或者贴图
            if (page instanceof MockPage) {
              webgl.bindTexture(gl, page.texture, _i3);
              channels[_i3] = page;
            } else {
              // 可能老的先删除
              if (last) {
                gl.deleteTexture(last.texture);
              }

              page.texture = webgl.createTexture(gl, page.canvas, _i3);
              channels[_i3] = page;
            }

            hash[page.uuid] = _i3;
          } else {
            hash[page.uuid] = _i3;
          } // 标识没有更新，以及最后使用时间


          page.update = false;
          page.time = inject.now();
        } // 再次遍历开始本次渲染并清空


        webgl.drawTextureCache(gl, list, hash, cx, cy, revertY);
        pages.splice(0);
        list.splice(0);
      }
    }
  }, {
    key: "findExistTexChannel",
    value: function findExistTexChannel(page) {
      return this.channels.indexOf(page);
    }
    /**
     * 获取并锁定一个纹理单元优先使用空的，其次最久未使用的
     * @returns {number|*}
     */

  }, {
    key: "lockOneChannel",
    value: function lockOneChannel() {
      // 优先返回空单元
      var channels = this.channels;
      var locks = this.locks;

      for (var i = 0; i < this.__units; i++) {
        if (!channels[i] && !locks[i]) {
          locks[i] = true;
          this.__lockUnits++;
          return i;
        }
      } // 根据NRU返回最久未使用的


      var units = this.__units;
      var cl = [];

      for (var _i4 = 0; _i4 < units; _i4++) {
        if (!locks[_i4]) {
          cl.push([_i4, channels[_i4]]);
        }
      }

      if (cl.length) {
        cl.sort(function (a, b) {
          if (a[1].time !== b[1].time) {
            return (a[1].time || 0) - (b[1].time || 0);
          }

          if (a[1].fullSize !== b[1].fullSize) {
            return a[1].fullSize - b[1].fullSize;
          }

          return a[0] - b[0];
        });
        var _i5 = cl[0][0];
        channels[_i5] = null;
        locks[_i5] = true;
        this.__lockUnits++;
        return _i5;
      }

      throw new Error('No free texture unit');
    }
    /**
     * 释放掉i单元，并且设置内容到缓存channel中
     * @param i
     * @param setToChannel
     */

  }, {
    key: "releaseLockChannel",
    value: function releaseLockChannel(i, setToChannel) {
      if (this.locks[i]) {
        this.locks[i] = false;
        this.__lockUnits--;

        if (setToChannel) {
          this.channels[i] = setToChannel;
        }
      }
    } // 指定锁定一个单元

  }, {
    key: "lockChannel",
    value: function lockChannel(i) {
      var channels = this.channels;
      var locks = this.locks;

      if (!locks[i]) {
        channels[i] = null;
        locks[i] = true;
        this.__lockUnits++;
      }
    }
    /**
     * 释放纹理单元
     * @param gl
     */

  }, {
    key: "release",
    value: function release(gl) {
      this.channels.forEach(function (item) {
        if (item) {
          gl.deleteTexture(item.texture);
        }
      });
    }
  }, {
    key: "channels",
    get: function get() {
      return this.__channels;
    }
  }, {
    key: "locks",
    get: function get() {
      return this.__locks;
    }
  }]);

  return TexCache;
}();

var _DIRECTION_HASH;
var _enums$STYLE_KEY$6 = enums.STYLE_KEY,
    TOP = _enums$STYLE_KEY$6.TOP,
    RIGHT = _enums$STYLE_KEY$6.RIGHT,
    BOTTOM = _enums$STYLE_KEY$6.BOTTOM,
    LEFT = _enums$STYLE_KEY$6.LEFT,
    POSITION = _enums$STYLE_KEY$6.POSITION,
    DISPLAY = _enums$STYLE_KEY$6.DISPLAY,
    VISIBILITY = _enums$STYLE_KEY$6.VISIBILITY,
    COLOR = _enums$STYLE_KEY$6.COLOR,
    WIDTH = _enums$STYLE_KEY$6.WIDTH,
    HEIGHT = _enums$STYLE_KEY$6.HEIGHT,
    Z_INDEX = _enums$STYLE_KEY$6.Z_INDEX,
    MARGIN_TOP = _enums$STYLE_KEY$6.MARGIN_TOP,
    MARGIN_LEFT = _enums$STYLE_KEY$6.MARGIN_LEFT,
    MARGIN_BOTTOM = _enums$STYLE_KEY$6.MARGIN_BOTTOM,
    PADDING_TOP = _enums$STYLE_KEY$6.PADDING_TOP,
    PADDING_LEFT = _enums$STYLE_KEY$6.PADDING_LEFT,
    PADDING_BOTTOM = _enums$STYLE_KEY$6.PADDING_BOTTOM,
    BORDER_TOP_WIDTH = _enums$STYLE_KEY$6.BORDER_TOP_WIDTH,
    BORDER_LEFT_WIDTH = _enums$STYLE_KEY$6.BORDER_LEFT_WIDTH,
    BORDER_BOTTOM_WIDTH = _enums$STYLE_KEY$6.BORDER_BOTTOM_WIDTH,
    POINTER_EVENTS = _enums$STYLE_KEY$6.POINTER_EVENTS,
    _enums$UPDATE_KEY = enums.UPDATE_KEY,
    UPDATE_NODE = _enums$UPDATE_KEY.UPDATE_NODE,
    UPDATE_STYLE = _enums$UPDATE_KEY.UPDATE_STYLE,
    UPDATE_KEYS = _enums$UPDATE_KEY.UPDATE_KEYS,
    UPDATE_COMPONENT = _enums$UPDATE_KEY.UPDATE_COMPONENT,
    UPDATE_FOCUS = _enums$UPDATE_KEY.UPDATE_FOCUS,
    UPDATE_MEASURE = _enums$UPDATE_KEY.UPDATE_MEASURE,
    UPDATE_OVERWRITE = _enums$UPDATE_KEY.UPDATE_OVERWRITE,
    UPDATE_LIST = _enums$UPDATE_KEY.UPDATE_LIST,
    UPDATE_CONFIG = _enums$UPDATE_KEY.UPDATE_CONFIG,
    UPDATE_ADD_DOM = _enums$UPDATE_KEY.UPDATE_ADD_DOM,
    UPDATE_REMOVE_DOM = _enums$UPDATE_KEY.UPDATE_REMOVE_DOM,
    _enums$NODE_KEY = enums.NODE_KEY,
    NODE_TAG_NAME = _enums$NODE_KEY.NODE_TAG_NAME,
    NODE_CACHE_STYLE = _enums$NODE_KEY.NODE_CACHE_STYLE,
    NODE_CACHE_PROPS = _enums$NODE_KEY.NODE_CACHE_PROPS,
    NODE_CURRENT_STYLE = _enums$NODE_KEY.NODE_CURRENT_STYLE,
    NODE_COMPUTED_STYLE = _enums$NODE_KEY.NODE_COMPUTED_STYLE,
    NODE_CURRENT_PROPS = _enums$NODE_KEY.NODE_CURRENT_PROPS,
    NODE_DOM_PARENT = _enums$NODE_KEY.NODE_DOM_PARENT,
    NODE_IS_MASK = _enums$NODE_KEY.NODE_IS_MASK,
    NODE_REFRESH_LV = _enums$NODE_KEY.NODE_REFRESH_LV,
    NODE_IS_DESTROYED = _enums$NODE_KEY.NODE_IS_DESTROYED,
    NODE_STYLE = _enums$NODE_KEY.NODE_STYLE,
    NODE_UPDATE_HASH = _enums$NODE_KEY.NODE_UPDATE_HASH,
    NODE_UNIQUE_UPDATE_ID = _enums$NODE_KEY.NODE_UNIQUE_UPDATE_ID,
    NODE_CACHE = _enums$NODE_KEY.NODE_CACHE,
    NODE_CACHE_TOTAL = _enums$NODE_KEY.NODE_CACHE_TOTAL,
    NODE_CACHE_FILTER = _enums$NODE_KEY.NODE_CACHE_FILTER,
    NODE_CACHE_OVERFLOW = _enums$NODE_KEY.NODE_CACHE_OVERFLOW,
    NODE_CACHE_MASK = _enums$NODE_KEY.NODE_CACHE_MASK,
    NODE_STRUCT = _enums$NODE_KEY.NODE_STRUCT,
    _enums$STRUCT_KEY = enums.STRUCT_KEY,
    STRUCT_INDEX = _enums$STRUCT_KEY.STRUCT_INDEX,
    STRUCT_TOTAL = _enums$STRUCT_KEY.STRUCT_TOTAL,
    STRUCT_NODE = _enums$STRUCT_KEY.STRUCT_NODE;
var DIRECTION_HASH = (_DIRECTION_HASH = {}, _defineProperty(_DIRECTION_HASH, TOP, true), _defineProperty(_DIRECTION_HASH, RIGHT, true), _defineProperty(_DIRECTION_HASH, BOTTOM, true), _defineProperty(_DIRECTION_HASH, LEFT, true), _DIRECTION_HASH);
var isNil$7 = util.isNil,
    isObject = util.isObject,
    isFunction$1 = util.isFunction;
var AUTO = o$4.AUTO,
    PX = o$4.PX,
    PERCENT = o$4.PERCENT,
    INHERIT = o$4.INHERIT;
var isRelativeOrAbsolute = css.isRelativeOrAbsolute,
    equalStyle = css.equalStyle;
var contain = o$1.contain,
    getLevel = o$1.getLevel,
    isRepaint = o$1.isRepaint,
    NONE = o$1.NONE,
    FILTER = o$1.FILTER,
    PERSPECTIVE = o$1.PERSPECTIVE,
    REPAINT = o$1.REPAINT,
    REFLOW = o$1.REFLOW,
    REBUILD = o$1.REBUILD;
var isIgnore = o$2.isIgnore,
    isGeom = o$2.isGeom,
    isMeasure = o$2.isMeasure;
var ROOT_DOM_NAME = {
  canvas: 'canvas',
  svg: 'svg',
  webgl: 'canvas'
};

function getDom(dom) {
  if (util.isString(dom) && dom) {
    var o = document.querySelector(dom);

    if (!o) {
      throw new Error('Can not find dom of selector: ' + dom);
    }

    return o;
  }

  if (!dom) {
    throw new Error('Can not find dom: ' + dom);
  }

  return dom;
}

function renderProp(k, v) {
  var s = Array.isArray(v) ? util.joinSourceArray(v) : util.stringify(v);

  if (k === 'className') {
    k = 'class';
  } else if (k === 'style') {
    return '';
  }

  return ' ' + k + '="' + util.encodeHtml(s, true) + '"';
}

var EVENT_LIST = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];

function initEvent(dom, Root) {
  var list = [];
  EVENT_LIST.forEach(function (type) {
    function cb(e) {
      var root = dom.__root;

      if (root && root instanceof Root) {
        if (['touchend', 'touchcancel', 'touchmove'].indexOf(type) > -1) {
          var target = root.__touchstartTarget;

          var event = root.__wrapEvent(e);

          event.target = target;

          while (target) {
            target.__emitEvent(event, true);

            target = target.domParent;
          }
        } else {
          root.__cb(e);
        }
      }
    }

    dom.addEventListener(type, cb);
    list.push([type, cb]);
  });
  return list;
}

function removeEvent(dom, list) {
  list.forEach(function (item) {
    dom.removeEventListener(item[0], item[1]);
  });
} // 提取出对比节点尺寸是否固定非AUTO


function isFixedWidthOrHeight(node, k) {
  var c = node.currentStyle[k];
  return c[1] !== AUTO;
} // 除了固定尺寸，父级也不能是flex或变化flex


function isFixedSize(node, includeParentFlex) {
  var res = isFixedWidthOrHeight(node, WIDTH) && isFixedWidthOrHeight(node, HEIGHT);

  if (res && includeParentFlex) {
    var parent = node.domParent;

    if (parent) {
      if (parent.currentStyle[DISPLAY] === 'flex' || parent.computedStyle[DISPLAY] === 'flex') {
        return false;
      }
    }
  }

  return res;
}

function isLAYOUT(node) {
  return node.hasOwnProperty('__uniqueReflowId');
}

var __uniqueReflowId = 0;

function setLAYOUT(node, hash, component, addDom) {
  if (!node.hasOwnProperty('__uniqueReflowId')) {
    node.__uniqueReflowId = __uniqueReflowId;
    hash[__uniqueReflowId++] = {
      node: node,
      component: component,
      addDom: addDom
    };
  }
}
/**
 * 单独提出共用检测影响的函数，从节点本身开始向上分析影响，找到最上层的影响节点设置其重新布局
 * 过程即__checkReflow中所提及的，各种情况
 * 将影响升至最近的父级节点，并添加布局标识，这样后面的深度遍历会以父级为准忽略本身
 * 如果最终是root，则返回true标识，直接整个重新开始布局
 * ====
 * addDom情况下的特殊影响检测，类似checkInfluence
 * 添加的是absolute则只影响自己，大部分交互游戏情况属于此类型优化
 * 添加的是inline/inlineBlock的话，影响最近非inline父节点
 * 父为flex则直接影响父节点，不管添加情况如何
 * 添加block/flex的话，上下都block/flex则只影响自己，否则还是影响父节点
 * 如果最终是root，则返回true标识，直接整个重新开始布局
 * @returns {boolean}
 */


function checkInfluence(root, reflowHash, node, component, addDom) {
  // add情况abs节点特殊对待不影响其它节点，不能判断display，因为inline会强制block
  if (addDom && node.currentStyle[POSITION] === 'absolute') {
    return;
  }

  var target = node; // inline新老都影响，节点变为最近的父非inline

  if (['inline', 'inlineBlock', 'inline-block'].indexOf(target.currentStyle[DISPLAY]) > -1 || ['inline', 'inlineBlock', 'inline-block'].indexOf(target.computedStyle[DISPLAY]) > -1) {
    do {
      target = target.domParent; // 父到root提前跳出

      if (target === root) {
        return true;
      } // 父已有LAYOUT跳出防重


      if (isLAYOUT(target)) {
        return;
      } // 遇到absolute跳出，设置其布局；如果absolute不变化普通处理，如果absolute发生变化，一定会存在于列表中，不用考虑


      if (target.currentStyle[POSITION] === 'absolute' || target.computedStyle[POSITION] === 'absolute') {
        setLAYOUT(target, reflowHash, component, addDom);
        return;
      }
    } while (target && (['inline', 'inlineBlock', 'inline-block'].indexOf(target.currentStyle[DISPLAY]) > -1 || ['inline', 'inlineBlock', 'inline-block'].indexOf(target.computedStyle[DISPLAY]) > -1)); // target已不是inline，父固定宽高跳出直接父进行LAYOUT即可，不影响上下文，但不能是flex孩子，此时固定尺寸无用


    if (isFixedSize(target, true)) {
      setLAYOUT(target, reflowHash, component, addDom);
      return;
    }
  } // 此时target指向node，如果原本是inline则是其flow的非inline父


  var parent = target.domParent; // parent有LAYOUT跳出，已被包含

  if (isLAYOUT(parent)) {
    return;
  } // 向上检查flex，如果父级中有flex，以最上层的flex视作其更改，node本身flex不进入


  var topFlex;

  do {
    // 父已有LAYOUT跳出防重
    if (isLAYOUT(parent)) {
      return;
    } // flex相关，包含变化或不变化


    if (parent.computedStyle[DISPLAY] === 'flex' || parent.currentStyle[DISPLAY] === 'flex') {
      topFlex = parent;
    } // 遇到absolute跳出，如果absolute不变化普通处理，如果absolute发生变化，一定会存在于列表中，不用考虑


    if (parent.currentStyle[POSITION] === 'absolute' || parent.computedStyle[POSITION] === 'absolute') {
      break;
    } // 父固定宽高跳出


    if (isFixedSize(parent, true)) {
      break;
    }

    parent = parent.domParent;
  } while (parent); // 找到最上层flex，视作其更改


  if (topFlex) {
    target = topFlex;
  }

  if (target === root) {
    return true;
  }

  parent = target; // 向上检查非固定尺寸的absolute，找到则视为其变更，上面过程中一定没有出现absolute

  while (parent) {
    // 无论新老absolute，不变化则设置，变化一定会出现在列表中
    if (parent.currentStyle[POSITION] === 'absolute' || parent.computedStyle[POSITION] === 'absolute') {
      if (parent === root) {
        break;
      } // 固定尺寸的不用设置，需要跳出循环


      if (isFixedSize(parent)) {
        break;
      } else {
        setLAYOUT(parent, reflowHash, component, addDom);
        return;
      }
    }

    parent = parent.domParent;
  } // 向上查找了并且没提前跳出的target如果不等于自身则重新布局，自身外面设置过了


  if (target !== node) {
    setLAYOUT(target, reflowHash, component, addDom);
  } else if (addDom) {
    // 前后必须都是block，否则还是视为父布局
    var isSiblingBlock = true;
    var prev = node.prev,
        next = node.next;

    if (prev && ['inline', 'inline-block', 'inlineBlock'].indexOf(prev.currentStyle[DISPLAY]) > -1) {
      isSiblingBlock = false;
    } else if (next && ['inline', 'inline-block', 'inlineBlock'].indexOf(next.currentStyle[DISPLAY]) > -1) {
      isSiblingBlock = false;
    }

    if (!isSiblingBlock) {
      target = node.domParent;

      if (target === root) {
        return true;
      }

      setLAYOUT(target, reflowHash, false, true);
    }
  }
}

var uniqueUpdateId = 0;

function parseUpdate(renderMode, root, target, reflowList, measureList, cacheHash, cacheList, zHash, zList) {
  var node = target[UPDATE_NODE],
      style = target[UPDATE_STYLE],
      overwrite = target[UPDATE_OVERWRITE],
      focus = target[UPDATE_FOCUS],
      component = target[UPDATE_COMPONENT],
      measure = target[UPDATE_MEASURE],
      list = target[UPDATE_LIST],
      keys = target[UPDATE_KEYS],
      __config = target[UPDATE_CONFIG],
      addDom = target[UPDATE_ADD_DOM],
      removeDom = target[UPDATE_REMOVE_DOM];

  if (__config[NODE_IS_DESTROYED]) {
    return;
  } // updateStyle()这样的调用需要覆盖原有样式，因为是按顺序遍历，后面的优先级自动更高不怕重复


  if (overwrite) {
    Object.assign(__config[NODE_STYLE], overwrite);
  } // 多次调用更新才会有list，一般没有，优化；component无需，因为多次都是它自己


  if (list && !component) {
    keys = (keys || []).slice(0); // 防止原始值被更改

    var hash = {};
    keys.forEach(function (k) {
      hash[k] = true;
    });
    list.forEach(function (item) {
      var style2 = item[UPDATE_STYLE],
          overwrite = item[UPDATE_OVERWRITE],
          keys2 = item[UPDATE_KEYS];
      (keys2 || []).forEach(function (k2) {
        if (!hash.hasOwnProperty(k2)) {
          hash[k2] = true;
          keys.push(k2);
        }
      });

      if (overwrite) {
        Object.assign(__config[NODE_STYLE], overwrite);
      }

      if (style2) {
        if (style) {
          Object.assign(style, style2);
        } else {
          style = style2;
        }
      }
    });
  } // 按节点合并完style后判断改变等级


  var tagName = __config[NODE_TAG_NAME],
      __cacheStyle = __config[NODE_CACHE_STYLE],
      __cacheProps = __config[NODE_CACHE_PROPS],
      currentStyle = __config[NODE_CURRENT_STYLE],
      computedStyle = __config[NODE_COMPUTED_STYLE],
      currentProps = __config[NODE_CURRENT_PROPS],
      domParent = __config[NODE_DOM_PARENT],
      isMask = __config[NODE_IS_MASK];
  var lv = focus || NONE;
  var hasMeasure = measure;
  var hasZ, hasVisibility, hasColor, hasDisplay; // component无需遍历直接赋值，img重新加载等情况没有样式更新

  if (!component && style && keys) {
    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      var v = style[k]; // 只有geom的props和style2种可能

      if (node instanceof Geom && isGeom(tagName, k)) {
        if (!equalStyle(k, v, currentProps[k], node)) {
          lv |= REPAINT;
          __cacheProps[k] = undefined;
          currentProps[k] = v;
        }
      } else {
        // 需和现在不等，且不是pointerEvents这种无关的
        if (!equalStyle(k, v, currentStyle[k], node)) {
          // pointerEvents这种无关的只需更新
          if (isIgnore(k)) {
            __cacheStyle[k] = undefined;
            currentStyle[k] = v;
          } else {
            // TRBL变化只对relative/absolute起作用，其它忽视
            if (DIRECTION_HASH.hasOwnProperty(k)) {
              var position = currentStyle[POSITION];

              if (position !== 'relative' && position !== 'absolute') {
                delete style[k];
                continue;
              }
            } else if (k === DISPLAY) {
              hasDisplay = true;
            } // repaint细化等级，reflow在checkReflow()


            lv |= getLevel(k);

            if (isMeasure(k)) {
              hasMeasure = true;
            } // repaint置空，如果reflow会重新生成空的


            __cacheStyle[k] = undefined;
            currentStyle[k] = v;

            if (k === Z_INDEX && node !== root) {
              hasZ = true;
            }

            if (k === VISIBILITY) {
              hasVisibility = true;
            }

            if (k === COLOR) {
              hasColor = true;
            }
          }
        }
      }
    }
  } // 无任何改变处理的去除记录，如pointerEvents、无效的left
  // 但是perspective需考虑进来，虽然不影响自己但影响别人，要返回true表明有变更


  if (lv === NONE && !component) {
    delete __config[NODE_UNIQUE_UPDATE_ID];
    return;
  } // 由于父节点中有display:none，或本身节点也为none，执行普通动画是无效的，此时没有display变化


  if (computedStyle[DISPLAY] === 'none' && !hasDisplay) {
    return;
  } // 记录下来清除parent的zIndexChildren缓存


  if (hasZ && domParent) {
    delete domParent.__zIndexChildren;
  } // visibility/color变化，影响子继承


  if (hasVisibility || hasColor) {
    for (var __structs = root.__structs, __struct = node.__config[NODE_STRUCT], _i = __struct[STRUCT_INDEX] + 1, _len = _i + __struct[STRUCT_TOTAL]; _i < _len; _i++) {
      var _structs$_i = __structs[_i],
          _node = _structs$_i[STRUCT_NODE],
          total = _structs$_i[STRUCT_TOTAL];
      var _config = _node.__config;
      var _currentStyle = _config[NODE_CURRENT_STYLE];

      var _need = void 0; // text的style指向parent，因此text一定变更


      if (hasVisibility && (_node instanceof Text || _currentStyle[VISIBILITY][1] === INHERIT)) {
        _need = true;
      }

      if (hasColor && (_node instanceof Text || _currentStyle[COLOR][1] === INHERIT)) {
        _need = true;
      }

      if (_need) {
        _config[NODE_REFRESH_LV] |= REPAINT;

        if (_node instanceof Xom) {
          _node.clearCache();
        }
      } else {
        _i += total || 0;
      }
    }
  } // mask需清除遮罩对象的缓存


  if (isMask) {
    var prev = node.prev;

    while (prev && prev.isMask) {
      prev = prev.prev;
    }

    if (prev && prev.__config[NODE_CACHE_MASK]) {
      prev.__config[NODE_CACHE_MASK].release();
    }
  } // 特殊情况，父节点display:none，子节点进行任意变更，应视为无效
  // 如果父节点由none变block，这里也return false，因为父节点会重新layout+render
  // 如果父节点由block变none，同上，所以只要current/computed里有none就return false


  var parent = domParent;

  if (hasDisplay && parent) {
    var _config2 = parent.__config;

    if (_config2[NODE_CURRENT_STYLE][DISPLAY] === 'none' || _config2[NODE_COMPUTED_STYLE][DISPLAY] === 'none') {
      computedStyle[DISPLAY] = 'none';
      return;
    }
  } // reflow/repaint/measure相关的记录下来


  var isRp = !component && isRepaint(lv);

  if (isRp) {
    // zIndex变化需清空svg缓存
    if (hasZ && renderMode === mode.SVG) {
      lv |= REPAINT;
      domParent && cleanSvgCache(domParent);
    } // z改变影响struct局部重排，它的数量不会变因此不影响外围，此处先收集，最后统一对局部根节点进行更新


    if (hasZ && !component && zHash) {
      if (domParent && !domParent.hasOwnProperty('__uniqueZId')) {
        zHash[uniqueUpdateId] = true;
        domParent.__uniqueZId = uniqueUpdateId++;
        zList.push(domParent);
      }
    }
  } // reflow在root的refresh中做
  else {
    reflowList.push({
      node: node,
      style: style,
      component: component,
      addDom: addDom,
      removeDom: removeDom
    }); // measure需要提前先处理

    if (hasMeasure) {
      measureList.push(node);
    }
  } // 这里也需|运算，每次刷新会置0，但是如果父元素进行继承变更，会在此元素分析前更改，比如visibility，此时不能直接赋值


  __config[NODE_REFRESH_LV] |= lv;

  if (component || addDom || removeDom) {
    root.__rlv = REBUILD;
  } else {
    root.__rlv = Math.max(root.__rlv, lv);
  } // dom在>=REPAINT时total失效，svg的Geom比较特殊


  var need = lv >= REPAINT || renderMode === mode.SVG && node instanceof Geom;

  if (need) {
    if (__config[NODE_CACHE]) {
      __config[NODE_CACHE].release();
    }
  } // perspective也特殊只清空total的cache，和>=REPAINT清空total共用


  if (need || contain(lv, PERSPECTIVE)) {
    if (__config[NODE_CACHE_TOTAL]) {
      __config[NODE_CACHE_TOTAL].release();
    }

    if (__config[NODE_CACHE_MASK]) {
      __config[NODE_CACHE_MASK].release();
    }

    if (__config[NODE_CACHE_OVERFLOW]) {
      __config[NODE_CACHE_OVERFLOW].release();
    }
  } // 特殊的filter清除cache


  if ((need || contain(lv, FILTER)) && __config[NODE_CACHE_FILTER]) {
    __config[NODE_CACHE_FILTER].release();
  } // 向上清除等级>=REPAINT的汇总缓存信息，过程中可能会出现重复，因此节点上记录一个临时标防止重复递归


  while (parent) {
    var _config3 = parent.__config; // 向上查找，出现重复跳出

    if (_config3.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
      var id = _config3[NODE_UNIQUE_UPDATE_ID];

      if (cacheHash.hasOwnProperty(id)) {
        break;
      }

      cacheHash[id] = true;
    } // 没有的需要设置一个标识
    else {
      cacheHash[uniqueUpdateId] = true;
      _config3[NODE_UNIQUE_UPDATE_ID] = uniqueUpdateId++;
      cacheList.push(_config3);
    }

    var _lv = _config3[NODE_REFRESH_LV];

    var _need2 = _lv >= REPAINT;

    if (_need2 && _config3[NODE_CACHE]) {
      _config3[NODE_CACHE].release();
    } // 前面已经过滤了无改变NONE的，只要孩子有任何改变父亲就要清除


    if (_config3[NODE_CACHE_TOTAL]) {
      _config3[NODE_CACHE_TOTAL].release();
    }

    if (_config3[NODE_CACHE_FILTER]) {
      _config3[NODE_CACHE_FILTER].release();
    }

    if (_config3[NODE_CACHE_MASK]) {
      _config3[NODE_CACHE_MASK].release();
    }

    if (_config3[NODE_CACHE_OVERFLOW]) {
      _config3[NODE_CACHE_OVERFLOW].release();
    }

    parent = _config3[NODE_DOM_PARENT];
  }

  return true;
}

function cleanSvgCache(node, child) {
  var __config = node.__config;

  if (child) {
    __config[NODE_REFRESH_LV] |= REPAINT;
  } else {
    __config[NODE_CACHE_TOTAL].release();
  }

  if (Array.isArray(node.children)) {
    node.children.forEach(function (child) {
      if (child instanceof Component) {
        child = child.shadowRoot;
      }

      if (!(child instanceof Text)) {
        cleanSvgCache(child, true);
      }
    });
  }
}

var uuid = 0;

var Root = /*#__PURE__*/function (_Dom) {
  _inherits(Root, _Dom);

  var _super = _createSuper(Root);

  function Root(tagName, props, children) {
    var _this;

    _classCallCheck(this, Root);

    _this = _super.call(this, tagName, props);
    _this.__cd = children || []; // 原始children，再初始化过程中生成真正的dom

    _this.__dom = null; // 真实DOM引用

    _this.__mw = 0; // 记录最大宽高，防止尺寸变化清除不完全

    _this.__mh = 0; // this.__scx = 1; // 默认缩放，css改变canvas/svg缩放后影响事件坐标，有值手动指定，否则自动计算
    // this.__scy = 1;

    _this.__taskUp = [];
    _this.__taskCp = [];
    _this.__ref = {};
    _this.__reflowList = [{
      node: _assertThisInitialized(_this)
    }]; // 初始化填自己，第一次布局时复用逻辑完全重新布局

    _this.__animateController = new Controller();
    Event.mix(_assertThisInitialized(_this));
    _this.__config[NODE_UPDATE_HASH] = _this.__updateHash = {};
    _this.__uuid = uuid++;
    _this.__rlv = REBUILD; // 每次刷新最大lv

    return _this;
  }

  _createClass(Root, [{
    key: "__initProps",
    value: function __initProps() {
      var w = this.props.width;

      if (!isNil$7(w)) {
        var value = parseFloat(w) || 0;

        if (value > 0) {
          this.__width = value;
        }
      }

      var h = this.props.height;

      if (!isNil$7(h)) {
        var _value = parseFloat(h) || 0;

        if (_value > 0) {
          this.__height = _value;
        }
      }
    }
  }, {
    key: "__genHtml",
    value: function __genHtml(domName) {
      var _this2 = this;

      var res = "<".concat(domName); // 拼接处理属性

      Object.keys(this.props).forEach(function (k) {
        var v = _this2.props[k]; // 忽略事件

        if (!/^on[a-zA-Z]/.test(k)) {
          res += renderProp(k, v);
        }
      });
      res += "></".concat(domName, ">");
      return res;
    }
  }, {
    key: "__wrapEvent",
    value: function __wrapEvent(e) {
      var x, y; // 触摸结束取消特殊没有touches

      if (['touchend', 'touchcancel'].indexOf(e.type) === -1) {
        var dom = this.dom,
            __scx = this.__scx,
            __scy = this.__scy;

        var _dom$getBoundingClien = dom.getBoundingClientRect(),
            x2 = _dom$getBoundingClien.x,
            y2 = _dom$getBoundingClien.y,
            left = _dom$getBoundingClien.left,
            top = _dom$getBoundingClien.top,
            width = _dom$getBoundingClien.width,
            height = _dom$getBoundingClien.height;

        x = x2 || left || 0;
        y = y2 || top || 0;

        var _ref = e.touches ? e.touches[0] : e,
            clientX = _ref.clientX,
            clientY = _ref.clientY;

        x = clientX - x;
        y = clientY - y; // 外边的scale影响元素事件响应，根据倍数计算真实的坐标，优先手动指定，否则自动计算

        if (!isNil$7(__scx)) {
          x /= __scx;
        } else {
          x *= this.width / width;
        }

        if (!isNil$7(__scy)) {
          y /= __scy;
        } else {
          y *= this.height / height;
        }
      }

      return {
        event: e,
        stopPropagation: function stopPropagation() {
          this.__stopPropagation = true;
          e.stopPropagation();
        },
        stopImmediatePropagation: function stopImmediatePropagation() {
          this.__stopPropagation = true;
          this.__stopImmediatePropagation = true;
          e.stopImmediatePropagation();
        },
        preventDefault: function preventDefault() {
          e.preventDefault();
        },
        x: x,
        y: y,
        __hasEmitted: false
      };
    } // 类似touchend/touchcancel/touchmove这种无需判断是否发生于元素上，直接响应

  }, {
    key: "__cb",
    value: function __cb(e) {
      if (e.type === 'touchmove' && !this.__touchstartTarget) {
        return;
      }

      var data = this.__wrapEvent(e);

      this.__emitEvent(data);

      return data;
    }
    /**
     * 添加到真实Dom上，优先已存在的同名canvas/svg节点，没有则dom下生成新的
     * @param dom
     */

  }, {
    key: "appendTo",
    value: function appendTo(dom) {
      dom = getDom(dom);
      this.__children = builder.initRoot(this.__cd, this);

      this.__initProps();

      this.__root = this;
      this.cache = !!this.props.cache;
      var tagName = this.tagName;
      var domName = ROOT_DOM_NAME[tagName]; // OffscreenCanvas兼容，包含worker的

      if (typeof window !== 'undefined' && window.OffscreenCanvas && dom instanceof window.OffscreenCanvas || typeof self !== 'undefined' && self.OffscreenCanvas && dom instanceof self.OffscreenCanvas) {
        this.__dom = dom;
        this.__width = dom.width;
        this.__height = dom.height;
      } // 已有root节点
      else if (dom.nodeName.toLowerCase() === domName) {
        this.__dom = dom;

        if (this.width) {
          dom.setAttribute('width', this.width);
        }

        if (this.height) {
          dom.setAttribute('height', this.height);
        }
      } // 没有canvas/svg节点则生成一个新的
      else {
        this.__dom = dom.querySelector(domName);

        if (!this.__dom) {
          dom.innerHTML = this.__genHtml(domName);
          this.__dom = dom.querySelector(domName);
        }
      }

      this.__defs = this.dom.__defs || Defs.getInstance(this.__uuid); // 没有设置width/height则采用css计算形式

      if (!this.width || !this.height) {
        var _css = window.getComputedStyle(dom, null);

        if (!this.width) {
          this.__width = parseFloat(_css.getPropertyValue('width')) || 0;
          dom.setAttribute('width', this.width);
        }

        if (!this.height) {
          this.__height = parseFloat(_css.getPropertyValue('height')) || 0;
          dom.setAttribute('height', this.height);
        }
      } // 只有canvas有ctx，svg用真实dom


      if (this.tagName === 'canvas') {
        this.__ctx = this.__dom.getContext('2d');
        this.__renderMode = mode.CANVAS;
      } else if (this.tagName === 'svg') {
        this.__renderMode = mode.SVG;
      } else if (this.tagName === 'webgl') {
        var gl = this.__ctx = this.__dom.getContext('webgl', ca);

        this.__renderMode = mode.WEBGL;
        gl.program = webgl.initShaders(gl, vertex, fragment);
        gl.programMask = webgl.initShaders(gl, vertexMask, fragmentMask);
        gl.programClip = webgl.initShaders(gl, vertexMask, fragmentClip);
        gl.programOverflow = webgl.initShaders(gl, vertexMask, fragmentOverflow);
        gl.programCm = webgl.initShaders(gl, vertexCm, fragmentCm);
        gl.useProgram(gl.program); // 第一次渲染生成纹理缓存管理对象，收集渲染过程中生成的纹理并在gl纹理单元满了时进行绘制和清空，减少texImage2d耗时问题

        var MAX_TEXTURE_IMAGE_UNITS = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
        this.__texCache = new TexCache(MAX_TEXTURE_IMAGE_UNITS);
      }

      this.refresh(null, true); // 第一次节点没有__root，渲染一次就有了才能diff

      if (this.dom.__root && this.dom.__root instanceof Root) {
        this.dom.__root.destroy();
      }

      this.__eventCbList = initEvent(this.dom, Root);
      this.dom.__root = this;
    }
  }, {
    key: "refresh",
    value: function refresh(cb, isFirst) {
      this.__hookTask = null;
      var isDestroyed = this.isDestroyed,
          renderMode = this.renderMode,
          ctx = this.ctx,
          defs = this.defs,
          width = this.width,
          height = this.height;

      if (isDestroyed) {
        return;
      }

      defs.clear(); // 首次递归测量整树的继承，后续更改各自更新机制做，防止每次整树遍历；root检查首次直接做，后续在checkUpdate()中插入

      if (isFirst) {
        this.__checkRoot(renderMode, width, height);

        this.__computeMeasure(renderMode, ctx);
      } // 非首次刷新如果没有更新则无需继续
      else if (!this.__checkUpdate(renderMode, ctx, width, height)) {
        return;
      } // 获取所有字体和大小测量，仅svg需要，canvas直接做


      inject.measureText();

      this.__checkReflow(width, height);

      if (renderMode === mode.CANVAS && !this.props.noRender) {
        this.__clear(ctx, renderMode); // 利用list循环代替tree递归快速渲染


        if (this.cache) {
          struct.renderCacheCanvas(renderMode, ctx, this);
        } else {
          struct.renderCanvas(renderMode, ctx, this);
        }
      } // svg的特殊diff需要
      else if (renderMode === mode.SVG && !this.props.noRender) {
        struct.renderSvg(renderMode, defs, this, isFirst);
        var nvd = this.virtualDom;
        nvd.defs = defs.value;

        if (this.dom.__vd) {
          // console.log(this.dom.__vd);
          // console.log(nvd);
          diff(this.dom, this.dom.__vd, nvd);
        } else {
          this.dom.innerHTML = util.joinVirtualDom(nvd);
        }

        this.dom.__vd = nvd;
        this.dom.__defs = defs;
      } else if (renderMode === mode.WEBGL && !this.props.noRender) {
        this.__clear(ctx, renderMode);

        struct.renderWebgl(renderMode, ctx, this);
      } // 特殊cb，供小程序绘制完回调使用


      if (isFunction$1(cb)) {
        cb();
      }

      this.emit(Event.REFRESH, this.__rlv);
      this.__rlv = NONE;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.__destroy();

      this.animateController.__destroy();

      var n = this.dom;

      if (n) {
        removeEvent(n, this.__eventCbList || []);
        n.__root = null;
      }

      var gl = this.ctx;

      if (this.__texCache && gl) {
        this.__texCache.release(gl);

        if (gl.program) {
          gl.deleteShader(gl.program.vertexShader);
          gl.deleteShader(gl.program.fragmentShader);
          gl.deleteProgram(gl.program);
        }

        if (gl.programMask) {
          gl.deleteShader(gl.programMask.vertexShader);
          gl.deleteShader(gl.programMask.fragmentShader);
          gl.deleteProgram(gl.programMask);
        }

        if (gl.programOverflow) {
          gl.deleteShader(gl.programOverflow.vertexShader);
          gl.deleteShader(gl.programOverflow.fragmentShader);
          gl.deleteProgram(gl.programOverflow);
        }
      }
    }
  }, {
    key: "scale",
    value: function scale() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      this.__scx = x;
      this.__scy = y;
    }
  }, {
    key: "resize",
    value: function resize(w, h, cb) {
      var self = this;

      if (w !== self.width || h !== self.height) {
        self.__width = w;
        self.__height = h;
        self.updateStyle({
          width: w,
          height: h
        }, cb);
      } else if (isFunction$1(cb)) {
        cb(-1);
      }
    }
  }, {
    key: "addRefreshTask",
    value: function addRefreshTask(cb) {
      var _this3 = this;

      var taskUp = this.taskUp,
          isDestroyed = this.isDestroyed;

      if (isDestroyed) {
        return;
      } // 第一个添加延迟侦听，后续放队列等待一并执行


      if (!taskUp.length) {
        var clone;
        frame.nextFrame({
          __before: function __before(diff) {
            if (_this3.isDestroyed) {
              return;
            }

            clone = taskUp.splice(0); // 前置一般是动画计算此帧样式应用，然后刷新后出发frame事件，图片加载等同

            if (clone.length) {
              clone.forEach(function (item, i) {
                if (isObject(item) && isFunction$1(item.__before)) {
                  item.__before(diff);
                }
              });
            }
          },
          __after: function __after(diff) {
            if (_this3.isDestroyed) {
              return;
            }

            clone.forEach(function (item) {
              if (isObject(item) && isFunction$1(item.__after)) {
                item.__after(diff);
              } else if (isFunction$1(item)) {
                item(diff);
              }
            });
          }
        });

        this.__frameHook();
      }

      if (taskUp.indexOf(cb) === -1) {
        taskUp.push(cb);
      }
    }
  }, {
    key: "delRefreshTask",
    value: function delRefreshTask(cb) {
      if (!cb) {
        return;
      }

      var taskUp = this.taskUp;

      for (var i = 0, len = taskUp.length; i < len; i++) {
        if (taskUp[i] === cb) {
          taskUp.splice(i, 1);
          break;
        }
      }
    }
    /**
     * 为component的setState更新专门开辟个独立的流水线，root/frame中以taskCp存储更新列表
     * 普通的动画、img加载等都走普通的refresh的task，component走这里，frame中的结构同样
     * 在frame的每帧调用中，先执行普通的动画task，再执行component的task
     * 这样动画执行完后，某个cp的sr及子节点依旧先进行了动画变更，进入__addUpdate()环节
     * 然后此cp再更新sr及子节点，这样会被__addUpdate()添加到尾部，依赖目前浏览器默认实现
     * 上一行cp更新过程中是updater.check()进行的，如果有新老交换且有动画，动画的assigning是true，进行继承
     * root刷新parseUpdate()时，老的sr及子节点先进行，随后新的sr后进行且有component标识，sr子节点不会有更新
     * @param cb
     */

  }, {
    key: "addRefreshCp",
    value: function addRefreshCp(cb) {
      var _this4 = this;

      var taskCp = this.taskCp,
          isDestroyed = this.isDestroyed;

      if (isDestroyed) {
        return;
      } // 每次只执行1次


      if (!taskCp.length) {
        var clone;

        frame.__nextFrameCp({
          __before: function __before(diff) {
            if (_this4.isDestroyed) {
              return;
            }

            clone = taskCp.splice(0);

            if (clone.length) {
              clone.forEach(function (item) {
                item.__before(diff);
              });
              updater.check(_this4);
              var len = updater.updateList.length;

              if (len) {
                updater.updateList.forEach(function (cp) {
                  var sr = cp.shadowRoot; // 可能返回text，需视为其parentNode

                  if (sr instanceof Text) {
                    sr = sr.domParent;
                  }

                  var res = {};
                  res[UPDATE_NODE] = sr;
                  res[UPDATE_STYLE] = sr.currentStyle;
                  res[UPDATE_FOCUS] = REFLOW;
                  res[UPDATE_MEASURE] = true;
                  res[UPDATE_COMPONENT] = cp;
                  res[UPDATE_CONFIG] = sr.__config;

                  _this4.__addUpdate(sr, sr.__config, _this4, _this4.__config, res);
                });
              }
            }
          },
          __after: function __after(diff) {
            if (_this4.isDestroyed) {
              return;
            }

            clone.forEach(function (item) {
              item.__after(diff);
            }); // 触发didUpdate

            updater.did();
          }
        });

        this.__frameHook();
      }

      if (taskCp.indexOf(cb) === -1) {
        taskCp.push(cb);
      }
    }
  }, {
    key: "getTargetAtPoint",
    value: function getTargetAtPoint(x, y, includeIgnore) {
      function scan(vd, x, y, path, zPath) {
        var __sx1 = vd.__sx1,
            __sy1 = vd.__sy1,
            offsetWidth = vd.offsetWidth,
            offsetHeight = vd.offsetHeight,
            matrixEvent = vd.matrixEvent,
            children = vd.children,
            zIndexChildren = vd.zIndexChildren,
            _vd$computedStyle = vd.computedStyle,
            display = _vd$computedStyle[DISPLAY],
            pointerEvents = _vd$computedStyle[POINTER_EVENTS];

        if (!includeIgnore && display === 'none') {
          return;
        }

        if (Array.isArray(zIndexChildren)) {
          for (var i = 0, len = children.length; i < len; i++) {
            children[i].__index__ = i;
          }

          for (var _i2 = zIndexChildren.length - 1; _i2 >= 0; _i2--) {
            var item = zIndexChildren[_i2];

            if (item instanceof karas.Text) {
              continue;
            }

            var path2 = path.slice();
            path2.push(item.__index__);
            var zPath2 = zPath.slice();
            zPath2.push(_i2);
            var res = scan(item, x, y, path2, zPath2);

            if (res) {
              return res;
            }
          }
        }

        if (!includeIgnore && pointerEvents === 'none') {
          return;
        }

        var inThis = geom$1.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + offsetWidth, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight, __sx1, __sy1 + offsetHeight, matrixEvent);

        if (inThis) {
          return {
            target: vd,
            path: path,
            zPath: zPath
          };
        }
      }

      return scan(this, x, y, [], []);
    }
    /**
     * 每次刷新前检查root节点的样式，有些固定的修改无效，有些继承的作为根初始化
     * @param renderMode
     * @param width
     * @param height
     * @private
     */

  }, {
    key: "__checkRoot",
    value: function __checkRoot(renderMode, width, height) {
      var dom = this.dom,
          currentStyle = this.currentStyle,
          computedStyle = this.computedStyle; // canvas/svg作为根节点一定是block或flex，不会是inline

      if (['flex', 'block'].indexOf(currentStyle[DISPLAY]) === -1) {
        computedStyle[DISPLAY] = currentStyle[DISPLAY] = 'block';
      } // 同理position不能为absolute


      if (currentStyle[POSITION] === 'absolute') {
        computedStyle[POSITION] = currentStyle[POSITION] = 'static';
      } // 根节点满宽高


      currentStyle[WIDTH] = [width, PX];
      currentStyle[HEIGHT] = [height, PX];
      computedStyle[WIDTH] = width;
      computedStyle[HEIGHT] = height; // 可能调用resize()导致变更，要重设，canvas无论离屏与否都可使用直接赋值，svg则按dom属性api

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (dom.width !== width) {
          dom.width = width;
        }

        if (dom.height !== height) {
          dom.height = height;
        }
      } else if (renderMode === mode.SVG) {
        dom.setAttribute('width', width);
        dom.setAttribute('height', height);
      }
    }
    /**
     * 添加更新入口，按节点汇总更新信息
     * @private
     */

  }, {
    key: "__addUpdate",
    value: function __addUpdate(node, nodeConfig, root, rootConfig, o) {
      var updateHash = rootConfig[NODE_UPDATE_HASH]; // root特殊处理，检查变更时优先看继承信息

      if (node === root) {
        updateHash = root.__updateRoot;

        if (updateHash) {
          if (o[UPDATE_FOCUS]) {
            updateHash[UPDATE_FOCUS] |= o[UPDATE_FOCUS];
          }

          if (o[UPDATE_MEASURE]) {
            updateHash[UPDATE_MEASURE] = true;
          } // 后续存在新建list上，需增加遍历逻辑


          if (o[UPDATE_STYLE]) {
            var _list$push;

            var list = updateHash[UPDATE_LIST] = updateHash[UPDATE_LIST] || [];
            list.push((_list$push = {}, _defineProperty(_list$push, UPDATE_STYLE, o[UPDATE_STYLE]), _defineProperty(_list$push, UPDATE_OVERWRITE, o[UPDATE_OVERWRITE]), _defineProperty(_list$push, UPDATE_KEYS, o[UPDATE_KEYS]), _list$push));
          }
        } else {
          root.__updateRoot = o;
        }
      } else if (!nodeConfig.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
        nodeConfig[NODE_UNIQUE_UPDATE_ID] = uniqueUpdateId; // 大多数情况节点都只有一次更新，所以优化首次直接存在style上，后续存在list

        updateHash[uniqueUpdateId++] = o;
      } else if (updateHash.hasOwnProperty(nodeConfig[NODE_UNIQUE_UPDATE_ID])) {
        var target = updateHash[nodeConfig[NODE_UNIQUE_UPDATE_ID]];

        if (o[UPDATE_FOCUS]) {
          target[UPDATE_FOCUS] |= o[UPDATE_FOCUS];
        }

        if (o[UPDATE_MEASURE]) {
          target[UPDATE_MEASURE] = true;
        } // 后续存在新建list上，需增加遍历逻辑


        if (o[UPDATE_STYLE]) {
          var _list$push2;

          var _list = target[UPDATE_LIST] = target[UPDATE_LIST] || [];

          _list.push((_list$push2 = {}, _defineProperty(_list$push2, UPDATE_STYLE, o[UPDATE_STYLE]), _defineProperty(_list$push2, UPDATE_OVERWRITE, o[UPDATE_OVERWRITE]), _defineProperty(_list$push2, UPDATE_KEYS, o[UPDATE_KEYS]), _list$push2));
        }
      } else {
        inject.error('Update process miss uniqueUpdateId');
      }
    }
    /**
     * 除首次外每次刷新前检查更新列表，计算样式变化，以及测量信息
     * @private
     */

  }, {
    key: "__checkUpdate",
    value: function __checkUpdate(renderMode, ctx, width, height) {
      var root = this;
      var measureList = [];
      var reflowList = [];
      var cacheHash = {};
      var cacheList = [];
      var zHash = {};
      var zList = [];
      var updateRoot = root.__updateRoot;
      var updateHash = root.__updateHash;
      var hasUpdate; // root更新特殊提前，因为有继承因素

      if (updateRoot) {
        root.__updateRoot = null;
        hasUpdate = parseUpdate(renderMode, root, updateRoot, reflowList, measureList, cacheHash, cacheList); // 此时做root检查，防止root出现继承等无效样式，或者发生resize()

        if (hasUpdate) {
          root.__checkRoot(renderMode, width, height);
        }
      } // 汇总处理每个节点，k是递增数字直接循环遍历


      var keys = Object.keys(updateHash);

      for (var i = 0, len = keys.length; i < len; i++) {
        var t = parseUpdate(renderMode, root, updateHash[keys[i]], reflowList, measureList, cacheHash, cacheList, zHash, zList);
        hasUpdate = hasUpdate || t;
      } // 先做一部分reset避免下面measureList干扰，cacheList的是专门收集新增的额外节点


      root.__reflowList = reflowList;
      uniqueUpdateId = 0;
      root.__updateHash = root.__config[NODE_UPDATE_HASH] = {};
      cacheList.forEach(function (__config) {
        delete __config[NODE_UNIQUE_UPDATE_ID];
      }); // zIndex改变的汇总修改，防止重复操作

      zList.forEach(function (item) {
        if (item.hasOwnProperty('__uniqueZId')) {
          delete item.__uniqueZId;

          item.__updateStruct(root.__structs);
        }
      });
      /**
       * 遍历每项节点，计算测量信息，节点向上向下查找继承信息，如果parent也是继承，先计算parent的
       * 过程中可能会出现重复，因此节点上记录一个临时标防止重复递归
       */

      var measureHash = {};
      measureList.forEach(function (node) {
        var _node$__config = node.__config,
            __uniqueUpdateId = _node$__config[NODE_UNIQUE_UPDATE_ID],
            parent = _node$__config[NODE_DOM_PARENT]; // 在root下的component变更时root会进入，但其没有__uniqueUpdateId

        if (node !== root) {
          if (measureHash.hasOwnProperty(__uniqueUpdateId)) {
            return;
          }

          measureHash[__uniqueUpdateId] = true;
        }

        var last = node; // 检查measure的属性是否是inherit，在root下的component变更时root会进入，但其没有__uniqueUpdateId
        // 另外dom标识表明有dom变更强制进入

        var isInherit = node !== root && (updateHash[__uniqueUpdateId][UPDATE_ADD_DOM] || o$2.isMeasureInherit(updateHash[__uniqueUpdateId][UPDATE_STYLE])); // 是inherit，需要向上查找，从顶部向下递归计算继承信息

        if (isInherit) {
          while (parent && parent !== root) {
            var _parent = parent,
                _uniqueUpdateId = _parent.__config[NODE_UNIQUE_UPDATE_ID],
                currentStyle = _parent.currentStyle;

            var _isInherit = void 0;

            if (parent.__config.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
              var style = updateHash[_uniqueUpdateId][UPDATE_STYLE];
              measureHash[_uniqueUpdateId] = true;
              var temp = o$2.measureInheritList(style);
              _isInherit = !!temp.length;
            } else {
              _isInherit = o$2.isMeasureInherit(currentStyle);
            } // 如果parent有inherit存入列表且继续向上，否则跳出循环


            if (_isInherit) {
              last = parent;
            } else {
              break;
            } // 考虑component下的继续往上继承


            parent = parent.domParent;
          }
        } // 自顶向下查找inherit的，利用已有的方法+回调，当递归包含重复时标记防止重复


        last.__computeMeasure(renderMode, ctx, function (target) {
          if (target.__config.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
            measureHash[target.__config[NODE_UNIQUE_UPDATE_ID]] = true;
          }
        });
      }); // 做完清空留待下次刷新重来

      for (var _i3 = 0, _len2 = keys.length; _i3 < _len2; _i3++) {
        delete updateHash[keys[_i3]][UPDATE_CONFIG][NODE_UNIQUE_UPDATE_ID];
      }

      return hasUpdate;
    }
    /**
     * 除首次外每次刷新前检查reflow列表，计算需要reflow的节点局部重新布局
     * 当一个元素absolute不变时，其变化不会影响父元素和兄弟元素，直接自己重新局部LAYOUT包含子节点
     * 当absolute发生改变时，其变化会影响父和兄弟，视作父重新布局
     * 当inline变化时，视为其最近block/flex父变化
     * 当block变化时，往上查找最上层flex视为其变化，如不是则影响后面兄弟offset和父resize
     * 当flex变化时，往上查找最上层flex视为其变化，如不是则影响所有递归子节点layout和父resize
     * 以上3种情况向上查找时遇到absolute父均提前跳出，并标记absolute父LAYOUT
     * 上面所有情况即便结束还得额外看是否处于absolute中，是还是标记absolute重新布局
     * 当relative只变化left/top/right/bottom时，自己重新layout
     * 检测节点时记录影响的所有节点，最终形成一棵或n棵局部树
     * 需要重新布局的记作LAYOUT，被兄弟影响只需偏移的记作OFFSET，OFFSET可能会重复变为LAYOUT
     * 上述情况倘若发生包含重复，去掉子树，因子树视为被包含的重新布局
     * 如果有从root开始的，直接重新布局像首次那样即可
     * 如果非root，所有树根按先根顺序记录下来，依次执行局部布局
     * =========================
     * addDom比较特殊，是向已有节点中添加新的节点，检查影响与普通domDiff变化不同
     * @private
     */

  }, {
    key: "__checkReflow",
    value: function __checkReflow(width, height) {
      var _this5 = this;

      var reflowList = this.__reflowList;

      if (!reflowList.length) {
        return;
      }

      var root = this;
      var uniqueList = [];
      var hasRoot;
      __uniqueReflowId = 0;
      var reflowHash = {}; // 遍历检查发生布局改变的节点列表，此时computedStyle还是老的，currentStyle是新的

      for (var i = 0, len = reflowList.length; i < len; i++) {
        var item = reflowList[i];
        var node = item.node,
            component = item.component,
            addDom = item.addDom,
            removeDom = item.removeDom; // root提前跳出，完全重新布局

        if (node === this) {
          hasRoot = true;
          break;
        } // 添加时如果是cp则node取sr来布局


        if (addDom && node instanceof Component) {
          node = node.shadowRoot;
        } // 每个节点生成唯一的布局识别id存入hash防止重复


        if (!node.hasOwnProperty('__uniqueReflowId')) {
          node.__uniqueReflowId = __uniqueReflowId;
          reflowHash[__uniqueReflowId++] = item;
        } // 每个节点都向上检查影响，以及是否从root开始完全重新，remove特殊对待，影响父节点视为普通父节点relay


        if (checkInfluence(root, reflowHash, node, component, addDom)) {
          hasRoot = true;

          if (addDom) {
            this.__zIndexChildren = null;
          }

          break;
        } // remove的要特殊对待，因为提前删除了父子兄弟关系，下面deepScan不会出现
        else if (removeDom) {
          uniqueList.push(item);
        }
      }

      __uniqueReflowId = 0;
      this.__reflowList = []; // 有root提前跳出

      if (hasRoot) {
        reflow.clearUniqueReflowId(reflowHash); // 布局分为两步，普通流和定位流，互相递归

        this.__layout({
          x: 0,
          y: 0,
          w: width,
          h: height
        }); // 绝对布局需要从根开始保存相对坐标系的容器引用，并根据relative/absolute情况变更


        this.__layoutAbs(this, {
          x: 0,
          y: 0,
          w: width,
          h: height
        });

        this.__structs = this.__structure(0, 0);
        return true;
      }
      /**
       * 修剪树，自顶向下深度遍历
       * LAYOUT节点作为局部根，其递归子节点无需重复任何操作，直接去重
       * OFFSET节点作为局部根，其递归子节点先执行任何操作，后续根节点再偏移一次
       */
      else {
        this.__deepScan(function (node, options) {
          if (node.hasOwnProperty('__uniqueReflowId')) {
            var o = reflowHash[node.__uniqueReflowId];
            options.uniqueList.push(o); // 返回true即可提前结束深度遍历，在reflowHash有记录时提前跳出，子节点交由上面逻辑执行

            return true;
          } // reflowHash没有记录则无返回继续递归执行

        }, {
          uniqueList: uniqueList
        });
        /**
         * 按顺序执行列表即可，上层LAYOUT先执行且停止递归子节点，上层OFFSET后执行等子节点先LAYOUT/OFFSET
         * 同级按先后顺序排列，过程中记录diff在结束后进行structs更新
         * 这里要注意margin合并的逻辑，因为最终都是block（flex等同），需要进行合并
         * 在处理一个block时，先判断是否是空block，同时看后面紧邻的有没有在uniqueList的下一个
         * 单独空block处理、2个相邻的非block处理直接可以进行判断
         * 中间的空block（即非空block的下一个是空block，且下一个不是最后一个），先记录下来list，合并后一并offset
         * 合并margin和Dom的逻辑一样，抽离共有方法
         **/


        var diffList = [];
        var diffI = 0;
        var mergeOffsetList = [];
        var __uniqueMergeOffsetId = 0;
        uniqueList.forEach(function (item) {
          var node = item.node,
              component = item.component,
              addDom = item.addDom,
              removeDom = item.removeDom; // 重新layout的w/h数据使用之前parent暂存的，x使用parent，y使用prev或者parent的

          var cps = node.computedStyle,
              cts = node.currentStyle;
          var zIndex = cps[Z_INDEX],
              position = cps[POSITION],
              display = cps[DISPLAY];
          var isLastAbs = position === 'absolute';
          var isNowAbs = cts[POSITION] === 'absolute';
          var isLastNone = display === 'none';
          var isNowNone = cts[DISPLAY] === 'none'; // none不可见布局无效可以无视

          if (isLastNone && isNowNone) {
            return;
          }

          var parent = node.domParent;
          var _parent$__layoutData = parent.__layoutData,
              x = _parent$__layoutData.x,
              y = _parent$__layoutData.y,
              h = _parent$__layoutData.h,
              width = parent.width,
              computedStyle = parent.computedStyle;
          var current = node; // cp的shadowRoot要向上到cp本身，考虑高阶组件在内到真正的顶层cp

          if (current.isShadowRoot) {
            current = current.hostRoot;
          } // y使用prev或者parent的，首个节点无prev，prev要忽略absolute的和display:none的


          var ref = current.prev;
          var hasFlowPrev;

          while (ref) {
            if (ref instanceof Text || ref.computedStyle[POSITION] !== 'absolute' && ref.computedStyle[DISPLAY] !== 'none') {
              y = ref.y + ref.outerHeight;
              hasFlowPrev = true;
              break;
            }

            ref = ref.prev;
          } // 找不到prev以parent为基准，找到则增加自身，排除remove


          if (!removeDom) {
            if (!hasFlowPrev) {
              y += computedStyle[MARGIN_TOP] + computedStyle[BORDER_TOP_WIDTH] + computedStyle[PADDING_TOP];
            }

            x += computedStyle[MARGIN_LEFT] + computedStyle[BORDER_LEFT_WIDTH] + computedStyle[PADDING_LEFT];
          } // 找到最上层容器，如果是组件的子节点，以sr为container，sr本身往上找


          var container = node; // remove的节点本身无需再次布局

          if (!removeDom) {
            if (isNowAbs) {
              container = container.domParent;

              while (container && container !== root) {
                if (isRelativeOrAbsolute(container)) {
                  break;
                } // 不能用domParent，必须在组件环境内


                if (container.parent) {
                  container = container.parent;
                } else if (container.host) {
                  break;
                }
              }

              if (!container) {
                container = root;
              } // 由setState引发的要检查是cp自身还是更上层，如果cp被abs包含，那么node是cp的父亲，否则node是cp的sr
              // 而这种情况下传cp或node都一样，所以最终统一传node


              parent.__layoutAbs(container, null, node); // 优先判断dom变更


              if (addDom) {
                var arr = parent.__modifyStruct(root, diffI);

                diffI += arr[1];
                diffList.push(arr);

                parent.__updateStruct(root.__structs);

                if (_this5.renderMode === mode.SVG) {
                  cleanSvgCache(parent);
                }

                return;
              } // 前后都是abs无需偏移后面兄弟和parent调整，component变化节点需更新struct
              else if (isLastAbs) {
                if (component) {
                  var _arr = node.__modifyStruct(root, diffI);

                  diffI += _arr[1];
                  diffList.push(_arr);

                  if (position !== cts[POSITION] && (position === 'static' || cts[POSITION] === 'static') || zIndex !== cts[Z_INDEX]) {
                    parent.__updateStruct(root.__structs);

                    if (_this5.renderMode === mode.SVG) {
                      cleanSvgCache(parent);
                    }
                  }
                } else if (isLastNone || isNowNone) {
                  node.__zIndexChildren = null;

                  var _arr2 = node.__modifyStruct(root, diffI);

                  diffI += _arr2[1];
                  diffList.push(_arr2);
                }

                return;
              } // 标识flow变abs，可能引发zIndex变更，重设struct和svg


              parent.__updateStruct(root.__structs);

              if (_this5.renderMode === mode.SVG) {
                cleanSvgCache(parent);
              }
            } // 现在是普通流，不管之前是啥直接布局，排除remove删除的
            else {
              node.__layout({
                x: x,
                y: y,
                w: width,
                h: h
              });

              y += node.outerHeight;

              if (component) {
                container = node;
              } else {
                container = container.domParent;

                while (container && container !== root) {
                  if (isRelativeOrAbsolute(container)) {
                    break;
                  } // 不能用domParent，必须在组件环境内


                  if (container.parent) {
                    container = container.parent;
                  } else if (container.host) {
                    break;
                  }
                }
              }

              if (!container) {
                container = root;
              } // 防止geom


              if (node instanceof Dom) {
                node.__layoutAbs(container, {
                  x: x,
                  y: y,
                  w: width,
                  h: h
                });
              }
            }
          } // 向上查找最近的parent是relative，需再次累加ox/oy，无需继续向上递归，因为parent已经递归包含了
          // 这样node重新布局后再次设置其使用parent的偏移


          var p = node;

          while (p && p !== root) {
            p = p.domParent;
            computedStyle = p.computedStyle;

            if (computedStyle[POSITION] === 'relative') {
              var _p = p,
                  ox = _p.ox,
                  oy = _p.oy;
              ox && node.__offsetX(ox);
              oy && node.__offsetY(oy);
              break;
            }
          } // 向下调整next的flow位置，遇到重复LAYOUT的跳出等待其调用并处理其next，忽视掉abs，margin和abs在merge中做


          if (node.isShadowRoot) {
            node = node.hostRoot;
          }

          var next = node.next;

          while (next && !next.hasOwnProperty('__uniqueReflowId')) {
            if (next.computedStyle[POSITION] === 'absolute') {
              next = next.next;
              continue;
            }

            var _next = next,
                _oy = _next.y;

            var _diff = y - _oy;

            if (_diff) {
              while (next && !next.hasOwnProperty('__uniqueReflowId')) {
                var target = next;

                if (target instanceof Component) {
                  target = target.shadowRoot;
                }

                var cs = target.computedStyle;

                if (cs[POSITION] !== 'absolute' && cs[DISPLAY] !== 'none') {
                  target.__offsetY(_diff, true, REPAINT);
                }

                next = next.next;
              }
            }

            break;
          } // 去重防止abs并记录parent，整个结束后按先序顺序进行margin合并以及偏移，注意忽略有display:none变block同时为absolute的


          if (!parent.hasOwnProperty('__uniqueMergeOffsetId') && !(isNowAbs && isLastNone)) {
            parent.__uniqueMergeOffsetId = __uniqueMergeOffsetId++;
            mergeOffsetList.push(parent);
          } // add和remove都需父节点重新生成struct，zIndexChildren已在对应api操作的before()侦听做了


          if (addDom || removeDom) {
            var _arr3 = parent.__modifyStruct(root, diffI);

            diffI += _arr3[1];
            diffList.push(_arr3);

            if (_this5.renderMode === mode.SVG) {
              cleanSvgCache(parent);
            }
          } // component未知dom变化，所以强制重新struct，text则为其父节点，同时防止zIndex变更影响父节点
          else if (component) {
            var _arr4 = node.__modifyStruct(root, diffI);

            diffI += _arr4[1];
            diffList.push(_arr4);

            if (position !== cts[POSITION] && (position === 'static' || cts[POSITION] === 'static') || zIndex !== cts[Z_INDEX]) {
              node.domParent.__updateStruct(root.__structs);

              if (_this5.renderMode === mode.SVG) {
                cleanSvgCache(node.domParent);
              }
            }
          } // display有none变化，重置struct和zIndexChildren
          else if (isLastNone || isNowNone) {
            node.__zIndexChildren = null;

            var _arr5 = node.__modifyStruct(root, diffI);

            diffI += _arr5[1];
            diffList.push(_arr5);
          }
        });
        /**
         * mergeMargin后续调整，记录的是变更节点的父节点，因此每个节点内部直接遍历孩子进行
         * 由于保持先根遍历的顺序，因此会从最上最里的节点开始，先进行margin合并
         * 由于之前忽略掉abs节点，因此再检查直接abs是否要调整
         * 完成后对此父节点的后续兄弟节点进行调整，多次不会干扰影响
         * 然后继续往上循环，直到root结束
         */

        var inDirectAbsList = [];
        mergeOffsetList.forEach(function (parent) {
          delete parent.__uniqueMergeOffsetId;
          var flowChildren = parent.flowChildren,
              absChildren = parent.absChildren;
          var mergeMarginBottomList = [],
              mergeMarginTopList = [];
          var length = flowChildren.length,
              lastChild;
          var isStart, startIndex; // 遍历flow孩子，从开始变化的节点开始，看变化造成的影响，对其后面节点进行偏移，并统计总偏移量

          for (var _i4 = 0; _i4 < length; _i4++) {
            var _item = flowChildren[_i4];

            if (_item instanceof Component) {
              _item = _item.shadowRoot;
            }

            var isXom = _item instanceof Xom; // 忽略掉前面没有变更的节点，不能合并

            if (!isStart && isXom) {
              if (_item.hasOwnProperty('__uniqueReflowId')) {
                isStart = true;
                startIndex = _i4;
              }
            } // 开始变更的节点，至少不是第0个


            var _cs = isXom && _item.currentStyle;

            var isInline = isXom && _cs[DISPLAY] === 'inline';
            var isInlineBlock = isXom && ['inlineBlock', 'inline-block'].indexOf(_cs[DISPLAY]) > -1;
            lastChild = _item; // 每次循环开始前，这次不是block的话，看之前遗留的，可能是以空block结束，需要特殊处理，单独一个空block也包含

            if (!isXom || isInline || isInlineBlock) {
              if (mergeMarginBottomList.length && mergeMarginTopList.length && isStart) {
                var _diff2 = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList);

                if (_diff2) {
                  for (var j = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); j < length; j++) {
                    flowChildren[j].__offsetY(_diff2, true, REPAINT);
                  }
                }
              }

              mergeMarginTopList = [];
              mergeMarginBottomList = [];
            } // 和普通布局类似，只是不用重新布局只需处理合并margin再根据差值偏移


            if (isXom && !isInline) {
              var isNone = isXom && _cs[DISPLAY] === 'none';
              var isEmptyBlock = void 0;

              if (!isNone && _item.flowChildren && _item.flowChildren.length === 0) {
                var _item$computedStyle = _item.computedStyle,
                    marginTop = _item$computedStyle[MARGIN_TOP],
                    marginBottom = _item$computedStyle[MARGIN_BOTTOM],
                    paddingTop = _item$computedStyle[PADDING_TOP],
                    paddingBottom = _item$computedStyle[PADDING_BOTTOM],
                    _height = _item$computedStyle[HEIGHT],
                    borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH],
                    borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

                if (paddingTop <= 0 && paddingBottom <= 0 && _height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                  mergeMarginBottomList.push(marginBottom);
                  mergeMarginTopList.push(marginTop);
                  isEmptyBlock = true;
                }
              } // 空block要留下轮循环看，除非是最后一个，非空本轮处理掉看是否要合并


              if (!isNone && !isEmptyBlock) {
                var _item$computedStyle2 = _item.computedStyle,
                    _marginTop = _item$computedStyle2[MARGIN_TOP],
                    _marginBottom = _item$computedStyle2[MARGIN_BOTTOM]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
                // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

                if (mergeMarginBottomList.length) {
                  mergeMarginTopList.push(_marginTop);

                  if (isStart) {
                    var _diff3 = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList); // 需要合并的情况，根据记录数和索引向上向下遍历节点设置偏移，同时设置总偏移量供父级使用


                    if (_diff3) {
                      for (var _j = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); _j < length; _j++) {
                        flowChildren[_j].__offsetY(_diff3, true, REPAINT);
                      }
                    }
                  }
                } // 同时自己保存bottom，为后续block准备


                mergeMarginTopList = [];
                mergeMarginBottomList = [_marginBottom];
              } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0，最后一个一定有不必判断isStart
              else if (_i4 === length - 1) {
                var _diff4 = reflow.getMergeMarginTB(mergeMarginTopList, mergeMarginBottomList);

                if (_diff4) {
                  for (var _j2 = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); _j2 < length; _j2++) {
                    flowChildren[_j2].__offsetY(_diff4, true, REPAINT);
                  }
                }
              }
            }
          } // 先检查parent的尺寸是否发生了变化，从而决定是否调整next以及向上递归调整


          var cs = parent.currentStyle;
          var height = cs[HEIGHT];
          var isContainer = parent === root || parent.isShadowRoot || cs[POSITION] === 'absolute' || cs[POSITION] === 'relative';

          if (height[1] === AUTO && lastChild) {
            var oldH = parent.height + parent.computedStyle[PADDING_TOP];
            var nowH = lastChild.y + lastChild.outerHeight - parent.y;

            var _diff5 = nowH - oldH; // 调整next以及非固定PX的abs，再递归向上


            if (_diff5) {
              parent.__resizeY(_diff5, REPAINT);

              var container;

              for (var _i5 = 0, _len3 = absChildren.length; _i5 < _len3; _i5++) {
                var _item2 = absChildren[_i5];
                var _item2$currentStyle = _item2.currentStyle,
                    top = _item2$currentStyle[TOP],
                    bottom = _item2$currentStyle[BOTTOM],
                    _height2 = _item2$currentStyle[HEIGHT]; // 是容器，所有的都调整，不是容器，其偏移是上级parent的某一个，根据情况具体不同

                if (top[1] === AUTO) {
                  if (bottom[1] === AUTO) {
                    var prev = _item2.prev;

                    while (prev) {
                      var target = prev;

                      if (target instanceof Component) {
                        target = target.shadowRoot;
                      }

                      var _isXom = target instanceof Xom;

                      var _cs2 = _isXom && target.currentStyle;

                      var isAbs = _isXom && _cs2[POSITION] === 'absolute';

                      if (!isAbs) {
                        var y = target.y + target.outerHeight;
                        var d = y - _item2.y;

                        if (d) {
                          _item2.__offsetY(d, true, REPAINT);
                        }

                        break;
                      }

                      prev = prev.prev;
                    }
                  } else if (bottom[1] === PX) {
                    _item2.__offsetY(_diff5, true, REPAINT);
                  } else if (bottom[1] === PERCENT) {
                    var v = (1 - bottom[0] * 0.01) * _diff5;

                    _item2.__offsetY(v, true, REPAINT);
                  }
                } else if (top[1] === PERCENT) {
                  if (isContainer) {
                    var _v = top[0] * 0.01 * _diff5;

                    _item2.__offsetY(_v, true, REPAINT);
                  } // 非容器的特殊处理
                  else {
                    if (!container) {
                      container = parent.domParent;

                      while (container) {
                        if (container === root || container.isShadowRoot) {
                          break;
                        }

                        var _cs3 = container.currentStyle;

                        if (_cs3[POSITION] === 'absolute' || _cs3[POSITION] === 'relative') {
                          break;
                        }

                        container = container.domParent;
                      }
                    }

                    if (container.currentStyle[HEIGHT][1] !== PX) {
                      var _v2 = top[0] * 0.01 * _diff5;

                      _item2.__offsetY(_v2, true, REPAINT);
                    }
                  }
                } // 高度百分比需发生变化的重新布局，需要在容器内


                if (_height2[1] === PERCENT) {
                  if (isContainer) {
                    parent.__layoutAbs(parent, null, _item2);
                  } // 不在容器内说明在上级，存入等结束后统一重新布局
                  else {
                    if (!container) {
                      container = parent.domParent;

                      while (container) {
                        if (container === root || container.isShadowRoot) {
                          break;
                        }

                        var _cs4 = container.currentStyle;

                        if (_cs4[POSITION] === 'absolute' || _cs4[POSITION] === 'relative') {
                          break;
                        }

                        container = container.domParent;
                      }
                    }

                    inDirectAbsList.push([parent, container, _item2]);
                  }
                }
              }

              reflow.offsetAndResizeByNodeOnY(parent, root, reflowHash, _diff5, inDirectAbsList);
              return;
            }
          } // 没有diff变化或者固定尺寸，可能内部发生变化，调整AUTO的abs，不递归向上


          for (var _i6 = 0, _len4 = absChildren.length; _i6 < _len4; _i6++) {
            var _item3 = absChildren[_i6];
            var _item3$currentStyle = _item3.currentStyle,
                _top = _item3$currentStyle[TOP],
                _bottom = _item3$currentStyle[BOTTOM];

            if (_top[1] === AUTO && _bottom[1] === AUTO) {
              var _prev = _item3.prev;

              while (_prev) {
                var _target = _prev;

                if (_target instanceof Component) {
                  _target = _target.shadowRoot;
                }

                var _isXom2 = _target instanceof Xom;

                var _cs5 = _isXom2 && _target.currentStyle;

                var _isAbs = _isXom2 && _cs5[POSITION] === 'absolute';

                if (!_isAbs) {
                  var _y = _target.y + _target.outerHeight;

                  var _d = _y - _item3.y;

                  if (_d) {
                    _item3.__offsetY(_d, true, REPAINT);
                  }

                  break;
                }

                _prev = _prev.prev;
              }
            }
          }
        }); // merge过程中需要重新布局的abs

        inDirectAbsList.forEach(function (arr) {
          arr[0].__layoutAbs(arr[1], null, arr[2]);
        }); // 调整因reflow造成的原struct数据索引数量偏差，纯zIndex的已经在repaint里面重新生成过了
        // 这里因为和update保持一致的顺序，因此一定是先根顺序且互不包含

        var diff = 0,
            lastIndex = 0,
            isFirst = true,
            structs = root.__structs;
        diffList.forEach(function (item) {
          var _item4 = _slicedToArray(item, 2),
              ns = _item4[0],
              d = _item4[1]; // 第一个有变化的，及后面无论有无变化都需更新
          // 第1个变化区域无需更改前面一段


          if (isFirst) {
            isFirst = false;
            lastIndex = ns[STRUCT_INDEX] + (ns[STRUCT_TOTAL] || 0) + 1;
            diff += d;
          } // 第2+个变化区域看是否和前面一个相连，有不变的段则先偏移它，然后再偏移自己
          else {
            var j = ns[STRUCT_INDEX] + (ns[STRUCT_TOTAL] || 0) + 1 + diff;

            for (var _i7 = lastIndex; _i7 < j; _i7++) {
              structs[_i7][STRUCT_INDEX] += diff;
            }

            lastIndex = j;
            diff += d;
          }
        }); // 后面的要根据偏移量校正索引

        if (diff) {
          for (var _i8 = lastIndex, _len5 = structs.length; _i8 < _len5; _i8++) {
            structs[_i8][STRUCT_INDEX] += diff;
          }
        } // 清除id


        reflow.clearUniqueReflowId(reflowHash);
      }
    } // 特殊覆盖方法，不需要super()计算自己，因为放在每次checkRoot()做过了

  }, {
    key: "__computeMeasure",
    value: function __computeMeasure(renderMode, ctx) {
      css.computeMeasure(this, true);
      this.children.forEach(function (item) {
        item.__computeMeasure(renderMode, ctx);
      });
    } // 每个root拥有一个刷新hook，多个root塞到frame的__hookTask里
    // frame在所有的帧刷新逻辑执行后检查hook列表，进行root刷新操作

  }, {
    key: "__frameHook",
    value: function __frameHook() {
      var _this6 = this;

      if (!this.__hookTask) {
        var r = this.__hookTask = function () {
          _this6.refresh();
        };

        frame.__hookTask.push(r);
      }
    }
  }, {
    key: "__clear",
    value: function __clear(ctx, renderMode) {
      if (renderMode === mode.CANVAS) {
        // 可能会调整宽高，所以每次清除用最大值
        this.__mw = Math.max(this.__mw, this.width);
        this.__mh = Math.max(this.__mh, this.height); // 清除前得恢复默认matrix，防止每次布局改变了属性

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.__mw, this.__mh);
      } else if (renderMode === mode.WEBGL) {
        ctx.clearColor(0, 0, 0, 0);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
      }
    }
  }, {
    key: "dom",
    get: function get() {
      return this.__dom;
    }
  }, {
    key: "uuid",
    get: function get() {
      return this.__uuid;
    }
  }, {
    key: "renderMode",
    get: function get() {
      return this.__renderMode;
    }
  }, {
    key: "ctx",
    get: function get() {
      return this.__ctx;
    }
  }, {
    key: "defs",
    get: function get() {
      return this.__defs;
    }
  }, {
    key: "taskUp",
    get: function get() {
      return this.__taskUp;
    }
  }, {
    key: "taskCp",
    get: function get() {
      return this.__taskCp;
    }
  }, {
    key: "ref",
    get: function get() {
      return this.__ref;
    }
  }, {
    key: "animateController",
    get: function get() {
      return this.__animateController;
    }
  }, {
    key: "texCache",
    get: function get() {
      return this.__texCache;
    }
  }]);

  return Root;
}(Dom);

var _enums$STYLE_KEY$5 = enums.STYLE_KEY,
    STROKE_WIDTH$5 = _enums$STYLE_KEY$5.STROKE_WIDTH,
    BOX_SHADOW$5 = _enums$STYLE_KEY$5.BOX_SHADOW,
    FONT_SIZE$5 = _enums$STYLE_KEY$5.FONT_SIZE;
var isNil$6 = util.isNil;
var REM$5 = o$4.REM,
    VW$5 = o$4.VW,
    VH$5 = o$4.VH;

function reBuild(target, origin, base, isMulti) {
  if (isMulti) {
    return target.map(function (item) {
      return origin + item * base;
    });
  } else {
    return origin + target * base;
  }
}

function reBuildC(target, originX, originY, width, height, isMulti) {
  if (isMulti) {
    if (target) {
      return target.map(function (item) {
        return reBuildC(item, originX, originY, width, height);
      });
    }
  } else {
    if (target && target.length >= 2) {
      return [originX + target[0] * width, originY + target[1] * height];
    }
  }

  return [];
}

function curveNum(controlA, controlB) {
  var num = 0;

  if (controlA.length >= 2) {
    num++;
  }

  if (controlB.length >= 2) {
    num += 2;
  }

  return num;
}

function limitStartEnd$1(v) {
  if (v < 0) {
    v = 0;
  } else if (v > 1) {
    v = 1;
  }

  return v;
}

function getNewPoint(x1, y1, x2, y2, controlA, controlB, num) {
  var start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  var end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

  if (start > 0 || end < 1) {
    if (num === 3) {
      var _geom$sliceBezier2Bot = geom$1.sliceBezier2Both([[x1, y1], controlA, controlB, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot2 = _slicedToArray(_geom$sliceBezier2Bot, 4);

      var _geom$sliceBezier2Bot3 = _slicedToArray(_geom$sliceBezier2Bot2[0], 2);

      x1 = _geom$sliceBezier2Bot3[0];
      y1 = _geom$sliceBezier2Bot3[1];
      controlA = _geom$sliceBezier2Bot2[1];
      controlB = _geom$sliceBezier2Bot2[2];

      var _geom$sliceBezier2Bot4 = _slicedToArray(_geom$sliceBezier2Bot2[3], 2);

      x2 = _geom$sliceBezier2Bot4[0];
      y2 = _geom$sliceBezier2Bot4[1];
    } else if (num === 2) {
      var _geom$sliceBezier2Bot5 = geom$1.sliceBezier2Both([[x1, y1], controlB, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot6 = _slicedToArray(_geom$sliceBezier2Bot5, 3);

      var _geom$sliceBezier2Bot7 = _slicedToArray(_geom$sliceBezier2Bot6[0], 2);

      x1 = _geom$sliceBezier2Bot7[0];
      y1 = _geom$sliceBezier2Bot7[1];
      controlB = _geom$sliceBezier2Bot6[1];

      var _geom$sliceBezier2Bot8 = _slicedToArray(_geom$sliceBezier2Bot6[2], 2);

      x2 = _geom$sliceBezier2Bot8[0];
      y2 = _geom$sliceBezier2Bot8[1];
    } else if (num === 1) {
      var _geom$sliceBezier2Bot9 = geom$1.sliceBezier2Both([[x1, y1], controlA, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot10 = _slicedToArray(_geom$sliceBezier2Bot9, 3);

      var _geom$sliceBezier2Bot11 = _slicedToArray(_geom$sliceBezier2Bot10[0], 2);

      x1 = _geom$sliceBezier2Bot11[0];
      y1 = _geom$sliceBezier2Bot11[1];
      controlA = _geom$sliceBezier2Bot10[1];

      var _geom$sliceBezier2Bot12 = _slicedToArray(_geom$sliceBezier2Bot10[2], 2);

      x2 = _geom$sliceBezier2Bot12[0];
      y2 = _geom$sliceBezier2Bot12[1];
    } else {
      var a = Math.abs(x1 - x2);
      var b = Math.abs(y1 - y2);
      x1 += a * start;
      y1 += b * start;
      x2 -= a * (1 - end);
      y2 -= b * (1 - end);
    }
  }

  return [x1, y1, x2, y2, controlA, controlB];
}

var Line = /*#__PURE__*/function (_Geom) {
  _inherits(Line, _Geom);

  var _super = _createSuper(Line);

  function Line(tagName, props) {
    var _this;

    _classCallCheck(this, Line);

    _this = _super.call(this, tagName, props); // x1,y1和x2,y2表明线段的首尾坐标，control表明控制点坐标

    if (_this.isMulti) {
      _this.__x1 = [0];
      _this.__y1 = [0];
      _this.__x2 = [1];
      _this.__y2 = [1];
      _this.__controlA = [[]];
      _this.__controlB = [[]];
      _this.__start = [0];
      _this.__end = [1];

      if (Array.isArray(props.x1)) {
        _this.__x1 = props.x1.map(function (i) {
          return parseFloat(i) || 0;
        });
      } else if (!isNil$6(props.x1)) {
        _this.__x1 = [parseFloat(props.x1) || 0];
      }

      if (Array.isArray(props.y1)) {
        _this.__y1 = props.y1.map(function (i) {
          return parseFloat(i) || 0;
        });
      } else if (!isNil$6(props.y1)) {
        _this.__y1 = [parseFloat(props.y1) || 0];
      }

      if (Array.isArray(props.x2)) {
        _this.__x2 = props.x2.map(function (i) {
          return parseFloat(i) || 0;
        });
      } else if (!isNil$6(props.x2)) {
        _this.__x2 = [parseFloat(props.x2) || 0];
      }

      if (Array.isArray(props.y2)) {
        _this.__y2 = props.y2.map(function (i) {
          return parseFloat(i) || 0;
        });
      } else if (!isNil$6(props.y2)) {
        _this.__y2 = [parseFloat(props.y2) || 0];
      }

      if (Array.isArray(props.controlA)) {
        _this.__controlA = props.controlA.map(function (item) {
          if (Array.isArray(item)) {
            return item;
          }

          return [];
        });
      }

      if (Array.isArray(props.controlB)) {
        _this.__controlB = props.controlB.map(function (item) {
          if (Array.isArray(item)) {
            return item;
          }

          return [];
        });
      }

      if (Array.isArray(props.start)) {
        _this.__start = props.start.map(function (i) {
          return limitStartEnd$1(parseFloat(i) || 0);
        });

        for (var i = _this.__start.length; i < _this.__x1.length; i++) {
          _this.__start.push(0);
        }
      } else if (!isNil$6(props.start)) {
        var v = limitStartEnd$1(parseFloat(props.start) || 0);
        _this.__start = _this.__x1.map(function () {
          return v;
        });
      }

      if (Array.isArray(props.end)) {
        _this.__end = props.end.map(function (i) {
          var v = parseFloat(i);

          if (isNaN(v)) {
            v = 1;
          }

          return limitStartEnd$1(v);
        });

        for (var _i = _this.__end.length; _i < _this.__x1.length; _i++) {
          _this.__end.push(1);
        }
      } else if (!isNil$6(props.end)) {
        var _v = parseFloat(props.end);

        if (isNaN(_v)) {
          _v = 1;
        }

        _v = limitStartEnd$1(_v);
        _this.__end = _this.__x1.map(function () {
          return _v;
        });
      }
    } else {
      _this.__x1 = _this.__y1 = _this.__start = 0;
      _this.__x2 = _this.__y2 = _this.__end = 1;
      _this.__controlA = [];
      _this.__controlB = [];

      if (!isNil$6(props.x1)) {
        _this.__x1 = parseFloat(props.x1) || 0;
      }

      if (!isNil$6(props.y1)) {
        _this.__y1 = parseFloat(props.y1) || 0;
      }

      if (!isNil$6(props.x2)) {
        _this.__x2 = parseFloat(props.x2) || 0;
      }

      if (!isNil$6(props.y2)) {
        _this.__y2 = parseFloat(props.y2) || 0;
      }

      if (!isNil$6(props.start)) {
        _this.__start = limitStartEnd$1(parseFloat(props.start) || 0);
      }

      if (!isNil$6(props.end)) {
        var _v2 = parseFloat(props.end);

        if (isNaN(_v2)) {
          _v2 = 1;
        }

        _this.__end = limitStartEnd$1(_v2);
      }

      if (Array.isArray(props.controlA)) {
        _this.__controlA = props.controlA;
      }

      if (Array.isArray(props.controlB)) {
        _this.__controlB = props.controlB;
      }
    }

    return _this;
  }

  _createClass(Line, [{
    key: "buildCache",
    value: function buildCache(originX, originY, focus) {
      var _this2 = this;

      var width = this.width,
          height = this.height,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild;
      ['x1', 'x2'].forEach(function (k) {
        if (isNil$6(__cacheProps[k]) || focus) {
          rebuild = true;
          __cacheProps[k] = reBuild(_this2[k], originX, width, isMulti);
        }
      });
      ['y1', 'y2'].forEach(function (k) {
        if (isNil$6(__cacheProps[k]) || focus) {
          rebuild = true;
          __cacheProps[k] = reBuild(_this2[k], originY, height, isMulti);
        }
      });
      ['controlA', 'controlB'].forEach(function (k) {
        if (isNil$6(__cacheProps[k]) || focus) {
          rebuild = true;
          __cacheProps[k] = reBuildC(_this2[k], originX, originY, width, height, isMulti);
        }
      });
      ['start', 'end'].forEach(function (k) {
        if (isNil$6(__cacheProps[k]) || focus) {
          rebuild = true;
          __cacheProps[k] = _this2[k];
        }
      });
      return rebuild;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var _this3 = this;

      var res = _get(_getPrototypeOf(Line.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      ctx = res.ctx;
      var sx3 = res.sx3,
          sy3 = res.sy3,
          strokes = res.stroke,
          strokeWidths = res.strokeWidth,
          strokeDasharrays = res.strokeDasharray,
          strokeDasharrayStrs = res.strokeDasharrayStr,
          strokeLinecaps = res.strokeLinecap,
          strokeLinejoins = res.strokeLinejoin,
          strokeMiterlimits = res.strokeMiterlimit,
          dx = res.dx,
          dy = res.dy;
      var __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild = this.buildCache(sx3, sy3);

      if (rebuild && renderMode === mode.SVG) {
        var d = '';

        if (isMulti) {
          __cacheProps.x1.forEach(function (xa, i) {
            var xb = __cacheProps.x2[i];
            var ya = __cacheProps.y1[i];
            var yb = __cacheProps.y2[i];
            var ca = __cacheProps.controlA[i];
            var cb = __cacheProps.controlB[i];
            var start = __cacheProps.start[i];
            var end = __cacheProps.end[i];
            var curve = curveNum(ca, cb);

            if (start !== 0 || end !== 1) {
              var _getNewPoint = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

              var _getNewPoint2 = _slicedToArray(_getNewPoint, 6);

              xa = _getNewPoint2[0];
              ya = _getNewPoint2[1];
              xb = _getNewPoint2[2];
              ya = _getNewPoint2[3];
              ca = _getNewPoint2[4];
              cb = _getNewPoint2[5];
            }

            d += painter.svgLine(xa, ya, xb, yb, ca, cb, curve);
          });
        } else {
          var curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);
          var x1 = __cacheProps.x1,
              y1 = __cacheProps.y1,
              x2 = __cacheProps.x2,
              y2 = __cacheProps.y2,
              controlA = __cacheProps.controlA,
              controlB = __cacheProps.controlB,
              start = __cacheProps.start,
              end = __cacheProps.end;

          if (start !== 0 || end !== 1) {
            var _getNewPoint3 = getNewPoint(x1, y1, x2, y2, controlA, controlB, curve, start, end, __cacheProps.len);

            var _getNewPoint4 = _slicedToArray(_getNewPoint3, 6);

            x1 = _getNewPoint4[0];
            y1 = _getNewPoint4[1];
            x2 = _getNewPoint4[2];
            y2 = _getNewPoint4[3];
            controlA = _getNewPoint4[4];
            controlB = _getNewPoint4[5];
          }

          d = painter.svgLine(x1, y1, x2, y2, controlA, controlB, curve);
        }

        __cacheProps.d = d;
      }

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        strokes.forEach(function (stroke, i) {
          var strokeWidth = strokeWidths[i];
          var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

          if (strokeWidth > 0 && stroke !== 'none') {
            _this3.__preSetCanvas(renderMode, ctx, {
              stroke: stroke,
              strokeWidth: strokeWidth,
              strokeDasharray: strokeDasharrays[i],
              strokeLinecap: strokeLinecaps[i],
              strokeLinejoin: strokeLinejoins[i],
              strokeMiterlimit: strokeMiterlimits[i]
            });

            if (isStrokeRE) {
              ctx.strokeStyle = stroke.v[0];
            }

            ctx.beginPath();

            if (isMulti) {
              __cacheProps.x1.forEach(function (xa, i) {
                var xb = __cacheProps.x2[i];
                var ya = __cacheProps.y1[i];
                var yb = __cacheProps.y2[i];
                var ca = __cacheProps.controlA[i];
                var cb = __cacheProps.controlB[i];
                var start = __cacheProps.start[i];
                var end = __cacheProps.end[i];
                var curve = curveNum(ca, cb);

                if (start !== 0 || end !== 1) {
                  var _getNewPoint5 = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                  var _getNewPoint6 = _slicedToArray(_getNewPoint5, 6);

                  xa = _getNewPoint6[0];
                  ya = _getNewPoint6[1];
                  xb = _getNewPoint6[2];
                  ya = _getNewPoint6[3];
                  ca = _getNewPoint6[4];
                  cb = _getNewPoint6[5];
                }

                painter.canvasLine(ctx, xa, ya, xb, yb, ca, cb, curve, dx, dy);
              });
            } else {
              var _curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);

              var _x = __cacheProps.x1,
                  _y = __cacheProps.y1,
                  _x2 = __cacheProps.x2,
                  _y2 = __cacheProps.y2,
                  _controlA = __cacheProps.controlA,
                  _controlB = __cacheProps.controlB,
                  _start = __cacheProps.start,
                  _end = __cacheProps.end;

              if (_start !== 0 || _end !== 1) {
                var _getNewPoint7 = getNewPoint(_x, _y, _x2, _y2, _controlA, _controlB, _curve, _start, _end, __cacheProps.len);

                var _getNewPoint8 = _slicedToArray(_getNewPoint7, 6);

                _x = _getNewPoint8[0];
                _y = _getNewPoint8[1];
                _x2 = _getNewPoint8[2];
                _y2 = _getNewPoint8[3];
                _controlA = _getNewPoint8[4];
                _controlB = _getNewPoint8[5];
              }

              painter.canvasLine(ctx, _x, _y, _x2, _y2, _controlA, _controlB, _curve, dx, dy);
            }

            ctx.stroke();
            ctx.closePath();
          }
        });
      } else if (renderMode === mode.SVG) {
        strokes.forEach(function (stroke, i) {
          var strokeWidth = strokeWidths[i];
          var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);
          var props = [['d', __cacheProps.d], ['fill', 'none'], ['stroke', isStrokeRE ? stroke.v[0] : stroke.v || stroke], ['stroke-width', strokeWidth]];

          _this3.__propsStrokeStyle(props, strokeDasharrayStrs[i], strokeLinecaps[i], strokeLinejoins[i], strokeMiterlimits[i]);

          _this3.addGeom('path', props);
        });
      }

      return res;
    }
  }, {
    key: "x1",
    get: function get() {
      return this.getProps('x1');
    }
  }, {
    key: "y1",
    get: function get() {
      return this.getProps('y1');
    }
  }, {
    key: "x2",
    get: function get() {
      return this.getProps('x2');
    }
  }, {
    key: "y2",
    get: function get() {
      return this.getProps('y2');
    }
  }, {
    key: "controlA",
    get: function get() {
      return this.getProps('controlA');
    }
  }, {
    key: "controlB",
    get: function get() {
      return this.getProps('controlB');
    }
  }, {
    key: "start",
    get: function get() {
      return this.getProps('start');
    }
  }, {
    key: "end",
    get: function get() {
      return this.getProps('end');
    }
  }, {
    key: "bbox",
    get: function get() {
      var isMulti = this.isMulti,
          __cacheProps = this.__cacheProps,
          root = this.root,
          originX = this.__sx3,
          originY = this.__sy3,
          _this$currentStyle = this.currentStyle,
          strokeWidth = _this$currentStyle[STROKE_WIDTH$5],
          boxShadow = _this$currentStyle[BOX_SHADOW$5];
      this.buildCache(originX, originY);
      var x1 = __cacheProps.x1,
          y1 = __cacheProps.y1,
          x2 = __cacheProps.x2,
          y2 = __cacheProps.y2,
          controlA = __cacheProps.controlA,
          controlB = __cacheProps.controlB;

      var bbox = _get(_getPrototypeOf(Line.prototype), "bbox", this);

      var half = 0;
      strokeWidth.forEach(function (item) {
        if (item[1] === REM$5) {
          half = Math.max(item[0] * root.computedStyle[FONT_SIZE$5] * 0.5, half);
        } else if (item[1] === VW$5) {
          half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
        } else if (item[1] === VH$5) {
          half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
        } else {
          half = Math.max(item[0] * 0.5, half);
        }
      });
      half += 1;

      var _this$__spreadBbox = this.__spreadBbox(boxShadow),
          _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
          ox = _this$__spreadBbox2[0],
          oy = _this$__spreadBbox2[1];

      ox += half;
      oy += half;

      if (!isMulti) {
        x1 = [x1];
        x2 = [x2];
        y1 = [y1];
        y2 = [y2];
        controlA = [controlA];
        controlB = [controlB];
      }

      x1.forEach(function (xa, i) {
        var ya = y1[i];
        var xb = x2[i];
        var yb = y2[i];
        var ca = controlA[i];
        var cb = controlB[i];

        if ((isNil$6(ca) || ca.length < 2) && (isNil$6(cb) || cb.length < 2)) {
          bbox[0] = Math.min(bbox[0], xa - ox);
          bbox[0] = Math.min(bbox[0], xb - ox);
          bbox[1] = Math.min(bbox[1], ya - oy);
          bbox[1] = Math.min(bbox[1], yb - oy);
          bbox[2] = Math.max(bbox[2], xa + ox);
          bbox[2] = Math.max(bbox[2], xb + ox);
          bbox[3] = Math.max(bbox[3], ya + oy);
          bbox[3] = Math.max(bbox[3], yb + oy);
        } else if (isNil$6(ca) || ca.length < 2) {
          var bezierBox = geom$1.bboxBezier(xa, ya, cb[0], cb[1], xb, yb);
          bbox[0] = Math.min(bbox[0], bezierBox[0] - ox);
          bbox[0] = Math.min(bbox[0], bezierBox[2] - ox);
          bbox[1] = Math.min(bbox[1], bezierBox[1] - oy);
          bbox[1] = Math.min(bbox[1], bezierBox[3] - oy);
          bbox[2] = Math.max(bbox[2], bezierBox[0] + ox);
          bbox[2] = Math.max(bbox[2], bezierBox[2] + ox);
          bbox[3] = Math.max(bbox[3], bezierBox[1] + oy);
          bbox[3] = Math.max(bbox[3], bezierBox[3] + oy);
        } else if (isNil$6(cb) || cb.length < 2) {
          var _bezierBox = geom$1.bboxBezier(xa, ya, ca[0], ca[1], xb, yb);

          bbox[0] = Math.min(bbox[0], _bezierBox[0] - ox);
          bbox[0] = Math.min(bbox[0], _bezierBox[2] - ox);
          bbox[1] = Math.min(bbox[1], _bezierBox[1] - oy);
          bbox[1] = Math.min(bbox[1], _bezierBox[3] - oy);
          bbox[2] = Math.max(bbox[2], _bezierBox[0] + ox);
          bbox[2] = Math.max(bbox[2], _bezierBox[2] + ox);
          bbox[3] = Math.max(bbox[3], _bezierBox[1] + oy);
          bbox[3] = Math.max(bbox[3], _bezierBox[3] + oy);
        } else {
          var _bezierBox2 = geom$1.bboxBezier(xa, ya, ca[0], ca[1], cb[0], cb[1], xb, yb);

          bbox[0] = Math.min(bbox[0], _bezierBox2[0] - ox);
          bbox[0] = Math.min(bbox[0], _bezierBox2[2] - ox);
          bbox[1] = Math.min(bbox[1], _bezierBox2[1] - oy);
          bbox[1] = Math.min(bbox[1], _bezierBox2[3] - oy);
          bbox[2] = Math.max(bbox[2], _bezierBox2[0] + ox);
          bbox[2] = Math.max(bbox[2], _bezierBox2[2] + ox);
          bbox[3] = Math.max(bbox[3], _bezierBox2[1] + oy);
          bbox[3] = Math.max(bbox[3], _bezierBox2[3] + oy);
        }
      });
      return bbox;
    }
  }]);

  return Line;
}(Geom);

var _enums$STYLE_KEY$4 = enums.STYLE_KEY,
    STROKE_WIDTH$4 = _enums$STYLE_KEY$4.STROKE_WIDTH,
    BOX_SHADOW$4 = _enums$STYLE_KEY$4.BOX_SHADOW,
    FONT_SIZE$4 = _enums$STYLE_KEY$4.FONT_SIZE;
var isNil$5 = util.isNil;
var REM$4 = o$4.REM,
    VW$4 = o$4.VW,
    VH$4 = o$4.VH;

function concatPointAndControl(point, control) {
  if (Array.isArray(control) && (control.length === 2 || control.length === 4) && Array.isArray(point) && point.length === 2) {
    return control.concat(point);
  }

  return point;
}

function limitStartEnd(v) {
  if (v < 0) {
    v = 0;
  } else if (v > 1) {
    v = 1;
  }

  return v;
}

function getLength(list, isMulti) {
  var res = [];
  var total = 0;
  var increase = [];

  if (isMulti) {
    total = [];
    list.forEach(function (list) {
      var temp = getLength(list);
      res.push(temp.list);
      total.push(temp.total);
      increase.push([0].concat(temp.increase));
    });
  } else if (Array.isArray(list)) {
    total = 0;
    increase.push(0);
    var start = 0;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item)) {
        start = i;
        break;
      }
    }

    var prev = list[start];

    for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
      var _item = list[_i];

      if (!Array.isArray(_item)) {
        continue;
      }

      if (_item.length === 2) {
        var a = Math.abs(_item[0] - prev[0]);
        var b = Math.abs(_item[1] - prev[1]);
        var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
        res.push(c);
        total += c;
        increase.push(total);
        prev = _item;
      } else if (_item.length === 4) {
        var _c = geom$1.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]]], 2);

        res.push(_c);
        total += _c;
        increase.push(total);
        prev = [_item[2], _item[3]];
      } else if (_item.length === 6) {
        var _c2 = geom$1.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]], [_item[4], _item[5]]], 3);

        res.push(_c2);
        total += _c2;
        increase.push(total);
        prev = [_item[4], _item[5]];
      }
    }
  }

  return {
    list: res,
    total: total,
    increase: increase
  };
}

function getIndex(list, t, i, j) {
  if (i === j) {
    if (list[i] > t) {
      return i - 1;
    }

    return i;
  }

  var middle = i + (j - i >> 1);

  if (list[middle] === t) {
    return middle;
  } else if (list[middle] > t) {
    return getIndex(list, t, i, Math.max(middle - 1, i));
  } else {
    return getIndex(list, t, Math.min(middle + 1, j), j);
  }
}

function getNewList(list, len) {
  var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  if (start === 0 && end === 1) {
    return list;
  }

  if (start >= end) {
    return [];
  }

  var i = 0,
      j = list.length - 1;

  if (start > 0) {
    i = getIndex(len.increase, start * len.total, i, j);
  }

  if (end < 1) {
    j = getIndex(len.increase, end * len.total, i, j);
  }

  list = util.clone(list);
  end *= len.total;
  var prePercent = 1;

  if (end > len.increase[j]) {
    var prev = list[j].slice(list[j].length - 2); // 最后2个点是x,y，前面是control

    var current = list[j + 1];
    var l = len.list[j];
    var diff = end - len.increase[j];
    var t = diff / l;
    prePercent = t;

    if (current.length === 2) {
      var a = Math.abs(current[0] - prev[0]);
      var b = Math.abs(current[1] - prev[1]);

      if (current[0] < prev[0]) {
        a = -a;
      }

      if (current[1] < prev[1]) {
        b = -b;
      }

      list[j + 1] = [current[1] - (1 - t) * a, current[1] - (1 - t) * b];
    } else if (current.length === 4) {
      var res = geom$1.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]]], t);
      list[j + 1] = [res[1][0], res[1][1], res[2][0], res[2][1]];
    } else if (current.length === 6) {
      var _res = geom$1.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]], [current[4], current[5]]], t);

      list[j + 1] = [_res[1][0], _res[1][1], _res[2][0], _res[2][1], _res[3][0], _res[3][1]];
    }
  }

  start *= len.total;

  if (start > len.increase[i]) {
    var _prev = list[i].slice(list[i].length - 2);

    var _current = list[i + 1];
    var _l = len.list[i]; // 同一条线段时如果有end裁剪，会影响start长度

    if (i === j && prePercent !== 1) {
      _l *= prePercent;
    }

    var _diff = start - len.increase[i];

    var _t = _diff / _l;

    if (_current.length === 2) {
      var _a = Math.abs(_current[0] - _prev[0]);

      var _b = Math.abs(_current[1] - _prev[1]);

      if (_current[0] < _prev[0]) {
        _a = -_a;
      }

      if (_current[1] < _prev[1]) {
        _b = -_b;
      }

      list[i] = [_prev[0] + _t * _a, _prev[1] + _t * _b];
    } else if (_current.length === 4) {
      var _res2 = geom$1.sliceBezier([[_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

      list[i] = _res2[0];
      list[i + 1] = [_res2[1][0], _res2[1][1], _res2[2][0], _res2[2][1]];
    } else if (_current.length === 6) {
      var _res3 = geom$1.sliceBezier([[_current[4], _current[5]], [_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

      list[i] = _res3[0];
      list[i + 1] = [_res3[1][0], _res3[1][1], _res3[2][0], _res3[2][1], _current[4], _current[5]];
    }
  }

  if (j < list.length - 2) {
    list = list.slice(0, j + 2);
  }

  if (i > 0) {
    list = list.slice(i);
  }

  return list;
}

var Polyline = /*#__PURE__*/function (_Geom) {
  _inherits(Polyline, _Geom);

  var _super = _createSuper(Polyline);

  function Polyline(tagName, props) {
    var _this;

    _classCallCheck(this, Polyline);

    _this = _super.call(this, tagName, props); // 所有点的列表

    if (_this.isMulti) {
      _this.__points = [[]];
      _this.__controls = [[]];
      _this.__start = [0];
      _this.__end = [1];

      if (Array.isArray(props.start)) {
        _this.__start = props.start.map(function (i) {
          return limitStartEnd(parseFloat(i) || 0);
        });

        for (var i = _this.__start.length; i < _this.__points.length; i++) {
          _this.__start.push(0);
        }
      } else if (!isNil$5(props.start)) {
        var v = limitStartEnd(parseFloat(props.start) || 0);
        _this.__start = _this.__points.map(function () {
          return v;
        });
      }

      if (Array.isArray(props.end)) {
        _this.__end = props.end.map(function (i) {
          var v = parseFloat(i);

          if (isNaN(v)) {
            v = 1;
          }

          return limitStartEnd(v);
        });

        for (var _i2 = _this.__end.length; _i2 < _this.__points.length; _i2++) {
          _this.__end.push(1);
        }
      } else if (!isNil$5(props.end)) {
        var _v = parseFloat(props.end);

        if (isNaN(_v)) {
          _v = 1;
        }

        _v = limitStartEnd(_v);
        _this.__end = _this.__points.map(function () {
          return _v;
        });
      }
    } else {
      _this.__points = []; // 控制点

      _this.__controls = [];
      _this.__start = 0;
      _this.__end = 1;

      if (!isNil$5(props.start)) {
        _this.__start = limitStartEnd(parseFloat(props.start) || 0);
      }

      if (!isNil$5(props.end)) {
        var _v2 = parseFloat(props.end);

        if (isNaN(_v2)) {
          _v2 = 1;
        }

        _this.__end = limitStartEnd(_v2);
      }
    }

    if (Array.isArray(props.controls)) {
      _this.__controls = props.controls;
    }

    if (Array.isArray(props.points)) {
      _this.__points = props.points;
    }

    return _this;
  }

  _createClass(Polyline, [{
    key: "__getPoints",
    value: function __getPoints(originX, originY, width, height, points, isControl) {
      return points.map(function (item, i) {
        if (!Array.isArray(item)) {
          return;
        }

        var len = item.length;

        if (isControl) {
          if (len !== 0 && len !== 2 && len !== 4) {
            return;
          }
        } else {
          if (len !== 0 && len !== 2) {
            return;
          }
        }

        var res = [];

        for (var _i3 = 0; _i3 < len; _i3++) {
          if (_i3 % 2 === 0) {
            res.push(originX + item[_i3] * width);
          } else {
            res.push(originY + item[_i3] * height);
          }
        }

        return res;
      });
    }
  }, {
    key: "buildCache",
    value: function buildCache(originX, originY) {
      var _this2 = this;

      var width = this.width,
          height = this.height,
          points = this.points,
          controls = this.controls,
          start = this.start,
          end = this.end,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild, rebuildSE;

      if (isNil$5(__cacheProps.points)) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.points = points.map(function (item) {
            if (Array.isArray(item)) {
              return _this2.__getPoints(originX, originY, width, height, item);
            }
          });
        } else {
          __cacheProps.points = this.__getPoints(originX, originY, width, height, points);
        }
      }

      if (isNil$5(__cacheProps.controls)) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.controls = controls.map(function (item) {
            if (Array.isArray(item)) {
              return _this2.__getPoints(originX, originY, width, height, item, true);
            }

            return item;
          });
        } else {
          __cacheProps.controls = this.__getPoints(originX, originY, width, height, controls, true);
        }
      }

      if (isNil$5(__cacheProps.start)) {
        rebuildSE = true;
        __cacheProps.start = start;
      }

      if (isNil$5(__cacheProps.end)) {
        rebuildSE = true;
        __cacheProps.end = end;
      } // points/controls有变化就需要重建顶点


      if (rebuild) {
        var _points = __cacheProps.points,
            _controls = __cacheProps.controls;

        if (isMulti) {
          __cacheProps.list2 = _points.filter(function (item) {
            return Array.isArray(item);
          }).map(function (item, i) {
            var cl = _controls[i];

            if (Array.isArray(item)) {
              return item.map(function (point, j) {
                if (j) {
                  return concatPointAndControl(point, cl && cl[j - 1]);
                }

                return point;
              });
            }
          });
          __cacheProps.len = getLength(__cacheProps.list2, isMulti);
        } else {
          __cacheProps.list2 = _points.filter(function (item) {
            return Array.isArray(item);
          }).map(function (point, i) {
            if (i) {
              return concatPointAndControl(point, _controls[i - 1]);
            }

            return point;
          });
          __cacheProps.len = getLength(__cacheProps.list2, isMulti);
        }
      }

      if (rebuild || rebuildSE) {
        if (isMulti) {
          __cacheProps.list = __cacheProps.list2.map(function (item, i) {
            if (Array.isArray(item)) {
              var len = __cacheProps.len;
              return getNewList(item, {
                list: len.list[i],
                total: len.total[i],
                increase: len.increase[i]
              }, __cacheProps.start[i], __cacheProps.end[i]);
            }
          });
        } else {
          __cacheProps.list = getNewList(__cacheProps.list2, __cacheProps.len, __cacheProps.start, __cacheProps.end);
        }
      }

      return rebuild || rebuildSE;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Polyline.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      this.buildCache(res.sx3, res.sy3);
      ctx = res.ctx;

      this.__renderPolygon(renderMode, ctx, res);

      return res;
    }
  }, {
    key: "points",
    get: function get() {
      return this.getProps('points');
    }
  }, {
    key: "controls",
    get: function get() {
      return this.getProps('controls');
    }
  }, {
    key: "start",
    get: function get() {
      return this.getProps('start');
    }
  }, {
    key: "end",
    get: function get() {
      return this.getProps('end');
    }
  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            root = this.root,
            originX = this.__sx3,
            originY = this.__sy3,
            _this$currentStyle = this.currentStyle,
            strokeWidth = _this$currentStyle[STROKE_WIDTH$4],
            boxShadow = _this$currentStyle[BOX_SHADOW$4];
        this.buildCache(originX, originY);

        var bbox = _get(_getPrototypeOf(Polyline.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          if (item[1] === REM$4) {
            half = Math.max(item[0] * root.computedStyle[FONT_SIZE$4] * 0.5, half);
          } else if (item[1] === VW$4) {
            half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
          } else if (item[1] === VH$4) {
            half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
          } else {
            half = Math.max(item[0] * 0.5, half);
          }
        });
        half += 1;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        ox += half;
        oy += half;
        var points = __cacheProps.points,
            controls = __cacheProps.controls;

        if (!isMulti) {
          points = [points];
          controls = [controls];
        }

        points.forEach(function (pointList, i) {
          if (!pointList || pointList.length < 2 || pointList[0].length < 2 || pointList[1].length < 2) {
            return;
          }

          var controlList = controls[i] || [];

          var _pointList$ = _slicedToArray(pointList[0], 2),
              xa = _pointList$[0],
              ya = _pointList$[1];

          for (var _i4 = 1, len = pointList.length; _i4 < len; _i4++) {
            var _pointList$_i = _slicedToArray(pointList[_i4], 2),
                xb = _pointList$_i[0],
                yb = _pointList$_i[1];

            var c = controlList[_i4 - 1];

            if (c && c.length === 4) {
              var bezierBox = geom$1.bboxBezier(xa, ya, c[0], c[1], c[2], c[3], xb, yb);
              bbox[0] = Math.min(bbox[0], bezierBox[0] - ox);
              bbox[1] = Math.min(bbox[1], bezierBox[1] - oy);
              bbox[2] = Math.max(bbox[2], bezierBox[2] + ox);
              bbox[3] = Math.max(bbox[3], bezierBox[3] + oy);
            } else if (c && c.length === 2) {
              var _bezierBox = geom$1.bboxBezier(xa, ya, c[0], c[1], xb, yb);

              bbox[0] = Math.min(bbox[0], _bezierBox[0] - ox);
              bbox[1] = Math.min(bbox[1], _bezierBox[1] - oy);
              bbox[2] = Math.max(bbox[2], _bezierBox[2] + ox);
              bbox[3] = Math.max(bbox[3], _bezierBox[3] + oy);
            } else {
              bbox[0] = Math.min(bbox[0], xa - ox);
              bbox[1] = Math.min(bbox[1], ya - oy);
              bbox[2] = Math.max(bbox[2], xa + ox);
              bbox[3] = Math.max(bbox[3], ya + oy);
            }

            xa = xb;
            ya = yb;
          }
        });
        this.__bbox = bbox;
      }

      return this.__bbox;
    }
  }]);

  return Polyline;
}(Geom);

var Polygon = /*#__PURE__*/function (_Polyline) {
  _inherits(Polygon, _Polyline);

  var _super = _createSuper(Polygon);

  function Polygon(tagName, props) {
    _classCallCheck(this, Polygon);

    return _super.call(this, tagName, props);
  }

  _createClass(Polygon, [{
    key: "__getPoints",
    value: function __getPoints(originX, originY, width, height, points, isControl) {
      var res = _get(_getPrototypeOf(Polygon.prototype), "__getPoints", this).call(this, originX, originY, width, height, points, isControl);

      if (!isControl) {
        res.push(res[0]);
      }

      return res;
    }
  }]);

  return Polygon;
}(Polyline);

var _enums$STYLE_KEY$3 = enums.STYLE_KEY,
    STROKE_WIDTH$3 = _enums$STYLE_KEY$3.STROKE_WIDTH,
    BOX_SHADOW$3 = _enums$STYLE_KEY$3.BOX_SHADOW,
    FONT_SIZE$3 = _enums$STYLE_KEY$3.FONT_SIZE;
var isNil$4 = util.isNil;
var sectorPoints = geom$1.sectorPoints;
var REM$3 = o$4.REM,
    VW$3 = o$4.VW,
    VH$3 = o$4.VH;

function getR$3(v, dft) {
  v = parseFloat(v);

  if (isNaN(v)) {
    v = dft;
  }

  return v;
}

var Sector = /*#__PURE__*/function (_Geom) {
  _inherits(Sector, _Geom);

  var _super = _createSuper(Sector);

  function Sector(tagName, props) {
    var _this;

    _classCallCheck(this, Sector);

    _this = _super.call(this, tagName, props); // 角度

    if (_this.isMulti) {
      _this.__begin = [0];
      _this.__end = [0];
      _this.__r = [1];

      if (Array.isArray(props.begin)) {
        _this.__begin = props.begin.map(function (i) {
          return getR$3(i, 0);
        });
      }

      if (Array.isArray(props.end)) {
        _this.__end = props.end.map(function (i) {
          return getR$3(i, 0);
        });
      }

      if (Array.isArray(props.r)) {
        _this.__r = props.r.map(function (i) {
          return getR$3(i, 1);
        });
      }

      if (Array.isArray(props.edge)) {
        _this.__edge = props.edge.map(function (i) {
          return !!i;
        });
      }

      if (Array.isArray(props.closure)) {
        _this.__closure = props.closure.map(function (i) {
          return !!i;
        });
      }
    } else {
      _this.__begin = _this.__end = 0; // 半径[0, ∞)，默认1

      _this.__r = 1; // 扇形两侧是否有边

      _this.__edge = false; // 扇形大于180°时，是否闭合两端

      _this.__closure = false;

      if (!isNil$4(props.begin)) {
        _this.__begin = getR$3(props.begin, 0);
      }

      if (!isNil$4(props.end)) {
        _this.__end = getR$3(props.end, 0);
      }

      if (!isNil$4(props.r)) {
        _this.__r = getR$3(props.r, 1);
      }

      if (!isNil$4(props.edge)) {
        _this.__edge = !!props.edge;
      }

      if (!isNil$4(props.closure)) {
        _this.__closure = !!props.closure;
      }
    }

    return _this;
  }

  _createClass(Sector, [{
    key: "buildCache",
    value: function buildCache(cx, cy, focus) {
      var width = this.width,
          begin = this.begin,
          end = this.end,
          r = this.r,
          edge = this.edge,
          closure = this.closure,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild;

      if (isNil$4(__cacheProps.begin) || focus) {
        rebuild = true;
        __cacheProps.begin = (begin || 0) % 360;
      }

      if (isNil$4(__cacheProps.end) || focus) {
        rebuild = true;
        __cacheProps.end = (end || 0) % 360;
      }

      if (isNil$4(__cacheProps.r) || focus) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.r = r.map(function (r) {
            return r * width * 0.5;
          });
        } else {
          __cacheProps.r = r * width * 0.5;
        }
      }

      r = __cacheProps.r;

      if (isNil$4(__cacheProps.edge) || focus) {
        rebuild = true;
        __cacheProps.edge = edge;
      }

      if (isNil$4(__cacheProps.closure) || focus) {
        rebuild = true;
        __cacheProps.closure = closure;
      }

      if (rebuild) {
        if (isMulti) {
          __cacheProps.list = [];
          __cacheProps.sList = [];
          begin.forEach(function (begin, i) {
            var r2 = isNil$4(r[i]) ? width * 0.5 : r[i];
            var list = sectorPoints(cx, cy, r2, parseFloat(begin || 0) % 360, parseFloat(end[i] || 0) % 360);
            var sList = list.slice(0);

            if (closure[i]) {
              list.push(list[0].slice(0));

              if (edge) {
                sList.push(sList[0].slice(0));
              }
            } else {
              list.unshift([cx, cy]);
              list.push([cx, cy]);

              if (edge) {
                sList.unshift([cx, cy]);
                sList.push([cx, cy]);
              }
            }

            __cacheProps.list.push(list);

            __cacheProps.sList.push(sList);
          });
        } else {
          var list = sectorPoints(cx, cy, r, parseFloat(begin || 0), parseFloat(end || 0));
          var sList = list.slice(0);

          if (closure) {
            list.push(list[0].slice(0));

            if (edge) {
              sList.push(sList[0].slice(0));
            }
          } else {
            list.unshift([cx, cy]);
            list.push([cx, cy]);

            if (edge) {
              sList.unshift([cx, cy]);
              sList.push([cx, cy]);
            }
          }

          __cacheProps.list = list;
          __cacheProps.sList = sList;
        }
      }

      return rebuild;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Sector.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      this.buildCache(res.cx, res.cy);
      ctx = res.ctx;
      var fills = res.fill,
          fillRules = res.fillRule,
          strokes = res.stroke,
          strokeWidths = res.strokeWidth,
          strokeDasharrays = res.strokeDasharray,
          strokeDasharrayStrs = res.strokeDasharrayStr,
          strokeLinecaps = res.strokeLinecap,
          strokeLinejoins = res.strokeLinejoin,
          strokeMiterlimits = res.strokeMiterlimit,
          dx = res.dx,
          dy = res.dy;
      var _this$__cacheProps = this.__cacheProps,
          list = _this$__cacheProps.list,
          sList = _this$__cacheProps.sList,
          isMulti = this.isMulti; // 普通情况下只有1个，按普通情况走

      if (fills.length <= 1 && strokes.length <= 1) {
        var o = {
          fill: fills[0],
          fillRule: fillRules[0],
          stroke: strokes[0],
          strokeWidth: strokeWidths[0],
          strokeDasharray: strokeDasharrays[0],
          strokeDasharrayStr: strokeDasharrayStrs[0],
          strokeLinecap: strokeLinecaps[0],
          strokeLinejoin: strokeLinejoins[0],
          strokeMiterlimit: strokeMiterlimits[0],
          dx: dx,
          dy: dy
        };

        this.__renderOneSector(renderMode, ctx, isMulti, list, sList, o);
      } // 多个需要fill在下面，stroke在上面，依次循环
      else {
        for (var i = 0, len = fills.length; i < len; i++) {
          var fill = fills[i];

          if (fill) {
            var _o = {
              fill: fill,
              fillRule: fillRules[i],
              dx: dx,
              dy: dy
            };

            this.__renderOneSector(renderMode, ctx, isMulti, list, sList, _o);
          }
        }

        for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
          var stroke = strokes[_i];

          if (stroke) {
            var _o2 = {
              stroke: stroke,
              strokeWidth: strokeWidths[_i],
              strokeDasharray: strokeDasharrays[_i],
              strokeDasharrayStr: strokeDasharrayStrs[_i],
              strokeLinecap: strokeLinecaps[_i],
              strokeLinejoin: strokeLinejoins[_i],
              strokeMiterlimit: strokeMiterlimits[_i],
              dx: dx,
              dy: dy
            };

            this.__renderOnePolygon(renderMode, ctx, isMulti, list, sList, _o2);
          }
        }
      }

      return res;
    }
  }, {
    key: "__renderOneSector",
    value: function __renderOneSector(renderMode, ctx, isMulti, list, sList, res) {
      var fill = res.fill,
          stroke = res.stroke,
          strokeWidth = res.strokeWidth;
      var isFillCE = fill.k === 'conic';
      var isStrokeCE = stroke.k === 'conic';
      var isFillRE = fill.k === 'radial' && Array.isArray(fill.v);
      var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

      if (isFillCE || isStrokeCE) {
        if (isFillCE) {
          this.__conicGradient(renderMode, ctx, list, isMulti, res);
        } else if (fill && fill !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
        }

        if (strokeWidth > 0 && isStrokeCE) {
          inject.warn('Stroke style can not use conic-gradient');
        } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
        }
      } else if (isFillRE || isStrokeRE) {
        if (isFillRE) {
          this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
        } else if (fill && fill !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
        } // stroke椭圆渐变matrix会变形，降级为圆


        if (strokeWidth > 0 && isStrokeRE) {
          inject.warn('Stroke style can not use radial-gradient for ellipse');
          res.stroke = res.stroke.v[0];

          this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
        } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
        }
      } else {
        if (fill && fill !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, false);
        }

        if (strokeWidth > 0 && stroke && stroke !== 'none') {
          this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
        }
      }
    }
  }, {
    key: "__genSector",
    value: function __genSector(edge, d, fill, stroke, strokeWidth, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
      if (edge) {
        var props = [['d', d[0]], ['fill', fill.v || fill], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

        this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

        this.addGeom('path', props);
      } else {
        this.addGeom('path', [['d', d[0]], ['fill', fill.v || fill]]);

        if (strokeWidth > 0) {
          var _props = [['d', d[1]], ['fill', 'none'], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

          this.__propsStrokeStyle(_props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

          this.addGeom('path', _props);
        }
      }
    }
  }, {
    key: "begin",
    get: function get() {
      return this.getProps('begin');
    }
  }, {
    key: "end",
    get: function get() {
      return this.getProps('end');
    }
  }, {
    key: "r",
    get: function get() {
      return this.getProps('r');
    }
  }, {
    key: "edge",
    get: function get() {
      return this.getProps('edge');
    } // >180°时是否链接端点

  }, {
    key: "closure",
    get: function get() {
      return this.getProps('closure');
    }
  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            root = this.root,
            originX = this.__sx3,
            originY = this.__sy3,
            width = this.width,
            height = this.height,
            _this$currentStyle = this.currentStyle,
            strokeWidth = _this$currentStyle[STROKE_WIDTH$3],
            boxShadow = _this$currentStyle[BOX_SHADOW$3];
        var cx = originX + width * 0.5;
        var cy = originY + height * 0.5;
        this.buildCache(cx, cy);
        var r = 0;

        if (isMulti) {
          var max = 0;

          __cacheProps.r.forEach(function (r) {
            max = Math.max(r, max);
          });

          r = max;
        } else {
          r = __cacheProps.r;
        }

        var bbox = _get(_getPrototypeOf(Sector.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          if (item[1] === REM$3) {
            half = Math.max(item[0] * root.computedStyle[FONT_SIZE$3] * 0.5, half);
          } else if (item[1] === VW$3) {
            half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
          } else if (item[1] === VH$3) {
            half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
          } else {
            half = Math.max(item[0] * 0.5, half);
          }
        });
        half += 1;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        ox += half;
        oy += half;
        var xa = cx - r - ox;
        var xb = cx + r + ox;
        var ya = cy - r - oy;
        var yb = cy + r + oy;
        bbox[0] = Math.min(bbox[0], xa);
        bbox[1] = Math.min(bbox[1], ya);
        bbox[2] = Math.max(bbox[2], xb);
        bbox[3] = Math.max(bbox[3], yb);
        this.__bbox = bbox;
      }

      return this.__bbox;
    }
  }]);

  return Sector;
}(Geom);

var _enums$STYLE_KEY$2 = enums.STYLE_KEY,
    STROKE_WIDTH$2 = _enums$STYLE_KEY$2.STROKE_WIDTH,
    BOX_SHADOW$2 = _enums$STYLE_KEY$2.BOX_SHADOW,
    FONT_SIZE$2 = _enums$STYLE_KEY$2.FONT_SIZE;
var isNil$3 = util.isNil;
var REM$2 = o$4.REM,
    VW$2 = o$4.VW,
    VH$2 = o$4.VH;

function genVertex(x, y, width, height) {
  var rx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var ry = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (rx === 0 || ry === 0) {
    return [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]];
  }

  var ox = rx * geom$1.H;
  var oy = ry * geom$1.H;
  return [[x + rx, y], [x + width - rx, y], [x + width + ox - rx, y, x + width, y + ry - oy, x + width, y + ry], [x + width, y + height - ry], [x + width, y + height + oy - ry, x + width + ox - rx, y + height, x + width - rx, y + height], [x + rx, y + height], [x + rx - ox, y + height, x, y + height + oy - ry, x, y + height - ry], [x, y + ry], [x, y + ry - oy, x + rx - ox, y, x + rx, y]];
}

function getR$2(v) {
  v = parseFloat(v);

  if (isNaN(v)) {
    v = 0;
  }

  return v;
}

var Rect = /*#__PURE__*/function (_Geom) {
  _inherits(Rect, _Geom);

  var _super = _createSuper(Rect);

  function Rect(tagName, props) {
    var _this;

    _classCallCheck(this, Rect);

    _this = _super.call(this, tagName, props); // 圆角

    if (_this.isMulti) {
      _this.__rx = [0];
      _this.__ry = [0];

      if (Array.isArray(props.rx)) {
        _this.__rx = props.rx.map(function (i) {
          return getR$2(i);
        });
      }

      if (Array.isArray(props.ry)) {
        _this.__ry = props.ry.map(function (i) {
          return getR$2(i);
        });
      }
    } else {
      _this.__rx = _this.__ry = 0;

      if (!isNil$3(props.rx)) {
        _this.__rx = getR$2(props.rx);
      }

      if (!isNil$3(props.ry)) {
        _this.__ry = getR$2(props.ry);
      }
    }

    return _this;
  }

  _createClass(Rect, [{
    key: "buildCache",
    value: function buildCache(originX, originY, focus) {
      var width = this.width,
          height = this.height,
          rx = this.rx,
          ry = this.ry,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild;

      if (isNil$3(__cacheProps.rx) || focus) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.rx = rx.map(function (rx) {
            return Math.min(rx, 0.5) * width;
          });
        } else {
          __cacheProps.rx = Math.min(rx, 0.5) * width;
        }
      }

      if (isNil$3(__cacheProps.ry) || focus) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.ry = rx.map(function (ry) {
            return Math.min(ry, 0.5) * height;
          });
        } else {
          __cacheProps.ry = Math.min(ry, 0.5) * height;
        }
      }

      if (rebuild) {
        var _rx = __cacheProps.rx,
            _ry = __cacheProps.ry;

        if (isMulti) {
          __cacheProps.list = _rx.map(function (rx, i) {
            return genVertex(originX, originY, width, height, rx, _ry[i]);
          });
        } else {
          __cacheProps.list = genVertex(originX, originY, width, height, _rx, _ry);
        }
      }

      return rebuild;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Rect.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      this.buildCache(res.sx3, res.sy3);
      ctx = res.ctx;

      this.__renderPolygon(renderMode, ctx, res);

      return res;
    }
  }, {
    key: "rx",
    get: function get() {
      return this.getProps('rx');
    }
  }, {
    key: "ry",
    get: function get() {
      return this.getProps('ry');
    }
  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var root = this.root,
            originX = this.__sx3,
            originY = this.__sy3,
            width = this.width,
            height = this.height,
            _this$currentStyle = this.currentStyle,
            strokeWidth = _this$currentStyle[STROKE_WIDTH$2],
            boxShadow = _this$currentStyle[BOX_SHADOW$2];
        this.buildCache(originX, originY);

        var bbox = _get(_getPrototypeOf(Rect.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          if (item[1] === REM$2) {
            half = Math.max(item[0] * root.computedStyle[FONT_SIZE$2] * 0.5, half);
          } else if (item[1] === VW$2) {
            half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
          } else if (item[1] === VH$2) {
            half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
          } else {
            half = Math.max(item[0] * 0.5, half);
          }
        });
        half += 1;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        ox += half;
        oy += half;
        bbox[0] = Math.min(bbox[0], originX - ox);
        bbox[1] = Math.min(bbox[1], originY - oy);
        bbox[2] = Math.max(bbox[2], originX + width + ox);
        bbox[3] = Math.max(bbox[3], originY + height + oy);
        this.__bbox = bbox;
      }

      return this.__bbox;
    }
  }]);

  return Rect;
}(Geom);

var _enums$STYLE_KEY$1 = enums.STYLE_KEY,
    STROKE_WIDTH$1 = _enums$STYLE_KEY$1.STROKE_WIDTH,
    BOX_SHADOW$1 = _enums$STYLE_KEY$1.BOX_SHADOW,
    FONT_SIZE$1 = _enums$STYLE_KEY$1.FONT_SIZE;
var isNil$2 = util.isNil;
var REM$1 = o$4.REM,
    VW$1 = o$4.VW,
    VH$1 = o$4.VH;

function getR$1(v) {
  v = parseFloat(v);

  if (isNaN(v)) {
    v = 1;
  }

  return v;
}

var Circle = /*#__PURE__*/function (_Geom) {
  _inherits(Circle, _Geom);

  var _super = _createSuper(Circle);

  function Circle(tagName, props) {
    var _this;

    _classCallCheck(this, Circle);

    _this = _super.call(this, tagName, props); // 半径[0, ∞)，默认1

    if (_this.isMulti) {
      _this.__r = [1];

      if (Array.isArray(props.r)) {
        _this.__r = props.r.map(function (i) {
          return getR$1(i);
        });
      } else if (!isNil$2(props.r)) {
        _this.__r = getR$1(props.r);
      }
    } else {
      _this.__r = 1;

      if (!isNil$2(props.r)) {
        _this.__r = getR$1(props.r);
      }
    }

    return _this;
  }

  _createClass(Circle, [{
    key: "buildCache",
    value: function buildCache(cx, cy, focus) {
      var width = this.width,
          r = this.r,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;

      if (isNil$2(__cacheProps.r) || focus) {
        if (isMulti) {
          __cacheProps.r = r.map(function (i) {
            return i * width * 0.5;
          });
          __cacheProps.list = __cacheProps.r.map(function (r) {
            return geom$1.ellipsePoints(cx, cy, r);
          });
        } else {
          __cacheProps.r = r * width * 0.5;
          __cacheProps.list = geom$1.ellipsePoints(cx, cy, __cacheProps.r);
        }
      }
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Circle.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      this.buildCache(res.cx, res.cy);
      ctx = res.ctx;

      this.__renderPolygon(renderMode, ctx, res);

      return res;
    }
  }, {
    key: "r",
    get: function get() {
      return this.getProps('r');
    }
  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            root = this.root,
            originX = this.__sx3,
            originY = this.__sy3,
            width = this.width,
            height = this.height,
            _this$currentStyle = this.currentStyle,
            strokeWidth = _this$currentStyle[STROKE_WIDTH$1],
            boxShadow = _this$currentStyle[BOX_SHADOW$1];
        var cx = originX + width * 0.5;
        var cy = originY + height * 0.5;
        this.buildCache(cx, cy);
        var r = 0;

        if (isMulti) {
          var max = 0;

          __cacheProps.r.forEach(function (r) {
            max = Math.max(r, max);
          });

          r = max;
        } else {
          r = __cacheProps.r;
        }

        var bbox = _get(_getPrototypeOf(Circle.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          if (item[1] === REM$1) {
            half = Math.max(item[0] * root.computedStyle[FONT_SIZE$1] * 0.5, half);
          } else if (item[1] === VW$1) {
            half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
          } else if (item[1] === VH$1) {
            half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
          } else {
            half = Math.max(item[0] * 0.5, half);
          }
        });
        half += 1;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        ox += half;
        oy += half;
        var xa = cx - r - ox;
        var xb = cx + r + ox;
        var ya = cy - r - oy;
        var yb = cy + r + oy;
        bbox[0] = Math.min(bbox[0], xa);
        bbox[1] = Math.min(bbox[1], ya);
        bbox[2] = Math.max(bbox[2], xb);
        bbox[3] = Math.max(bbox[3], yb);
        this.__bbox = bbox;
      }

      return this.__bbox;
    }
  }]);

  return Circle;
}(Geom);

var _enums$STYLE_KEY = enums.STYLE_KEY,
    STROKE_WIDTH = _enums$STYLE_KEY.STROKE_WIDTH,
    BOX_SHADOW = _enums$STYLE_KEY.BOX_SHADOW,
    FONT_SIZE = _enums$STYLE_KEY.FONT_SIZE;
var isNil$1 = util.isNil;
var REM = o$4.REM,
    VW = o$4.VW,
    VH = o$4.VH;

function getR(v) {
  v = parseFloat(v);

  if (isNaN(v)) {
    v = 1;
  }

  return v;
}

var Ellipse = /*#__PURE__*/function (_Geom) {
  _inherits(Ellipse, _Geom);

  var _super = _createSuper(Ellipse);

  function Ellipse(tagName, props) {
    var _this;

    _classCallCheck(this, Ellipse);

    _this = _super.call(this, tagName, props); // 半径[0, ∞)，默认1

    if (_this.isMulti) {
      _this.__rx = [1];
      _this.__ry = [1];

      if (Array.isArray(props.rx)) {
        _this.__rx = props.rx.map(function (i) {
          return getR(i);
        });
      } else if (!isNil$1(props.rx)) {
        _this.__rx = [getR(props.rx)];
      }

      if (Array.isArray(props.ry)) {
        _this.__ry = props.ry.map(function (i) {
          return getR(i);
        });
      } else if (!isNil$1(props.ry)) {
        _this.__ry = [getR(props.ry)];
      }
    } else {
      _this.__rx = 1;

      if (!isNil$1(props.rx)) {
        _this.__rx = getR(props.rx);
      }

      _this.__ry = 1;

      if (!isNil$1(props.ry)) {
        _this.__ry = getR(props.ry);
      }
    }

    return _this;
  }

  _createClass(Ellipse, [{
    key: "buildCache",
    value: function buildCache(cx, cy, focus) {
      var width = this.width,
          height = this.height,
          rx = this.rx,
          ry = this.ry,
          __cacheProps = this.__cacheProps,
          isMulti = this.isMulti;
      var rebuild;

      if (isNil$1(__cacheProps.rx) || focus) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.rx = rx.map(function (i) {
            return i * width * 0.5;
          });
        } else {
          __cacheProps.rx = rx * width * 0.5;
        }
      }

      if (isNil$1(__cacheProps.ry) || focus) {
        rebuild = true;

        if (isMulti) {
          __cacheProps.ry = ry.map(function (i) {
            return i * height * 0.5;
          });
        } else {
          __cacheProps.ry = ry * height * 0.5;
        }
      }

      if (rebuild) {
        var _rx = __cacheProps.rx,
            _ry = __cacheProps.ry;

        if (isMulti) {
          __cacheProps.list = _rx.map(function (rx, i) {
            return geom$1.ellipsePoints(cx, cy, rx, _ry[i]);
          });
        } else {
          __cacheProps.list = geom$1.ellipsePoints(cx, cy, _rx, _ry);
        }
      }

      return rebuild;
    }
  }, {
    key: "render",
    value: function render(renderMode, lv, ctx, cache) {
      var res = _get(_getPrototypeOf(Ellipse.prototype), "render", this).call(this, renderMode, lv, ctx, cache);

      if (res["break"]) {
        return res;
      }

      this.buildCache(res.cx, res.cy);
      ctx = res.ctx;

      this.__renderPolygon(renderMode, ctx, res);

      return res;
    }
  }, {
    key: "rx",
    get: function get() {
      return this.getProps('rx');
    }
  }, {
    key: "ry",
    get: function get() {
      return this.getProps('ry');
    }
  }, {
    key: "bbox",
    get: function get() {
      if (!this.__bbox) {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            root = this.root,
            originX = this.__sx3,
            originY = this.__sy3,
            width = this.width,
            height = this.height,
            _this$currentStyle = this.currentStyle,
            strokeWidth = _this$currentStyle[STROKE_WIDTH],
            boxShadow = _this$currentStyle[BOX_SHADOW];
        var cx = originX + width * 0.5;
        var cy = originY + height * 0.5;
        this.buildCache(cx, cy);
        var rx = 0,
            ry = 0;

        if (isMulti) {
          var mx = 0,
              my = 0;

          __cacheProps.rx.forEach(function (rx, i) {
            mx = Math.max(rx, mx);
            my = Math.max(ry, __cacheProps.ry[i]);
          });

          rx = mx;
          ry = my;
        } else {
          rx = __cacheProps.rx;
          ry = __cacheProps.ry;
        }

        var bbox = _get(_getPrototypeOf(Ellipse.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          if (item[1] === REM) {
            half = Math.max(item[0] * root.computedStyle[FONT_SIZE] * 0.5, half);
          } else if (item[1] === VW) {
            half = Math.max(item[0] * root.width * 0.01 * 0.5, half);
          } else if (item[1] === VH) {
            half = Math.max(item[0] * root.height * 0.01 * 0.5, half);
          } else {
            half = Math.max(item[0] * 0.5, half);
          }
        });
        half += 1;

        var _this$__spreadBbox = this.__spreadBbox(boxShadow),
            _this$__spreadBbox2 = _slicedToArray(_this$__spreadBbox, 2),
            ox = _this$__spreadBbox2[0],
            oy = _this$__spreadBbox2[1];

        ox += half;
        oy += half;
        var xa = cx - rx - ox;
        var xb = cx + rx + ox;
        var ya = cy - ry - oy;
        var yb = cy + ry + oy;
        bbox[0] = Math.min(bbox[0], xa);
        bbox[1] = Math.min(bbox[1], ya);
        bbox[2] = Math.max(bbox[2], xb);
        bbox[3] = Math.max(bbox[3], yb);
        this.__bbox = bbox;
      }

      return this.__bbox;
    }
  }]);

  return Ellipse;
}(Geom);

var fullCssProperty = {
  skewX: 'kx',
  skewY: 'ky',
  transform: 'tf',
  fontSize: 'fz',
  offset: 'os',
  easing: 'e',
  filter: 'ft',
  boxShadow: 'bd',
  overflow: 'of',
  backgroundClip: 'bp',
  textOverflow: 'tof',
  flexWrap: 'fp',
  perspective: 'ppt',
  rotate3d: 'r3'
};
var abbrCssProperty$1 = {
  os: 'offset',
  // 非css属性不会被下面反向遍历插入，手动
  e: 'easing'
};
var fullAnimate = {
  value: 'v',
  options: 'o'
};
var abbrAnimate$1 = {};
var fullAnimateOption = {
  duration: 'dt',
  delay: 'd',
  endDelay: 'ed',
  iterations: 'i',
  direction: 'dc',
  fill: 'f',
  fps: 'fp',
  playbackRate: 'p',
  spfLimit: 'sl'
};
var abbrAnimateOption$1 = {};
reset.DOM_KEY_SET.concat(reset.GEOM_KEY_SET).forEach(function (k) {
  if (fullCssProperty.hasOwnProperty(k)) {
    abbrCssProperty$1[fullCssProperty[k]] = k;
    return;
  }

  var v = k.charAt(0) + k.replace(/[a-z]/g, '').toLowerCase();
  fullCssProperty[k] = v;
  abbrCssProperty$1[v] = k;
});
Object.keys(fullAnimate).forEach(function (k) {
  abbrAnimate$1[fullAnimate[k]] = k;
});
Object.keys(fullAnimateOption).forEach(function (k) {
  abbrAnimateOption$1[fullAnimateOption[k]] = k;
});
var abbr = {
  fullCssProperty: fullCssProperty,
  abbrCssProperty: abbrCssProperty$1,
  fullAnimate: fullAnimate,
  abbrAnimate: abbrAnimate$1,
  fullAnimateOption: fullAnimateOption,
  abbrAnimateOption: abbrAnimateOption$1
};

var TYPE_VD = $$type.TYPE_VD,
    TYPE_GM = $$type.TYPE_GM,
    TYPE_CP = $$type.TYPE_CP;
var isNil = util.isNil,
    isFunction = util.isFunction,
    isPrimitive = util.isPrimitive,
    clone = util.clone,
    extend = util.extend;
var abbrCssProperty = abbr.abbrCssProperty,
    abbrAnimateOption = abbr.abbrAnimateOption,
    abbrAnimate = abbr.abbrAnimate;
/**
 * 还原缩写到全称，涉及样式和动画属性
 * @param target 还原的对象
 * @param hash 缩写映射
 */

function abbr2full(target, hash) {
  // 也许节点没写样式
  if (target) {
    Object.keys(target).forEach(function (k) {
      // var-attr格式特殊考虑，仅映射attr部分，var-还要保留
      if (k.indexOf('var-') === 0) {
        var k2 = k.slice(4);

        if (hash.hasOwnProperty(k2)) {
          var fk = hash[k2];
          target['var-' + fk] = target[k]; // delete target[k];
        }
      } // 普通样式缩写还原
      else if (hash.hasOwnProperty(k)) {
        var _fk = hash[k];
        target[_fk] = target[k]; // 删除以免二次解析

        delete target[k];
      }
    });
  }
}

function replaceVars(json, vars) {
  if (json && vars) {
    // 新版vars语法
    if (json.hasOwnProperty('vars')) {
      var slot = json.vars;

      if (!Array.isArray(slot)) {
        slot = [slot];
      }

      if (Array.isArray(slot)) {
        slot.forEach(function (item) {
          var id = item.id,
              member = item.member;

          if (!Array.isArray(member)) {
            member = [member];
          } // 排除特殊的library


          if (Array.isArray(member) && member.length && member[0] !== 'library' && vars.hasOwnProperty(id)) {
            var target = json;

            for (var i = 0, len = member.length; i < len; i++) {
              var k = member[i]; // 最后一个属性可以为空

              if (target.hasOwnProperty(k) || i === len - 1) {
                // 最后一个member表达式替换
                if (i === len - 1) {
                  var v = vars[id]; // undefined和null意义不同

                  if (v === undefined) {
                    return;
                  } // 支持函数模式和值模式


                  if (isFunction(v)) {
                    v = v(target(k));
                  }

                  target[k] = v;
                } else {
                  target = target[k];
                }
              } else {
                inject.error('Slot miss ' + k);
                return;
              }
            }
          }
        });
      }
    } else {
      Object.keys(json).forEach(function (k) {
        if (k.indexOf('var-') === 0) {
          var v = json[k];

          if (!v) {
            return;
          }

          var k2 = k.slice(4); // 有id且变量里面传入了替换的值，值可为null，因为某些情况下空为自动

          if (k2 && v.id && vars.hasOwnProperty(v.id)) {
            var value = vars[v.id]; // undefined和null意义不同

            if (value === undefined) {
              return;
            }

            var target = json; // 如果有.则特殊处理子属性

            if (k2.indexOf('.') > -1) {
              var list = k2.split('.');
              var len = list.length;

              for (var i = 0; i < len - 1; i++) {
                k2 = list[i]; // 避免异常

                if (target[k2]) {
                  target = target[k2];
                } else {
                  inject.warn('parseJson vars is not exist: ' + v.id + ', ' + k + ', ' + list.slice(0, i).join('.'));
                  return;
                }
              }

              k2 = list[len - 1];
            } // 支持函数模式和值模式


            if (isFunction(value)) {
              value = value(v);
            }

            target[k2] = value;
          }
        }
      });
    }
  }
}

function replaceLibraryVars(json, hash, vars) {
  if (vars) {
    // 新版同级vars语法
    if (json.hasOwnProperty('vars')) {
      var slot = json.vars;

      if (!Array.isArray(slot)) {
        slot = [slot];
      }

      if (Array.isArray(slot)) {
        slot.forEach(function (item) {
          var id = item.id,
              member = item.member;

          if (!Array.isArray(member)) {
            member = [member];
          } // library.xxx，需要>=2的长度


          if (Array.isArray(member) && member.length > 1 && vars.hasOwnProperty(id)) {
            if (member[0] === 'library') {
              var target = hash;

              for (var i = 1, len = member.length; i < len; i++) {
                var k = member[i]; // 最后一个属性可以为空

                if (target.hasOwnProperty(k) || i === len - 1) {
                  // 最后一个member表达式替换
                  if (i === len - 1) {
                    var v = vars[id]; // 支持函数模式和值模式

                    if (isFunction(v)) {
                      v = v(target(k));
                    }

                    var old = target[k]; // 直接替换library的子对象，需补充id和tagName

                    if (i === 1) {
                      target[k] = Object.assign({
                        id: old.id,
                        tagName: old.tagName
                      }, v);
                    } // 替换library中子对象的一个属性直接赋值
                    else {
                      target[k] = v;
                    }
                  } else {
                    target = target[k];
                  }
                } else {
                  inject.error('Library slot miss ' + k);
                  return;
                }
              }
            }
          }
        });
      }
    } // 兼容老版var-
    else {
      Object.keys(json).forEach(function (k) {
        if (k.indexOf('var-library.') === 0) {
          var v = json[k]; // 直接移除library插槽，防止下面调用replaceVars(json, vars)时报错

          delete json[k];

          if (!v) {
            return;
          }

          var k2 = k.slice(12); // 有id且变量里面传入了替换的值

          if (k2 && v.id && vars.hasOwnProperty(v.id)) {
            var value = vars[v.id];

            if (isFunction(value)) {
              value = value(v);
            } // 替换图层的值必须是一个有tagName的对象


            if (!value || !value.tagName) {
              return;
            } // library对象也要加上id，与正常的library保持一致


            hash[k2] = Object.assign({
              id: k2
            }, value);
          }
        }
      });
    }
  }
}
/**
 * 遍历一遍library的一级，将一级的id存到hash上，无需递归二级，
 * 因为顺序前提要求排好且无循环依赖，所以被用到的一定在前面出现，
 * 一般是无children的元件在前，包含children的div在后
 * 即便library中的元素有children或library，在linkChild时将其link过去，parse递归会继续处理
 * @param item：library的一级孩子
 * @param hash：存放library的key/value引用
 */


function linkLibrary(item, hash) {
  var id = item.id; // library中一定有id，因为是一级，二级+特殊需求才会出现放开

  if (isNil(id)) {
    throw new Error('Library item miss id: ' + JSON.stringify(item));
  } else {
    hash[id] = item;
  }
}
/**
 * 链接child到library文件，
 * props需要是clone的，因为防止多个child使用同一个库文件
 * children则直接引用，无需担心多个使用同一个
 * library也需要带上，在library直接子元素还包含library时会用到
 * @param child
 * @param libraryItem
 */


function linkChild(child, libraryItem) {
  // 规定图层child只有init和动画，属性和子图层来自库
  child.tagName = libraryItem.tagName;
  child.props = clone(libraryItem.props);
  child.children = libraryItem.children;
  child.library = libraryItem.library; // library的var-也要继承过来，本身的var-优先级更高，目前只有children会出现优先级情况

  Object.keys(libraryItem).forEach(function (k) {
    if (k.indexOf('var-') === 0 && !child.hasOwnProperty(k)) {
      child[k] = libraryItem[k];
    }
  }); // 删除以免二次解析

  child.libraryId = null; // 规定图层实例化的属性和样式在init上，优先使用init，然后才取原型链的props

  var init = child.init;

  if (init) {
    var props = child.props = child.props || {};
    var style = props.style;
    extend(props, init); // style特殊处理，防止被上面覆盖丢失原始值

    if (style) {
      extend(style, init.style);
      props.style = style;
    } // 删除以免二次解析


    child.init = null;
  }
}

function parse(karas, json, animateRecords, opt) {
  var hash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  if (isPrimitive(json) || json instanceof Node || json instanceof Component) {
    return json;
  }

  if (Array.isArray(json)) {
    return json.map(function (item) {
      return parse(karas, item, animateRecords, opt, hash);
    });
  } // 先判断是否是个链接到库的节点，是则进行链接操作


  var libraryId = json.libraryId;

  if (!isNil(libraryId)) {
    var libraryItem = hash[libraryId]; // 规定图层child只有init和动画，tagName和属性和子图层来自库

    if (libraryItem) {
      linkChild(json, libraryItem);
    } else {
      throw new Error('Link library miss id: ' + libraryId);
    }

    json.libraryId = null;
  } // 再判断是否有library形成一个新的作用域，会出现library下的library使得一个链接节点链接后出现library的情况


  var library = json.library;

  if (Array.isArray(library)) {
    hash = {};
    library.forEach(function (item) {
      linkLibrary(item, hash);
    }); // 替换library插槽

    replaceLibraryVars(json, hash, opt.vars);
    json.library = null;
  }

  var tagName = json.tagName,
      _json$props = json.props,
      props = _json$props === void 0 ? {} : _json$props,
      _json$children = json.children,
      children = _json$children === void 0 ? [] : _json$children,
      _json$animate = json.animate,
      animate = _json$animate === void 0 ? [] : _json$animate;

  if (!tagName) {
    throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
  }

  var style = props.style;
  opt.abbr !== false && abbr2full(style, abbrCssProperty); // 先替换style的

  replaceVars(style, opt.vars); // 再替换静态属性，style也作为属性的一种，目前尚未被设计为被替换

  replaceVars(props, opt.vars); // 替换children里的内容，如文字，无法直接替换tagName/props/children/animate本身，因为下方用的还是原引用

  replaceVars(json, opt.vars);
  var vd;

  if (tagName.charAt(0) === '$') {
    vd = karas.createGm(tagName, props);
  } else if (/^[A-Z]/.test(tagName)) {
    var cp = Component.getRegister(tagName);
    vd = karas.createCp(cp, props, children.map(function (item) {
      if (item && [TYPE_VD, TYPE_GM, TYPE_CP].indexOf(item.$$type) > -1) {
        return item;
      }

      return parse(karas, item, animateRecords, opt, hash);
    }));
  } else {
    vd = karas.createVd(tagName, props, children.map(function (item) {
      if (item && [TYPE_VD, TYPE_GM, TYPE_CP].indexOf(item.$$type) > -1) {
        return item;
      }

      return parse(karas, item, animateRecords, opt, hash);
    }));
  }

  var animationRecord;

  if (animate) {
    if (Array.isArray(animate)) {
      var has;
      animate.forEach(function (item) {
        opt.abbr !== false && abbr2full(item, abbrAnimate);
        var value = item.value,
            options = item.options; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          has = true;
          value.forEach(function (item) {
            opt.abbr !== false && abbr2full(item, abbrCssProperty);
            replaceVars(item, opt.vars);
          });
        }

        if (options) {
          opt.abbr !== false && abbr2full(options, abbrAnimateOption);
          replaceVars(options, opt.vars);
        }
      });

      if (has) {
        animationRecord = {
          animate: animate,
          target: vd
        };
      }
    } else {
      opt.abbr !== false && abbr2full(animate, abbrAnimate);
      var value = animate.value,
          options = animate.options;

      if (Array.isArray(value) && value.length) {
        value.forEach(function (item) {
          opt.abbr !== false && abbr2full(item, abbrCssProperty);
          replaceVars(item, opt.vars);
        });
        animationRecord = {
          animate: animate,
          target: vd
        };
      }

      if (options) {
        opt.abbr !== false && abbr2full(options, abbrAnimateOption);
        replaceVars(options, opt.vars);
      }
    }
  } // 产生实际动画运行才存入列表供root调用执行


  if (animationRecord) {
    animateRecords.push(animationRecord);
  }

  return vd;
}

var o = {
  parse: function parse$1(karas, json, dom) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    json = util.clone(json); // 根节点的fonts字段定义字体信息

    var fonts = json.fonts;

    if (fonts) {
      if (!Array.isArray(fonts)) {
        fonts = [fonts];
      }

      fonts.forEach(function (item) {
        var fontFamily = item.fontFamily,
            data = item.data;

        if (fontFamily && data) {
          o$3.register(fontFamily, data);
        }
      });
    } // json中定义无abbr


    if (json.abbr === false) {
      options.abbr = false;
    }

    if (options.abbr !== false) {
      inject.warn('Abbr in json is deprecated');
    } // 重载，在确定dom传入选择器字符串或html节点对象时作为渲染功能，否则仅创建vd返回


    if (!inject.isDom(dom)) {
      options = dom || {};
      dom = null;
    } // 暂存所有动画声明，等root的生成后开始执行


    var animateRecords = [];

    var vd = parse(karas, json, animateRecords, options); // 有dom时parse作为根方法渲染


    if (dom) {
      var _json = json,
          tagName = _json.tagName;

      if (['canvas', 'svg', 'webgl'].indexOf(tagName) === -1) {
        throw new Error('Parse dom must be canvas/svg');
      } // parse直接（非递归）的动画记录


      var ac = options.controller instanceof Controller ? options.controller : vd.animateController; // 第一次render，收集递归json里面的animateRecords，它在xom的__layout最后生成

      karas.render(vd, dom); // 由于vd首先生成的都是json，根parse要特殊处理将target指向真正的vd引用，json的vd在builder中赋值

      animateRecords.forEach(function (item) {
        item.target = item.target.vd;
      }); // 直接的json里的animateRecords，再加上递归的parse的json的（第一次render布局时处理）动画一并播放

      if (options.autoPlay !== false) {
        ac.__records = ac.__records.concat(animateRecords);

        ac.__playAuto();
      } // 不自动播放进入记录列表，初始化并等待手动调用
      else {
        ac.__records2 = ac.__records2.concat(animateRecords);
        ac.init(ac.__records2, ac.list2);
      }
    } // 递归的parse，如果有动画，此时还没root，先暂存下来，等上面的root的render第一次布局时收集
    else {
      if (animateRecords.length) {
        vd.__animateRecords = {
          options: options,
          list: animateRecords,
          controller: options.controller instanceof Controller ? options.controller : null
        };
      }
    }

    return vd;
  },
  loadAndParse: function loadAndParse(karas, json, dom, options) {
    var fonts = json.fonts,
        components = json.components,
        imgs = json.imgs;
    var list1 = [];
    var list2 = [];
    var list3 = [];

    if (fonts) {
      if (!Array.isArray(fonts)) {
        fonts = [fonts];
      }

      fonts.forEach(function (item) {
        var url = item.url;

        if (url) {
          list1.push(url);
        }
      });
    }

    if (components) {
      if (!Array.isArray(components)) {
        components = [components];
      }

      components.forEach(function (item) {
        var tagName = item.tagName,
            url = item.url,
            reload = item.reload; // 如果没申明reload且已经被注册，则无需重复加载

        if (tagName && karas.Component.hasRegister(tagName) && !reload) {
          return;
        } // 即便没有tagName也要加载，可能组件内部执行了注册逻辑


        if (url) {
          list2.push(item);
        }
      });
    }

    if (imgs) {
      if (!Array.isArray(imgs)) {
        imgs = [imgs];
      }

      imgs.forEach(function (item) {
        var url = item.url;

        if (url) {
          list3.push(url);
        }
      });
    }

    var a = list1.length,
        b = list2.length,
        c = list3.length;

    if (a || b || c) {
      var count = 0;

      var cb = function cb() {
        if (count === a + b + c) {
          var res = o.parse(karas, json, dom, options);

          if (options && util.isFunction(options.callback)) {
            options.callback(res);
          }
        }
      };

      karas.inject.loadFont(list1, function () {
        count += a;
        cb();
      });
      karas.inject.loadComponent(list2.map(function (item) {
        return item.url;
      }), function () {
        count += b; // 默认约定加载的js组件会在全局变量申明同名tagName，已有不覆盖，防止组件代码内部本身有register

        list2.forEach(function (item) {
          var tagName = item.tagName;

          if (tagName && window[tagName] && !karas.Component.hasRegister(tagName)) {
            karas.Component.register(tagName, window[tagName]);
          }
        });
        cb();
      });
      karas.inject.measureImg(list3, function () {
        count += c;
        cb();
      });
    } else {
      var res = o.parse(karas, json, dom, options);

      if (options && util.isFunction(options.callback)) {
        options.callback(res);
      }

      return res;
    }
  },
  abbr: abbr
};

var style = {
  css: css,
  reset: reset,
  unit: o$4,
  font: o$3,
  abbr: abbr$1
};

var animate = {
  Animation: Animation,
  Controller: Controller,
  easing: easing,
  frame: frame
};

var refresh = {
  level: o$1,
  change: o$2,
  Page: Page,
  Cache: Cache
};

var version = "0.63.7";

Geom.register('$line', Line);
Geom.register('$polyline', Polyline);
Geom.register('$polygon', Polygon);
Geom.register('$sector', Sector);
Geom.register('$rect', Rect);
Geom.register('$circle', Circle);
Geom.register('$ellipse', Ellipse);
var karas$1 = {
  version: version,
  render: function render(root, dom) {
    if (!(root instanceof Root)) {
      throw new Error('Render dom must be canvas/svg');
    }

    if (dom) {
      root.appendTo(dom);
    }

    return root;
  },
  createElement: function createElement(tagName, props) {
    props = props || {};
    var children = [];

    for (var i = 2, len = arguments.length; i < len; i++) {
      children.push(arguments[i]);
    }

    if (util.isString(tagName)) {
      if (tagName.charAt(0) === '$') {
        return this.createGm(tagName, props);
      } else {
        return this.createVd(tagName, props, children);
      }
    } else if (tagName) {
      return this.createCp(tagName, props, children);
    }
  },
  createVd: function createVd(tagName, props) {
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    if (['canvas', 'svg', 'webgl'].indexOf(tagName) > -1) {
      return new Root(tagName, props, children);
    }

    if (tag.TAG_NAME.hasOwnProperty(tagName)) {
      return {
        tagName: tagName,
        props: props,
        children: children,
        $$type: $$type.TYPE_VD
      };
    }

    throw new Error("Can not use <".concat(tagName, ">"));
  },
  createGm: function createGm(tagName, props) {
    return {
      tagName: tagName,
      props: props,
      $$type: $$type.TYPE_GM
    };
  },
  createCp: function createCp(klass, props) {
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    props.children = children;
    return {
      klass: klass,
      props: props,
      $$type: $$type.TYPE_CP
    };
  },
  parse: function parse(json, dom, options) {
    return o.parse(this, json, dom, options);
  },
  loadAndParse: function loadAndParse(json, dom, options) {
    return o.loadAndParse(this, json, dom, options);
  },
  mode: mode,
  Component: Component,
  Node: Node,
  Text: Text,
  Geom: Geom,
  Xom: Xom,
  Dom: Dom,
  Img: Img,
  Root: Root,
  Event: Event,
  util: util,
  inject: inject,
  style: style,
  parser: o,
  animate: animate,
  math: math,
  builder: builder,
  updater: updater,
  refresh: refresh,
  enums: enums,

  set debug(v) {
    debug.flag = !!v;
  }

};
builder.ref({
  Xom: Xom,
  Dom: Dom,
  Img: Img,
  Geom: Geom,
  Component: Component
});

if (typeof window !== 'undefined') {
  window.karas = karas$1;
} else if (typeof self !== 'undefined') {
  self.karas = karas$1;
}

export { karas$1 as default };
//# sourceMappingURL=index.es.js.map
