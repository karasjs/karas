(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.karas = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var STYLE_KEY = {
    POSITION: 0,
    DISPLAY: 1,
    TOP: 2,
    RIGHT: 3,
    BOTTOM: 4,
    LEFT: 5,
    MARGIN_TOP: 6,
    MARGIN_RIGHT: 7,
    MARGIN_BOTTOM: 8,
    MARGIN_LEFT: 9,
    PADDING_TOP: 10,
    PADDING_RIGHT: 11,
    PADDING_BOTTOM: 12,
    PADDING_LEFT: 13,
    FONT_SIZE: 14,
    FONT_FAMILY: 15,
    COLOR: 16,
    FONT_STYLE: 17,
    FONT_WEIGHT: 18,
    LINE_HEIGHT: 19,
    BACKGROUND_IMAGE: 20,
    BACKGROUND_COLOR: 21,
    BACKGROUND_SIZE: 22,
    BACKGROUND_REPEAT: 23,
    BACKGROUND_POSITION_X: 24,
    BACKGROUND_POSITION_Y: 25,
    BORDER_TOP_WIDTH: 26,
    BORDER_RIGHT_WIDTH: 27,
    BORDER_BOTTOM_WIDTH: 28,
    BORDER_LEFT_WIDTH: 29,
    BORDER_TOP_COLOR: 30,
    BORDER_RIGHT_COLOR: 31,
    BORDER_BOTTOM_COLOR: 32,
    BORDER_LEFT_COLOR: 33,
    BORDER_TOP_STYLE: 34,
    BORDER_RIGHT_STYLE: 35,
    BORDER_BOTTOM_STYLE: 36,
    BORDER_LEFT_STYLE: 37,
    BORDER_TOP_LEFT_RADIUS: 38,
    BORDER_TOP_RIGHT_RADIUS: 39,
    BORDER_BOTTOM_RIGHT_RADIUS: 40,
    BORDER_BOTTOM_LEFT_RADIUS: 41,
    WIDTH: 42,
    HEIGHT: 43,
    FLEX_GROW: 44,
    FLEX_SHRINK: 45,
    FLEX_BASIS: 46,
    FLEX_DIRECTION: 47,
    JUSTIFY_CONTENT: 48,
    ALIGN_ITEMS: 49,
    ALIGN_SELF: 50,
    TEXT_ALIGN: 51,
    TRANSFORM_ORIGIN: 52,
    VISIBILITY: 53,
    OPACITY: 54,
    Z_INDEX: 55,
    TRANSFORM: 56,
    TRANSLATE_X: 57,
    TRANSLATE_Y: 58,
    TRANSLATE_Z: 59,
    SCALE_X: 60,
    SCALE_Y: 61,
    SCALE_Z: 62,
    SKEW_X: 63,
    SKEW_Y: 64,
    ROTATE_X: 65,
    ROTATE_Y: 66,
    ROTATE_Z: 67,
    ROTATE_3D: 68,
    PERSPECTIVE: 69,
    PERSPECTIVE_ORIGIN: 70,
    FILTER: 71,
    BOX_SHADOW: 72,
    POINTER_EVENTS: 73,
    OVERFLOW: 74,
    MIX_BLEND_MODE: 75,
    BACKGROUND_CLIP: 76,
    WHITE_SPACE: 77,
    TEXT_OVERFLOW: 78,
    LETTER_SPACING: 79,
    LINE_CLAMP: 80,
    ORDER: 81,
    FLEX_WRAP: 82,
    ALIGN_CONTENT: 83,
    TEXT_STROKE_WIDTH: 84,
    TEXT_STROKE_COLOR: 85,
    TEXT_STROKE_OVER: 86,
    WRITING_MODE: 87,
    // GEOM
    FILL: 88,
    STROKE: 89,
    STROKE_WIDTH: 90,
    STROKE_DASHARRAY: 91,
    STROKE_DASHARRAY_STR: 92,
    STROKE_LINECAP: 93,
    STROKE_LINEJOIN: 94,
    STROKE_MITERLIMIT: 95,
    FILL_RULE: 96,
    // 无此样式，仅cache或特殊情况需要
    MATRIX: 97,
    BORDER_TOP: 98,
    BORDER_RIGHT: 99,
    BORDER_BOTTOM: 100,
    BORDER_LEFT: 101,
    TRANSLATE_PATH: 102
  };
  var STYLE2LOWER_MAP = {};

  function style2Lower(s) {
    STYLE2LOWER_MAP[s] = STYLE2LOWER_MAP[s] || s.toLowerCase().replace(/_([a-z])/g, function ($0, $1) {
      return $1.toUpperCase();
    });
    return STYLE2LOWER_MAP[s];
  }

  var STYLE2UPPER_MAP = {};

  function style2Upper(s) {
    STYLE2UPPER_MAP[s] = STYLE2UPPER_MAP[s] || s.replace(/([a-z\d_])([A-Z])/g, function ($0, $1, $2) {
      return $1 + '_' + $2;
    }).toUpperCase();
    return STYLE2UPPER_MAP[s];
  }

  var STYLE_R_KEY = {};
  var STYLE_RV_KEY = {};
  var STYLE_V_KEY = {};
  Object.keys(STYLE_KEY).forEach(function (k) {
    var k2 = STYLE_KEY[k];
    STYLE_R_KEY[k2] = k;
    var l = style2Lower(k);
    STYLE_RV_KEY[k2] = l;
    STYLE_V_KEY[l] = k2;
  }); // Root的update过程使用

  var UPDATE_KEY = {
    UPDATE_NODE: 0,
    UPDATE_STYLE: 1,
    UPDATE_FOCUS: 2,
    UPDATE_COMPONENT: 3,
    UPDATE_OVERWRITE: 4,
    UPDATE_KEYS: 5,
    UPDATE_LIST: 6,
    UPDATE_CONFIG: 7,
    UPDATE_ADD_DOM: 8,
    UPDATE_REMOVE_DOM: 9
  }; // animation计算每帧使用

  var KEY_FRAME_KEY = {
    FRAME_STYLE: 0,
    FRAME_TIME: 1,
    FRAME_EASING: 2,
    FRAME_TRANSITION: 3
  }; // 节点使用

  var NODE_KEY = {
    NODE_DOM_PARENT: 0,
    NODE_OPACITY: 1,
    NODE_MATRIX: 2,
    NODE_MATRIX_EVENT: 3,
    NODE_CACHE: 4,
    NODE_CACHE_TOTAL: 5,
    NODE_CACHE_FILTER: 6,
    NODE_CACHE_MASK: 7,
    NODE_CACHE_OVERFLOW: 8,
    NODE_STRUCT: 9,
    NODE_TAG_NAME: 10,
    NODE_CURRENT_STYLE: 11,
    NODE_CURRENT_PROPS: 12,
    NODE_COMPUTED_STYLE: 13,
    NODE_CACHE_STYLE: 14,
    NODE_CACHE_PROPS: 15,
    NODE_LIMIT_CACHE: 16,
    NODE_IS_MASK: 17,
    NODE_IS_INLINE: 18,
    NODE_HAS_CONTENT: 19,
    NODE_REFRESH_LV: 20,
    NODE_IS_DESTROYED: 21,
    NODE_STYLE: 22,
    NODE_UPDATE_HASH: 23,
    NODE_UNIQUE_UPDATE_ID: 24,
    NODE_DEFS_CACHE: 25,
    NODE_PERSPECTIVE_MATRIX: 26,
    NODE_VIRTUAL_DOM: 27,
    NODE_CACHE_AS_BITMAP: 28
  }; // struct用

  var STRUCT_KEY = {
    STRUCT_NODE: 0,
    STRUCT_INDEX: 1,
    STRUCT_CHILD_INDEX: 2,
    STRUCT_LV: 3,
    STRUCT_NUM: 4,
    STRUCT_TOTAL: 5,
    STRUCT_HAS_MASK: 6
  };
  var ANIMATE_KEY = {
    I_ASSIGNING: 0,
    I_IN_FPS: 1,
    I_IS_DELAY: 2,
    I_BEGIN: 3,
    I_END: 4,
    I_FINISHED: 5,
    I_NEXT_END: 6,
    I_FIRST_PLAY: 7,
    I_PLAY_CB: 8,
    I_TARGET: 9,
    I_ROOT: 10,
    I_FRAMES: 11,
    I_FRAMES_R: 12,
    I_CURRENT_TIME: 13,
    I_NEXT_TIME: 14,
    I_STYLE: 15,
    I_DURATION: 16,
    I_ITERATIONS: 17,
    I_FILL: 18,
    I_PLAYBACK_RATE: 19,
    I_PLAY_COUNT: 20,
    I_PLAY_STATE: 21,
    I_DESTROYED: 22,
    I_START_TIME: 23,
    I_FPS_TIME: 24,
    I_EASING: 25,
    I_ENTER_FRAME: 26,
    I_DELAY: 27,
    I_END_DELAY: 28,
    I_KEYS: 29,
    I_ORIGIN_STYLE: 30,
    I_CURRENT_FRAMES: 31,
    I_CURRENT_FRAME: 32,
    I_SPF_LIMIT: 33,
    I_FPS: 34,
    I_DIRECTION: 35,
    I_FIRST_ENTER: 36,
    I_STAY_BEGIN: 37,
    I_STAY_END: 38,
    I_IS2: 39,
    I_END_TIME: 40,
    I_NODE_CONFIG: 41,
    I_ROOT_CONFIG: 42,
    I_OUT_BEGIN_DELAY: 43,
    I_TIME_STAMP: 44
  };
  var enums = {
    STYLE_KEY: STYLE_KEY,
    // 大写常量为k，数字为值
    STYLE_R_KEY: STYLE_R_KEY,
    // 数字为k，大写常量为值
    STYLE_RV_KEY: STYLE_RV_KEY,
    // 数字为k，小写为值
    STYLE_V_KEY: STYLE_V_KEY,
    // 小写为k，数字为值
    style2Lower: style2Lower,
    style2Upper: style2Upper,
    UPDATE_KEY: UPDATE_KEY,
    KEY_FRAME_KEY: KEY_FRAME_KEY,
    NODE_KEY: NODE_KEY,
    STRUCT_KEY: STRUCT_KEY,
    ANIMATE_KEY: ANIMATE_KEY,
    ELLIPSIS: '…'
  };

  var _enums$STRUCT_KEY = enums.STRUCT_KEY,
      STRUCT_NODE = _enums$STRUCT_KEY.STRUCT_NODE,
      STRUCT_INDEX = _enums$STRUCT_KEY.STRUCT_INDEX,
      STRUCT_CHILD_INDEX = _enums$STRUCT_KEY.STRUCT_CHILD_INDEX,
      STRUCT_LV = _enums$STRUCT_KEY.STRUCT_LV,
      _enums$NODE_KEY = enums.NODE_KEY,
      NODE_IS_DESTROYED = _enums$NODE_KEY.NODE_IS_DESTROYED,
      NODE_STRUCT = _enums$NODE_KEY.NODE_STRUCT;

  var Node = /*#__PURE__*/function () {
    function Node() {
      _classCallCheck(this, Node);

      this.__x = 0;
      this.__y = 0;
      this.__ox = 0; // relative造成的偏移量

      this.__oy = 0;
      this.__sx = 0;
      this.__sy = 0;
      this.__width = 0;
      this.__height = 0;
      this.__baseline = 0;
      this.__verticalBaseline = 0;
      this.__config = {};
      this.__prev = null;
      this.__next = null;
      this.__parent = null;
      this.__domParent = null;
      this.__root = null;
      this.__host = null;
      this.__virtualDom = null;
      this.__bbox = null;
      this.__filterBbox = null;
    }

    _createClass(Node, [{
      key: "__structure",
      value: function __structure(i, lv, j) {
        var _this$__config$NODE_S;

        return this.__config[NODE_STRUCT] = (_this$__config$NODE_S = {}, _defineProperty(_this$__config$NODE_S, STRUCT_NODE, this), _defineProperty(_this$__config$NODE_S, STRUCT_INDEX, i), _defineProperty(_this$__config$NODE_S, STRUCT_CHILD_INDEX, j), _defineProperty(_this$__config$NODE_S, STRUCT_LV, lv), _this$__config$NODE_S);
      }
    }, {
      key: "__modifyStruct",
      value: function __modifyStruct(root) {
        var struct = this.__config[NODE_STRUCT];
        return [struct, 0];
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout) {
        if (isLayout) {
          this.__x += diff;
        } else {
          this.__ox += diff;
        }

        this.__sx += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout) {
        if (isLayout) {
          this.__y += diff;
        } else {
          this.__oy += diff;
        }

        this.__sy += diff;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__config[NODE_IS_DESTROYED] = true;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "ox",
      get: function get() {
        return this.__ox;
      }
    }, {
      key: "oy",
      get: function get() {
        return this.__oy;
      }
    }, {
      key: "sx",
      get: function get() {
        return this.x + this.ox;
      }
    }, {
      key: "sy",
      get: function get() {
        return this.y + this.oy;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      } // canvas/svg根节点

    }, {
      key: "root",
      get: function get() {
        return this.__root;
      } // component根节点

    }, {
      key: "host",
      get: function get() {
        return this.__host;
      } // 考虑高阶组件在内的component根节点

    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.__baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.__verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__config[NODE_IS_DESTROYED];
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return false;
      }
    }]);

    return Node;
  }();

  var mode = {
    CANVAS: 0,
    SVG: 1,
    WEBGL: 2
  };

  var o = {
    AUTO: 0,
    PX: 1,
    PERCENT: 2,
    NUMBER: 3,
    INHERIT: 4,
    DEG: 5,
    STRING: 6,
    RGBA: 7,
    REM: 8,
    EM: 9,
    VW: 10,
    VH: 11,
    VMAX: 12,
    VMIN: 13,
    GRADIENT: 14,
    // 特殊格式，color/fill/stroke用给ctx传值

    /**
     * 通用的格式化计算数值单位的方法，百分比/像素/REM/VW/auto和纯数字
     * @param v value
     * @returns 格式化好的[number, unit]
     */
    calUnit: function calUnit(v) {
      var n = parseFloat(v) || 0;

      if (/%$/.test(v)) {
        return [n, o.PERCENT];
      } else if (/px$/i.test(v)) {
        return [n, o.PX];
      } else if (/deg$/i.test(v)) {
        return [n, o.DEG];
      } else if (/rem$/i.test(v)) {
        return [n, o.REM];
      } else if (/vw$/i.test(v)) {
        return [n, o.VW];
      } else if (/vh$/i.test(v)) {
        return [n, o.VH];
      } else if (/em$/i.test(v)) {
        return [n, o.EM];
      } else if (/vw$/i.test(v)) {
        return [n, o.VW];
      } else if (/vh$/i.test(v)) {
        return [n, o.VH];
      } else if (/vmax$/i.test(v)) {
        return [n, o.VMAX];
      } else if (/vmin$/i.test(v)) {
        return [n, o.VMIN];
      }

      return [n, o.NUMBER];
    }
  };

  var o$1 = {
    info: {
      arial: {
        lhr: 1.14990234375,
        // 默认line-height ratio，(67+1854+434)/2048
        // car: 1.1171875, // content-area ratio，(1854+434)/2048
        blr: 0.9052734375,
        // base-line ratio，1854/2048
        // mdr: 0.64599609375, // middle ratio，(1854-1062/2)/2048
        lgr: 0.03271484375 // line-gap ratio，67/2048，默认0

      },
      helvetica: {
        lhr: 1.14990234375,
        // (8+1900+447)/2048
        blr: 0.927734375,
        // 1900/2048
        lgr: 0.00390625 // 8/2048

      },
      verdana: {
        lhr: 1.21533203125,
        // (0+2059+430)/2048
        blr: 1.00537109375 // 2059/2048

      },
      tahoma: {
        lhr: 1.20703125,
        // (0+2049+423)/2048
        blr: 1.00048828125 // 2049/2048

      },
      georgia: {
        lhr: 1.13623046875,
        // (0+1878+449)/2048
        blr: 0.9169921875 // 1878/2048

      },
      'courier new': {
        lhr: 1.1328125,
        // (0+1705+615)/2048
        blr: 0.83251953125 // 1705/2048

      },
      'pingfang sc': {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06 // 1060/1000

      },
      simsun: {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06
      }
    },
    support: function support(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].checked;
    },
    register: function register(name, info) {
      var _ref = info || {},
          _ref$emSquare = _ref.emSquare,
          emSquare = _ref$emSquare === void 0 ? 2048 : _ref$emSquare,
          _ref$ascent = _ref.ascent,
          ascent = _ref$ascent === void 0 ? 1854 : _ref$ascent,
          _ref$descent = _ref.descent,
          descent = _ref$descent === void 0 ? 434 : _ref$descent,
          _ref$lineGap = _ref.lineGap,
          lineGap = _ref$lineGap === void 0 ? 0 : _ref$lineGap;

      this.info[name.toLowerCase()] = {
        lhr: (ascent + descent + lineGap) / emSquare,
        blr: ascent / emSquare
      };
    },
    hasRegister: function hasRegister(fontFamily) {
      return this.info.hasOwnProperty(fontFamily);
    },
    hasChecked: function hasChecked(fontFamily) {
      return this.hasRegister(fontFamily) && this.info[fontFamily].hasOwnProperty('checked');
    },
    setChecked: function setChecked(fontFamily, res) {
      return this.info[fontFamily].checked = res;
    },
    addPadding: function addPadding(name, padding) {
      Object.assign(this.info[name.toLowerCase()].padding, padding);
    }
  };
  o$1.info['宋体'] = o$1.info.simsun;
  o$1.info['pingfang'] = o$1.info['pingfang sc'];

  // 类型为引用防止json仿造
  var TYPE_VD = Symbol('Dom');
  var TYPE_GM = Symbol('Geom');
  var TYPE_CP = Symbol('Component');
  var $$type = {
    TYPE_VD: TYPE_VD,
    TYPE_GM: TYPE_GM,
    TYPE_CP: TYPE_CP
  };

  // 生成4*4单位矩阵
  function identity() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  } // 矩阵a*b，固定两个matrix都是长度16


  function multiply(a, b) {
    if (isE(a)) {
      return b;
    }

    if (isE(b)) {
      return a;
    }

    var c = [];

    for (var i = 0; i < 4; i++) {
      var a0 = a[i] || 0;
      var a1 = a[i + 4] || 0;
      var a2 = a[i + 8] || 0;
      var a3 = a[i + 12] || 0;
      c[i] = a0 * b[0] + a1 * b[1] + a2 * b[2] + a3 * b[3];
      c[i + 4] = a0 * b[4] + a1 * b[5] + a2 * b[6] + a3 * b[7];
      c[i + 8] = a0 * b[8] + a1 * b[9] + a2 * b[10] + a3 * b[11];
      c[i + 12] = a0 * b[12] + a1 * b[13] + a2 * b[14] + a3 * b[15];
    }

    return c;
  }

  function calPoint(point, m) {
    var _point = _slicedToArray(point, 4),
        x = _point[0],
        y = _point[1],
        z = _point[2],
        w = _point[3];

    if (w === undefined) {
      w = 1;
    }

    if (m && !isE(m)) {
      if (m.length === 16) {
        z = z || 0;

        var _m = _slicedToArray(m, 16),
            a1 = _m[0],
            b1 = _m[1],
            c1 = _m[2],
            d1 = _m[3],
            a2 = _m[4],
            b2 = _m[5],
            c2 = _m[6],
            d2 = _m[7],
            a3 = _m[8],
            b3 = _m[9],
            c3 = _m[10],
            d3 = _m[11],
            a4 = _m[12],
            b4 = _m[13],
            c4 = _m[14],
            d4 = _m[15];

        w *= x * d1 + y * d2 + z * d3 + d4;
        return [x * a1 + y * a2 + z * a3 + a4, x * b1 + y * b2 + z * b3 + b4, x * c1 + y * c2 + z * c3 + c4, w];
      } // 6位类型


      var _m2 = _slicedToArray(m, 6),
          a = _m2[0],
          b = _m2[1],
          c = _m2[2],
          d = _m2[3],
          e = _m2[4],
          f = _m2[5];

      return [a * x + c * y + e, b * x + d * y + f];
    }

    return [x, y, z, w];
  }
  /**
   * 初等行变换求3*3特定css的matrix方阵，一维6长度
   * https://blog.csdn.net/iloveas2014/article/details/82930946
   * @param m
   * @returns {number[]|*}
   */


  function inverse(m) {
    if (m.length === 16) {
      return inverse4(m);
    }

    var _m3 = _slicedToArray(m, 6),
        a = _m3[0],
        b = _m3[1],
        c = _m3[2],
        d = _m3[3],
        e = _m3[4],
        f = _m3[5];

    if (a === 1 && b === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
      return m;
    }

    var divisor = a * d - b * c;

    if (divisor === 0) {
      return m;
    }

    return [d / divisor, -b / divisor, -c / divisor, a / divisor, (c * f - d * e) / divisor, (b * e - a * f) / divisor];
  } // 16位或者6位单位矩阵判断，空也认为是


  function isE(m) {
    if (!m || !m.length) {
      return true;
    }

    if (m.length === 16) {
      return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }

    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
  }
  /**
   * 求任意4*4矩阵的逆矩阵，行列式为 0 则返回单位矩阵兜底
   * 格式：matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)
   * 参见: https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d()
   * 对应：
   * [
   *   a1,a2,a3,a4,
   *   b1,b2,b3,b4,
   *   c1,c2,c3,c4,
   *   d1,d2,d3,d4,
   * ]
   *
   * 根据公式 A* = |A|A^-1 来计算
   * A* 表示矩阵 A 的伴随矩阵，A^-1 表示矩阵 A 的逆矩阵，|A| 表示行列式的值
   *
   * @returns {number[]}
   */


  function inverse4(s) {
    var inv = [];
    inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
    inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
    inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
    inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
    inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
    inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
    inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
    inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
    inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
    inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
    inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
    inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
    inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
    inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
    inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
    inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
    var det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];

    if (det === 0) {
      return identity();
    }

    det = 1 / det;
    var d = [];

    for (var i = 0; i < 16; i++) {
      d[i] = inv[i] * det;
    }

    return d;
  } // 将4*4的16长度矩阵转成css/canvas的6位标准使用，忽略transform3d


  function m2m6(m) {
    return [m[0], m[1], m[4], m[5], m[12], m[13]];
  }

  function point2d(point) {
    var w = point[3];

    if (w && w !== 1) {
      point = point.slice(0, 2);
      point[0] /= w;
      point[1] /= w;
    }

    return point;
  }

  var mx = {
    identity: identity,
    multiply: multiply,
    calPoint: calPoint,
    point2d: point2d,
    inverse: inverse,
    isE: isE,
    m2m6: m2m6
  };

  var toString = {}.toString;

  function isType(type) {
    return function (obj) {
      return toString.call(obj) === '[object ' + type + ']';
    };
  }

  var isObject = isType('Object');
  var isString = isType('String');
  var isFunction = isType('Function');
  var isNumber = isType('Number');
  var isBoolean = isType('Boolean');
  var isDate = isType('Date');
  var hasOwn = {}.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);

  function isNil(v) {
    return v === undefined || v === null;
  }

  function _joinSourceArray(arr) {
    var res = '';

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        res += _joinSourceArray(item);
      } else {
        res += stringify(item);
      }
    }

    return res;
  }

  function stringify(s) {
    if (isNil(s)) {
      return '';
    }

    return s.toString();
  }

  function encodeHtml(s, prop) {
    if (prop) {
      return s.replace(/"/g, '&quot;');
    }

    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/ /g, '&nbsp;');
  } // 根元素专用


  function joinVirtualDom(vd) {
    var s = '<defs>';
    vd.defs.forEach(function (item) {
      s += joinDef(item);
    });
    s += '</defs><g>';
    vd.bb.forEach(function (item) {
      s += joinVd(item);
    });
    s += '</g><g';

    if (vd.conClip) {
      s += ' clip-path="' + vd.conClip + '"';
    }

    s += '>';
    (vd.children || []).forEach(function (item) {
      if (item.isMask) {
        return;
      }

      s += joinVd(item);
    });
    s += '</g>';
    return s;
  } // 普通元素


  function joinVd(vd) {
    if (vd.type === 'item' || vd.type === 'img') {
      var s = '';
      (vd.props || []).forEach(function (item) {
        s += ' ' + item[0] + '="' + item[1] + '"';
      });

      if (vd.tagName === 'text') {
        return '<text' + s + '>' + vd.content + '</text>';
      }

      return '<' + vd.tagName + s + '/>';
    } else if (vd.type === 'text') {
      var _s = ''; // text有许多lineBox

      (vd.children || []).forEach(function (item) {
        _s += joinVd(item);
      });
      return '<g>' + _s + '</g>';
    } else if (vd.type === 'dom' || vd.type === 'geom') {
      var _s2 = '<g>';
      vd.bb.forEach(function (item) {
        _s2 += joinVd(item);
      });
      _s2 += '</g><g';

      if (vd.conClip) {
        _s2 += ' clip-path="' + vd.conClip + '"';
      }

      _s2 += '>';
      (vd.children || []).forEach(function (item) {
        if (item.isMask) {
          return;
        }

        _s2 += joinVd(item);
      });
      _s2 += '</g>';
      var opacity = vd.opacity,
          transform = vd.transform,
          visibility = vd.visibility,
          mask = vd.mask,
          overflow = vd.overflow,
          filter = vd.filter,
          mixBlendMode = vd.mixBlendMode;
      return '<g' + (opacity !== 1 && opacity !== undefined ? ' opacity="' + opacity + '"' : '') + (transform ? ' transform="' + transform + '"' : '') + ' visibility="' + visibility + '"' + (mask ? ' mask="' + mask + '"' : '') + (overflow ? ' clip-path="' + overflow + '"' : '') + (filter || mixBlendMode ? ' style="' : '') + (filter ? 'filter:' + filter + ';' : '') + (mixBlendMode ? 'mix-blend-mode:' + mixBlendMode + ';' : '') + (filter || mixBlendMode ? '"' : '') + '>' + _s2 + '</g>';
    }
  }

  function joinDef(def) {
    var s = '<' + def.tagName + ' id="' + def.uuid + '"';

    if (def.tagName === 'mask' || def.tagName === 'clipPath') ; else if (def.tagName === 'filter') ; else {
      s += ' gradientUnits="userSpaceOnUse"';
    }

    (def.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '>';
    (def.children || []).forEach(function (item) {
      s += joinItem(item);
    });
    s += '</' + def.tagName + '>';
    return s;
  }

  function joinItem(item) {
    var s = '<' + item.tagName;
    (item.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '></' + item.tagName + '>';
    return s;
  }

  function rgba2int(color) {
    if (Array.isArray(color)) {
      return color;
    }

    var res = [];

    if (!color || color === 'transparent') {
      res = [0, 0, 0, 0];
    } else if (color.charAt(0) === '#') {
      color = color.slice(1);

      if (color.length === 3) {
        res.push(parseInt(color.charAt(0) + color.charAt(0), 16));
        res.push(parseInt(color.charAt(1) + color.charAt(1), 16));
        res.push(parseInt(color.charAt(2) + color.charAt(2), 16));
        res[3] = 1;
      } else if (color.length === 6) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4), 16));
        res[3] = 1;
      } else if (color.length === 8) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4, 6), 16));
        res.push(parseInt(color.slice(6), 16) / 255);
      } else {
        res[0] = res[1] = res[2] = 0;
        res[3] = 1;
      }
    } else {
      var c = color.match(/rgba?\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);

      if (c) {
        res = [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];

        if (!isNil(c[4])) {
          res[3] = parseFloat(c[4]);
        } else {
          res[3] = 1;
        }
      } else {
        res = [0, 0, 0, 0];
      }
    }

    return res;
  }

  function int2rgba(color) {
    if (Array.isArray(color)) {
      if (color.length === 4) {
        color = color.map(function (c, i) {
          return i === 3 ? c : Math.floor(Math.max(0, c));
        });
        return 'rgba(' + joinArr(color, ',') + ')';
      } else if (color.length === 3) {
        color = color.map(function (c) {
          return Math.floor(c);
        });
        return 'rgba(' + joinArr(color, ',') + ',1)';
      }
    }

    return color || 'rgba(0,0,0,0)';
  }

  function int2invert(color) {
    if (Array.isArray(color)) {
      color = color.slice(0);
      color[0] = 255 - color[0];
      color[1] = 255 - color[1];
      color[2] = 255 - color[2];

      if (color.length === 4) {
        return 'rgba(' + joinArr(color, ',') + ')';
      } else if (color.length === 3) {
        return 'rgba(' + joinArr(color, ',') + ',1)';
      }
    }

    return 'rgba(0,0,0,0)';
  }

  function arr2hash(arr) {
    var hash = {};

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        hash[item[0]] = item[1];
      } else {
        for (var list = Object.keys(item), j = list.length - 1; j >= 0; j--) {
          var k = list[j];
          hash[k] = item[k];
        }
      }
    }

    return hash;
  }

  function hash2arr(hash) {
    if (Array.isArray(hash)) {
      return hash;
    }

    var arr = [];

    for (var list = Object.keys(hash), i = 0, len = list.length; i < len; i++) {
      var k = list[i];
      arr.push([k, hash[k]]);
    }

    return arr;
  }

  function clone(obj) {
    if (isNil(obj) || _typeof(obj) !== 'object') {
      return obj;
    } // parse递归会出现内部先返回解析好的json，外部parse不能clone


    if (obj.$$type === $$type.TYPE_VD || obj.$$type === $$type.TYPE_GM || obj.$$type === $$type.TYPE_CP) {
      return obj;
    }

    if (util.isDate(obj)) {
      return new Date(obj);
    }

    if (!isPlainObject(obj) && !Array.isArray(obj)) {
      return obj;
    }

    var n = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(function (i) {
      n[i] = clone(obj[i]);
    });
    return n;
  }
  /**
   * 简化的arr对比，arr中只有arr和其它类型，其它类型对比值或引用，arr递归
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equalArr(a, b) {
    if (!a || !b) {
      return a === b;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0, len = a.length; i < len; i++) {
      var ai = a[i];
      var bi = b[i];
      var isArrayA = Array.isArray(ai);
      var isArrayB = Array.isArray(bi);

      if (isArrayA && isArrayB) {
        if (!equalArr(ai, bi)) {
          return false;
        }
      } else if (isArrayA || isArrayB) {
        return false;
      } else if (ai !== bi) {
        return false;
      }
    }

    return true;
  }
  /**
   * 深度对比对象
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equal(a, b) {
    if (a === b) {
      return true;
    }

    if (isObject(a) && isObject(b)) {
      var hash = {};

      for (var i = 0, arr = Object.keys(a), len = arr.length; i < len; i++) {
        var k = arr[i];

        if (!b.hasOwnProperty(k) || !equal(a[k], b[k])) {
          return false;
        }

        hash[k] = true;
      } // a没有b有则false


      for (var _i = 0, _arr = Object.keys(b), _len = _arr.length; _i < _len; _i++) {
        var _k = _arr[_i];

        if (!hash.hasOwnProperty(_k)) {
          return false;
        }
      }
    } else if (isDate(a) && isDate(b)) {
      return a.getTime() === b.getTime();
    } else if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        if (!equal(a[_i2], b[_i2])) {
          return false;
        }
      }
    } else {
      return a === b;
    }

    return true;
  }

  function extend(target, source, keys) {
    if (source === null || _typeof(source) !== 'object') {
      return target;
    }

    if (!keys) {
      keys = Object.keys(source);
    }

    var i = 0;
    var len = keys.length;

    while (i < len) {
      var k = keys[i];
      target[k] = source[k];
      i++;
    }

    return target;
  }

  function joinArr(arr, split) {
    var s = arr.length ? arr[0] : '';

    for (var i = 1, len = arr.length; i < len; i++) {
      s += split + arr[i];
    }

    return s;
  }

  function extendAnimate(ovd, nvd) {
    var list = nvd.__animationList = ovd.animationList.splice(0);
    list.forEach(function (item) {
      item.__setTarget(nvd); // 事件队列的缘故，可能动画本帧刚执行过，然后再继承，就会缺失，需再次赋值一遍；也有可能停留最后


      if (item.assigning || item.finished && item.__stayEnd()) {
        item.assignCurrentStyle();
      }
    }); // 帧动画继承

    nvd.__frameAnimateList = ovd.__frameAnimateList.splice(0);
  }

  function transformBbox(bbox, matrix) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (matrix && !mx.isE(matrix)) {
      var _bbox = bbox,
          _bbox2 = _slicedToArray(_bbox, 4),
          x1 = _bbox2[0],
          y1 = _bbox2[1],
          x2 = _bbox2[2],
          y2 = _bbox2[3]; // 可能因filter的原因扩展范围


      if (dx) {
        x1 -= dx;
        x2 += dx;
      }

      if (dy) {
        y1 -= dy;
        y2 += dy;
      }

      var list = [x2, y1, x1, y2, x2, y2];
      var w;

      var _mx$calPoint = mx.calPoint([x1, y1], matrix);

      var _mx$calPoint2 = _slicedToArray(_mx$calPoint, 4);

      x1 = _mx$calPoint2[0];
      y1 = _mx$calPoint2[1];
      w = _mx$calPoint2[3];

      if (w && w !== 1) {
        x1 /= w;
        y1 /= w;
      }

      var xa = x1,
          ya = y1,
          xb = x1,
          yb = y1;

      for (var i = 0; i < 6; i += 2) {
        var x = list[i],
            y = list[i + 1];

        var _mx$calPoint3 = mx.calPoint([x, y], matrix);

        var _mx$calPoint4 = _slicedToArray(_mx$calPoint3, 4);

        x = _mx$calPoint4[0];
        y = _mx$calPoint4[1];
        w = _mx$calPoint4[3];

        if (w && w !== 1) {
          x /= w;
          y /= w;
        }

        xa = Math.min(xa, x);
        xb = Math.max(xb, x);
        ya = Math.min(ya, y);
        yb = Math.max(yb, y);
      }

      bbox = [xa, ya, xb, yb];
    } else if (dx || dy) {
      bbox = bbox.slice(0);
      bbox[0] -= dx;
      bbox[1] -= dy;
      bbox[2] += dx;
      bbox[3] += dy;
    }

    return bbox;
  }

  function isPlainObject(obj) {
    if (!obj || toString.call(obj) !== '[object Object]') {
      return false;
    }

    var proto = Object.getPrototypeOf(obj);

    if (!proto) {
      return true;
    }

    var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
  }

  function assignMatrix(t, v) {
    t[0] = v[0];
    t[1] = v[1];
    t[2] = v[2];
    t[3] = v[3];
    t[4] = v[4];
    t[5] = v[5];
    t[6] = v[6];
    t[7] = v[7];
    t[8] = v[8];
    t[9] = v[9];
    t[10] = v[10];
    t[11] = v[11];
    t[12] = v[12];
    t[13] = v[13];
    t[14] = v[14];
    t[15] = v[15];
    return t;
  }

  function prefixHex(s) {
    if (s.length === 1) {
      return '0' + s;
    }

    return s;
  }

  function replaceRgba2Hex(s) {
    return (s || '').replace(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/ig, function ($0, $1, $2, $3, $4) {
      var res = '#' + prefixHex(parseInt($1).toString(16)) + prefixHex(parseInt($2).toString(16)) + prefixHex(parseInt($3).toString(16));

      if ($4) {
        res += prefixHex(Math.floor(parseFloat($4) * 255).toString(16));
      }

      return res;
    });
  }

  var util = {
    isObject: isObject,
    isString: isString,
    isFunction: isFunction,
    isNumber: isNumber,
    isBoolean: isBoolean,
    isDate: isDate,
    isNil: isNil,
    isPrimitive: function isPrimitive(v) {
      return util.isNil(v) || util.isBoolean(v) || util.isString(v) || util.isNumber(v);
    },
    // css中常用undefined/null表示auto本身
    isAuto: function isAuto(v) {
      return isNil(v) || v === 'auto';
    },
    isPlainObject: isPlainObject,
    stringify: stringify,
    joinSourceArray: function joinSourceArray(arr) {
      return _joinSourceArray(arr);
    },
    encodeHtml: encodeHtml,
    joinVirtualDom: joinVirtualDom,
    joinVd: joinVd,
    joinDef: joinDef,
    rgba2int: rgba2int,
    int2rgba: int2rgba,
    int2invert: int2invert,
    arr2hash: arr2hash,
    hash2arr: hash2arr,
    clone: clone,
    equalArr: equalArr,
    equal: equal,
    extend: extend,
    joinArr: joinArr,
    extendAnimate: extendAnimate,
    transformBbox: transformBbox,
    assignMatrix: assignMatrix,
    prefixHex: prefixHex,
    replaceRgba2Hex: replaceRgba2Hex
  };

  var debug = {
    flag: false
  };

  var ca = {
    alpha: true,
    antialias: true,
    premultipliedAlpha: true,
    preserveDrawingBuffer: true // depth: true,
    // stencil: true,

  };

  var calPoint$1 = mx.calPoint;
  /**
   * 初始化 shader
   * @param gl GL context
   * @param vshader vertex shader (string)
   * @param fshader fragment shader (string)
   * @return program, if the program object was created and successfully made current
   */

  function initShaders(gl, vshader, fshader) {
    var program = createProgram(gl, vshader, fshader);

    if (!program) {
      throw new Error('Failed to create program');
    } // 要开启透明度，用以绘制透明的图形


    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    return program;
  }
  /**
   * Create the linked program object
   * @param gl GL context
   * @param vshader a vertex shader program (string)
   * @param fshader a fragment shader program (string)
   * @return created program object, or null if the creation has failed
   */


  function createProgram(gl, vshader, fshader) {
    // Create shader object
    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

    if (!vertexShader || !fragmentShader) {
      return null;
    } // Create a program object


    var program = gl.createProgram();

    if (!program) {
      return null;
    }

    program.vertexShader = vertexShader;
    program.fragmentShader = fragmentShader; // Attach the shader objects

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader); // Link the program object

    gl.linkProgram(program); // Check the result of linking

    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (!linked) {
      var error = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      gl.deleteShader(fragmentShader);
      gl.deleteShader(vertexShader);
      throw new Error('Failed to link program: ' + error);
    }

    return program;
  }
  /**
   * Create a shader object
   * @param gl GL context
   * @param type the type of the shader object to be created
   * @param source shader program (string)
   * @return created shader object, or null if the creation has failed.
   */


  function loadShader(gl, type, source) {
    // Create shader object
    var shader = gl.createShader(type);

    if (shader == null) {
      throw new Error('unable to create shader');
    } // Set the shader program


    gl.shaderSource(shader, source); // Compile the shader

    gl.compileShader(shader); // Check the result of compilation

    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (!compiled) {
      var error = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error('Failed to compile shader: ' + error);
    }

    return shader;
  }

  function convertCoords2Gl(_ref, cx, cy, revertY) {
    var _ref2 = _slicedToArray(_ref, 4),
        x = _ref2[0],
        y = _ref2[1],
        z = _ref2[2],
        w = _ref2[3];

    if (z === undefined) {
      z = 0;
    }

    if (w === undefined) {
      w = 1;
    }

    if (w && w !== 1) {
      x /= w;
      y /= w;
      z /= w;
    }

    if (x === cx) {
      x = 0;
    } else {
      x = (x - cx) / cx;
    }

    if (y === cy) {
      y = 0;
    } else {
      y = (y - cy) / cy;

      if (revertY) {
        y = -y;
      }
    }

    return [x * w, y * w, z * w, w];
  }

  function createTexture(gl, tex, n, width, height) {
    var texture = gl.createTexture();
    bindTexture(gl, texture, n); // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, -1);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); // 传入高宽时是绑定fbo，且tex一定为null

    if (width && height) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    } // 普通将canvas对象作为纹理
    else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
  }

  function bindTexture(gl, texture, n) {
    gl.activeTexture(gl['TEXTURE' + n]);
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }
  /**
   * texCache集满纹理上传占用最多可用纹理单元后，进行批量顺序绘制
   * 将所有dom的矩形顶点（经过transform变换后的）、贴图坐标、透明度存入3个buffer中，
   * 然后相同纹理单元的形成一批，设置uniform的纹理单元号进行绘制，如此循环
   * @param gl
   * @param list
   * @param hash
   * @param cx
   * @param cy
   * @param revertY
   */


  function drawTextureCache(gl, list, hash, cx, cy, revertY) {
    var vtPoint = [],
        vtTex = [],
        vtOpacity = [];
    var lastChannel; // 上一个dom的单元号

    var record = [0]; // [num, channel]每一批的数量和单元号记录

    var stack = [record]; // 所有批的数据记录集合

    list.forEach(function (item, i) {
      var _item = _slicedToArray(item, 5),
          cache = _item[0],
          opacity = _item[1],
          matrix = _item[2],
          dx = _item[3],
          dy = _item[4];

      if (i) {
        var channel = hash[cache.page.uuid]; // 和上一个单元号不同时，生成新的批次记录

        if (lastChannel !== channel) {
          lastChannel = channel;
          record = [0, lastChannel];
          stack.push(record);
        }
      } else {
        lastChannel = hash[cache.page.uuid];
        record[1] = lastChannel;
      }

      var x = cache.x,
          y = cache.y,
          width = cache.width,
          height = cache.height,
          page = cache.page,
          bbox = cache.bbox; // 计算顶点坐标和纹理坐标，转换[0,1]对应关系

      var bx = bbox[0],
          by = bbox[1];
      var xa = bx + (dx || 0),
          ya = by + height + (dy || 0);
      var xb = bx + width + (dx || 0),
          yb = by + (dy || 0);

      var _calPoint = calPoint$1([xa, ya], matrix),
          _calPoint2 = _slicedToArray(_calPoint, 4),
          x1 = _calPoint2[0],
          y1 = _calPoint2[1],
          w1 = _calPoint2[3];

      var _calPoint3 = calPoint$1([xb, ya], matrix),
          _calPoint4 = _slicedToArray(_calPoint3, 4),
          x2 = _calPoint4[0],
          y2 = _calPoint4[1],
          w2 = _calPoint4[3];

      var _calPoint5 = calPoint$1([xb, yb], matrix),
          _calPoint6 = _slicedToArray(_calPoint5, 4),
          x3 = _calPoint6[0],
          y3 = _calPoint6[1],
          w3 = _calPoint6[3];

      var _calPoint7 = calPoint$1([xa, yb], matrix),
          _calPoint8 = _slicedToArray(_calPoint7, 4),
          x4 = _calPoint8[0],
          y4 = _calPoint8[1],
          w4 = _calPoint8[3];

      var _convertCoords2Gl = convertCoords2Gl([x1, y1, 0, w1], cx, cy, revertY);

      var _convertCoords2Gl2 = _slicedToArray(_convertCoords2Gl, 2);

      x1 = _convertCoords2Gl2[0];
      y1 = _convertCoords2Gl2[1];

      var _convertCoords2Gl3 = convertCoords2Gl([x2, y2, 0, w2], cx, cy, revertY);

      var _convertCoords2Gl4 = _slicedToArray(_convertCoords2Gl3, 2);

      x2 = _convertCoords2Gl4[0];
      y2 = _convertCoords2Gl4[1];

      var _convertCoords2Gl5 = convertCoords2Gl([x3, y3, 0, w3], cx, cy, revertY);

      var _convertCoords2Gl6 = _slicedToArray(_convertCoords2Gl5, 2);

      x3 = _convertCoords2Gl6[0];
      y3 = _convertCoords2Gl6[1];

      var _convertCoords2Gl7 = convertCoords2Gl([x4, y4, 0, w4], cx, cy, revertY);

      var _convertCoords2Gl8 = _slicedToArray(_convertCoords2Gl7, 2);

      x4 = _convertCoords2Gl8[0];
      y4 = _convertCoords2Gl8[1];
      vtPoint.push(x1, y1, 0, w1, x4, y4, 0, w4, x2, y2, 0, w2, x4, y4, 0, w4, x2, y2, 0, w2, x3, y3, 0, w3);
      var tx1 = x / page.width,
          ty1 = (y + height) / page.height;
      var tx2 = (x + width) / page.width,
          ty2 = y / page.height;
      vtTex.push(tx1, ty1, tx1, ty2, tx2, ty1, tx1, ty2, tx2, ty1, tx2, ty2);
      vtOpacity.push(opacity, opacity, opacity, opacity, opacity, opacity);
      record[0]++;
    }); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtPoint), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    gl.vertexAttribPointer(a_position, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtTex), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtOpacity), gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
    var count = 0; // 循环按批次渲染

    stack.forEach(function (record) {
      var _record = _slicedToArray(record, 2),
          num = _record[0],
          channel = _record[1];

      gl.uniform1i(u_texture, channel);
      num *= 6;
      gl.drawArrays(gl.TRIANGLES, count, num);
      count += num;
    });
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.disableVertexAttribArray(a_opacity);
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核扩大3倍性能慢
   * x/y方向分开执行，加速性能，计算次数由d*d变为d+d，d为卷积核大小
   * spread由d和sigma计算得出，d由sigma计算得出，sigma即css的blur()参数
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * i和j为total和filter的纹理单元，3次执行（x/y合起来算1次）需互换单元，来回执行源和结果
   * 由total变为filter时cache会各方向上扩展spread的大小到width/height
   * 因此第一次绘制时坐标非1，后面则固定1
   * @param gl
   * @param program
   * @param frameBuffer
   * @param tex1 初次绘制目标纹理
   * @param tex2 初次绘制源纹理
   * @param i 初次绘制目标纹理单元
   * @param j 初次绘制源纹理单元
   * @param width
   * @param height
   * @param spread
   * @param widthNew
   * @param heightNew
   * @param cx
   * @param cy
   */


  function drawBlur(gl, program, frameBuffer, tex1, tex2, i, j, width, height, spread, widthNew, heightNew, cx, cy) {
    // 第一次将total绘制到blur上，此时尺寸存在spread差值，因此不加模糊防止坐标计算问题，仅作为扩展纹理尺寸
    var _convertCoords2Gl9 = convertCoords2Gl([spread, height + spread, 0, 1], cx, cy, false),
        _convertCoords2Gl10 = _slicedToArray(_convertCoords2Gl9, 2),
        x1 = _convertCoords2Gl10[0],
        y2 = _convertCoords2Gl10[1];

    var _convertCoords2Gl11 = convertCoords2Gl([width + spread, spread, 0, 1], cx, cy, false),
        _convertCoords2Gl12 = _slicedToArray(_convertCoords2Gl11, 2),
        x2 = _convertCoords2Gl12[0],
        y1 = _convertCoords2Gl12[1]; // 顶点buffer


    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // direction全0，即无模糊，此时只是进行扩展尺寸操作，还没到模糊所以传0

    var u_direction = gl.getUniformLocation(program, 'u_direction');
    gl.uniform2f(u_direction, 0, 0); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, j);
    gl.drawArrays(gl.TRIANGLES, 0, 6); // fbo绑定切换纹理对象和单元索引，同时注意不能向源纹理绘制，因为源是cacheTotal，需要重新生成一个，y方向再来一次

    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    /**
     * 反复执行共3次，坐标等均不变，只是切换fbo绑定对象和纹理单元
     * 注意max和ratio的设置，当是100尺寸的正方形时，传给direction的始终为1
     * 当正方形<100时，direction相应地要扩大相对于100的倍数，反之则缩小，如此为了取相邻点坐标时是+-1
     * 当非正方形时，长轴一端为基准值不变，短的要二次扩大比例倍数
     */

    var max = 100 / Math.max(widthNew, heightNew);
    var ratio = widthNew / heightNew;
    var recycle = []; // 3次过程中新生成的中间纹理需要回收

    for (var k = 0; k < 3; k++) {
      var tex3 = createTexture(gl, null, j, widthNew, heightNew);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex3, 0);

      if (widthNew >= heightNew) {
        gl.uniform2f(u_direction, max, 0);
      } else {
        gl.uniform2f(u_direction, max * ratio, 0);
      }

      gl.uniform1i(u_texture, i);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      recycle.push(tex1);
      var tex4 = createTexture(gl, null, i, widthNew, heightNew);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex4, 0);

      if (widthNew >= heightNew) {
        gl.uniform2f(u_direction, 0, max * ratio);
      } else {
        gl.uniform2f(u_direction, 0, max);
      }

      gl.uniform1i(u_texture, j);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      tex1 = tex4;
      recycle.push(tex3);
    } // 回收


    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    recycle.forEach(function (item) {
      return gl.deleteTexture(item);
    });
    return tex1;
  }

  function drawCm(gl, program, i, m) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, i); // matrix

    var u_m = gl.getUniformLocation(program, 'u_m');
    gl.uniform1fv(u_m, new Float32Array(m));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }
  /**
   * 根据total/filter生成overflow
   * @param gl
   * @param i 输入纹理单元
   * @param dx 二者偏移值
   * @param dy
   * @param width 最终大小
   * @param height
   * @param w 输入纹理大小
   * @param h
   */


  function drawOverflow(gl, i, dx, dy, width, height, w, h) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.programOverflow, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer，原本大小width/height，使用其中的w/h

    var x1 = dx / w,
        y1 = dy / h,
        x2 = (width + dx) / w,
        y2 = (height + dy) / h;
    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.programOverflow, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.programOverflow, 'u_texture');
    gl.uniform1i(u_texture, i);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
  }

  function drawMask(gl, i, j, program) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, j);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, i);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawMbm(gl, program, i, j, W, H) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, i);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, j);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawDropShadow(gl, program, frameBuffer, tex1, tex2, i, j, width, height, color) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, j); // color

    var u_color = gl.getUniformLocation(program, 'u_color');
    gl.uniform1fv(u_color, new Float32Array([color[0] / 255, color[1] / 255, color[2] / 255, color[3]]));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    return tex1;
  }

  var webgl = {
    initShaders: initShaders,
    createTexture: createTexture,
    bindTexture: bindTexture,
    drawTextureCache: drawTextureCache,
    drawBlur: drawBlur,
    drawOverflow: drawOverflow,
    drawMask: drawMask,
    drawMbm: drawMbm,
    drawCm: drawCm,
    drawDropShadow: drawDropShadow
  };

  var SPF = 1000 / 60;
  var CANVAS = {};
  var WEBGL = {};
  var CANVAS_LIST = [];
  var WEBGL_LIST = [];
  var SUPPORT_OFFSCREEN_CANVAS = typeof OffscreenCanvas === 'function' && util.isFunction(OffscreenCanvas.prototype.getContext);
  var defaultFontFamilyData;

  function cache(key, width, height, hash, message) {
    var o;

    if (!key) {
      var target = hash === CANVAS ? CANVAS_LIST : WEBGL_LIST;

      if (target.length) {
        o = target.pop();
      } else {
        o = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
      }
    } else if (!hash[key]) {
      o = hash[key] = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
    } else {
      o = hash[key];
    }

    o.width = width;
    o.height = height;

    if (debug.flag) {
      o.style.width = width + 'px';
      o.style.height = height + 'px';
      o.setAttribute('type', hash === CANVAS ? 'canvas' : 'webgl');

      if (key) {
        o.setAttribute('key', key);
      }

      if (message) {
        o.setAttribute('message', message);
      }

      document.body.appendChild(o);
    }

    var ctx;

    if (hash === CANVAS) {
      ctx = o.getContext('2d');
    } else {
      ctx = o.getContext('webgl', ca) || o.getContext('experimental-webgl', ca);
    }

    return {
      canvas: o,
      ctx: ctx,
      draw: function draw() {// 空函数，仅对小程序提供hook特殊处理，flush缓冲
      },
      enabled: true,
      available: true,
      release: function release() {
        if (!key && this.available) {
          if (hash === CANVAS) {
            CANVAS_LIST.push(this.canvas);
          } else {
            WEBGL_LIST.push(this.canvas);
          }
        }

        this.available = false;
      }
    };
  }

  function cacheCanvas(key, width, height, message) {
    return cache(key, width, height, CANVAS, message);
  }

  function cacheWebgl(key, width, height, message) {
    return cache(key, width, height, WEBGL, message);
  }

  var IMG = {};
  var INIT = 0;
  var LOADING = 1;
  var LOADED = 2;
  var FONT = {};
  var COMPONENT = {};
  var div;

  function createDiv() {
    div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '99999px';
    div.style.top = '-99999px';
    div.style.visibility = 'hidden';
    div.style.whiteSpace = 'nowrap';
    document.body.appendChild(div);
  }

  var inject = {
    measureTextSync: function measureTextSync(str, ff, fs, fw, isUpright) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;

      if (isUpright) {
        div.style.writingMode = 'vertical-lr';
      } else {
        div.style.writingMode = 'horizontal-tb';
      }

      div.innerHTML = str.replace(/</g, '&lt;').replace(/[ \n]/g, '&nbsp;');

      if (isUpright) {
        return parseFloat(window.getComputedStyle(div, null).height);
      } else {
        return parseFloat(window.getComputedStyle(div, null).width);
      }
    },
    measureTextListMax: function measureTextListMax(str, ff, fs, fw) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;
      var s = '';

      for (var i = 0, len = str.length; i < len; i++) {
        s += '<span style="position:absolute">' + str.charAt(i).replace('<', '&lt;').replace(/[ \n]/, '&nbsp;') + '</span>';
      }

      div.innerHTML = s;
      var max = 0;
      var cns = div.childNodes;

      for (var _i = 0, _len = cns.length; _i < _len; _i++) {
        var node = cns[_i]; // clientWidth只返回ceil整数，精度必须用getComputedStyle

        max = Math.max(max, parseFloat(window.getComputedStyle(node, null).width));
      }

      return max;
    },
    IMG: IMG,
    INIT: INIT,
    LOADED: LOADED,
    LOADING: LOADING,
    measureImg: function measureImg(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.measureImg(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Measure img invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = IMG[url] = IMG[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);
        var img = new Image();

        img.onload = function () {
          cache.state = LOADED;
          cache.success = true;
          cache.width = img.width;
          cache.height = img.height;
          cache.source = img;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        };

        img.onerror = function (e) {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        };

        if (url.substr(0, 5) !== 'data:') {
          var host = /^(?:\w+:)?\/\/([^/:]+)/.exec(url);

          if (host) {
            if (typeof location === 'undefined' || location.hostname !== host[1]) {
              img.crossOrigin = 'anonymous';
            }
          }
        }

        img.src = url;

        if (debug.flag && typeof document !== 'undefined') {
          document.body.appendChild(img);
        }
      }
    },
    warn: function warn(s) {
      console.warn(s);
    },
    error: function error(s) {
      console.error(s);
    },
    requestAnimationFrame: function (_requestAnimationFrame) {
      function requestAnimationFrame(_x) {
        return _requestAnimationFrame.apply(this, arguments);
      }

      requestAnimationFrame.toString = function () {
        return _requestAnimationFrame.toString();
      };

      return requestAnimationFrame;
    }(function (cb) {
      if (!cb) {
        return;
      }

      var res;

      if (typeof requestAnimationFrame !== 'undefined') {
        inject.requestAnimationFrame = requestAnimationFrame.bind(window);
        res = requestAnimationFrame(cb);
      } else {
        res = setTimeout(cb, SPF);

        inject.requestAnimationFrame = function (cb) {
          return setTimeout(cb, SPF);
        };
      }

      return res;
    }),
    cancelAnimationFrame: function (_cancelAnimationFrame) {
      function cancelAnimationFrame(_x2) {
        return _cancelAnimationFrame.apply(this, arguments);
      }

      cancelAnimationFrame.toString = function () {
        return _cancelAnimationFrame.toString();
      };

      return cancelAnimationFrame;
    }(function (id) {
      var res;

      if (typeof cancelAnimationFrame !== 'undefined') {
        inject.cancelAnimationFrame = cancelAnimationFrame.bind(window);
        res = cancelAnimationFrame(id);
      } else {
        res = clearTimeout(id);

        inject.cancelAnimationFrame = function (id) {
          return clearTimeout(id);
        };
      }

      return res;
    }),
    now: function now() {
      if (typeof performance !== 'undefined') {
        inject.now = function () {
          return Math.floor(performance.now());
        };

        return Math.floor(performance.now());
      }

      inject.now = Date.now.bind(Date);
      return Date.now();
    },
    hasCacheCanvas: function hasCacheCanvas(key) {
      return key && CANVAS.hasOwnProperty(key);
    },
    getCacheCanvas: function getCacheCanvas(width, height, key, message) {
      return cacheCanvas(key, width, height, message);
    },
    releaseCacheCanvas: function releaseCacheCanvas(o) {
      CANVAS_LIST.push(o);
    },
    delCacheCanvas: function delCacheCanvas(key) {
      key && delete CANVAS[key];
    },
    hasCacheWebgl: function hasCacheWebgl(key) {
      return key && WEBGL.hasOwnProperty(key);
    },
    getCacheWebgl: function getCacheWebgl(width, height, key, message) {
      return cacheWebgl(key, width, height, message);
    },
    releaseCacheWebgl: function releaseCacheWebgl(o) {
      WEBGL_LIST.push(o);
    },
    delCacheWebgl: function delCacheWebgl(key) {
      key && delete WEBGL[key];
    },
    isDom: function isDom(o) {
      if (o) {
        if (util.isString(o)) {
          return true;
        }

        if (typeof window !== 'undefined' && window.Element && o instanceof window.Element) {
          return true;
        }

        if (typeof window !== 'undefined' && window.OffscreenCanvas && o instanceof window.OffscreenCanvas) {
          return true;
        } // worker


        if (typeof self !== 'undefined' && self.OffscreenCanvas && o instanceof self.OffscreenCanvas) {
          return true;
        }

        if (util.isFunction(o.getElementsByTagName)) {
          return true;
        }
      }

      return false;
    },
    isWebGLTexture: function isWebGLTexture(o) {
      if (o && typeof WebGLTexture !== 'undefined') {
        return o instanceof WebGLTexture;
      }
    },
    defaultFontFamily: 'arial',
    getFontCanvas: function getFontCanvas() {
      return inject.getCacheCanvas(16, 16, '__$$CHECK_SUPPORT_FONT_FAMILY$$__');
    },
    checkSupportFontFamily: function checkSupportFontFamily(ff) {
      ff = ff.toLowerCase(); // 强制arial兜底

      if (ff === this.defaultFontFamily || ff === 'serif' || ff === 'sans-serif' || ff === 'sansserif') {
        return true;
      }

      if (!o$1.info.hasOwnProperty(ff)) {
        return false;
      }

      if (o$1.info[ff].hasOwnProperty('checked')) {
        return o$1.info[ff].checked;
      }

      var canvas = inject.getFontCanvas();
      var context = canvas.ctx;
      context.textAlign = 'center';
      context.fillStyle = '#000';
      context.textBaseline = 'middle';

      if (!defaultFontFamilyData) {
        context.clearRect(0, 0, 16, 16);
        context.font = '16px ' + this.defaultFontFamily;
        context.fillText('a', 8, 8);
        canvas.draw();
        defaultFontFamilyData = context.getImageData(0, 0, 16, 16).data;
      }

      context.clearRect(0, 0, 16, 16);
      context.font = '16px ' + ff;
      context.fillText('a', 8, 8);
      canvas.draw();
      var data = context.getImageData(0, 0, 16, 16).data;

      for (var i = 0, len = data.length; i < len; i++) {
        if (defaultFontFamilyData[i] !== data[i]) {
          return o$1.info[ff].checked = true;
        }
      }

      return o$1.info[ff].checked = false;
    },
    loadFont: function loadFont(fontFamily, url, cb) {
      if (util.isFunction(url)) {
        cb = url;
        url = fontFamily;
      }

      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadFont(item.fontFamily, item.url, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load font invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      if (!fontFamily) {
        fontFamily = url;
      }

      var cache = FONT[url] = FONT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);

        if (!/url\(/.test(url)) {
          url = "url(".concat(url, ")");
        }

        var f = new FontFace(fontFamily, url);
        f.load().then(function () {
          document.fonts.add(f);
          cache.state = LOADED;
          cache.success = true;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        })["catch"](function () {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        });
      }
    },
    loadComponent: function loadComponent(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadComponent(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load component invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = COMPONENT[url] = COMPONENT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);
        var script = document.createElement('script');
        script.src = url;
        script.async = true;

        script.onload = function () {
          cache.state = LOADED;
          cache.success = true;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
          document.head.removeChild(script);
        };

        script.onerror = function () {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
          document.head.removeChild(script);
        };

        document.head.appendChild(script);
      }
    }
  };

  var DOM = {
    position: 'static',
    display: 'block',
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto',
    marginTop: 0,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    fontSize: 'inherit',
    fontFamily: 'inherit',
    color: 'inherit',
    fontStyle: 'inherit',
    fontWeight: 'inherit',
    lineHeight: 'inherit',
    backgroundImage: null,
    backgroundColor: 'transparent',
    backgroundSize: 'auto',
    backgroundRepeat: 'repeat',
    backgroundPositionX: 0,
    backgroundPositionY: 0,
    backgroundClip: 'borderBox',
    borderTopWidth: 0,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    borderLeftWidth: 0,
    borderTopColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderTopStyle: 'none',
    borderRightStyle: 'none',
    borderBottomStyle: 'none',
    borderLeftStyle: 'none',
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0,
    width: 'auto',
    height: 'auto',
    flexGrow: 0,
    flexShrink: 1,
    flexBasis: 'auto',
    flexDirection: 'row',
    flexWrap: 'nowrap',
    order: 0,
    justifyContent: 'flexStart',
    alignItems: 'stretch',
    alignSelf: 'auto',
    alignContent: 'stretch',
    textAlign: 'inherit',
    letterSpacing: 'inherit',
    transformOrigin: 'center',
    visibility: 'inherit',
    opacity: 1,
    zIndex: 0,
    transform: null,
    translateX: 0,
    translateY: 0,
    translateZ: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    skewX: 0,
    skewY: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    rotate3d: '0, 0, 0, 0',
    perspective: 0,
    perspectiveOrigin: 'center',
    filter: null,
    boxShadow: null,
    pointerEvents: 'inherit',
    overflow: 'visible',
    mixBlendMode: 'normal',
    whiteSpace: 'inherit',
    textOverflow: 'clip',
    lineClamp: 0,
    textStrokeWidth: 'inherit',
    textStrokeColor: 'inherit',
    textStrokeOver: 'inherit',
    writingMode: 'inherit'
  };
  var GEOM = {
    fill: 'transparent',
    stroke: '#000',
    strokeWidth: 1,
    strokeDasharray: '',
    strokeLinecap: 'butt',
    strokeLinejoin: 'miter',
    strokeMiterlimit: 4,
    fillRule: 'nonzero'
  };
  var DOM_ENTRY_SET = [];
  var DOM_KEY_SET = [];
  Object.keys(DOM).forEach(function (k) {
    DOM_KEY_SET.push(k);
    var v = DOM[k];
    DOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var GEOM_ENTRY_SET = [];
  var GEOM_KEY_SET = [];
  Object.keys(GEOM).forEach(function (k) {
    GEOM_KEY_SET.push(k);
    var v = GEOM[k];
    GEOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var INHERIT = {
    get fontFamily() {
      return inject.defaultFontFamily;
    },

    fontSize: 16,
    fontWeight: 400,
    fontStyle: 'normal',
    color: '#000',
    textAlign: 'left',
    visibility: 'visible',
    pointerEvents: 'auto',
    textStrokeColor: '#000',
    textStrokeWidth: 1,
    textStrokeOver: 'none',
    writingMode: 'horizontalTb'
  };
  var INHERIT_KEY_SET = [];
  Object.keys(INHERIT).forEach(function (k) {
    INHERIT_KEY_SET.push(k);
  }); // 默认值放第一个

  var VALID_STRING_VALUE = {
    position: ['static', 'relative', 'absolute'],
    display: ['block', 'inlineBlock', 'inline', 'flex', 'none'],
    flexDirection: ['row', 'column', 'rowReverse', 'columnReverse'],
    flexWrap: ['wrap', 'wrapReverse', 'nowrap'],
    justifyContent: ['flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround', 'spaceEvenly'],
    alignItems: ['stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    alignSelf: ['auto', 'stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    overflow: ['visible', 'hidden'],
    mixBlendMode: ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'colorDodge', 'colorBurn', 'hardLight', 'softLight', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
    borderTopStyle: ['solid', 'dashed', 'dotted'],
    borderRightStyle: ['solid', 'dashed', 'dotted'],
    borderBottomStyle: ['solid', 'dashed', 'dotted'],
    borderLeftStyle: ['solid', 'dashed', 'dotted'],
    backgroundClip: ['borderBox', 'paddingBox', 'contentBox'],
    textOverflow: ['clip', 'ellipsis'],
    alignContent: ['stretch', 'flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround']
  };
  var reset = {
    DOM: DOM,
    GEOM: GEOM,
    isValid: function isValid(i) {
      return DOM.hasOwnProperty(i) || GEOM.hasOwnProperty(i);
    },
    DOM_KEY_SET: DOM_KEY_SET,
    GEOM_KEY_SET: GEOM_KEY_SET,
    DOM_ENTRY_SET: DOM_ENTRY_SET,
    GEOM_ENTRY_SET: GEOM_ENTRY_SET,
    INHERIT: INHERIT,
    INHERIT_KEY_SET: INHERIT_KEY_SET,
    VALID_STRING_VALUE: VALID_STRING_VALUE
  };

  var reg = {
    position: /(([-+]?[\d.]+[pxremvwhina%]*)|(left|top|right|bottom|center)){1,2}/ig,
    gradient: /\b(\w+)-?gradient\((.+)\)/i,
    img: /(?:\burl\((['"]?)(.*?)\1\))|(?:\b((data:)))/i
  };

  // 向量点乘积
  function dotProduct(x1, y1, x2, y2) {
    return x1 * x2 + y1 * y2;
  } // 向量叉乘积


  function crossProduct(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }

  var vector = {
    dotProduct: dotProduct,
    crossProduct: crossProduct
  };

  var H = 4 * (Math.sqrt(2) - 1) / 3;
  var crossProduct$1 = vector.crossProduct;
  var calPoint$2 = mx.calPoint,
      isE$1 = mx.isE;
  var _enums$STYLE_KEY = enums.STYLE_KEY,
      WIDTH = _enums$STYLE_KEY.WIDTH,
      HEIGHT = _enums$STYLE_KEY.HEIGHT,
      TRANSFORM_ORIGIN = _enums$STYLE_KEY.TRANSFORM_ORIGIN;
  /**
   * 圆弧拟合公式，根据角度求得3阶贝塞尔控制点比例长度，一般<=90，超过拆分
   * @param deg
   * @returns {number}
   */

  function h(deg) {
    deg *= 0.5;
    return 4 * ((1 - Math.cos(deg)) / Math.sin(deg)) / 3;
  }
  /**
   * 判断点是否在多边形内
   * @param x 点坐标
   * @param y
   * @param vertexes 多边形顶点坐标
   * @returns {boolean}
   */


  function pointInPolygon(x, y, vertexes) {
    // 先取最大最小值得一个外围矩形，在外边可快速判断false
    var _vertexes$ = _slicedToArray(vertexes[0], 2),
        xmax = _vertexes$[0],
        ymax = _vertexes$[1];

    var _vertexes$2 = _slicedToArray(vertexes[0], 2),
        xmin = _vertexes$2[0],
        ymin = _vertexes$2[1];

    var len = vertexes.length;

    for (var i = 1; i < len; i++) {
      var _vertexes$i = _slicedToArray(vertexes[i], 2),
          _x = _vertexes$i[0],
          _y = _vertexes$i[1];

      xmax = Math.max(xmax, _x);
      ymax = Math.max(ymax, _y);
      xmin = Math.min(xmin, _x);
      ymin = Math.min(ymin, _y);
    }

    if (x < xmin || y < ymin || x > xmax || y > ymax) {
      return false;
    } // 所有向量积均为非负数说明在多边形内或边上


    for (var _i = 0, _len = vertexes.length; _i < _len; _i++) {
      var _vertexes$_i = _slicedToArray(vertexes[_i], 2),
          x1 = _vertexes$_i[0],
          y1 = _vertexes$_i[1];

      var _vertexes = _slicedToArray(vertexes[(_i + 1) % _len], 2),
          x2 = _vertexes[0],
          y2 = _vertexes[1];

      if (crossProduct$1(x2 - x1, y2 - y1, x - x1, y - y1) < 0) {
        return false;
      }
    }

    return true;
  } // 判断点是否在一个4边形内，比如事件发生是否在节点上


  function pointInQuadrilateral(x, y, x1, y1, x2, y2, x4, y4, x3, y3, matrix) {
    if (matrix && !isE$1(matrix)) {
      var w1, w2, w3, w4;

      var _calPoint = calPoint$2([x1, y1], matrix);

      var _calPoint2 = _slicedToArray(_calPoint, 4);

      x1 = _calPoint2[0];
      y1 = _calPoint2[1];
      w1 = _calPoint2[3];

      var _calPoint3 = calPoint$2([x2, y2], matrix);

      var _calPoint4 = _slicedToArray(_calPoint3, 4);

      x2 = _calPoint4[0];
      y2 = _calPoint4[1];
      w2 = _calPoint4[3];

      var _calPoint5 = calPoint$2([x3, y3], matrix);

      var _calPoint6 = _slicedToArray(_calPoint5, 4);

      x3 = _calPoint6[0];
      y3 = _calPoint6[1];
      w3 = _calPoint6[3];

      var _calPoint7 = calPoint$2([x4, y4], matrix);

      var _calPoint8 = _slicedToArray(_calPoint7, 4);

      x4 = _calPoint8[0];
      y4 = _calPoint8[1];
      w4 = _calPoint8[3];

      if (w1 && w1 !== 1) {
        x1 /= w1;
        y1 /= w1;
      }

      if (w2 && w2 !== 1) {
        x2 /= w2;
        y2 /= w2;
      }

      if (w3 && w3 !== 1) {
        x3 /= w3;
        y3 /= w3;
      }

      if (w4 && w4 !== 1) {
        x4 /= w4;
        y4 /= w4;
      }

      return pointInPolygon(x, y, [[x1, y1], [x2, y2], [x4, y4], [x3, y3]]);
    } else {
      return x >= x1 && y >= y1 && x <= x4 && y <= y4;
    }
  }
  /**
   * 余弦定理3边长求夹角
   * @param a
   * @param b
   * @param c
   */


  function angleBySide(a, b, c) {
    var theta = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
    return Math.acos(theta);
  }
  /**
   * 余弦定理2边长和夹角求3边
   * @param alpha 弧度
   * @param a
   * @param b
   */


  function sideByAngle(alpha, a, b) {
    var cos = Math.cos(alpha);
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * cos);
  }
  /**
   * 两点距离
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   */


  function pointsDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  /**
   * 三角形内心
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @param x3
   * @param y3
   */


  function triangleIncentre(x1, y1, x2, y2, x3, y3) {
    var a = pointsDistance(x2, y2, x3, y3);
    var b = pointsDistance(x1, y1, x3, y3);
    var c = pointsDistance(x1, y1, x2, y2);
    return [(a * x1 + b * x2 + c * x3) / (a + b + c), (a * y1 + b * y2 + c * y3) / (a + b + c)];
  }
  /**
   * 椭圆圆心和长短轴生成4个端点和控制点
   */


  function ellipsePoints(x, y, a) {
    var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a;
    var ox = a * H;
    var oy = b === a ? ox : b * H;
    return [[x - a, y], [x - a, y - oy, x - ox, y - b, x, y - b], [x + ox, y - b, x + a, y - oy, x + a, y], [x + a, y + oy, x + ox, y + b, x, y + b], [x - ox, y + b, x - a, y + oy, x - a, y]];
  }
  /**
   * 扇形圆心和半径起始角度生成4个端点和控制点
   * 分为4个象限进行拟合，0、1、2、3
   */


  function sectorPoints(x, y, r, begin, end) {
    if (begin > end) {
      var _ref = [end, begin];
      begin = _ref[0];
      end = _ref[1];
    }

    if (begin === end) {
      return [];
    }

    var list = [];
    var b = Math.floor(begin / 90);
    var e = Math.floor(end / 90); // 同象限直接算

    if (b === e || e - b === 1 && end % 90 === 0) {
      var h2 = h(d2r(Math.abs(begin - end)));
      var d = h2 * r;
      var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
      var alpha = Math.atan(d / r);

      if (b < 90) {
        // 第1个交点
        var rx = Math.sin(d2r(begin)) * r;
        var ry = Math.cos(d2r(begin)) * r;
        var p1 = [x + rx, y - ry]; // 第1个控制点

        var deg = alpha + d2r(begin);
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p2 = [x + rx, y - ry]; // 第2个交点

        rx = Math.sin(d2r(end)) * r;
        ry = Math.cos(d2r(end)) * r;
        var p4 = [x + rx, y - ry]; // 第2个控制点

        deg = d2r(end) - alpha;
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p3 = [x + rx, y - ry];
        list.push(p1);
        list.push(p2.concat(p3).concat(p4));
      } else if (b < 180) {
        // 第1个交点
        var _rx = Math.cos(d2r(begin - 90)) * r;

        var _ry = Math.sin(d2r(begin - 90)) * r;

        var _p = [x + _rx, y + _ry]; // 第1个控制点

        var _deg = alpha + d2r(begin - 90);

        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p2 = [x + _rx, y + _ry]; // 第2个交点

        _rx = Math.cos(d2r(end - 90)) * r;
        _ry = Math.sin(d2r(end - 90)) * r;
        var _p3 = [x + _rx, y + _ry]; // 第2个控制点

        _deg = d2r(end - 90) - alpha;
        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p4 = [x + _rx, y + _ry];
        list.push(_p);
        list.push(_p2.concat(_p4).concat(_p3));
      } else if (b < 270) {
        // 第1个交点
        var _rx2 = Math.sin(d2r(begin - 180)) * r;

        var _ry2 = Math.cos(d2r(begin - 180)) * r;

        var _p5 = [x - _rx2, y + _ry2]; // 第1个控制点

        var _deg2 = alpha + d2r(begin - 180);

        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p6 = [x - _rx2, y + _ry2]; // 第2个交点

        _rx2 = Math.sin(d2r(end - 180)) * r;
        _ry2 = Math.cos(d2r(end - 180)) * r;
        var _p7 = [x - _rx2, y + _ry2]; // 第2个控制点

        _deg2 = d2r(end - 180) - alpha;
        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p8 = [x - _rx2, y + _ry2];
        list.push(_p5);
        list.push(_p6.concat(_p8).concat(_p7));
      } else {
        // 第1个交点
        var _rx3 = Math.cos(d2r(begin - 270)) * r;

        var _ry3 = Math.sin(d2r(begin - 270)) * r;

        var _p9 = [x - _rx3, y + _ry3]; // 第1个控制点

        var _deg3 = alpha + d2r(begin - 270);

        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p10 = [x - _rx3, y + _ry3]; // 第2个交点

        _rx3 = Math.cos(d2r(end - 270)) * r;
        _ry3 = Math.sin(d2r(end - 270)) * r;
        var _p11 = [x - _rx3, y + _ry3]; // 第2个控制点

        _deg3 = d2r(end - 270) - alpha;
        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p12 = [x - _rx3, y + _ry3];
        list.push(_p9);
        list.push(_p10.concat(_p12).concat(_p11));
      }
    } // 跨象限循环算
    else {
      var i = b;
      var temp = [];

      for (; i <= e; i++) {
        if (i === 0) {
          var res = sectorPoints(x, y, r, begin, 90);
          temp.push(res);
        } else if (i === 1) {
          // 防止90~90这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 90) {
            var _res = sectorPoints(x, y, r, begin < 90 ? 90 : begin, end > 180 ? 180 : end);

            temp.push(_res);
          }
        } else if (i === 2) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 180) {
            var _res2 = sectorPoints(x, y, r, begin < 180 ? 180 : begin, end > 270 ? 270 : end);

            temp.push(_res2);
          }
        } else if (i === 3) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 270) {
            var _res3 = sectorPoints(x, y, r, begin < 270 ? 270 : begin, end);

            temp.push(_res3);
          }
        }
      } // 去掉重复的首尾扇弧点


      list = temp[0];

      for (var _i2 = 1, len = temp.length; _i2 < len; _i2++) {
        list.push(temp[_i2][1]);
      }
    }

    return list;
  }
  /**
   * 获取2个矩形重叠区域，如不重叠返回null
   * @param a
   * @param b
   */


  function getRectsIntersection(a, b) {
    if (!isRectsOverlap(a, b)) {
      return null;
    }

    var _a = _slicedToArray(a, 4),
        ax1 = _a[0],
        ay1 = _a[1],
        ax4 = _a[2],
        ay4 = _a[3];

    var _b = _slicedToArray(b, 4),
        bx1 = _b[0],
        by1 = _b[1],
        bx4 = _b[2],
        by4 = _b[3];

    return [Math.max(ax1, bx1), Math.max(ay1, by1), Math.min(ax4, bx4), Math.min(ay4, by4)];
  }
  /**
   * 2个矩形是否重叠
   * @param a
   * @param b
   */


  function isRectsOverlap(a, b) {
    var _a2 = _slicedToArray(a, 4),
        ax1 = _a2[0],
        ay1 = _a2[1],
        ax4 = _a2[2],
        ay4 = _a2[3];

    var _b2 = _slicedToArray(b, 4),
        bx1 = _b2[0],
        by1 = _b2[1],
        bx4 = _b2[2],
        by4 = _b2[3];

    if (ax1 >= bx4 || ay1 >= by4 || bx1 >= ax4 || by1 >= ay4) {
      return false;
    }

    return true;
  }
  /**
   * 2个矩形是否包含，a包含b
   * @param a
   * @param b
   */


  function isRectsInside(a, b) {
    var _a3 = _slicedToArray(a, 4),
        ax1 = _a3[0],
        ay1 = _a3[1],
        ax4 = _a3[2],
        ay4 = _a3[3];

    var _b3 = _slicedToArray(b, 4),
        bx1 = _b3[0],
        by1 = _b3[1],
        bx4 = _b3[2],
        by4 = _b3[3];

    if (ax1 <= bx1 && ay1 <= by1 && ax4 >= bx4 && ay4 >= by4) {
      return true;
    }

    return false;
  }

  function calCoordsInNode(px, py, node) {
    var _node$matrix = node.matrix,
        matrix = _node$matrix === void 0 ? [1, 0, 0, 1, 0, 0] : _node$matrix,
        _node$computedStyle = node.computedStyle,
        computedStyle = _node$computedStyle === void 0 ? {} : _node$computedStyle;
    var width = computedStyle[WIDTH],
        height = computedStyle[HEIGHT],
        _computedStyle$TRANSF = computedStyle[TRANSFORM_ORIGIN];
    _computedStyle$TRANSF = _computedStyle$TRANSF === void 0 ? [width * 0.5, height * 0.5] : _computedStyle$TRANSF;

    var _computedStyle$TRANSF2 = _slicedToArray(_computedStyle$TRANSF, 2),
        ox = _computedStyle$TRANSF2[0],
        oy = _computedStyle$TRANSF2[1];

    var _calPoint9 = calPoint$2([px * width - ox, py * height - oy], matrix);

    var _calPoint10 = _slicedToArray(_calPoint9, 2);

    px = _calPoint10[0];
    py = _calPoint10[1];
    return [px + ox, py + oy];
  }

  function calPercentInNode(x, y, node) {
    var _node$computedStyle2 = node.computedStyle,
        width = _node$computedStyle2[WIDTH],
        height = _node$computedStyle2[HEIGHT],
        _node$computedStyle2$ = _slicedToArray(_node$computedStyle2[TRANSFORM_ORIGIN], 2),
        ox = _node$computedStyle2$[0],
        oy = _node$computedStyle2$[1]; // 先求无旋转时右下角相对于原点的角度ds


    var ds = Math.atan((height - oy) / (width - ox));

    var _calCoordsInNode = calCoordsInNode(1, 1, node),
        _calCoordsInNode2 = _slicedToArray(_calCoordsInNode, 2),
        x1 = _calCoordsInNode2[0],
        y1 = _calCoordsInNode2[1];

    var d1;
    var deg; // 根据旋转后的坐标，分4个象限，求旋转后的右下角相对于原点的角度d1，得出偏移角度deg，分顺逆时针[-180, 180]

    if (x1 >= ox && y1 >= oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((y1 - oy) / (x1 - ox));
      }

      deg = d1 - ds;
    } else if (x1 >= ox && y1 < oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((oy - y1) / (x1 - ox));
      }

      deg = d1 + ds;
    } else if (x1 < ox && y1 >= oy) {
      d1 = Math.atan((y1 - oy) / (ox - x1));
      deg = d1 - ds;
    } else if (x1 < ox && y1 < oy) {
      d1 = Math.atan((y1 - oy) / (x1 - ox));

      if (ds >= d1) {
        deg = d1 + Math.PI - ds;
      } else {
        deg = Math.PI - d1 + ds;
        deg = -deg;
      }
    } else {
      deg = 0;
    } // 目标点到原点的边长不会变


    var dt = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2)); // 分4个象限，先求目标点到原点的角度d2，再偏移deg后求得原始坐标

    var d2;

    if (x >= ox && y >= oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = Math.atan((y - oy) / (x - ox));
      }
    } else if (x >= ox && y < oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = -Math.atan((y - oy) / (ox - x));
      }
    } else if (x < ox && y >= oy) {
      d2 = Math.PI - Math.atan((y - oy) / (ox - x));
    } else {
      d2 = Math.atan((y - oy) / (x - ox)) - Math.PI;
    }

    d2 -= deg;

    if (d2 > Math.PI) {
      d2 -= Math.PI;
      return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    if (d2 > Math.PI * 0.5) {
      d2 = Math.PI - d2;
      return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
    }

    if (d2 >= 0) {
      return [(ox + dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
    }

    if (d2 >= -Math.PI * 0.5) {
      d2 = -d2;
      return [(ox + dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    if (d2 >= -Math.PI) {
      d2 = Math.PI + d2;
      return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    d2 = -Math.PI - d2;
    return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
  }

  function d2r(n) {
    return n * Math.PI / 180;
  }

  function r2d(n) {
    return n * 180 / Math.PI;
  }
  /**
   * 二阶贝塞尔曲线范围框
   * @param x0
   * @param y0
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @returns {number[]}
   * https://www.iquilezles.org/www/articles/bezierbbox/bezierbbox.htm
   */


  function bboxBezier2(x0, y0, x1, y1, x2, y2) {
    var minX = Math.min(x0, x2);
    var minY = Math.min(y0, y2);
    var maxX = Math.max(x0, x2);
    var maxY = Math.max(y0, y2); // 控制点位于边界内部时，边界就是范围框，否则计算导数获取极值

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY) {
      var tx = (x0 - x1) / (x0 - 2 * x1 + x2);
      var ty = (y0 - y1) / (y0 - 2 * y1 + y2);
      var sx = 1 - tx;
      var sy = 1 - ty;
      var qx = sx * sx * x0 + 2 * sx * tx * x1 + tx * tx * x2;
      var qy = sy * sy * y0 + 2 * sy * ty * y1 + ty * ty * y2;
      minX = Math.min(minX, qx);
      minY = Math.min(minY, qy);
      maxX = Math.min(maxX, qx);
      maxY = Math.min(maxY, qy);
    }

    return [minX, minY, maxX, maxY];
  }
  /**
   * 同上三阶的
   */


  function bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3) {
    var minX = Math.min(x0, x3);
    var minY = Math.min(y0, y3);
    var maxX = Math.max(x0, x3);
    var maxY = Math.max(y0, y3);

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY || x2 < minX || y2 < minY || x2 > maxX || y2 > maxY) {
      var cx = -x0 + x1;
      var cy = -y0 + y1;
      var bx = x0 - 2 * x1 + x2;
      var by = y0 - 2 * y1 + y2;
      var ax = -x0 + 3 * x1 - 3 * x2 + x3;
      var ay = -y0 + 3 * y1 - 3 * y2 + y3;
      var hx = bx * bx - ax * cx;
      var hy = by * by - ay * cy;

      if (hx > 0) {
        hx = Math.sqrt(hx);
        var t = (-bx - hx) / ax;

        if (t > 0 && t < 1) {
          var s = 1 - t;
          var q = s * s * s * x0 + 3 * s * s * t * x1 + 3 * s * t * t * x2 + t * t * t * x3;
          minX = Math.min(minX, q);
          maxX = Math.max(maxX, q);
        }

        t = (-bx + hx) / ax;

        if (t > 0 && t < 1) {
          var _s = 1 - t;

          var _q = _s * _s * _s * x0 + 3 * _s * _s * t * x1 + 3 * _s * t * t * x2 + t * t * t * x3;

          minX = Math.min(minX, _q);
          maxX = Math.max(maxX, _q);
        }
      }

      if (hy > 0) {
        hy = Math.sqrt(hy);

        var _t = (-by - hy) / ay;

        if (_t > 0 && _t < 1) {
          var _s2 = 1 - _t;

          var _q2 = _s2 * _s2 * _s2 * y0 + 3 * _s2 * _s2 * _t * y1 + 3 * _s2 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q2);
          maxY = Math.max(maxY, _q2);
        }

        _t = (-by + hy) / ay;

        if (_t > 0 && _t < 1) {
          var _s3 = 1 - _t;

          var _q3 = _s3 * _s3 * _s3 * y0 + 3 * _s3 * _s3 * _t * y1 + 3 * _s3 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q3);
          maxY = Math.max(maxY, _q3);
        }
      }
    }

    return [minX, minY, maxX, maxY];
  }

  function bboxBezier(x0, y0, x1, y1, x2, y2, x3, y3) {
    if (arguments.length === 4) {
      return [x0, y0, x1, y1];
    }

    if (arguments.length === 6) {
      return bboxBezier2(x0, y0, x1, y1, x2, y2);
    }

    if (arguments.length === 8) {
      return bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3);
    }
  }
  /**
   * 范数 or 模
   */


  function norm(v) {
    var order = v.length;
    var sum = v.reduce(function (a, b) {
      return Math.pow(a, order) + Math.pow(b, order);
    });
    return Math.pow(sum, 1 / order);
  }

  function simpson38(derivativeFunc, l, r) {
    var f = derivativeFunc;
    var middleL = (2 * l + r) / 3;
    var middleR = (l + 2 * r) / 3;
    return (f(l) + 3 * f(middleL) + 3 * f(middleR) + f(r)) * (r - l) / 8;
  }
  /**
   * bezier 曲线的长度
   * @param derivativeFunc 微分函数
   * @param l 左点
   * @param r 右点
   * @param eps 精度
   * @return {*} number
   */


  function adaptiveSimpson38(derivativeFunc, l, r) {
    var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
    var f = derivativeFunc;
    var mid = (l + r) / 2;
    var st = simpson38(f, l, r);
    var sl = simpson38(f, l, mid);
    var sr = simpson38(f, mid, r);
    var ans = sl + sr - st;

    if (Math.abs(ans) <= 15 * eps) {
      return sl + sr + ans / 15;
    }

    return adaptiveSimpson38(f, l, mid, eps / 2) + adaptiveSimpson38(f, mid, r, eps / 2);
  }
  /**
   * bezier 曲线的长度
   * @param points 曲线的起止点 和 控制点
   * @param order 阶次， 2 和 3
   * @param startT 计算长度的起点，满足 0 <= startT <= endT <= 1
   * @param endT 计算长度的终点
   * @return {*} number
   */


  function bezierLength(points, order) {
    var startT = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var endT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points, order));
    };

    return adaptiveSimpson38(derivativeFunc, startT, endT);
  }
  /**
   * 3 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at3(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points = _slicedToArray(points, 4),
        p0 = _points[0],
        p1 = _points[1],
        p2 = _points[2],
        p3 = _points[3];

    var _p13 = _slicedToArray(p0, 2),
        x0 = _p13[0],
        y0 = _p13[1];

    var _p14 = _slicedToArray(p1, 2),
        x1 = _p14[0],
        y1 = _p14[1];

    var _p15 = _slicedToArray(p2, 2),
        x2 = _p15[0],
        y2 = _p15[1];

    var _p16 = _slicedToArray(p3, 2),
        x3 = _p16[0],
        y3 = _p16[1];

    var x = 0;
    var y = 0;

    if (order === 0) {
      x = Math.pow(1 - t, 3) * x0 + 3 * t * Math.pow(1 - t, 2) * x1 + 3 * (1 - t) * Math.pow(t, 2) * x2 + Math.pow(t, 3) * x3;
      y = Math.pow(1 - t, 3) * y0 + 3 * t * Math.pow(1 - t, 2) * y1 + 3 * (1 - t) * Math.pow(t, 2) * y2 + Math.pow(t, 3) * y3;
    } else if (order === 1) {
      x = 3 * ((1 - t) * (1 - t) * (x1 - x0) + 2 * (1 - t) * t * (x2 - x1) + t * t * (x3 - x2));
      y = 3 * ((1 - t) * (1 - t) * (y1 - y0) + 2 * (1 - t) * t * (y2 - y1) + t * t * (y3 - y2));
    } else if (order === 2) {
      x = 6 * (x2 - 2 * x1 + x0) * (1 - t) + 6 * (x3 - 2 * x2 + x1) * t;
      y = 6 * (y2 - 2 * y1 + y0) * (1 - t) + 6 * (y3 - 2 * y2 + y1) * t;
    } else if (order === 3) {
      x = 6 * (x3 - 3 * x2 + 3 * x1 - x0);
      y = 6 * (y3 - 3 * y2 + 3 * y1 - y0);
    } else {
      // 3阶导数就是常数了，大于3阶的都是0
      x = 0;
      y = 0;
    }

    return [x, y];
  }
  /**
   * 2 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at2(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points2 = _slicedToArray(points, 3),
        p0 = _points2[0],
        p1 = _points2[1],
        p2 = _points2[2];

    var _p17 = _slicedToArray(p0, 2),
        x0 = _p17[0],
        y0 = _p17[1];

    var _p18 = _slicedToArray(p1, 2),
        x1 = _p18[0],
        y1 = _p18[1];

    var _p19 = _slicedToArray(p2, 2),
        x2 = _p19[0],
        y2 = _p19[1];

    var x = 0;
    var y = 0;

    if (order === 0) {
      x = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
      y = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
    } else if (order === 1) {
      x = 2 * (1 - t) * (x1 - x0) + 2 * t * (x2 - x1);
      y = 2 * (1 - t) * (y1 - y0) + 2 * t * (y2 - y1);
    } else if (order === 2) {
      x = 2 * (x2 - 2 * x1 + x0);
      y = 2 * (y2 - 2 * y1 + y0);
    } else {
      x = 0;
      y = 0;
    }

    return [x, y];
  }

  function at(t, points, bezierOrder) {
    var derivativeOrder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    if (bezierOrder === 2) {
      return at2(t, points, derivativeOrder);
    } else if (bezierOrder === 3) {
      return at3(t, points, derivativeOrder);
    }
  }

  function pointAtBezier(points, order, percent, maxIteration, eps) {
    var length = bezierLength(points, order, 0, 1);
    return pointAtBezierWithLength(points, order, length, percent, maxIteration, eps);
  }

  function pointAtBezierWithLength(points, order, length) {
    var percent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    var maxIteration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;
    var eps = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.001;

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points, order));
    };

    var targetLen = length * percent;
    var approachLen = length;
    var approachT = percent;
    var preApproachT = approachT;

    for (var i = 0; i < maxIteration; i++) {
      approachLen = simpson38(derivativeFunc, 0, approachT);
      var d = approachLen - targetLen;

      if (Math.abs(d) < eps) {
        break;
      } // Newton 法


      var derivative1 = norm(at(approachT, points, order, 1)); // 1 阶导数

      var derivative2 = norm(at(approachT, points, order, 2)); // 2 阶导数

      var numerator = d * derivative1;
      var denominator = d * derivative2 + derivative1 * derivative1;
      approachT = approachT - numerator / denominator;

      if (Math.abs(approachT - preApproachT) < eps) {
        break;
      } else {
        preApproachT = approachT;
      }
    }

    return at(approachT, points, order, 0);
  }

  function sliceBezier(points, t) {
    var _points3 = _slicedToArray(points, 4),
        _points3$ = _slicedToArray(_points3[0], 2),
        x1 = _points3$[0],
        y1 = _points3$[1],
        _points3$2 = _slicedToArray(_points3[1], 2),
        x2 = _points3$2[0],
        y2 = _points3$2[1],
        _points3$3 = _slicedToArray(_points3[2], 2),
        x3 = _points3$3[0],
        y3 = _points3$3[1],
        p4 = _points3[3];

    var x12 = (x2 - x1) * t + x1;
    var y12 = (y2 - y1) * t + y1;
    var x23 = (x3 - x2) * t + x2;
    var y23 = (y3 - y2) * t + y2;
    var x123 = (x23 - x12) * t + x12;
    var y123 = (y23 - y12) * t + y12;

    if (points.length === 4) {
      var _p20 = _slicedToArray(p4, 2),
          x4 = _p20[0],
          y4 = _p20[1];

      var x34 = (x4 - x3) * t + x3;
      var y34 = (y4 - y3) * t + y3;
      var x234 = (x34 - x23) * t + x23;
      var y234 = (y34 - y23) * t + y23;
      var x1234 = (x234 - x123) * t + x123;
      var y1234 = (y234 - y123) * t + y123;
      return [[x1, y1], [x12, y12], [x123, y123], [x1234, y1234]];
    } else if (points.length === 3) {
      return [[x1, y1], [x12, y12], [x123, y123]];
    }
  }

  function sliceBezier2Both(points) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    start = Math.max(start, 0);
    end = Math.min(end, 1);

    if (start === 0 && end === 1) {
      return points;
    }

    if (end < 1) {
      points = sliceBezier(points, end);
    }

    if (start > 0) {
      if (end < 1) {
        start = start / end;
      }

      points = sliceBezier(points.reverse(), 1 - start).reverse();
    }

    return points;
  }

  function pointOnCircle(x, y, r, deg) {
    if (deg >= 270) {
      deg -= 270;
      deg = d2r(deg);
      return [x - Math.cos(deg) * r, y - Math.sin(deg) * r];
    } else if (deg >= 180) {
      deg -= 180;
      deg = d2r(deg);
      return [x - Math.sin(deg) * r, y + Math.cos(deg) * r];
    } else if (deg >= 90) {
      deg -= 90;
      deg = d2r(deg);
      return [x + Math.cos(deg) * r, y + Math.sin(deg) * r];
    } else {
      deg = d2r(deg);
      return [x + Math.sin(deg) * r, y - Math.cos(deg) * r];
    }
  }

  var geom = {
    pointInPolygon: pointInPolygon,
    pointInQuadrilateral: pointInQuadrilateral,
    d2r: d2r,
    r2d: r2d,
    // 贝塞尔曲线模拟1/4圆弧比例
    H: H,
    // <90任意角度贝塞尔曲线拟合圆弧的比例公式
    h: h,
    angleBySide: angleBySide,
    sideByAngle: sideByAngle,
    pointsDistance: pointsDistance,
    triangleIncentre: triangleIncentre,
    ellipsePoints: ellipsePoints,
    sectorPoints: sectorPoints,
    getRectsIntersection: getRectsIntersection,
    isRectsOverlap: isRectsOverlap,
    isRectsInside: isRectsInside,
    calCoordsInNode: calCoordsInNode,
    calPercentInNode: calPercentInNode,
    bboxBezier: bboxBezier,
    bezierLength: bezierLength,
    pointAtBezier: pointAtBezier,
    pointAtBezierWithLength: pointAtBezierWithLength,
    sliceBezier: sliceBezier,
    sliceBezier2Both: sliceBezier2Both,
    pointOnCircle: pointOnCircle
  };

  /**
   * @typedef {Object} gradientStatement
   * @property {Array<number>} color - 颜色rgba，0～255，如 [0, 255, 0, 255]
   * @property {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
   */

  /**
   * 获取渐变图像像素数组
   * @param {number} originX - 渐变中心x坐标（相对图片左上角(0,0)的值，可在图片外，下同）
   * @param {number} originY - 渐变中心y坐标
   * @param {number} width - 图片宽度
   * @param {number} height - 图片高度
   * @param {Array<stop>} stop - 渐变声明列表
   * @param data - canvas的imgData.data
   * @returns {Array<number>} 图像像素数组，每4个元素（rgba）构成一个像素点
   * @example
       // 矩形宽度为200*200，此时坐标为0～199，渐变中心为中点时，应传入99.5，可消除零点问题
       // 若渐变中心在某一整数轴上，就会引入零点问题，此时零点取y轴正半轴的色值，要消除这个问题，可以对渐变中心增加一个偏移量，使其不为整数
       let w = 200;
       let h = 200;
       let ctx = document.getElementById('example').getContext('2d');
       let imgData = ctx.getImageData(0,0, w, h);
       let data = getConicGradientImage(99.5, 99.5, w, h, [{
         color: [0,0,0,255],
         angle: 0,
       } ,{
         color: [255,0,0,255],
         angle: 2 * Math.PI,
       }]);
       for (let i = 0; i < imgData.data.length; i++) {
         imgData.data[i] = data[i];
       }
       ctx.putImageData(imgData, 0, 0);
   */
  function getConicGradientImage(originX, originY, width, height, stop, data) {
    if (stop.length < 2) {
      throw new Error('Conic gradient should recieve at least 2 gradient statements (start line and end line).');
    }

    width = Math.floor(width);
    height = Math.floor(height);
    /**
     * 根据坐标获取角度
     * @param {number} x - x坐标，左上角为原点
     * @param {number} y - y坐标，左上角为原点
     * @returns {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
     */

    var getAngle = function getAngle(x, y) {
      // 此函数注释内的x、y轴基于 (originX, originY)
      // 计算相对 (originX, originY) 的坐标(dx, dy)
      var dx = x - originX;
      var dy = originY - y; // 在y轴上

      if (dx === 0) {
        return dy < 0 ? // y轴负半轴，
        1 * Math.PI : // y轴正半轴，因此，(originX, originY) 的angle视作0
        0;
      } // 在x轴上


      if (dy === 0) {
        return dx < 0 ? // x轴负半轴
        1.5 * Math.PI : // x轴正半轴
        0.5 * Math.PI;
      }

      var atan = Math.atan(dy / dx);
      /**
       *  2   |  1
       * -----|-----
       *  3   |  4
       */
      // 第一象限，atan > 0
      // 第四象限，atan < 0

      if (dx > 0) {
        return 0.5 * Math.PI - atan;
      } // 第二象限，atan < 0
      // 第三象限，atan > 0


      if (dx < 0) {
        return 1.5 * Math.PI - atan;
      }
    };

    var increasingList = stop.map(function (item) {
      return {
        color: item[0],
        angle: item[1] * Math.PI * 2
      };
    });

    for (var y = 0; y < height; y++) {
      var _loop = function _loop(x) {
        // step 1. 找到当前点坐标相对 (originX, originY) 的角度
        var angle = getAngle(x, y); // step 2. 找到当前点坐标对应的渐变区间

        var j = void 0;

        for (j = 0; j < increasingList.length && increasingList[j].angle <= angle; j++) {}

        var start = increasingList[j - 1];
        var end = increasingList[j];

        if (!(start && end)) {
          // step 2-1. 不在渐变区间里
          return "continue";
        } // step 3. 计算色值并填充


        var factor = (angle - start.angle) / (end.angle - start.angle);
        var color = end.color.map(function (v, idx) {
          return factor * (v - start.color[idx]) + start.color[idx];
        });
        var i = (x + y * width) * 4;
        data[i] = color[0];
        data[i + 1] = color[1];
        data[i + 2] = color[2];
        data[i + 3] = Math.min(255, color[3] * 255);
      };

      for (var x = 0; x < width; x++) {
        var _ret = _loop(x);

        if (_ret === "continue") continue;
      }
    }

    return data;
  }

  var gradient = {
    getConicGradientImage: getConicGradientImage
  };

  var int2rgba$1 = util.int2rgba;

  function canvasPolygon(ctx, list) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (!list || !list.length) {
      return;
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return;
    }

    var first = list[start];
    ctx.moveTo(first[0] + dx, first[1] + dy); // 特殊的情况，布尔运算数学库会打乱原有顺序，致使第一个点可能有冗余的贝塞尔值，move到正确的索引坐标

    if (first.length === 4) {
      ctx.moveTo(first[2] + dx, first[3] + dy);
    } else if (first.length === 6) {
      ctx.moveTo(first[4] + dx, first[5] + dy);
    }

    for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
      var _item = list[_i];

      if (!Array.isArray(_item)) {
        continue;
      }

      if (_item.length === 2) {
        ctx.lineTo(_item[0] + dx, _item[1] + dy);
      } else if (_item.length === 4) {
        ctx.quadraticCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy);
      } else if (_item.length === 6) {
        ctx.bezierCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy, _item[4] + dx, _item[5] + dy);
      }
    }
  }

  function svgPolygon(list) {
    if (!list || !list.length) {
      return '';
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return '';
    }

    var first = list[start];
    var s = 'M' + first[0] + ',' + first[1];

    if (first.length === 4) {
      s = 'M' + first[2] + ',' + first[3];
    } else if (first.length === 6) {
      s = 'M' + first[4] + ',' + first[5];
    }

    for (var _i2 = start + 1, _len2 = list.length; _i2 < _len2; _i2++) {
      var _item2 = list[_i2];

      if (!Array.isArray(_item2)) {
        continue;
      }

      if (_item2.length === 2) {
        s += 'L' + _item2[0] + ',' + _item2[1];
      } else if (_item2.length === 4) {
        s += 'Q' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3];
      } else if (_item2.length === 6) {
        s += 'C' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3] + ' ' + _item2[4] + ',' + _item2[5];
      }
    }

    return s;
  }

  function canvasLine(ctx, x1, y1, x2, y2, controlA, controlB, num) {
    var dx = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var dy = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    ctx.moveTo(x1 + dx, y1 + dy);

    if (num === 3) {
      ctx.bezierCurveTo(controlA[0] + dx, controlA[1] + dy, controlB[0] + dx, controlB[1], x2 + dx, y2 + dy);
      return 2;
    } else if (num === 2) {
      ctx.quadraticCurveTo(controlB[0] + dx, controlB[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else if (num === 1) {
      ctx.quadraticCurveTo(controlA[0] + dx, controlA[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else {
      ctx.lineTo(x2 + dx, y2 + dy);
      return 1;
    }
  }

  function svgLine(x1, y1, x2, y2, controlA, controlB, num) {
    if (num === 3) {
      return 'M' + x1 + ',' + y1 + 'C' + controlA[0] + ',' + controlA[1] + ' ' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 2) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 1) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlA[0] + ',' + controlA[1] + ' ' + x2 + ',' + y2;
    } else {
      return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;
    }
  }

  function canvasFilter(filter) {
    var s = '';
    filter.forEach(function (item) {
      var _item3 = _slicedToArray(item, 2),
          k = _item3[0],
          v = _item3[1];

      if (k === 'blur') {
        s += "blur(".concat(v, "px)");
      } else if (k === 'dropShadow') {
        // 浏览器暂未支持spread，去掉v[3]
        s += "drop-shadow(".concat(v[0], "px ").concat(v[1], "px ").concat(v[2], "px ").concat(int2rgba$1(v[4]), ")");
      } else if (k === 'hueRotate') {
        s += "hue-rotate(".concat(v, "deg)");
      } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
        s += "".concat(k, "(").concat(v, "%)");
      }
    });
    return s;
  }

  var painter = {
    canvasPolygon: canvasPolygon,
    svgPolygon: svgPolygon,
    canvasLine: canvasLine,
    svgLine: svgLine,
    canvasFilter: canvasFilter,
    svgFilter: canvasFilter
  };

  var H$1 = geom.H;
  var PX = o.PX,
      PERCENT = o.PERCENT,
      REM = o.REM,
      VW = o.VW,
      VH = o.VH,
      VMAX = o.VMAX,
      VMIN = o.VMIN;
  var canvasPolygon$1 = painter.canvasPolygon,
      svgPolygon$1 = painter.svgPolygon;
  var _enums$STYLE_KEY$1 = enums.STYLE_KEY,
      BORDER_LEFT_WIDTH = _enums$STYLE_KEY$1.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH = _enums$STYLE_KEY$1.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH = _enums$STYLE_KEY$1.BORDER_BOTTOM_WIDTH,
      PADDING_LEFT = _enums$STYLE_KEY$1.PADDING_LEFT,
      PADDING_BOTTOM = _enums$STYLE_KEY$1.PADDING_BOTTOM,
      PADDING_TOP = _enums$STYLE_KEY$1.PADDING_TOP,
      BORDER_TOP_LEFT_RADIUS = _enums$STYLE_KEY$1.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS = _enums$STYLE_KEY$1.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS = _enums$STYLE_KEY$1.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS = _enums$STYLE_KEY$1.BORDER_BOTTOM_RIGHT_RADIUS,
      FONT_SIZE = _enums$STYLE_KEY$1.FONT_SIZE;
  /* 获取合适的虚线实体空白宽度ps/pd和数量n
   * 总长total，start边长bs，end边长be，内容长w，
   * 实体长范围[smin,smax]，空白长范围[dmin,dmax]
   */

  function calFitDashed(total, bs, be, w, smin, smax, dmin, dmax) {
    var n = 1;
    var ps = 1;
    var pd = 1; // 从最大实体空白长开始尝试

    outer: for (var i = smax; i >= smin; i--) {
      for (var j = dmax; j >= dmin; j--) {
        // 已知实体空白长度，n实体和n-1空白组成total，计算获取n数量
        var per = i + j;
        var num = Math.floor((total + j) / per);
        var k = j; // 可能除不尽，此时扩展空白长

        if (num * per < j + total) {
          var free = total - num * i;
          k = free / (num - 1);

          if (k > dmax) {
            continue;
          }
        }

        per = i + k; // bs比实体大才有效，因为小的话必定和第一个实体完整相连

        if (bs > 1 && bs > i) {
          var mo = bs % per;

          if (mo > i) {
            continue;
          }

          if (be > 1) {
            var _mo = (bs + w) % per;

            if (_mo > i) {
              continue;
            }
          }
        }

        if (be > 1) {
          var _mo2 = (bs + w) % per;

          if (_mo2 > i) {
            continue;
          }
        }

        if (num > 0) {
          n = num;
          ps = i;
          pd = k;
        }

        break outer;
      }
    }

    return {
      n: n,
      ps: ps,
      pd: pd
    };
  } // dashed时n个实线和n-1虚线默认以3:1宽度组成，dotted则是n和n以1:1组成


  function calDashed(style, m1, m2, m3, m4, bw) {
    var total = m4 - m1;
    var w = m3 - m2;
    var bs = m2 - m1;
    var be = m4 - m3;

    if (style === 'dotted') {
      return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
    } else {
      var _calFitDashed = calFitDashed(total, bs, be, w, bw, bw * 3, Math.max(1, bw * 0.25), bw * 2),
          n = _calFitDashed.n,
          ps = _calFitDashed.ps,
          pd = _calFitDashed.pd;

      if (n === 1) {
        return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
      } // 降级为dotted


      return {
        n: n,
        ps: ps,
        pd: pd
      };
    }
  } // 获取边框分割为几块的坐标，虚线分割为若干四边形、三边型、五边形
  // 三边形重复内外边交点形成四边形，五边形进行切割形成2个四边形
  // direction为上右下左0123


  function calPoints(borderWidth, borderStyle, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, direction, beginRadius, endRadius) {
    var points = [];

    if (borderStyle === 'none') {
      return points;
    }

    if (['dashed', 'dotted'].indexOf(borderStyle) > -1) {
      // 寻找一个合适的虚线线段长度和之间空白边距长度
      var _ref = direction === 0 || direction === 2 ? calDashed(borderStyle, x1, x2, x3, x4, borderWidth) : calDashed(borderStyle, y1, y2, y3, y4, borderWidth),
          n = _ref.n,
          ps = _ref.ps,
          pd = _ref.pd;

      if (n > 1) {
        for (var i = 0; i < n; i++) {
          // 最后一个可能没有到底，延长之
          var isLast = i === n - 1;
          var main1 = void 0;
          var main2 = void 0;
          var cross1 = void 0;
          var cross2 = void 0;

          if (direction === 0 || direction === 2) {
            main1 = i ? x1 + ps * i + pd * i : x1;
          } else {
            main1 = i ? y1 + ps * i + pd * i : y1;
          }

          main2 = main1 + ps;

          if (direction === 0) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y1], [x4, y1], [x3, y2], [x2, y2]]);
              } else {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                cross2 = y1 + (main2 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y1 + (x4 - main1) * Math.tan(deg2);
              cross2 = y1 + (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, y1], [x4, y1], [x4, y1], [main1, cross1]]);
              } else {
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross1]]);

                if (isLast) {
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                  points.push([[x3, y1], [x4, y1], [x4, y1], [x2, y2]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y1 + (x4 - main2) * Math.tan(deg2);
                    points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                    points.push([[x3, y1], [main2, y1], [main2, cross2], [x3, y2]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y1], [main2, y1], [main2, y2], [x2, y2]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y1 + (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y1 + (main1 - x1) * Math.tan(deg1);
                  points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross2]]);
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y1], [x3, y1], [x3, y2], [main1, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y1], [x4, y1], [x3, y2], [main1, y2]]);
                } else {
                  points.push([[main1, y1], [main2, y1], [main2, y2], [main1, y2]]);
                }
              }
            }
          } else if (direction === 1) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x3, y2], [x4, y1], [x4, y4], [x3, y3]]);
              } else {
                cross1 = x4 - (main1 - y1) * Math.tan(deg1);
                cross2 = x4 - (main2 - y1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x3 + (main1 - y3) * Math.tan(deg2);
              cross2 = x3 + (main2 - y3) * Math.tan(deg2);

              if (isLast) {
                points.push([[cross1, main1], [x4, main1], [x4, y4], [x4, y4]]);
              } else {
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x3 + (y2 - main1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, y2], [x3, y2]]);

                if (isLast) {
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                  points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x3 + (main2 - y3) * Math.tan(deg2);
                    points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross2, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x3, y2], [x4, y2], [x4, main2], [x3, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x3 + (main2 - y3) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x3 + (y2 - main1) * Math.tan(deg1);
                  points.push([[cross2, main1], [x4, main1], [x4, y2], [x3, y2]]);
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, x4], [x4, x4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x3, main1], [x4, main1], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x3, main1], [x4, main1], [x4, y4], [x3, y3]]);
                } else {
                  points.push([[x3, main1], [x4, main1], [x4, main2], [x3, main2]]);
                }
              }
            }
          } else if (direction === 2) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y4], [x2, y3], [x3, y3], [x4, y4]]);
              } else {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                cross2 = y4 - (main2 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y4 - (x4 - main1) * Math.tan(deg2);
              cross2 = y4 - (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, cross1], [x4, y4], [x4, y4], [main1, y4]]);
              } else {
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [x2, y3], [x2, y4], [main1, y4]]);

                if (isLast) {
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                  points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y4 - (main2 - x3) * Math.tan(deg2);
                    points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                    points.push([[x3, y3], [main2, cross2], [main2, y4], [x3, y4]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y3], [main2, y3], [main2, y4], [x2, y4]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y4 - (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y4 - (main1 - x3) * Math.tan(deg1);
                  points.push([[main1, cross2], [x2, y3], [x2, y4], [main1, y4]]);
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y3], [x3, y3], [x3, y4], [main1, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y3], [x3, y3], [x4, y4], [main1, y4]]);
                } else {
                  points.push([[main1, y3], [main2, y3], [main2, y4], [main1, y4]]);
                }
              }
            }
          } else if (direction === 3) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x1, y1], [x2, y2], [x2, y3], [x1, y4]]);
              } else {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                cross2 = x1 + (main2 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x1 + (y4 - main1) * Math.tan(deg2);
              cross2 = x1 + (y4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[x1, main1], [cross1, main1], [x1, y4], [x1, y4]]);
              } else {
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [x2, y2], [x1, y2]]);

                if (isLast) {
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                  points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x1 + (y4 - main2) * Math.tan(deg2);
                    points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                    points.push([[x1, y3], [x2, y3], [cross2, main2], [x1, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x1, y2], [x2, y2], [x2, main2], [x1, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x1 + (y4 - main2) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x1 + (main1 - y1) * Math.tan(deg1);
                  points.push([[x1, main1], [cross2, main1], [x2, y2], [x1, y1]]);
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y4]]);
                } else {
                  points.push([[x1, main1], [x2, main1], [x2, main2], [x1, main2]]);
                }
              }
            }
          }
        }

        if (direction === 0) {
          return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 1) {
          return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 2) {
          return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 3) {
          return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        }
      }
    } // 兜底返回实线


    if (direction === 0) {
      if (x2 > x1) {
        points.push([[x1, y1], [x2, y1], [x2, y2], [x1, y1]]);
      }

      points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

      if (x4 > x3) {
        points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
      }

      return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 1) {
      if (y2 > y1) {
        points.push([[x4, y1], [x4, y1], [x4, y2], [x3, y2]]);
      }

      points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

      if (y4 > y3) {
        points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
      }

      return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 2) {
      if (x2 > x1) {
        points.push([[x1, y4], [x2, y3], [x2, y4], [x1, y4]]);
      }

      points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

      if (x4 > x3) {
        points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
      }

      return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 3) {
      if (y2 > y1) {
        points.push([[x1, y1], [x1, y1], [x2, y2], [x1, y2]]);
      }

      points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

      if (y4 > y3) {
        points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
      }

      return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    }
  }

  function calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius = _slicedToArray(beginRadius, 2),
        brx = _beginRadius[0],
        bry = _beginRadius[1];

    var _endRadius = _slicedToArray(endRadius, 2),
        erx = _endRadius[0],
        ery = _endRadius[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[1][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[0][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[1][0] > oxr && points[0][0] < oxl) {
        var ya = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        beginList.push([points[0], [oxl, y1], [oxl, ya], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y1], [oxr, y1], [oxr, y2], [oxl, y2]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y1], [x3, y1], [x3, y2], [oxl, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [oxr, y1], [oxr, y2], [x2, y2]]);
          } else {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          }
        }

        endList.push([[oxr, y1], points[1], points[2], [oxr, yb]]);
      } // 跨越右圆角
      else if (points[1][0] > oxr) {
        var y = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        centerList.push([points[0], [oxr, y1], [oxr, y], points[3]]);
        endList.push([[oxr, y1], points[1], points[2], [oxr, y]]);
      } // 跨越左圆角
      else if (points[0][0] < oxl) {
        var _y = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;

        beginList.push([points[0], [oxl, y1], [oxl, _y], points[3]]);
        centerList.push([[oxl, y1], points[1], points[2], [oxl, _y]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y1 + bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya, xb, _yb;

      var ca = calBezierTopLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$ = _slicedToArray(ca[0], 2);

      xa = _ca$[0];
      _ya = _ca$[1];
      var cb;

      if (needInner) {
        cb = calBezierTopLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$ = _slicedToArray(cb[0], 2);

        xb = _cb$[0];
        _yb = _cb$[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierTopLeft(points[0], points[1], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierTopLeft(points[3], points[2], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i = 0, _len = controls1.length; _i < _len; _i++) {
          limit(controls1[_i], xa, _ya, 0);
        }

        points[0] = controls1[0];
        points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);

        if (needInner) {
          for (var _i2 = 0, _len2 = controls2.length; _i2 < _len2; _i2++) {
            limit(controls2[_i2], xb, _yb, 0);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg = Math.atan((x4 - x3) / (y2 - y1));

      var _rx = erx;
      var _ry = ery;

      var _sx = _ry / _rx;

      var oyr = y1 + ery;

      var _rx2 = erx - (x4 - x3);

      var _ry2 = ery - (y2 - y1);

      var _sx2 = _ry2 / _rx2; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa, _ya2, _xb, _yb2;

      var _ca = calBezierTopRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx, _ry, true, Math.tan(_crossDeg) * _ry);

      var _ca2 = _slicedToArray(_ca[_ca.length - 1], 2);

      _xa = _ca2[0];
      _ya2 = _ca2[1];

      var _cb;

      if (_needInner) {
        _cb = calBezierTopRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx2, _ry2, true, Math.tan(_crossDeg) * _ry2);

        var _cb2 = _slicedToArray(_cb[_cb.length - 1], 2);

        _xb = _cb2[0];
        _yb2 = _cb2[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca;

          if (_needInner) {
            controls2 = _cb;
          }
        } else {
          controls1 = calBezierTopRight(points[0], points[1], oxr, oyr, _sx, _ry);

          if (_needInner) {
            controls2 = calBezierTopRight(points[3], points[2], oxr, oyr, _sx2, _ry2);
          }
        }

        for (var _i3 = 0, _len3 = controls1.length; _i3 < _len3; _i3++) {
          limit(controls1[_i3], _xa, _ya2, 1);
        }

        points[0] = controls1[0];
        points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);

        if (_needInner) {
          for (var _i4 = 0, _len4 = controls2.length; _i4 < _len4; _i4++) {
            limit(controls2[_i4], _xb, _yb2, 1);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierTopLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p = _slicedToArray(p1, 2),
        p1x = _p[0],
        p1y = _p[1];

    var _p2 = _slicedToArray(p2, 2),
        p2x = _p2[0],
        p2y = _p2[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(p1x, p1y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(p2x, p2y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierTopRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p3 = _slicedToArray(p1, 2),
        p1x = _p3[0],
        p1y = _p3[1];

    var _p4 = _slicedToArray(p2, 2),
        p2x = _p4[0],
        p2y = _p4[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (oy - p1y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy - Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy - Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (oy - p2y));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy - Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius2 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius2[0],
        bry = _beginRadius2[1];

    var _endRadius2 = _slicedToArray(endRadius, 2),
        erx = _endRadius2[0],
        ery = _endRadius2[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[2][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[1][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[2][1] > oyb && points[1][1] < oyt) {
        var xa = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;
        var xb = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        beginList.push([points[0], points[1], [x4, oyt], [xa, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x3, oyt], [x4, oyt], [x4, oyb], [x3, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, oyb], [x3, oyb]]);
          } else {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          }
        }

        endList.push([[xb, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[2][1] > oyb) {
        var x = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        centerList.push([points[0], points[1], [x4, oyb], [x, oyb]]);
        endList.push([[x, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;

        beginList.push([points[0], points[1], [x4, oyt], [_x, oyt]]);
        centerList.push([[_x, oyt], [x4, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x4 - x3) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x4 - brx;
      var rx2 = brx - (x4 - x3);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa2, ya, _xb2, yb;

      var ca = calBezierRightTop(beginList[0][1], beginList[0][2], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca3 = _slicedToArray(ca[ca.length - 1], 2);

      _xa2 = _ca3[0];
      ya = _ca3[1];
      var cb;

      if (needInner) {
        cb = calBezierRightTop(beginList[0][0], beginList[0][3], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb3 = _slicedToArray(cb[cb.length - 1], 2);

        _xb2 = _cb3[0];
        yb = _cb3[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierRightTop(points[1], points[2], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierRightTop(points[0], points[3], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i5 = 0, _len5 = controls1.length; _i5 < _len5; _i5++) {
          limit(controls1[_i5], _xa2, ya, 2);
        }

        if (needInner) {
          for (var _i6 = 0, _len6 = controls2.length; _i6 < _len6; _i6++) {
            limit(controls2[_i6], _xb2, yb, 2);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner2 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg2 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx3 = erx;
      var _ry3 = ery;

      var _sx3 = _ry3 / _rx3;

      var oxb = x4 - erx;

      var _rx4 = erx - (x4 - x3);

      var _ry4 = ery - (y4 - y3);

      var _sx4 = _ry4 / _rx4; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa3, _ya3, _xb3, _yb3;

      var _ca4 = calBezierRightBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx3, _ry3, true, Math.tan(_crossDeg2) * _ry3);

      var _ca4$ = _slicedToArray(_ca4[0], 2);

      _xa3 = _ca4$[0];
      _ya3 = _ca4$[1];

      var _cb4;

      if (_needInner2) {
        _cb4 = calBezierRightBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx4, _ry4, true, Math.tan(_crossDeg2) * _ry4);

        var _cb4$ = _slicedToArray(_cb4[0], 2);

        _xb3 = _cb4$[0];
        _yb3 = _cb4$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca4;

          if (_needInner2) {
            controls2 = _cb4;
          }
        } else {
          controls1 = calBezierRightBottom(points[1], points[2], oxb, oyb, _sx3, _ry3);

          if (_needInner2) {
            controls2 = calBezierRightBottom(points[0], points[3], oxb, oyb, _sx4, _ry4);
          }
        }

        for (var _i7 = 0, _len7 = controls1.length; _i7 < _len7; _i7++) {
          limit(controls1[_i7], _xa3, _ya3, 3);
        }

        if (_needInner2) {
          for (var _i8 = 0, _len8 = controls2.length; _i8 < _len8; _i8++) {
            limit(controls2[_i8], _xb3, _yb3, 3);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierRightTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p5 = _slicedToArray(p1, 2),
        p1x = _p5[0],
        p1y = _p5[1];

    var _p6 = _slicedToArray(p2, 2),
        p2x = _p6[0],
        p2y = _p6[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox + Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox + Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox + Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierRightBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p7 = _slicedToArray(p1, 2),
        p1x = _p7[0],
        p1y = _p7[1];

    var _p8 = _slicedToArray(p2, 2),
        p2x = _p8[0],
        p2y = _p8[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius3 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius3[0],
        bry = _beginRadius3[1];

    var _endRadius3 = _slicedToArray(endRadius, 2),
        erx = _endRadius3[0],
        ery = _endRadius3[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[2][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[3][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[2][0] > oxr && points[3][0] < oxl) {
        var ya = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        beginList.push([points[0], [oxl, ya], [oxl, y4], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y3], [oxr, y3], [oxr, y4], [oxl, y4]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y3], [x3, y3], [x3, y4], [oxl, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [oxr, y3], [oxr, y4], [x2, y4]]);
          } else {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          }
        }

        endList.push([[oxr, yb], points[1], points[2], [oxr, y4]]);
      } // 跨越右圆角
      else if (points[2][0] > oxr) {
        var y = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        centerList.push([points[0], [oxr, y], [oxr, y4], points[3]]);
        endList.push([[oxr, y], points[1], points[2], [oxr, y4]]);
      } // 跨越左圆角
      else if (points[3][0] < oxl) {
        var _y2 = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y3;

        beginList.push([points[0], [oxl, _y2], [oxl, y4], points[3]]);
        centerList.push([[oxl, _y2], points[1], points[2], [oxl, y4]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y4 - y3));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y4 - bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y4 - y3);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya4, xb, _yb4;

      var ca = calBezierBottomLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$2 = _slicedToArray(ca[0], 2);

      xa = _ca$2[0];
      _ya4 = _ca$2[1];
      var cb;

      if (needInner) {
        cb = calBezierBottomLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$2 = _slicedToArray(cb[0], 2);

        xb = _cb$2[0];
        _yb4 = _cb$2[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierBottomLeft(points[3], points[2], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierBottomLeft(points[0], points[1], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i9 = 0, _len9 = controls1.length; _i9 < _len9; _i9++) {
          limit(controls1[_i9], xa, _ya4, 4);
        }

        if (needInner) {
          for (var _i10 = 0, _len10 = controls2.length; _i10 < _len10; _i10++) {
            limit(controls2[_i10], xb, _yb4, 4);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];
        points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner3 = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg3 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx5 = erx;
      var _ry5 = ery;

      var _sx5 = _ry5 / _rx5;

      var oyr = y4 - ery;

      var _rx6 = erx - (x4 - x3);

      var _ry6 = ery - (y4 - y3);

      var _sx6 = _ry6 / _rx6; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa4, _ya5, _xb4, _yb5;

      var _ca5 = calBezierBottomRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx5, _ry5, true, Math.tan(_crossDeg3) * _ry5);

      var _ca6 = _slicedToArray(_ca5[_ca5.length - 1], 2);

      _xa4 = _ca6[0];
      _ya5 = _ca6[1];

      var _cb5;

      if (_needInner3) {
        _cb5 = calBezierBottomRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx6, _ry6, true, Math.tan(_crossDeg3) * _ry6);

        var _cb6 = _slicedToArray(_cb5[_cb5.length - 1], 2);

        _xb4 = _cb6[0];
        _yb5 = _cb6[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca5;

          if (_needInner3) {
            controls2 = _cb5;
          }
        } else {
          controls1 = calBezierBottomRight(points[3], points[2], oxr, oyr, _sx5, _ry5);

          if (_needInner3) {
            controls2 = calBezierBottomRight(points[0], points[1], oxr, oyr, _sx6, _ry6);
          }
        }

        for (var _i11 = 0, _len11 = controls1.length; _i11 < _len11; _i11++) {
          limit(controls1[_i11], _xa4, _ya5, 5);
        }

        if (_needInner3) {
          for (var _i12 = 0, _len12 = controls2.length; _i12 < _len12; _i12++) {
            limit(controls2[_i12], _xb4, _yb5, 5);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];
        points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierBottomLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p9 = _slicedToArray(p1, 2),
        p1x = _p9[0],
        p1y = _p9[1];

    var _p10 = _slicedToArray(p2, 2),
        p2x = _p10[0],
        p2y = _p10[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (p2y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy + Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy + Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (p1y - oy));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy + Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierBottomRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p11 = _slicedToArray(p1, 2),
        p1x = _p11[0],
        p1y = _p11[1];

    var _p12 = _slicedToArray(p2, 2),
        p2x = _p12[0],
        p2y = _p12[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius4 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius4[0],
        bry = _beginRadius4[1];

    var _endRadius4 = _slicedToArray(endRadius, 2),
        erx = _endRadius4[0],
        ery = _endRadius4[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[3][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[0][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[3][1] > oyb && points[0][1] < oyt) {
        var xa = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;
        var xb = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        beginList.push([points[0], points[1], [xa, oyt], [x1, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, oyb], [x1, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, oyb], [x1, oyb]]);
          } else {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          }
        }

        endList.push([[x1, oyb], [xb, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[3][1] > oyb) {
        var x = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        centerList.push([points[0], points[1], [x, oyb], [x1, oyb]]);
        endList.push([[x1, oyb], [x, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x2 = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;

        beginList.push([points[0], points[1], [_x2, oyt], [x1, oyt]]);
        centerList.push([[x1, oyt], [_x2, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x1 + brx;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa5, ya, _xb5, yb;

      var ca = calBezierLeftTop(beginList[0][0], beginList[0][3], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca7 = _slicedToArray(ca[ca.length - 1], 2);

      _xa5 = _ca7[0];
      ya = _ca7[1];
      var cb;

      if (needInner) {
        cb = calBezierLeftTop(beginList[0][1], beginList[0][2], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb7 = _slicedToArray(cb[cb.length - 1], 2);

        _xb5 = _cb7[0];
        yb = _cb7[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierLeftTop(points[0], points[3], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierLeftTop(points[1], points[2], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i13 = 0, _len13 = controls1.length; _i13 < _len13; _i13++) {
          limit(controls1[_i13], _xa5, ya, 6);
        }

        if (needInner) {
          for (var _i14 = 0, _len14 = controls2.length; _i14 < _len14; _i14++) {
            limit(controls2[_i14], _xb5, yb, 6);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner4 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg4 = Math.atan((x2 - x1) / (y4 - y3));

      var _rx7 = erx;
      var _ry7 = ery;

      var _sx7 = _ry7 / _rx7;

      var oxb = x1 + erx;

      var _rx8 = erx - (x2 - x1);

      var _ry8 = ery - (y4 - y3);

      var _sx8 = _ry8 / _rx8; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa6, _ya6, _xb6, _yb6;

      var _ca8 = calBezierLeftBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx7, _ry7, true, Math.tan(_crossDeg4) * _ry7);

      var _ca8$ = _slicedToArray(_ca8[0], 2);

      _xa6 = _ca8$[0];
      _ya6 = _ca8$[1];

      var _cb8;

      if (_needInner4) {
        _cb8 = calBezierLeftBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx8, _ry8, true, Math.tan(_crossDeg4) * _ry8);

        var _cb8$ = _slicedToArray(_cb8[0], 2);

        _xb6 = _cb8$[0];
        _yb6 = _cb8$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca8;

          if (_needInner4) {
            controls2 = _cb8;
          }
        } else {
          controls1 = calBezierLeftBottom(points[0], points[3], oxb, oyb, _sx7, _ry7);

          if (_needInner4) {
            controls2 = calBezierLeftBottom(points[1], points[2], oxb, oyb, _sx8, _ry8);
          }
        }

        for (var _i15 = 0, _len15 = controls1.length; _i15 < _len15; _i15++) {
          limit(controls1[_i15], _xa6, _ya6, 7);
        }

        if (_needInner4) {
          for (var _i16 = 0, _len16 = controls2.length; _i16 < _len16; _i16++) {
            limit(controls2[_i16], _xb6, _yb6, 7);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierLeftTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p13 = _slicedToArray(p1, 2),
        p1x = _p13[0],
        p1y = _p13[1];

    var _p14 = _slicedToArray(p2, 2),
        p2x = _p14[0],
        p2y = _p14[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierLeftBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p15 = _slicedToArray(p1, 2),
        p1x = _p15[0],
        p1y = _p15[1];

    var _p16 = _slicedToArray(p2, 2),
        p2x = _p16[0],
        p2y = _p16[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox - Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox - Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox - Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }
  /**
   * 简单计算椭圆的圆化坐标控制点，视作重合位置，外面判断backgroundClip并调整坐标
   * @param x 起始x
   * @param y 起始y
   * @param w 宽
   * @param h 高
   * @param btlr borderTopLeftRadius
   * @param btrr borderTopRightRadius
   * @param bbrr borderBottomRightRadius
   * @param bblr borderBottomLeftRadius
   * @returns {[]} 多边形的顶点和曲线控制点
   */


  function calRadius(x, y, w, h, btlr, btrr, bbrr, bblr) {
    var need;

    var _btlr = _slicedToArray(btlr, 2),
        btlx = _btlr[0],
        btly = _btlr[1];

    var _btrr = _slicedToArray(btrr, 2),
        btrx = _btrr[0],
        btry = _btrr[1];

    var _bbrr = _slicedToArray(bbrr, 2),
        bbrx = _bbrr[0],
        bbry = _bbrr[1];

    var _bblr = _slicedToArray(bblr, 2),
        bblx = _bblr[0],
        bbly = _bblr[1];

    btlx = Math.max(btlx, 0);
    btly = Math.max(btly, 0);
    btrx = Math.max(btrx, 0);
    btry = Math.max(btry, 0);
    bbrx = Math.max(bbrx, 0);
    bbry = Math.max(bbry, 0);
    bblx = Math.max(bblx, 0);
    bbly = Math.max(bbly, 0); // 圆角必须x/y都>0才有效，否则视为不绘制

    if (btlx > 0 && btly > 0 || btrx > 0 && btry > 0 || bbrx > 0 && bbry > 0 || bblx > 0 && bbly > 0) {
      need = true;
    }

    if (need) {
      var list = [];

      if (btlx > 0 && btly > 0) {
        list.push([x, y + btly]);
        list.push([x, y + btly * (1 - H$1), x + btlx * (1 - H$1), y, x + btlx, y]);
      } else {
        list.push([x, y]);
      }

      if (btrx > 0 && btry > 0) {
        list.push([x + w - btrx, y]);
        list.push([x + w - btrx * (1 - H$1), y, x + w, y + btry * (1 - H$1), x + w, y + btry]);
      } else {
        list.push([x + w, y]);
      }

      if (bbrx > 0 && bbry > 0) {
        list.push([x + w, y + h - bbry]);
        list.push([x + w, y + h - bbry * (1 - H$1), x + w - bbrx * (1 - H$1), y + h, x + w - bbrx, y + h]);
      } else {
        list.push([x + w, y + h]);
      }

      if (bblx > 0 && bbly > 0) {
        list.push([x + bblx, y + h]);
        list.push([x + bblx * (1 - H$1), y + h, x, y + h - bbly * (1 - H$1), x, y + h - bbly]);
      } else {
        list.push([x, y + h]);
      }

      return list;
    }
  }

  function limit(points, x, y, direction) {
    if (direction === 0) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 1) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 2) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 3) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 4) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 5) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 6) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 7) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    }
  }

  var BR_KS = [BORDER_TOP_LEFT_RADIUS, BORDER_TOP_RIGHT_RADIUS, BORDER_BOTTOM_RIGHT_RADIUS, BORDER_BOTTOM_LEFT_RADIUS];

  function calBorderRadius(w, h, currentStyle, computedStyle, root) {
    var noRadius = true;
    BR_KS.forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        if (item[0] > 0) {
          noRadius = false;
        } else {
          return 0;
        }

        if (item[1] === PX) {
          return Math.max(0, item[0]);
        } else if (item[1] === PERCENT) {
          return Math.max(0, item[0] * (i ? h : w) * 0.01);
        } else if (item[1] === REM) {
          return Math.max(0, item[0] * root.computedStyle[FONT_SIZE]);
        } else if (item[1] === VW) {
          return Math.max(0, item[0] * root.width * 0.01);
        } else if (item[1] === VH) {
          return Math.max(0, item[0] * root.height * 0.01);
        } else if (item[1] === VMAX) {
          return Math.max(0, item[0] * Math.max(root.width, root.height) * 0.01);
        } else if (item[1] === VMIN) {
          return Math.max(0, item[0] * Math.min(root.width, root.height) * 0.01);
        }

        return 0;
      });
    }); // 优化提前跳出

    if (noRadius) {
      return;
    } // radius限制，相交的2个之和不能超过边长，如果2个都超过中点取中点，只有1个超过取交点，这包含了单个不能超过总长的逻辑


    BR_KS.forEach(function (k, i) {
      var j = i % 2 === 0 ? 0 : 1;
      var target = j ? h : w;
      var prev = computedStyle[k];
      var next = computedStyle[BR_KS[(i + 1) % 4]]; // 相加超过边长则是相交

      if (prev[j] + next[j] > target) {
        var half = target * 0.5; // 都超过一半中点取中点

        if (prev[j] >= half && next[j] >= half) {
          prev[j] = next[j] = half;
        } // 仅1个超过中点，因相交用总长减去另一方即可
        else if (prev[j] > half) {
          prev[j] = target - next[j];
        } else if (next[j] > half) {
          next[j] = target - prev[j];
        }
      }
    });
  }

  function calBorderRadiusInline(contentBoxList, currentStyle, computedStyle) {
    var first, last;

    if (contentBoxList.length) {
      first = contentBoxList[0];
      last = contentBoxList[contentBoxList.length - 1]; // 不用instanceof防止循环依赖

      if (last.isEllipsis) {
        last = contentBoxList[contentBoxList.length - 2];
      }
    } // 先看first的左侧


    var w = first ? first.outerWidth : 0,
        h = first ? first.outerHeight : 0;
    w += computedStyle[BORDER_LEFT_WIDTH] + computedStyle[PADDING_LEFT];
    h += computedStyle[BORDER_TOP_WIDTH] + computedStyle[BORDER_BOTTOM_WIDTH] + computedStyle[PADDING_TOP] + computedStyle[PADDING_BOTTOM];
    [BORDER_TOP_LEFT_RADIUS, BORDER_BOTTOM_LEFT_RADIUS].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item[1] === PX) {
          v = Math.max(0, item[0]);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item[0] * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    }); // 再看end的右侧

    w = last ? last.outerWidth : 0;
    h = last ? last.outerHeight : 0;
    [BORDER_TOP_RIGHT_RADIUS, BORDER_BOTTOM_RIGHT_RADIUS].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item[1] === PX) {
          v = Math.max(0, item[0]);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item[0] * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    });
  }

  function renderBorder(xom, renderMode, ctx, points, color, dx, dy) {
    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      points.forEach(function (point) {
        canvasPolygon$1(ctx, point, dx, dy);
      });
      ctx.fill();
      ctx.closePath();
    } else if (renderMode === mode.SVG) {
      var s = '';
      points.forEach(function (point) {
        s += svgPolygon$1(point);
      });
      xom.virtualDom.bb.push({
        type: 'item',
        tagName: 'path',
        props: [['d', s], ['fill', color]]
      });
    }
  }

  var border = {
    calPoints: calPoints,
    calRadius: calRadius,
    calBorderRadius: calBorderRadius,
    calBorderRadiusInline: calBorderRadiusInline,
    renderBorder: renderBorder
  };

  var rgba2int$1 = util.rgba2int,
      isNil$1 = util.isNil;
  var PX$1 = o.PX,
      PERCENT$1 = o.PERCENT,
      DEG = o.DEG,
      NUMBER = o.NUMBER,
      REM$1 = o.REM,
      VW$1 = o.VW,
      VH$1 = o.VH,
      VMAX$1 = o.VMAX,
      VMIN$1 = o.VMIN,
      calUnit = o.calUnit;
  var d2r$1 = geom.d2r;
  var canvasPolygon$2 = painter.canvasPolygon;
  var FONT_SIZE$1 = enums.STYLE_KEY.FONT_SIZE;

  function getLinearDeg(v) {
    var deg = 180;

    if (v === 'to top') {
      deg = 0;
    } else if (v === 'to top right') {
      deg = 45;
    } else if (v === 'to right') {
      deg = 90;
    } else if (v === 'to bottom right') {
      deg = 135;
    } else if (v === 'to bottom') ; else if (v === 'to bottom left') {
      deg = 225;
    } else if (v === 'to left') {
      deg = 270;
    } else if (v === 'to top left') {
      deg = 315;
    } // 数字角度，没有的话取默认角度
    else {
      var match = /([-+]?[\d.]+)deg/.exec(v);

      if (match) {
        deg = parseFloat(match[1]);
      }
    }

    return deg % 360;
  }

  function getRadialPosition(data) {
    if (/^[-+]?[\d.]/.test(data)) {
      var v = calUnit(data);

      if ([NUMBER, DEG].indexOf(v[1]) > -1) {
        v[1] = PX$1;
      }

      return v;
    } else {
      return [{
        top: 0,
        left: 0,
        center: 50,
        right: 100,
        bottom: 100
      }[data] || 50, PERCENT$1];
    }
  } // 获取color-stop区间范围，去除无用值


  function getColorStop(v, length, root) {
    var list = [];
    var firstColor = v[0][0]; // 先把已经声明距离的换算成[0,1]以数组形式存入，未声明的原样存入

    for (var i = 0, len = v.length; i < len; i++) {
      var item = v[i]; // 考虑是否声明了位置

      if (item.length > 1) {
        var p = item[1];

        if (p[1] === PERCENT$1) {
          list.push([item[0], p[0] * 0.01]);
        } else if (p[1] === REM$1) {
          list.push([item[0], p[0] * root.computedStyle[FONT_SIZE$1] / length]);
        } else if (p[1] === VW$1) {
          list.push([item[0], p[0] * root.width / length]);
        } else if (p[1] === VH$1) {
          list.push([item[0], p[0] * root.height / length]);
        } else if (p[1] === VMAX$1) {
          list.push([item[0], p[0] * Math.max(root.width, root.height) / length]);
        } else if (p[1] === VMIN$1) {
          list.push([item[0], p[0] * Math.min(root.width, root.height) / length]);
        } else {
          list.push([item[0], p[0] / length]);
        }
      } else {
        list.push([item[0]]);
      }
    }

    if (list.length === 1) {
      list.push(util.clone(list[0]));
    } // 首尾不声明默认为[0, 1]


    if (list[0].length === 1) {
      list[0].push(0);
    }

    if (list.length > 1) {
      var _i = list.length - 1;

      if (list[_i].length === 1) {
        list[_i].push(1);
      }
    } // 找到未声明位置的，需区间计算，找到连续的未声明的，前后的区间平分


    var start = list[0][1];

    for (var _i2 = 1, _len = list.length; _i2 < _len - 1; _i2++) {
      var _item = list[_i2];

      if (_item.length > 1) {
        start = _item[1];
      } else {
        var j = _i2 + 1;
        var end = list[list.length - 1][1];

        for (; j < _len - 1; j++) {
          var _item2 = list[j];

          if (_item2.length > 1) {
            end = _item2[1];
            break;
          }
        }

        var num = j - _i2 + 1;
        var per = (end - start) / num;

        for (var k = _i2; k < j; k++) {
          var _item3 = list[k];

          _item3.push(start + per * (k + 1 - _i2));
        }

        _i2 = j;
      }
    } // 每个不能小于前面的，canvas/svg不能兼容这种情况，需处理


    for (var _i3 = 1, _len2 = list.length; _i3 < _len2; _i3++) {
      var _item4 = list[_i3];
      var prev = list[_i3 - 1];

      if (_item4[1] < prev[1]) {
        _item4[1] = prev[1];
      }
    } // 0之前的和1之后的要过滤掉


    for (var _i4 = 0, _len3 = list.length; _i4 < _len3; _i4++) {
      var _item5 = list[_i4];

      if (_item5[1] > 1) {
        list.splice(_i4);
        var _prev = list[_i4 - 1];

        if (_prev && _prev[1] < 1) {
          var dr = _item5[0][0] - _prev[0][0];
          var dg = _item5[0][1] - _prev[0][1];
          var db = _item5[0][2] - _prev[0][2];
          var da = _item5[0][3] - _prev[0][3];

          var _p = (1 - _prev[1]) / (_item5[1] - _prev[1]);

          list.push([[_item5[0][0] + dr * _p, _item5[0][1] + dg * _p, _item5[0][2] + db * _p, _item5[0][3] + da * _p], 1]);
        }

        break;
      }
    }

    for (var _i5 = list.length - 1; _i5 >= 0; _i5--) {
      var _item6 = list[_i5];

      if (_item6[1] < 0) {
        list.splice(0, _i5 + 1);
        var next = list[_i5];

        if (next && next[1] > 0) {
          var _dr = next[0][0] - _item6[0][0];

          var _dg = next[0][1] - _item6[0][1];

          var _db = next[0][2] - _item6[0][2];

          var _da = next[0][3] - _item6[0][3];

          var _p2 = -_item6[1] / (next[1] - _item6[1]);

          list.unshift([[_item6[0][0] + _dr * _p2, _item6[0][1] + _dg * _p2, _item6[0][2] + _db * _p2, _item6[0][3] + _da * _p2], 0]);
        }

        break;
      }
    } // 可能存在超限情况，如在使用px单位超过len或<len时，canvas会报错超过[0,1]区间，需手动换算至区间内


    list.forEach(function (item) {
      // item[0] = int2rgba(item[0]);
      if (item[1] < 0) {
        item[1] = 0;
      } else if (item[1] > 1) {
        item[1] = 1;
      }
    }); // 都超限时，第一个颜色兜底

    if (!list.length) {
      list.push([firstColor, 0]);
    }

    return list;
  } // 根据角度和圆心获取渐变的4个点坐标


  function calLinearCoords(deg, length, cx, cy) {
    var x0;
    var y0;
    var x1;
    var y1;

    if (deg >= 270) {
      var r = d2r$1(360 - deg);
      x0 = cx + Math.sin(r) * length;
      y0 = cy + Math.cos(r) * length;
      x1 = cx - Math.sin(r) * length;
      y1 = cy - Math.cos(r) * length;
    } else if (deg >= 180) {
      var _r = d2r$1(deg - 180);

      x0 = cx + Math.sin(_r) * length;
      y0 = cy - Math.cos(_r) * length;
      x1 = cx - Math.sin(_r) * length;
      y1 = cy + Math.cos(_r) * length;
    } else if (deg >= 90) {
      var _r2 = d2r$1(180 - deg);

      x0 = cx - Math.sin(_r2) * length;
      y0 = cy - Math.cos(_r2) * length;
      x1 = cx + Math.sin(_r2) * length;
      y1 = cy + Math.cos(_r2) * length;
    } else {
      var _r3 = d2r$1(deg);

      x0 = cx - Math.sin(_r3) * length;
      y0 = cy + Math.cos(_r3) * length;
      x1 = cx + Math.sin(_r3) * length;
      y1 = cy - Math.cos(_r3) * length;
    }

    return [x0, y0, x1, y1];
  }

  function calCircleCentre(position, x1, y1, iw, ih, root) {
    var cx, cy;
    var positionX = position[0],
        positionY = position[1];

    if (positionX[1] === PERCENT$1) {
      cx = x1 + positionX[0] * iw * 0.01;
    } else if (positionX[1] === REM$1) {
      cx = x1 + positionX[0] * root.computedStyle[FONT_SIZE$1];
    } else if (positionX[1] === VW$1) {
      cx = x1 + positionX[0] * root.width * 0.01;
    } else if (positionX[1] === VH$1) {
      cx = x1 + positionX[0] * root.height * 0.01;
    } else if (positionX[1] === VMAX$1) {
      cx = x1 + positionX[0] * Math.max(root.width, root.height) * 0.01;
    } else if (positionX[1] === VMIN$1) {
      cx = x1 + positionX[0] * Math.min(root.width, root.height) * 0.01;
    } else {
      cx = x1 + positionX[0];
    }

    if (positionY[1] === PERCENT$1) {
      cy = y1 + positionY[0] * ih * 0.01;
    } else if (positionY[1] === REM$1) {
      cy = y1 + positionY[0] * root.computedStyle[FONT_SIZE$1];
    } else if (positionY[1] === VW$1) {
      cy = y1 + positionY[0] * root.width * 0.01;
    } else if (positionY[1] === VH$1) {
      cy = y1 + positionY[0] * root.height * 0.01;
    } else if (positionY[1] === VH$1) {
      cy = y1 + positionY[0] * Math.max(root.width, root.height) * 0.01;
    } else if (positionY[1] === VH$1) {
      cy = y1 + positionY[0] * Math.min(root.width, root.height) * 0.01;
    } else {
      cy = y1 + positionY[0];
    }

    return [cx, cy];
  } // 获取径向渐变圆心半径


  function calRadialRadius(shape, size, position, iw, ih, x1, y1, x2, y2, root) {
    var cx,
        cy,
        xl,
        yl,
        r,
        tx,
        ty,
        d = 0; // 扩展的from to ratio格式，圆心、长轴坐标、短轴缩放比

    if (Array.isArray(size)) {
      cx = x1 + size[0] * iw;
      cy = y1 + size[1] * ih;
      tx = x1 + size[4] * iw;
      ty = y1 + size[5] * ih;

      if (size[6] <= 0) {
        r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
      } else {
        xl = Math.sqrt(Math.pow((size[2] - size[0]) * iw, 2) + Math.pow((size[3] - size[1]) * ih, 2));
        yl = xl * size[6];
        r = Math.max(xl, yl); // 看旋转

        if (xl !== yl) {
          if (size[2] >= size[0]) {
            if (size[3] >= size[1]) {
              d = Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = -Math.asin((size[1] - size[3]) * ih / xl);
            }
          } else {
            if (size[3] >= size[1]) {
              d = d2r$1(180) - Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = Math.asin((size[1] - size[3]) * ih / xl) - d2r$1(180);
            }
          }
        }
      }
    } else {
      // 默认椭圆a是水平轴，b是垂直轴
      var _calCircleCentre = calCircleCentre(position, x1, y1, iw, ih, root);

      var _calCircleCentre2 = _slicedToArray(_calCircleCentre, 2);

      cx = _calCircleCentre2[0];
      cy = _calCircleCentre2[1];
      tx = cx;
      ty = cy;
      var ratio = 1;

      if (size === 'closest-corner' && shape === 'circle') {
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.sqrt(Math.pow(xl, 2) + Math.pow(yl, 2));
        }
      } else if (size === 'closest-side' || size === 'closest-corner') {
        // 在边外特殊情况只有end颜色填充
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          var _ratio = 1;

          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.min(xl, yl); // css的角和边有对应关系，即边扩展倍数，计算为固定值

          if (size === 'closest-corner') {
            _ratio = Math.sqrt(2);
          }

          xl *= _ratio;
          yl *= _ratio;
          r *= _ratio;
        }
      } else {
        if (cx <= x1) {
          xl = x1 - cx + iw;
        } else if (cx >= x2) {
          xl = cx - x2 + iw;
        } else if (cx < x1 + iw * 0.5) {
          xl = x2 - cx;
        } else {
          xl = cx - x1;
        }

        if (cy <= y1) {
          yl = y1 - cy + ih;
        } else if (cy >= y2) {
          yl = cy - y2 + ih;
        } else if (cy < y1 + ih * 0.5) {
          yl = y2 - cy;
        } else {
          yl = cy - y1;
        }

        r = Math.max(xl, yl);

        if (size !== 'farthest-side') {
          ratio = Math.sqrt(2);
        }

        xl *= ratio;
        yl *= ratio;
        r *= ratio;
      }
    }

    if (shape === 'circle') {
      xl = yl = r;
    }

    return [cx, cy, r, xl, yl, tx, ty, d];
  }

  function parseGradient(s) {
    var gradient = reg.gradient.exec(s);

    if (gradient) {
      var o = {
        k: gradient[1]
      };

      if (o.k === 'linear') {
        var deg = /([-+]?[\d.]+deg)|(to\s+[toprighbml]+)/i.exec(gradient[2]);

        if (deg) {
          o.d = getLinearDeg(deg[0].toLowerCase());
        } // 扩展支持从a点到b点相对坐标，而不是css角度，sketch等ui软件中用此格式
        else {
          var points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)/.exec(gradient[2]);

          if (points) {
            o.d = [parseFloat(points[1]), parseFloat(points[2]), parseFloat(points[3]), parseFloat(points[4])];
          } else {
            o.d = 180;
          }
        }
      } else if (o.k === 'radial') {
        o.s = gradient[2].indexOf('circle') > -1 ? 'circle' : 'ellipse';
        var size = /(closest|farthest)-(side|corner)/i.exec(gradient[2]);

        if (size) {
          o.z = size[0].toLowerCase();
        } // 扩展支持从a点到b点相对坐标，而不是size，sketch等ui软件中用此格式
        else {
          var _points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?/.exec(gradient[2]);

          if (_points) {
            o.z = [parseFloat(_points[1]), parseFloat(_points[2]), parseFloat(_points[3]), parseFloat(_points[4])];
            var i5 = !isNil$1(_points[5]),
                i6 = !isNil$1(_points[6]),
                i7 = !isNil$1(_points[7]); // 重载，567是偏移x/y和ratio，都可省略即不偏移和半径1，只有5是ratio，只有56是x/y

            if (i5 && i6 && i7) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(parseFloat(_points[7]));
            } else if (i5 && i6) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(1);
            } else if (i5) {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(parseFloat(_points[5]));
            } else {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(1);
            }
          } else {
            o.z = 'farthest-corner';
          }
        }

        var position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (position) {
          var x = getRadialPosition(position[1]);
          var y = position[2] ? getRadialPosition(position[2]) : x;
          o.p = [x, y];
        } else {
          o.p = [[50, PERCENT$1], [50, PERCENT$1]];
        }
      } else if (o.k === 'conic') {
        var _deg = /([-+]?[\d.]+deg)/i.exec(gradient[2]);

        if (_deg) {
          o.d = parseFloat(_deg[0]) % 360;
        } else {
          o.d = 0;
        }

        var _position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (_position) {
          var _x = getRadialPosition(_position[1]);

          var _y = _position[2] ? getRadialPosition(_position[2]) : _x;

          o.p = [_x, _y];
        } else {
          o.p = [[50, PERCENT$1], [50, PERCENT$1]];
        }
      }

      var v = gradient[2].match(/(([-+]?[\d.]+[pxremvwhina%]+)?\s*((#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))\s*([-+]?[\d.]+[pxremvwhina%]+)?)|(transparent)/ig) || [];
      o.v = v.map(function (item) {
        var color = /(?:#[0-9a-f]{3,8})|(?:rgba?\s*\(.+?\))|(?:transparent)/i.exec(item);
        var arr = [rgba2int$1(color[0])];
        var percent = /[-+]?[\d.]+[pxremvwhina%]+/.exec(item);

        if (percent) {
          var _v = calUnit(percent[0]);

          if ([NUMBER, DEG].indexOf(_v[1]) > -1) {
            _v[1] = PX$1;
          }

          arr[1] = _v;
        }

        return arr;
      });
      return o;
    }
  }

  function getLinear(v, d, ox, oy, cx, cy, w, h, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    ox += dx;
    oy += dy;
    cx += dx;
    cy += dy; // d为数组是2个坐标点，数字是css标准角度

    var x1, y1, x2, y2, stop;

    if (Array.isArray(d)) {
      x1 = ox + d[0] * w;
      y1 = oy + d[1] * h;
      x2 = ox + d[2] * w;
      y2 = oy + d[3] * h;
      var total = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      stop = getColorStop(v, total);
    } else {
      while (d >= 360) {
        d -= 360;
      }

      while (d < 0) {
        d += 360;
      } // 根据角度求直线上2点，设置半径为长宽最大值，这样一定在矩形外，看做一个向量A


      var len = Math.max(w, h);
      var coords = calLinearCoords(d, len, cx, cy);
      len *= 2; // start和4个顶点的向量在A上的投影长度

      var l1 = vector.dotProduct(ox - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l2 = vector.dotProduct(ox + w - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l3 = vector.dotProduct(ox + w - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l4 = vector.dotProduct(ox - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len; // 最小和最大值为0~100%

      var min = l1,
          max = l1;
      min = Math.min(min, Math.min(l2, Math.min(l3, l4)));
      max = Math.max(max, Math.max(l2, Math.max(l3, l4))); // 求得0和100%的长度和坐标

      var _total = max - min;

      var r1 = min / len;

      var _dx = coords[2] - coords[0];

      var _dy = coords[3] - coords[1];

      x1 = coords[0] + _dx * r1;
      y1 = coords[1] + _dy * r1;
      x2 = coords[2] - _dx * r1;
      y2 = coords[3] - _dy * r1;
      stop = getColorStop(v, _total, root);
    }

    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      stop: stop
    };
  }

  function getRadial(v, shape, size, position, x1, y1, x2, y2, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var w = x2 - x1;
    var h = y2 - y1;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _calRadialRadius = calRadialRadius(shape, size, position, w, h, x1, y1, x2, y2, root),
        _calRadialRadius2 = _slicedToArray(_calRadialRadius, 8),
        cx = _calRadialRadius2[0],
        cy = _calRadialRadius2[1],
        r = _calRadialRadius2[2],
        xl = _calRadialRadius2[3],
        yl = _calRadialRadius2[4],
        tx = _calRadialRadius2[5],
        ty = _calRadialRadius2[6],
        d = _calRadialRadius2[7]; // 圆形取最小值，椭圆根据最小圆进行transform，椭圆其中一边轴和r一样，另一边则大小缩放可能


    var matrix,
        scx = 1,
        scy = 1;

    if (xl !== yl || d) {
      matrix = [1, 0, 0, 1, 0, 0];

      if (d) {
        var sin = Math.sin(d);
        var cos = Math.cos(d);
        matrix = [cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      if (xl !== r) {
        scx = xl / r;
        var m = [scx, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix = mx.multiply(matrix, m);
      }

      if (yl !== r) {
        scy = yl / r;
        var _m = [1, 0, 0, 0, 0, scy, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix = mx.multiply(matrix, _m);
      }
    }

    var stop = getColorStop(v, r, root);
    return {
      cx: cx,
      cy: cy,
      tx: tx,
      ty: ty,
      r: r,
      stop: stop,
      scx: scx,
      scy: scy,
      matrix: matrix,
      d: d
    };
  }

  function getConic(v, d, p, x1, y1, x2, y2, ratio, root) {
    var _calConicRadius = calConicRadius(v, d, p, x1, y1, x2, y2, root),
        _calConicRadius2 = _slicedToArray(_calConicRadius, 4),
        cx = _calConicRadius2[0],
        cy = _calConicRadius2[1],
        r = _calConicRadius2[2],
        deg = _calConicRadius2[3];

    var stop = getColorStop(v, 1, root);
    r <<= 1; // 锥形半径*2，这样分割画圆时保证一定会填满原有矩形

    r *= ratio; // 矢量图形比较特殊，有可能超限，传入个倍数扩大半径

    return {
      cx: cx,
      cy: cy,
      w: x2 - x1,
      h: y2 - y1,
      r: r,
      deg: deg,
      stop: stop
    };
  }

  function calConicRadius(v, deg, position, x1, y1, x2, y2, root) {
    var iw = x2 - x1;
    var ih = y2 - y1;

    var _calCircleCentre3 = calCircleCentre(position, x1, y1, iw, ih, root),
        _calCircleCentre4 = _slicedToArray(_calCircleCentre3, 2),
        cx = _calCircleCentre4[0],
        cy = _calCircleCentre4[1];

    var r, a, b;

    if (cx >= x1 + iw * 0.5) {
      a = cx - x1;
    } else {
      a = x2 - cx;
    }

    if (cy >= y1 + ih * 0.5) {
      b = cy - y1;
    } else {
      b = y2 - cy;
    }

    r = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
    return [cx, cy, r, deg];
  }

  function renderConic(xom, renderMode, ctx, res, x, y, w, h, btlr, btrr, bbrr, bblr, isInline) {
    // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间
    var list = border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    }

    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
      var imgData = offscreen.ctx.getImageData(0, 0, w, h);
      gradient.getConicGradientImage(res.cx - x, res.cy - y, res.w, res.h, res.stop, imgData.data);
      offscreen.ctx.putImageData(imgData, 0, 0);
      ctx.save();
      ctx.beginPath();
      canvasPolygon$2(ctx, list);
      ctx.clip();
      ctx.closePath();
      ctx.drawImage(offscreen.canvas, x, y);
      ctx.restore();
      offscreen.ctx.clearRect(0, 0, w, h);
    }
  }

  var gradient$1 = {
    parseGradient: parseGradient,
    getLinear: getLinear,
    getRadial: getRadial,
    getConic: getConic,
    renderConic: renderConic
  };

  var isNil$2 = util.isNil;

  function parseFlex(style, grow, shrink, basis) {
    if (isNil$2(style.flexGrow)) {
      style.flexGrow = grow || 0;
    }

    if (isNil$2(style.flexShrink)) {
      style.flexShrink = shrink || 0;
    }

    if (isNil$2(style.flexBasis)) {
      style.flexBasis = basis || 0;
    }
  }

  function parseMarginPadding(style, key, list) {
    var temp = style[key];

    if (!isNil$2(temp)) {
      var match = temp.toString().match(/([-+]?[\d.]+[pxremvwhina%]*)|(auto)/ig);

      if (match) {
        if (match.length === 1) {
          match[3] = match[2] = match[1] = match[0];
        } else if (match.length === 2) {
          match[2] = match[0];
          match[3] = match[1];
        } else if (match.length === 3) {
          match[3] = match[1];
        }

        list.forEach(function (k, i) {
          if (isNil$2(style[k])) {
            style[k] = match[i];
          }
        });
      }
    }
  }

  function parseOneBorder(style, k) {
    var v = style[k];

    if (isNil$2(v)) {
      return;
    } // 后面会统一格式化处理


    if (isNil$2(style[k + 'Width'])) {
      var w = /\b[\d.]+[pxremvwhina%]*\b/i.exec(v);
      style[k + 'Width'] = w ? w[0] : 0;
    }

    if (isNil$2(style[k + 'Style'])) {
      var s = /\b(solid|dashed|dotted)\b/i.exec(v);
      style[k + 'Style'] = s ? s[1] : 'solid';
    }

    if (isNil$2(style[k + 'Color'])) {
      var c = /#[0-9a-f]{3,8}/i.exec(v);

      if (c && [4, 7, 9].indexOf(c[0].length) > -1) {
        style[k + 'Color'] = c[0];
      } else if (/\btransparent\b/i.test(v)) {
        style[k + 'Color'] = 'transparent';
      } else {
        c = /rgba?\s*\(.+\)/i.exec(v);
        style[k + 'Color'] = c ? c[0] : 'transparent';
      }
    }
  }

  var abbr = {
    margin: ['marginTop', 'marginRight', 'marginBottom', 'marginLeft'],
    padding: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
    border: ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'],
    borderTop: ['borderTopWidth', 'borderTopStyle', 'borderTopColor'],
    borderRight: ['borderRightWidth', 'borderRightStyle', 'borderRightColor'],
    borderBottom: ['borderBottomWidth', 'borderBottomStyle', 'borderBottomColor'],
    borderLeft: ['borderLeftWidth', 'borderLeftStyle', 'borderLeftColor'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    background: ['backgroundColor', 'backgroundImage', 'backgroundRepeat', 'backgroundPosition'],
    backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
    flex: ['flexGrow', 'flexShrink', 'flexBasis'],
    translate: ['translateX', 'translateY'],
    translate3d: ['translateX', 'translateY', 'translateY'],
    scale: ['scaleX', 'scaleY'],
    scale3d: ['scaleX', 'scaleY', 'scaleZ'],
    rotate: ['rotateZ'],
    skew: ['skewX', 'skewY'],
    textStroke: ['textStrokeWidth', 'textStrokeColor', 'textStrokeOver'],
    toFull: function toFull(style, k) {
      var _this = this;

      var v = style[k];

      if (k === 'background') {
        // bg缩写多个时有color则必须是最后一个
        if (Array.isArray(v)) {
          var length = v.length;

          if (isNil$2(style.backgroundColor)) {
            var bgc = /^\s*((transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))/i.exec(v[length - 1]);

            if (bgc) {
              style.backgroundColor = bgc[0];
              v = v.slice(0, length - 1);
            }
          }

          var bgi = [];
          var bgr = [];
          var bgp = [];
          v.forEach(function (item) {
            if (isNil$2(style.backgroundImage)) {
              var gd = reg.gradient.exec(item);

              if (gd) {
                bgi.push(gd[0]);
                item = item.replace(gd[0], '');
              } else {
                var img = reg.img.exec(v);

                if (img) {
                  bgi.push(img[0]);
                  item = item.replace(img[0], '');
                }
              }
            }

            if (isNil$2(style.backgroundRepeat)) {
              var repeat = /(no-?)?repeat(-?[xy])?/i.exec(item);

              if (repeat) {
                bgr.push(repeat[0].toLowerCase());
              }
            }

            if (isNil$2(style.backgroundPosition)) {
              var position = item.match(reg.position);

              if (position) {
                bgp.push(position.join(' '));
              }
            }
          });

          if (bgi.length) {
            style.backgroundImage = bgi;
          }

          if (bgr.length) {
            style.backgroundRepeat = bgr;
          }

          if (bgp.length) {
            style.backgroundPosition = bgp;
            this.toFull(style, 'backgroundPosition');
          }
        } else {
          if (isNil$2(style.backgroundImage)) {
            var gd = reg.gradient.exec(v);

            if (gd) {
              style.backgroundImage = gd[0];
              v = v.replace(gd[0], '');
            } else {
              var img = reg.img.exec(v);

              if (img) {
                style.backgroundImage = img[0];
                v = v.replace(img[0], '');
              }
            }
          }

          if (isNil$2(style.backgroundRepeat)) {
            var repeat = /(no-?)?repeat(-?[xy])?/i.exec(v);

            if (repeat) {
              style.backgroundRepeat = repeat[0].toLowerCase();
            }
          }

          if (isNil$2(style.backgroundColor)) {
            var _bgc = /^(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

            if (_bgc) {
              style.backgroundColor = _bgc[0];
              v = v.replace(_bgc[0], '');
            }
          }

          if (isNil$2(style.backgroundPosition)) {
            var position = v.match(reg.position);

            if (position) {
              style.backgroundPosition = position.join(' ');
              this.toFull(style, 'backgroundPosition');
            }
          }
        }
      } else if (k === 'flex') {
        if (v === 'none') {
          parseFlex(style, 0, 0, 'auto');
        } else if (v === 'auto') {
          parseFlex(style, 1, 1, 'auto');
        } else if (/^[\d.]+\s+[\d.]+\s+(auto|none|content)/.test(v) || /^[\d.]+\s+[\d.]+\s+[\d.]+[pxremvwhina%]*/.test(v)) {
          var arr = v.split(/\s+/);
          parseFlex(style, parseFloat(arr[0]), parseFloat(arr[1]), arr[2]);
        } else if (/^[\d.]+\s+[\d.]+$/.test(v)) {
          var _arr = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr[0]), parseFloat(_arr[1]), 0);
        } else if (/^[\d.]+\s+[\d.]+[pxremvwhina%]+/.test(v)) {
          var _arr2 = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr2[0]), 1, _arr2[1]);
        } else if (/^[\d.]+$/.test(v)) {
          parseFlex(style, parseFloat(v), 1, 0);
        } else if (/^[\d.]+[pxremvwhina%]+/i.test(v)) {
          parseFlex(style, 1, 1, v);
        } else {
          parseFlex(style, 0, 1, 'auto');
        }
      } else if (k === 'flexFlow') {
        v = v.toString().split(/\s+/);

        if (v.length) {
          if (isNil$2(style.flexDirection)) ;

          style.flexDirection = v[0];

          if (v.length > 1) {
            style.flexWrap = v[1];
          }
        }
      } else if (k === 'borderRadius') {
        // borderRadius缩写很特殊，/分隔x/y，然后上右下左4个
        v = v.toString().split('/');

        if (v.length === 1) {
          v[1] = v[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = v[i].toString().split(/\s+/);

          if (item.length === 0) {
            v[i] = [0, 0, 0, 0];
          } else if (item.length === 1) {
            v[i] = [item[0], item[0], item[0], item[0]];
          } else if (item.length === 2) {
            v[i] = [item[0], item[1], item[0], item[1]];
          } else if (item.length === 3) {
            v[i] = [item[0], item[1], item[2], item[1]];
          } else {
            v[i] = item.slice(0, 4);
          }
        }

        this[k].forEach(function (k, i) {
          if (isNil$2(style[k])) {
            style[k] = v[0][i] + ' ' + v[1][i];
          }
        });
      } else if (k === 'backgroundPosition') {
        if (!Array.isArray(v)) {
          v = [v];
        }

        var isEmpty = this[k].map(function (k2) {
          return isNil$2(style[k2]);
        });
        v.forEach(function (v2) {
          v2 = v2.toString().split(/\s+/);

          if (v2.length === 1) {
            v2[1] = '50%';
          }

          _this[k].forEach(function (k2, i) {
            if (isEmpty[i]) {
              style[k2] = style[k2] || [];
              style[k2].push(v2[i]);
            }
          });
        });
      } else if (['translate', 'scale', 'skew'].indexOf(k) > -1) {
        var _arr3 = v.toString().split(/\s*,\s*/);

        if (_arr3.length === 1) {
          _arr3[1] = _arr3[0];
        }

        this[k].forEach(function (k, i) {
          if (isNil$2(style[k])) {
            style[k] = _arr3[i];
          }
        });
      } else if (['translate3d', 'scale3d'].indexOf(k) > -1) {
        var _arr4 = v.toString().split(/\s*,\s*/);

        if (_arr4.length === 1) {
          _arr4[2] = _arr4[1] = _arr4[0];
        } else if (_arr4.length === 2) {
          _arr4[2] = k === 'scale3d' ? 1 : 0;
        }

        this[k].forEach(function (k, i) {
          if (isNil$2(style[k])) {
            style[k] = _arr4[i];
          }
        });
      } else if (k === 'margin' || k === 'padding') {
        parseMarginPadding(style, k, this[k]);
      } else if (/^border((Top)|(Right)|(Bottom)|(Left))$/.test(k)) {
        parseOneBorder(style, k);
      } else if (k === 'textStroke') {
        var w = /(?:^|\s)([-+]?[\d.]+[pxremvwhina%]*)/.exec(v);

        if (w) {
          style.textStrokeWidth = w[1];
        }

        var c = /(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

        if (c) {
          style.textStrokeColor = c[0];
        }

        if (/\bfill\b/i.test(v)) {
          style.textStrokeOver = 'fill';
        } else {
          style.textStrokeOver = 'none';
        }
      } else if (this[k]) {
        this[k].forEach(function (k) {
          if (isNil$2(style[k])) {
            style[k] = v;
          }
        });
      }

      return style;
    }
  };

  var STYLE_KEY$1 = enums.STYLE_KEY;
  var KEY_COLOR = [[STYLE_KEY$1.BACKGROUND_COLOR], [STYLE_KEY$1.BORDER_BOTTOM_COLOR], [STYLE_KEY$1.BORDER_LEFT_COLOR], [STYLE_KEY$1.BORDER_RIGHT_COLOR], [STYLE_KEY$1.BORDER_TOP_COLOR], [STYLE_KEY$1.COLOR], // 这2个特殊，新增GRADIENT渐变色
  [STYLE_KEY$1.TEXT_STROKE_COLOR]];
  var KEY_LENGTH = [[STYLE_KEY$1.FONT_SIZE], [STYLE_KEY$1.BORDER_BOTTOM_WIDTH], [STYLE_KEY$1.BORDER_LEFT_WIDTH], [STYLE_KEY$1.BORDER_RIGHT_WIDTH], [STYLE_KEY$1.BORDER_TOP_WIDTH], [STYLE_KEY$1.LEFT], [STYLE_KEY$1.TOP], [STYLE_KEY$1.RIGHT], [STYLE_KEY$1.BOTTOM], [STYLE_KEY$1.FLEX_BASIS], [STYLE_KEY$1.WIDTH], [STYLE_KEY$1.HEIGHT], [STYLE_KEY$1.LINE_HEIGHT], [STYLE_KEY$1.MARGIN_BOTTOM], [STYLE_KEY$1.MARGIN_LEFT], [STYLE_KEY$1.MARGIN_TOP], [STYLE_KEY$1.MARGIN_RIGHT], [STYLE_KEY$1.PADDING_TOP], [STYLE_KEY$1.PADDING_RIGHT], [STYLE_KEY$1.PADDING_BOTTOM], [STYLE_KEY$1.PADDING_LEFT], [STYLE_KEY$1.STROKE_WIDTH], [STYLE_KEY$1.STROKE_MITERLIMIT], [STYLE_KEY$1.LETTER_SPACING], [STYLE_KEY$1.PERSPECTIVE], [STYLE_KEY$1.TEXT_STROKE_WIDTH]];
  var KEY_GRADIENT = [[STYLE_KEY$1.BACKGROUND_IMAGE], [STYLE_KEY$1.FILL], [STYLE_KEY$1.STROKE]];
  var KEY_RADIUS = [[STYLE_KEY$1.BORDER_TOP_LEFT_RADIUS], [STYLE_KEY$1.BORDER_TOP_RIGHT_RADIUS], [STYLE_KEY$1.BORDER_BOTTOM_RIGHT_RADIUS], [STYLE_KEY$1.BORDER_BOTTOM_LEFT_RADIUS]];
  var COLOR_HASH = {};
  KEY_COLOR.forEach(function (k) {
    COLOR_HASH[k] = true;
  });
  var LENGTH_HASH = {};
  KEY_LENGTH.forEach(function (k) {
    LENGTH_HASH[k] = true;
  });
  var RADIUS_HASH = {};
  KEY_RADIUS.forEach(function (k) {
    RADIUS_HASH[k] = true;
  });
  var GRADIENT_HASH = {};
  KEY_GRADIENT.forEach(function (k) {
    GRADIENT_HASH[k] = true;
  });
  var GRADIENT_TYPE = {
    linear: true,
    radial: true,
    conic: true
  };
  var KEY_EXPAND = [[STYLE_KEY$1.TRANSLATE_X], [STYLE_KEY$1.TRANSLATE_Y], [STYLE_KEY$1.TRANSLATE_Z], [STYLE_KEY$1.SKEW_X], [STYLE_KEY$1.SKEW_Y], [STYLE_KEY$1.SCALE_X], [STYLE_KEY$1.SCALE_Y], [STYLE_KEY$1.SCALE_Z], [STYLE_KEY$1.ROTATE_X], [STYLE_KEY$1.ROTATE_Y], [STYLE_KEY$1.ROTATE_Z]];
  var EXPAND_HASH = {};
  KEY_EXPAND.forEach(function (k) {
    EXPAND_HASH[k] = true;
  });
  var key = {
    KEY_COLOR: KEY_COLOR,
    KEY_EXPAND: KEY_EXPAND,
    KEY_GRADIENT: KEY_GRADIENT,
    KEY_LENGTH: KEY_LENGTH,
    KEY_RADIUS: KEY_RADIUS,
    COLOR_HASH: COLOR_HASH,
    EXPAND_HASH: EXPAND_HASH,
    GRADIENT_HASH: GRADIENT_HASH,
    LENGTH_HASH: LENGTH_HASH,
    RADIUS_HASH: RADIUS_HASH,
    GRADIENT_TYPE: GRADIENT_TYPE
  };

  var _REPAINT;
  var RESET_DOM = reset.DOM,
      RESET_GEOM = reset.GEOM;
  var STYLE_KEY$2 = enums.STYLE_KEY;
  var GEOM$1 = {};
  var GEOM_KEY_SET$1 = [];

  var IGNORE = _defineProperty({}, STYLE_KEY$2.POINTER_EVENTS, true);

  var REPAINT = (_REPAINT = {}, _defineProperty(_REPAINT, STYLE_KEY$2.TRANSFORM, true), _defineProperty(_REPAINT, STYLE_KEY$2.TRANSLATE_X, true), _defineProperty(_REPAINT, STYLE_KEY$2.TRANSLATE_Y, true), _defineProperty(_REPAINT, STYLE_KEY$2.SKEW_X, true), _defineProperty(_REPAINT, STYLE_KEY$2.SKEW_Y, true), _defineProperty(_REPAINT, STYLE_KEY$2.SCALE_X, true), _defineProperty(_REPAINT, STYLE_KEY$2.SCALE_Y, true), _defineProperty(_REPAINT, STYLE_KEY$2.ROTATE_Z, true), _defineProperty(_REPAINT, STYLE_KEY$2.COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.FONT_STYLE, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE_WIDTH, true), _defineProperty(_REPAINT, STYLE_KEY$2.FILL, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE_DASHARRAY, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE_LINECAP, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE_LINEJOIN, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE_MITERLIMIT, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_IMAGE, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_POSITION_X, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_POSITION_Y, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_REPEAT, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_SIZE, true), _defineProperty(_REPAINT, STYLE_KEY$2.STROKE, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_BOTTOM_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_LEFT_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_RIGHT_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_TOP_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_TOP_LEFT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_TOP_RIGHT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_BOTTOM_RIGHT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$2.BORDER_BOTTOM_LEFT_RADIUS, true), _defineProperty(_REPAINT, STYLE_KEY$2.VISIBILITY, true), _defineProperty(_REPAINT, STYLE_KEY$2.OPACITY, true), _defineProperty(_REPAINT, STYLE_KEY$2.Z_INDEX, true), _defineProperty(_REPAINT, STYLE_KEY$2.FILTER, true), _defineProperty(_REPAINT, STYLE_KEY$2.BOX_SHADOW, true), _defineProperty(_REPAINT, STYLE_KEY$2.OVERFLOW, true), _defineProperty(_REPAINT, STYLE_KEY$2.BACKGROUND_CLIP, true), _defineProperty(_REPAINT, STYLE_KEY$2.TEXT_STROKE_WIDTH, true), _defineProperty(_REPAINT, STYLE_KEY$2.TEXT_STROKE_COLOR, true), _defineProperty(_REPAINT, STYLE_KEY$2.TEXT_STROKE_OVER, true), _REPAINT);
  var o$2 = {
    GEOM: GEOM$1,
    GEOM_KEY_SET: GEOM_KEY_SET$1,
    IGNORE: IGNORE,
    REPAINT: REPAINT,
    addGeom: function addGeom(tagName, ks, cb) {
      if (Array.isArray(ks)) {
        ks.forEach(function (k) {
          o$2.addGeom(tagName, k, cb);
        });
      } else if (ks) {
        if (!GEOM$1.hasOwnProperty(ks)) {
          GEOM_KEY_SET$1.push(ks);
        }

        var hash = GEOM$1[ks] = GEOM$1[ks] || {};
        hash[tagName] = cb || true;
      }
    },
    isIgnore: function isIgnore(k) {
      return IGNORE.hasOwnProperty(k);
    },
    isGeom: function isGeom(tagName, k) {
      return tagName && k && GEOM$1.hasOwnProperty(k) && GEOM$1[k].hasOwnProperty(tagName);
    },
    isRepaint: function isRepaint(k, tagName) {
      return REPAINT.hasOwnProperty(k) || o$2.isGeom(tagName, k);
    },
    isValid: function isValid(tagName, k) {
      if (!k) {
        return false;
      }

      if (RESET_DOM.hasOwnProperty(k)) {
        return true;
      } // geom的fill等矢量才有的样式


      if (tagName.charAt(0) === '$' && RESET_GEOM.hasOwnProperty(k)) {
        return true;
      }

      if (GEOM$1.hasOwnProperty(k)) {
        return GEOM$1[k].hasOwnProperty(tagName);
      }

      if (k === 'translatePath') {
        return true;
      }

      return false;
    }
  };
  o$2.addGeom('$line', ['x1', 'y1', 'x2', 'y2', 'controlA', 'controlB', 'start', 'end']);
  o$2.addGeom('$circle', ['r']);
  o$2.addGeom('$ellipse', ['rx', 'ry']);
  o$2.addGeom('$rect', ['rx', 'ry']);
  o$2.addGeom('$sector', ['begin', 'end', 'edge', 'closure']);
  o$2.addGeom('$polyline', ['points', 'controls', 'start', 'end']);
  o$2.addGeom('$polygon', ['points', 'controls', 'start', 'end', 'booleanOperations']);

  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据模糊参数sigma求卷积核尺寸
   * @param sigma
   * @returns {number}
   */
  function kernelSize(sigma) {
    if (sigma <= 0) {
      return 0;
    }

    var d = Math.floor(sigma * 3 * Math.sqrt(2 * Math.PI) / 4 + 0.5);

    if (d < 2) {
      d = 2;
    }

    if (d % 2 === 0) {
      d++;
    }

    return d;
  }
  /**
   * 根据sigma求模糊扩展尺寸，卷积核求得后为d，再求半径/2，然后因为算法要执行3次，所以*3
   * 比如本来d为5，半径2.5算上自身像素点则各方向扩展2，*3则扩展6
   * @param sigma
   * @returns {number}
   */


  function outerSize(sigma) {
    var d = kernelSize(sigma);
    return outerSizeByD(d);
  }

  function outerSizeByD(d) {
    return Math.floor(d * 0.5) * 3;
  }
  /**
   * 一维高斯正态分布，根据标准差和卷积核尺寸返回一维权重数组
   * @param sigma
   * @param d
   */


  function gaussianWeight(sigma, d) {
    var list = [];
    var len = Math.floor(d * 0.5);
    var total = 0;

    for (var i = len; i >= 0; i--) {
      var n = Math.pow(Math.E, -Math.pow(i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));
      list.push(n);
      total += n;
    }

    for (var _i = 1; _i <= len; _i++) {
      var _n = Math.pow(Math.E, -Math.pow(_i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));

      list.push(_n);
      total += _n;
    }

    if (total !== 1) {
      for (var _i2 = 0; _i2 < d; _i2++) {
        list[_i2] /= total;
      }
    }

    return list;
  }

  var blur = {
    kernelSize: kernelSize,
    outerSize: outerSize,
    outerSizeByD: outerSizeByD,
    gaussianWeight: gaussianWeight
  };

  var _VALUE, _ARRAY_, _ARRAY_0_;
  var STYLE_KEY$3 = enums.STYLE_KEY,
      style2Upper$1 = enums.style2Upper,
      _enums$STYLE_KEY$2 = enums.STYLE_KEY,
      POSITION = _enums$STYLE_KEY$2.POSITION,
      WIDTH$1 = _enums$STYLE_KEY$2.WIDTH,
      HEIGHT$1 = _enums$STYLE_KEY$2.HEIGHT,
      TRANSLATE_X = _enums$STYLE_KEY$2.TRANSLATE_X,
      TRANSLATE_Y = _enums$STYLE_KEY$2.TRANSLATE_Y,
      TRANSLATE_Z = _enums$STYLE_KEY$2.TRANSLATE_Z,
      SCALE_X = _enums$STYLE_KEY$2.SCALE_X,
      SCALE_Y = _enums$STYLE_KEY$2.SCALE_Y,
      SCALE_Z = _enums$STYLE_KEY$2.SCALE_Z,
      SKEW_X = _enums$STYLE_KEY$2.SKEW_X,
      SKEW_Y = _enums$STYLE_KEY$2.SKEW_Y,
      ROTATE_X = _enums$STYLE_KEY$2.ROTATE_X,
      ROTATE_Y = _enums$STYLE_KEY$2.ROTATE_Y,
      ROTATE_Z = _enums$STYLE_KEY$2.ROTATE_Z,
      ROTATE_3D = _enums$STYLE_KEY$2.ROTATE_3D,
      PERSPECTIVE = _enums$STYLE_KEY$2.PERSPECTIVE,
      PERSPECTIVE_ORIGIN = _enums$STYLE_KEY$2.PERSPECTIVE_ORIGIN,
      TRANSFORM = _enums$STYLE_KEY$2.TRANSFORM,
      TRANSFORM_ORIGIN$1 = _enums$STYLE_KEY$2.TRANSFORM_ORIGIN,
      BACKGROUND_IMAGE = _enums$STYLE_KEY$2.BACKGROUND_IMAGE,
      BACKGROUND_COLOR = _enums$STYLE_KEY$2.BACKGROUND_COLOR,
      BACKGROUND_POSITION_X = _enums$STYLE_KEY$2.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y = _enums$STYLE_KEY$2.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE = _enums$STYLE_KEY$2.BACKGROUND_SIZE,
      OPACITY = _enums$STYLE_KEY$2.OPACITY,
      Z_INDEX = _enums$STYLE_KEY$2.Z_INDEX,
      COLOR = _enums$STYLE_KEY$2.COLOR,
      FONT_SIZE$2 = _enums$STYLE_KEY$2.FONT_SIZE,
      FONT_FAMILY = _enums$STYLE_KEY$2.FONT_FAMILY,
      FONT_WEIGHT = _enums$STYLE_KEY$2.FONT_WEIGHT,
      FONT_STYLE = _enums$STYLE_KEY$2.FONT_STYLE,
      LINE_HEIGHT = _enums$STYLE_KEY$2.LINE_HEIGHT,
      TEXT_ALIGN = _enums$STYLE_KEY$2.TEXT_ALIGN,
      FILTER = _enums$STYLE_KEY$2.FILTER,
      VISIBILITY = _enums$STYLE_KEY$2.VISIBILITY,
      BOX_SHADOW = _enums$STYLE_KEY$2.BOX_SHADOW,
      POINTER_EVENTS = _enums$STYLE_KEY$2.POINTER_EVENTS,
      FILL = _enums$STYLE_KEY$2.FILL,
      STROKE = _enums$STYLE_KEY$2.STROKE,
      STROKE_WIDTH = _enums$STYLE_KEY$2.STROKE_WIDTH,
      STROKE_DASHARRAY = _enums$STYLE_KEY$2.STROKE_DASHARRAY,
      DISPLAY = _enums$STYLE_KEY$2.DISPLAY,
      FLEX_DIRECTION = _enums$STYLE_KEY$2.FLEX_DIRECTION,
      FLEX_GROW = _enums$STYLE_KEY$2.FLEX_GROW,
      FLEX_SHRINK = _enums$STYLE_KEY$2.FLEX_SHRINK,
      FLEX_BASIS = _enums$STYLE_KEY$2.FLEX_BASIS,
      JUSTIFY_CONTENT = _enums$STYLE_KEY$2.JUSTIFY_CONTENT,
      ALIGN_SELF = _enums$STYLE_KEY$2.ALIGN_SELF,
      ALIGN_ITEMS = _enums$STYLE_KEY$2.ALIGN_ITEMS,
      MATRIX = _enums$STYLE_KEY$2.MATRIX,
      LETTER_SPACING = _enums$STYLE_KEY$2.LETTER_SPACING,
      BACKGROUND_CLIP = _enums$STYLE_KEY$2.BACKGROUND_CLIP,
      WHITE_SPACE = _enums$STYLE_KEY$2.WHITE_SPACE,
      TEXT_OVERFLOW = _enums$STYLE_KEY$2.TEXT_OVERFLOW,
      LINE_CLAMP = _enums$STYLE_KEY$2.LINE_CLAMP,
      ORDER = _enums$STYLE_KEY$2.ORDER,
      FLEX_WRAP = _enums$STYLE_KEY$2.FLEX_WRAP,
      TRANSLATE_PATH = _enums$STYLE_KEY$2.TRANSLATE_PATH,
      TEXT_STROKE_COLOR = _enums$STYLE_KEY$2.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH = _enums$STYLE_KEY$2.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER = _enums$STYLE_KEY$2.TEXT_STROKE_OVER,
      WRITING_MODE = _enums$STYLE_KEY$2.WRITING_MODE;
  var AUTO = o.AUTO,
      PX$2 = o.PX,
      PERCENT$2 = o.PERCENT,
      NUMBER$1 = o.NUMBER,
      INHERIT$1 = o.INHERIT,
      DEG$1 = o.DEG,
      RGBA = o.RGBA,
      STRING = o.STRING,
      REM$2 = o.REM,
      VW$2 = o.VW,
      VH$2 = o.VH,
      VMAX$2 = o.VMAX,
      VMIN$2 = o.VMIN,
      GRADIENT = o.GRADIENT,
      calUnit$1 = o.calUnit;
  var isNil$3 = util.isNil,
      rgba2int$2 = util.rgba2int,
      equalArr$1 = util.equalArr,
      replaceRgba2Hex$1 = util.replaceRgba2Hex;
  var isGeom = o$2.isGeom,
      GEOM$2 = o$2.GEOM,
      GEOM_KEY_SET$2 = o$2.GEOM_KEY_SET;
  var VALID_STRING_VALUE$1 = reset.VALID_STRING_VALUE;
  var COLOR_HASH$1 = key.COLOR_HASH,
      LENGTH_HASH$1 = key.LENGTH_HASH,
      RADIUS_HASH$1 = key.RADIUS_HASH,
      GRADIENT_HASH$1 = key.GRADIENT_HASH,
      EXPAND_HASH$1 = key.EXPAND_HASH,
      GRADIENT_TYPE$1 = key.GRADIENT_TYPE;
  var TRANSFORM_HASH = {
    translateX: TRANSLATE_X,
    translateY: TRANSLATE_Y,
    translateZ: TRANSLATE_Z,
    scaleX: SCALE_X,
    scaleY: SCALE_Y,
    scaleZ: SCALE_Z,
    skewX: SKEW_X,
    skewY: SKEW_Y,
    rotateX: ROTATE_X,
    rotateY: ROTATE_Y,
    rotateZ: ROTATE_Z,
    rotate: ROTATE_Z
  };

  function compatibleTransform(k, arr) {
    if (k === SCALE_X || k === SCALE_Y || k === SCALE_Z) {
      arr[1] = NUMBER$1;
    } else if (k === TRANSLATE_X || k === TRANSLATE_Y || k === TRANSLATE_Z) {
      if (arr[1] === NUMBER$1) {
        arr[1] = PX$2;
      }
    } else if (k === PERSPECTIVE) {
      if ([NUMBER$1, PERCENT$2, DEG$1].indexOf(arr[1]) > -1) {
        arr[1] = PX$2;
      }
    } else {
      if (arr[1] === NUMBER$1) {
        arr[1] = DEG$1;
      }
    }
  }

  function camel(v) {
    if (isNil$3(v)) {
      v = '';
    }

    v = v.toString(); //有-才转换，否则可能是写好的驼峰

    if (v.indexOf('-') > -1) {
      return v.toString().toLowerCase().replace(/-([a-z])/ig, function ($0, $1) {
        return $1.toUpperCase();
      });
    }

    return v;
  }

  function convertStringValue(k, v) {
    v = camel(v);
    var list = VALID_STRING_VALUE$1[k];
    var i = list.indexOf(v);

    if (i > -1) {
      return list[i];
    } // 兜底默认


    return list[0];
  }
  /**
   * 将传入的手写style标准化，并且用resetList默认值覆盖其中为空的
   * @param style 手写的style样式
   * @param resetList 默认样式，可选
   * @returns Object 标准化的枚举数组结构样式
   */


  function normalize(style) {
    var resetList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!util.isObject(style)) {
      return {};
    }

    var res = {}; // style只有单层无需深度clone

    style = util.extend({}, style); // 缩写提前处理，因为reset里没有缩写

    var temp = style.border;

    if (temp) {
      abbr.toFull(style, 'border');
    }

    ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'].forEach(function (k) {
      abbr.toFull(style, k);
    });
    temp = style.borderWidth;

    if (temp) {
      abbr.toFull(style, 'borderWidth');
    }

    temp = style.borderColor;

    if (temp) {
      abbr.toFull(style, 'borderColor');
    }

    temp = style.borderStyle;

    if (temp) {
      abbr.toFull(style, 'borderStyle');
    }

    temp = style.borderRadius;

    if (temp) {
      abbr.toFull(style, 'borderRadius');
    }

    temp = style.background; // 处理渐变背景缩写

    if (temp) {
      abbr.toFull(style, 'background');
    } // 背景位置


    temp = style.backgroundPosition;

    if (!isNil$3(temp)) {
      abbr.toFull(style, 'backgroundPosition');
    } // flex


    temp = style.flex;

    if (temp) {
      abbr.toFull(style, 'flex');
    } // flex-flow


    temp = style.flexFlow;

    if (temp) {
      abbr.toFull(style, 'flexFlow');
    }

    temp = style.margin;

    if (!isNil$3(temp)) {
      abbr.toFull(style, 'margin');
    }

    temp = style.padding;

    if (!isNil$3(temp)) {
      abbr.toFull(style, 'padding');
    }

    temp = style.textStroke;

    if (temp) {
      abbr.toFull(style, 'textStroke');
    }

    temp = style.rotate3d;

    if (temp) {
      abbr.toFull(style, 'rotate3d');
    } // 扩展css，将transform几个值拆分为独立的css为动画准备，同时不能使用transform


    ['translate', 'scale', 'skew', 'translate3d', 'scale3d', 'rotate'].forEach(function (k) {
      temp = style[k];

      if (!isNil$3(temp)) {
        abbr.toFull(style, k);
      }
    }); // 扩展的不能和transform混用，给出警告

    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate3d'].forEach(function (k) {
      var v = style[k];

      if (v !== undefined && style.transform) {
        inject.warn("Can not use expand style \"".concat(k, "\" with transform"));
      }
    }); // 默认reset，根据传入不同，当style为空时覆盖

    resetList.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (isNil$3(style[k])) {
        style[k] = v;
      }
    }); // 背景图

    temp = style.backgroundImage;

    if (temp !== undefined) {
      if (!temp) {
        res[BACKGROUND_IMAGE] = [null];
      } else if (Array.isArray(temp)) {
        res[BACKGROUND_IMAGE] = temp.map(function (item) {
          if (!item) {
            return null;
          }

          if (reg.gradient.test(item)) {
            return [gradient$1.parseGradient(item), GRADIENT];
          }

          if (reg.img.test(item)) {
            return [reg.img.exec(item)[2], STRING];
          }

          return null;
        });
      } // 区分是渐变色还是图
      else if (reg.gradient.test(temp)) {
        res[BACKGROUND_IMAGE] = [[gradient$1.parseGradient(temp), GRADIENT]];
      } else if (reg.img.test(temp)) {
        res[BACKGROUND_IMAGE] = [[reg.img.exec(temp)[2], STRING]];
      } else {
        res[BACKGROUND_IMAGE] = [null];
      }
    }

    temp = style.backgroundColor;

    if (temp !== undefined) {
      temp = temp || 'transparent'; // 先赋值默认透明，后续操作有合法值覆盖

      var bgc = /^#[0-9a-f]{3,8}/i.exec(temp);

      if (bgc && [4, 7, 9].indexOf(bgc[0].length) > -1) {
        res[BACKGROUND_COLOR] = [rgba2int$2(bgc[0]), RGBA];
      } else {
        bgc = /rgba?\s*\(.+\)/i.exec(temp);
        res[BACKGROUND_COLOR] = [rgba2int$2(bgc ? bgc[0] : [0, 0, 0, 0]), RGBA];
      }
    }

    ['backgroundPositionX', 'backgroundPositionY'].forEach(function (k, i) {
      temp = style[k];

      if (temp !== undefined) {
        temp = temp || 0;
        k = i ? BACKGROUND_POSITION_Y : BACKGROUND_POSITION_X;

        if (!Array.isArray(temp)) {
          temp = [temp];
        }

        res[k] = temp.map(function (item) {
          if (/^[-+]?[\d.]/.test(item)) {
            var v = calUnit$1(item);

            if ([NUMBER$1, DEG$1].indexOf(v[1]) > -1) {
              v[1] = PX$2;
            }

            return v;
          } else {
            return [{
              top: 0,
              left: 0,
              center: 50,
              right: 100,
              bottom: 100
            }[item] || 0, PERCENT$2];
          }
        });
      }
    }); // 背景尺寸

    temp = style.backgroundSize;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[BACKGROUND_SIZE] = temp.map(function (item) {
        if (!item) {
          return [[0, AUTO], [0, AUTO]];
        }

        var match = item.toString().match(/\b(?:([-+]?[\d.]+[pxremvwhina%]*)|(contain|cover|auto))/ig);

        if (match) {
          if (match.length === 1) {
            if (match[0].toLowerCase() === 'contain' || match[0].toLowerCase() === 'cover') {
              match[1] = match[0].toLowerCase();
            } else {
              match[1] = 'auto';
            }
          }

          var v = [];

          for (var i = 0; i < 2; i++) {
            var _item = match[i].toLowerCase();

            if (/^[-+]?[\d.]/.test(_item)) {
              var n = calUnit$1(_item);

              if ([NUMBER$1, DEG$1].indexOf(n[1]) > -1) {
                n[1] = PX$2;
              }

              v.push(n);
            } else if (_item === 'contain' || _item === 'cover') {
              v.push([_item, STRING]);
            } else {
              v.push([0, AUTO]);
            }
          }

          return v;
        } else {
          return [[0, AUTO], [0, AUTO]];
        }
      });
    } // border-color


    ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
      k = 'border' + k + 'Color';
      var v = style[k];

      if (v !== undefined) {
        res[STYLE_KEY$3[style2Upper$1(k)]] = [rgba2int$2(v || 'transparent'), RGBA];
      }
    }); // border-radius

    ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].forEach(function (k) {
      k = 'border' + k + 'Radius';
      var v = style[k];

      if (v !== undefined) {
        v = v || 0;
        var arr = v.toString().split(/\s+/);

        if (arr.length === 1) {
          arr[1] = arr[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = arr[i];

          if (/^[-+]?[\d.]/.test(item)) {
            var n = calUnit$1(item);

            if ([NUMBER$1, DEG$1].indexOf(n[1]) > -1) {
              n[1] = PX$2;
            }

            if (n[0] < 0) {
              n[0] = 0;
            }

            arr[i] = n;
          } else {
            arr[i] = [0, PX$2];
          }
        }

        res[STYLE_KEY$3[style2Upper$1(k)]] = arr;
      }
    });
    temp = style.transform;

    if (temp === null) {
      res[TRANSFORM] = null;
    } else if (temp !== undefined) {
      var transform = res[TRANSFORM] = [];
      var match = (temp || '').toString().match(/\w+\(.+?\)/g);

      if (match) {
        match.forEach(function (item) {
          var i = item.indexOf('(');
          var k = item.slice(0, i);
          var v = item.slice(i + 1, item.length - 1);

          if (k === 'matrix') {
            var arr = v.toString().split(/\s*,\s*/);
            arr = arr.map(function (item) {
              return parseFloat(item);
            });

            if (arr.length > 6) {
              arr = arr.slice(0, 6);
            }

            if (arr.length === 6) {
              transform.push([MATRIX, [arr[0], arr[1], 0, 0, arr[2], arr[3], 0, 0, 0, 0, 1, 0, arr[4], arr[5], 0, 1]]);
            }
          } else if (k === 'matrix3d') {
            var _arr = v.toString().split(/\s*,\s*/);

            _arr = _arr.map(function (item) {
              return parseFloat(item);
            });

            if (_arr.length > 16) {
              _arr = _arr.slice(0, 16);
            }

            if (_arr.length === 16) {
              transform.push([MATRIX, _arr]);
            }
          } else if (k === 'perspective') {
            var _arr2 = calUnit$1(v);

            if (_arr2[0] < 0) {
              _arr2[0] = 0;
            }

            compatibleTransform(PERSPECTIVE, _arr2);
            transform.push([PERSPECTIVE, _arr2]);
          } else if (k === 'rotate3d') {
            var _arr3 = v.toString().split(/\s*,\s*/);

            if (_arr3.length === 4) {
              var deg = calUnit$1(_arr3[3]);
              compatibleTransform(ROTATE_3D, deg);
              _arr3[0] = parseFloat(_arr3[0].replace('(', ''));
              _arr3[1] = parseFloat(_arr3[1]);
              _arr3[2] = parseFloat(_arr3[2]);
              _arr3[3] = deg;
              transform.push([ROTATE_3D, _arr3]);
            }
          } else if (TRANSFORM_HASH.hasOwnProperty(k)) {
            var k2 = TRANSFORM_HASH[k];

            var _arr4 = calUnit$1(v);

            compatibleTransform(k2, _arr4);
            transform.push([k2, _arr4]);
          } else if ({
            translate: true,
            scale: true,
            skew: true
          }.hasOwnProperty(k)) {
            var _arr5 = v.toString().split(/\s*,\s*/);

            if (_arr5.length === 1) {
              _arr5[1] = k === 'scale' ? _arr5[0] : [0];
            }

            if (_arr5.length === 2) {
              var k1 = STYLE_KEY$3[style2Upper$1(k + 'X')];
              var _k = STYLE_KEY$3[style2Upper$1(k + 'Y')];
              var arr1 = calUnit$1(_arr5[0]);
              var arr2 = calUnit$1(_arr5[1]);
              compatibleTransform(k1, arr1);
              compatibleTransform(_k, arr2);
              transform.push([k1, arr1]);
              transform.push([_k, arr2]);
            }
          } else if ({
            translate3d: true,
            scale3d: true
          }.hasOwnProperty(k)) {
            var _arr6 = v.toString().split(/\s*,\s*/);

            if (_arr6.length === 1) {
              _arr6[1] = k === 'scale3d' ? [1] : [0];
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            } else if (_arr6.length === 2) {
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            }

            if (_arr6.length === 3) {
              var _k2 = STYLE_KEY$3[style2Upper$1(k + 'X')];
              var _k3 = STYLE_KEY$3[style2Upper$1(k + 'Y')];
              var k3 = STYLE_KEY$3[style2Upper$1(k + 'Z')];

              var _arr7 = calUnit$1(_arr6[0]);

              var _arr8 = calUnit$1(_arr6[1]);

              var arr3 = calUnit$1(_arr6[2]);
              compatibleTransform(_k2, _arr7);
              compatibleTransform(_k3, _arr8);
              compatibleTransform(k3, arr3);
              transform.push([_k2, _arr7]);
              transform.push([_k3, _arr8]);
              transform.push([k3, arr3]);
            }
          }
        });
      }
    }

    temp = style.perspective;

    if (temp !== undefined) {
      var arr = calUnit$1(temp || 0);

      if (arr[0] < 0) {
        arr[0] = 0;
      }

      compatibleTransform(PERSPECTIVE, arr);
      res[PERSPECTIVE] = arr;
    }

    ['perspectiveOrigin', 'transformOrigin'].forEach(function (k) {
      temp = style[k];

      if (temp !== undefined) {
        if (temp === null) {
          temp = '';
        }

        var _arr9 = res[STYLE_KEY$3[style2Upper$1(k)]] = [];

        var _match = temp.toString().match(reg.position);

        if (_match) {
          if (_match.length === 1) {
            _match[1] = _match[0];
          }

          for (var i = 0; i < 2; i++) {
            var item = _match[i];

            if (/^[-+]?[\d.]/.test(item)) {
              var n = calUnit$1(item);

              if ([NUMBER$1, DEG$1].indexOf(n[1]) > -1) {
                n[1] = PX$2;
              }

              _arr9.push(n);
            } else {
              _arr9.push([{
                top: 0,
                left: 0,
                center: 50,
                right: 100,
                bottom: 100
              }[item], PERCENT$2]); // 不规范的写法变默认值50%


              if (isNil$3(_arr9[i][0])) {
                _arr9[i][0] = 50;
              }
            }
          }
        } else {
          _arr9.push([50, PERCENT$2]);

          _arr9.push([50, PERCENT$2]);
        }
      }
    });
    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      if (v === null) {
        if (k.indexOf('scale') === 0) {
          v = 1;
        } else {
          v = 0;
        }
      }

      var k2 = TRANSFORM_HASH[k];
      var n = calUnit$1(v); // 没有单位或默认值处理单位

      compatibleTransform(k2, n);
      res[k2] = n;
    });
    temp = style.rotate3d;

    if (temp !== undefined) {
      var _arr10 = (temp || '').toString().split(/\s*,\s*/);

      if (_arr10.length === 4) {
        var deg = calUnit$1(_arr10[3]);
        compatibleTransform(ROTATE_3D, deg);
        _arr10[0] = parseFloat(_arr10[0].replace('(', ''));
        _arr10[1] = parseFloat(_arr10[1]);
        _arr10[2] = parseFloat(_arr10[2]);
        _arr10[3] = deg;
      }

      res[ROTATE_3D] = _arr10;
    }

    temp = style.opacity;

    if (temp !== undefined) {
      if (temp === null) {
        temp = 1;
      }

      temp = parseFloat(temp);

      if (!isNaN(temp)) {
        temp = Math.max(temp, 0);
        temp = Math.min(temp, 1);
        res[OPACITY] = temp;
      } else {
        res[OPACITY] = 1;
      }
    }

    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX] = parseInt(temp) || 0;
    } // 转化不同单位值为对象标准化，不写单位的变成number单位转化为px


    ['marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'top', 'right', 'bottom', 'left', 'width', 'height'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      if (v === 'auto') {
        v = [0, AUTO];
      } else {
        v = calUnit$1(v || 0); // 无单位视为px

        if ([NUMBER$1, DEG$1].indexOf(v[1]) > -1) {
          v[1] = PX$2;
        }
      }

      var k2 = STYLE_KEY$3[style2Upper$1(k)];
      res[k2] = v; // 限制padding/border为正数

      if ({
        paddingTop: true,
        paddingRight: true,
        paddingBottom: true,
        paddingLeft: true,
        borderTopWidth: true,
        borderRightWidth: true,
        borderBottomWidth: true,
        borderLeftWidth: true,
        width: true,
        height: true
      }.hasOwnProperty(k) && v[0] < 0) {
        v[0] = 0;
      }
    });
    temp = style.flexBasis;

    if (temp !== undefined) {
      if (/content/i.test(temp)) {
        res[FLEX_BASIS] = [temp, STRING];
      } else if (/^[\d.]/.test(temp)) {
        var v = res[FLEX_BASIS] = calUnit$1(temp);
        v[0] = Math.max(v[0], 0); // 无单位视为px

        if ([NUMBER$1, DEG$1].indexOf(v[1]) > -1) {
          v[1] = PX$2;
        }
      } else {
        res[FLEX_BASIS] = [0, AUTO];
      }
    }

    temp = style.order;

    if (temp !== undefined) {
      res[ORDER] = parseInt(temp) || 0;
    }

    temp = style.color;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[COLOR] = [[], INHERIT$1];
      } else if (reg.gradient.test(temp)) {
        res[COLOR] = [gradient$1.parseGradient(temp), GRADIENT];
      } else {
        res[COLOR] = [rgba2int$2(temp), RGBA];
      }
    }

    temp = style.textStrokeColor;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_COLOR] = [[], INHERIT$1];
      } else if (reg.gradient.test(temp)) {
        res[TEXT_STROKE_COLOR] = [gradient$1.parseGradient(temp), GRADIENT];
      } else {
        res[TEXT_STROKE_COLOR] = [rgba2int$2(temp), RGBA];
      }
    }

    temp = style.fontSize;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[FONT_SIZE$2] = [0, INHERIT$1];
      } else {
        var _v = calUnit$1(temp); // fontSize不能为负数，否则为继承


        if (_v < 0) {
          res[FONT_SIZE$2] = [0, INHERIT$1];
        } else {
          if ([NUMBER$1, DEG$1].indexOf(_v[1]) > -1) {
            _v[1] = PX$2;
          }

          res[FONT_SIZE$2] = _v;
        }
      }
    }

    temp = style.textStrokeWidth;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_WIDTH] = [0, INHERIT$1];
      } else {
        var _v2 = calUnit$1(temp); // textStrokeWidth不能为负数，否则为继承


        if (_v2 < 0) {
          res[TEXT_STROKE_WIDTH] = [0, INHERIT$1];
        } else {
          if ([NUMBER$1, DEG$1, PERCENT$2].indexOf(_v2[1]) > -1) {
            _v2[1] = PX$2;
          }

          res[TEXT_STROKE_WIDTH] = _v2;
        }
      }
    }

    temp = style.textStrokeOver;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_STROKE_OVER] = [0, INHERIT$1];
      } else {
        var _v3 = reset.INHERIT.textStrokeOver;

        if (/fill/i.test(temp)) {
          _v3 = 'fill';
        }

        res[TEXT_STROKE_OVER] = [_v3, STRING];
      }
    }

    temp = style.fontWeight;

    if (temp !== undefined) {
      if (/bold/i.test(temp)) {
        res[FONT_WEIGHT] = [700, NUMBER$1];
      } else if (/normal/i.test(temp)) {
        res[FONT_WEIGHT] = [400, NUMBER$1];
      } else if (/lighter/i.test(temp)) {
        res[FONT_WEIGHT] = [200, NUMBER$1];
      } else if (/inherit/i.test(temp)) {
        res[FONT_WEIGHT] = [0, INHERIT$1];
      } else {
        res[FONT_WEIGHT] = [Math.max(0, parseInt(temp)) || 400, NUMBER$1];
      }
    }

    temp = style.fontStyle;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_STYLE] = [0, INHERIT$1];
      } else {
        var _v4 = reset.INHERIT.fontStyle;

        if (/italic/i.test(temp)) {
          _v4 = 'italic';
        } else if (/oblique/i.test(temp)) {
          _v4 = 'oblique';
        }

        res[FONT_STYLE] = [_v4, STRING];
      }
    }

    temp = style.fontFamily;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_FAMILY] = [0, INHERIT$1];
      } else {
        // 统一文字声明格式
        res[FONT_FAMILY] = [temp.toString().toLowerCase().replace(/['"]/, '').replace(/\s*,\s*/g, ','), STRING];
      }
    }

    temp = style.writingMode;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WRITING_MODE] = [0, INHERIT$1];
      } else {
        var _v5 = reset.INHERIT.writingMode;

        if (/vertical-?rl/i.test(temp)) {
          _v5 = 'verticalRl';
        } else if (/vertical-?lr/i.test(temp)) {
          _v5 = 'verticalLr';
        }

        res[WRITING_MODE] = [_v5, STRING];
      }
    }

    temp = style.textAlign;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_ALIGN] = [0, INHERIT$1];
      } else {
        var _v6 = 'left';

        if (/center/i.test(temp)) {
          _v6 = 'center';
        } else if (/right/i.test(temp)) {
          _v6 = 'right';
        }

        res[TEXT_ALIGN] = [_v6, STRING];
      }
    }

    temp = style.lineHeight;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[LINE_HEIGHT] = [0, INHERIT$1];
      } else if (/normal/i.test(temp)) {
        res[LINE_HEIGHT] = [0, AUTO];
      } // lineHeight默认数字，想要px必须强制带单位
      else if (/^[\d.]+/i.test(temp)) {
        var _v7 = calUnit$1(temp);

        if ([DEG$1].indexOf(_v7[1]) > -1) {
          _v7[1] = NUMBER$1;
        }

        res[LINE_HEIGHT] = _v7;
      } else {
        var n = Math.max(0, parseFloat(temp)) || 'normal'; // 非法数字

        if (n === 'normal') {
          res[LINE_HEIGHT] = [null, AUTO];
        } else {
          res[LINE_HEIGHT] = [n, NUMBER$1];
        }
      }
    }

    temp = style.letterSpacing;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[LETTER_SPACING] = [0, INHERIT$1];
      } else if (/normal/i.test(temp)) {
        res[LETTER_SPACING] = [0, PX$2];
      } else if (/^[-+]?[\d.]/.test(temp)) {
        var _v8 = calUnit$1(temp);

        if ([NUMBER$1, DEG$1].indexOf(_v8[1]) > -1) {
          _v8[1] = PX$2;
        }

        res[LETTER_SPACING] = _v8;
      } else {
        res[LETTER_SPACING] = [parseFloat(temp) || 0, PX$2];
      }
    }

    temp = style.whiteSpace;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WHITE_SPACE] = [0, INHERIT$1];
      } else {
        res[WHITE_SPACE] = [temp, STRING];
      }
    }

    temp = style.lineClamp;

    if (temp !== undefined) {
      temp = parseInt(temp) || 0;
      res[LINE_CLAMP] = Math.max(0, temp);
    } // fill和stroke为渐变时特殊处理，fillRule无需处理字符串


    temp = style.fill;

    if (temp !== undefined) {
      if (!temp) {
        res[FILL] = [['none', STRING]];
      } else if (Array.isArray(temp)) {
        if (temp.length) {
          res[FILL] = temp.map(function (item) {
            if (!item) {
              return ['none', STRING];
            } else if (reg.gradient.test(item)) {
              return [gradient$1.parseGradient(item), GRADIENT];
            } else {
              return [rgba2int$2(item), RGBA];
            }
          });
        } else {
          res[FILL] = [['none', STRING]];
        }
      } else if (reg.gradient.test(temp)) {
        res[FILL] = [[gradient$1.parseGradient(temp), GRADIENT]];
      } else {
        res[FILL] = [[rgba2int$2(temp), RGBA]];
      }
    }

    temp = style.stroke;

    if (temp !== undefined) {
      if (!temp) {
        res[STROKE] = [['none', STRING]];
      } else if (Array.isArray(temp)) {
        if (temp.length) {
          res[STROKE] = temp.map(function (item) {
            if (!item) {
              return ['none', STRING];
            } else if (reg.gradient.test(item)) {
              return [gradient$1.parseGradient(item), GRADIENT];
            } else {
              return [rgba2int$2(item), RGBA];
            }
          });
        } else {
          res[STROKE] = [['none', STRING]];
        }
      } else if (reg.gradient.test(temp)) {
        res[STROKE] = [[gradient$1.parseGradient(temp), GRADIENT]];
      } else {
        res[STROKE] = [[rgba2int$2(temp), RGBA]];
      }
    }

    temp = style.strokeWidth;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[STROKE_WIDTH] = temp.map(function (item) {
        var v = calUnit$1(item);

        if ([NUMBER$1, DEG$1].indexOf(v[1]) > -1) {
          v[1] = PX$2;
        }

        v[0] = Math.max(v[0], 0);
        return v;
      });
    }

    temp = style.strokeDasharray;

    if (temp !== undefined) {
      if (Array.isArray(temp)) {
        res[STROKE_DASHARRAY] = temp.map(function (item) {
          var match = (item || '').toString().match(/[\d.]+/g);

          if (match) {
            match = match.map(function (item) {
              return parseFloat(item);
            });

            if (match.length % 2 === 1) {
              match.push(match[match.length - 1]);
            }

            return match;
          }

          return [];
        });
      } else {
        var _match2 = (temp || '').toString().match(/[\d.]+/g);

        if (_match2) {
          _match2 = _match2.map(function (item) {
            return parseFloat(item);
          });

          if (_match2.length % 2 === 1) {
            _match2.push(_match2[_match2.length - 1]);
          }

          res[STROKE_DASHARRAY] = [_match2];
        } else {
          res[STROKE_DASHARRAY] = [[]];
        }
      }
    }

    temp = style.filter;

    if (temp !== undefined) {
      var f = null; // 先替换掉rgba为#RGBA格式，然后分割

      var _arr11 = (replaceRgba2Hex$1(temp) || '').match(/[\w-]+\s*\(.+?\)/ig);

      if (_arr11) {
        _arr11.forEach(function (item) {
          var match = /([\w-]+)\s*\((\s*.+\s*)\)/i.exec(item);

          if (match) {
            var k = match[1].toLowerCase(),
                _v9 = match[2];

            if (k === 'drop-shadow' || k === 'dropshadow') {
              var coords = /([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*\s*)?([-+]?[\d.]+[pxremvwhina%]*\s*)?/i.exec(item);

              if (coords) {
                f = f || [];
                var _res = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

                for (var i = 1; i <= 4; i++) {
                  var item2 = coords[i];

                  if (item2) {
                    var _v10 = calUnit$1(item2);

                    if ([NUMBER$1, DEG$1].indexOf(_v10[1]) > -1) {
                      _v10[1] = PX$2;
                    } // x/y可以负，blur和spread不行


                    if (i > 2 && _v10[0] < 0) {
                      _v10 = 0;
                    }

                    _res.push(_v10);
                  } else {
                    _res.push([0, 1]);
                  }
                }

                var color = /#[a-f\d]{3,8}/i.exec(item);

                if (color) {
                  _res.push(rgba2int$2(color[0]));
                } else {
                  _res.push([0, 0, 0, 1]);
                }

                f.push(['dropShadow', _res]);
              }
            } else {
              var m2 = /([-+]?[\d.]+\s*[pxremvwhdg%]*)/i.exec(_v9);

              if (m2) {
                f = f || [];

                var _v11 = calUnit$1(m2[0]);

                if (k === 'blur') {
                  if ([DEG$1, PERCENT$2].indexOf(_v11[1]) > -1) {
                    return;
                  }

                  if (_v11[1] === NUMBER$1) {
                    _v11[1] = PX$2;
                  }

                  _v11[0] = Math.max(_v11[0], 0);
                  f.push([k, _v11]);
                } else if (k === 'hue-rotate' || k === 'huerotate') {
                  if ([NUMBER$1, DEG$1].indexOf(_v11[1]) === -1) {
                    return;
                  }

                  _v11[1] = DEG$1;
                  f.push(['hueRotate', _v11]);
                } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
                  if ([NUMBER$1, PERCENT$2].indexOf(_v11[1]) === -1) {
                    return;
                  }

                  _v11[0] = Math.max(_v11[0], 0);
                  _v11[1] = PERCENT$2;
                  f.push([k, _v11]);
                }
              }
            }
          }
        });
      }

      res[FILTER] = f;
    }

    temp = style.visibility;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[VISIBILITY] = [0, INHERIT$1];
      } else {
        var _v12 = reset.INHERIT.visibility;

        if (/hidden/i.test(temp)) {
          _v12 = 'hidden';
        }

        res[VISIBILITY] = [_v12, STRING];
      }
    }

    temp = style.pointerEvents;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[POINTER_EVENTS] = [0, INHERIT$1];
      } else {
        var _v13 = reset.INHERIT.pointerEvents;

        if (/none/i.test(temp)) {
          _v13 = 'none';
        }

        res[POINTER_EVENTS] = [_v13, STRING];
      }
    }

    temp = style.boxShadow;

    if (temp !== undefined) {
      var bs = null; // 先替换掉rgba为#RGBA格式，然后按逗号分割

      var _arr12 = (replaceRgba2Hex$1(temp) || '').split(',');

      if (_arr12) {
        _arr12.forEach(function (item) {
          var coords = /([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*\s*)?([-+]?[\d.]+[pxremvwhina%]*\s*)?/i.exec(item);

          if (coords) {
            bs = bs || [];
            var _res2 = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

            for (var i = 1; i <= 4; i++) {
              var item2 = coords[i];

              if (item2) {
                var _v14 = calUnit$1(item2);

                if ([NUMBER$1, DEG$1].indexOf(_v14[1]) > -1) {
                  _v14[1] = PX$2;
                } // x/y可以负，blur和spread不行


                if (i > 2 && _v14[0] < 0) {
                  _v14 = 0;
                }

                _res2.push(_v14);
              } else {
                _res2.push([0, 1]);
              }
            }

            var color = /#[a-f\d]{3,8}/i.exec(item);

            if (color) {
              _res2.push(rgba2int$2(color[0]));
            } else {
              _res2.push([0, 0, 0, 1]);
            }

            _res2.push(/inset/i.test(item) ? 'inset' : 'outset');

            bs.push(_res2);
          }
        });
      }

      res[BOX_SHADOW] = bs;
    } // 直接赋值的string类型


    ['position', 'display', 'flexDirection', 'flexWrap', 'justifyContent', 'alignItems', 'alignSelf', 'alignContent', 'overflow', 'mixBlendMode', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'backgroundClip', 'textOverflow'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$3[style2Upper$1(k)]] = convertStringValue(k, style[k]);
      }
    }); // 直接赋值的number类型

    ['flexGrow', 'flexShrink'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$3[style2Upper$1(k)]] = Math.max(parseFloat(style[k]) || 0, 0);
      }
    });
    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX] = parseFloat(temp) || 0;
    } // 这些支持多个的用数组表示


    ['backgroundRepeat', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'fillRule'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        var _v15 = style[k];

        if (!Array.isArray(_v15)) {
          _v15 = [_v15];
        }

        if (k === 'backgroundRepeat') {
          _v15.forEach(function (item, i) {
            if (item) {
              _v15[i] = camel(item);
            }
          });
        }

        res[STYLE_KEY$3[style2Upper$1(k)]] = _v15;
      }
    });
    GEOM_KEY_SET$2.forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[k] = style[k];
      }
    });
    return res;
  }

  function setFontStyle(style) {
    var fontSize = style[FONT_SIZE$2] || 0;
    var fontFamily = style[FONT_FAMILY] || inject.defaultFontFamily || 'arial';

    if (/\s/.test(fontFamily)) {
      fontFamily = '"' + fontFamily.replace(/"/g, '\\"') + '"';
    }

    return (style[FONT_STYLE] || 'normal') + ' ' + (style[FONT_WEIGHT] || '400') + ' ' + fontSize + 'px/' + fontSize + 'px ' + fontFamily;
  }

  function getFontFamily(str) {
    var ff = str.split(/\s*,\s*/);
    var f = inject.defaultFontFamily;

    for (var i = 0, len = ff.length; i < len; i++) {
      var fontFamily = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

      if (!o$1.hasRegister(fontFamily)) {
        continue;
      }

      if (!o$1.hasChecked(fontFamily)) {
        var res = inject.checkSupportFontFamily(fontFamily);

        if (o$1.setChecked(fontFamily, res)) {
          f = fontFamily;
          break;
        }
      }

      if (o$1.support(fontFamily)) {
        f = fontFamily;
        break;
      }
    }

    return f;
  }
  /**
   * https://zhuanlan.zhihu.com/p/25808995
   * 根据字形信息计算baseline的正确值，差值上下均分
   * @param style
   * @returns {number}
   */


  function getBaseline(style) {
    var fontSize = style[FONT_SIZE$2];
    var ff = getFontFamily(style[FONT_FAMILY]);
    var normal = calNormalLineHeight(style, ff);
    return (style[LINE_HEIGHT] - normal) * 0.5 + fontSize * (o$1.info[ff] || o$1.info[inject.defaultFontFamily] || o$1.info.arial).blr;
  } // 垂直排版的baseline和水平类似，只是原点坐标系不同，删除加本身高度变为加gap高度


  function getVerticalBaseline(style) {
    return style[LINE_HEIGHT] - getBaseline(style);
  }

  function calNormalLineHeight(style, ff) {
    ff = ff || getFontFamily(style[FONT_FAMILY]);
    return style[FONT_SIZE$2] * (o$1.info[ff] || o$1.info[inject.defaultFontFamily] || o$1.info.arial).lhr;
  }

  function calRelativePercent(n, parent, k) {
    n *= 0.01;

    while (parent) {
      var style = parent.currentStyle[k];

      if (style[1] === AUTO) {
        if (k === WIDTH$1) {
          parent = parent.domParent;
        } else {
          break;
        }
      } else if (style[1] === PX$2) {
        return n * style[0];
      } else if (style[1] === PERCENT$2) {
        n *= style[0] * 0.01;
        parent = parent.domParent;
      } else if (style[1] === REM$2) {
        return n * style[0] * parent.root.computedStyle[FONT_SIZE$2];
      } else if (style[1] === VW$2) {
        return n * style[0] * parent.root.width * 0.01;
      } else if (style[1] === VH$2) {
        return n * style[0] * parent.root.height * 0.01;
      } else if (style[1] === VMAX$2) {
        return n * style[0] * Math.max(parent.root.width, parent.root.height) * 0.01;
      } else if (style[1] === VMIN$2) {
        return n * style[0] * Math.min(parent.root.width, parent.root.height) * 0.01;
      }
    }

    return n;
  }

  function calRelative(currentStyle, k, v, parent, isWidth) {
    if (v[1] === AUTO) {
      v = 0;
    } else if ([PX$2, NUMBER$1].indexOf(v[1]) > -1) {
      v = v[0];
    } else if (v[1] === PERCENT$2) {
      if (isWidth) {
        v = calRelativePercent(v[0], parent, WIDTH$1);
      } else {
        v = calRelativePercent(v[0], parent, HEIGHT$1);
      }
    } else if (v[1] === REM$2) {
      v = v[0] * parent.root.computedStyle[FONT_SIZE$2];
    } else if (v[1] === VW$2) {
      v = v[0] * parent.root.width * 0.01;
    } else if (v[1] === VH$2) {
      v = v[0] * parent.root.height * 0.01;
    } else if (v[1] === VMAX$2) {
      v = v[0] * Math.max(parent.root.width, parent.root.height) * 0.01;
    } else if (v[1] === VMIN$2) {
      v = v[0] * Math.min(parent.root.width, parent.root.height) * 0.01;
    }

    return v;
  }

  function equalStyle(k, a, b, target) {
    if (!a || !b) {
      return a === b;
    }

    if (k === TRANSFORM) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0, len = a.length; i < len; i++) {
        var oa = a[i];
        var ob = b[i];

        if (oa[0] !== ob[0]) {
          return false;
        } // translate/matrix等都是数组


        if (!equalArr$1(oa[1], ob[1])) {
          return false;
        }
      }

      return true;
    }

    if (k === FILTER) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i = 0, _len = a.length; _i < _len; _i++) {
        if (!equalArr$1(a[_i], b[_i])) {
          return false;
        }
      }
    }

    if (k === BACKGROUND_SIZE) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        var aa = a[_i2],
            bb = b[_i2];

        if (aa[0][0] !== bb[0][0] || aa[0][1] !== bb[0][1] || aa[1][0] !== bb[1][0] || aa[1][1] !== bb[1][1]) {
          return false;
        }
      }

      return true;
    }

    if (k === TRANSFORM_ORIGIN$1 || RADIUS_HASH$1.hasOwnProperty(k)) {
      return a[0][0] === b[0][0] && a[0][1] === b[0][1] && a[1][0] === b[1][0] && a[1][1] === b[1][1];
    }

    if (k === BACKGROUND_POSITION_X || k === BACKGROUND_POSITION_Y || LENGTH_HASH$1.hasOwnProperty(k) || EXPAND_HASH$1.hasOwnProperty(k)) {
      return a[0] === b[0] && a[1] === b[1];
    }

    if (k === BOX_SHADOW) {
      return equalArr$1(a, b);
    } // color等是rgba颜色时


    if (k === COLOR || k === TEXT_STROKE_COLOR) {
      if (a[1] !== b[1]) {
        return false;
      }

      if (a[1] === RGBA) {
        return equalArr$1(a[0], b[0]);
      }
    }

    if (COLOR_HASH$1.hasOwnProperty(k)) {
      return a[1] === b[1] && equalArr$1(a[0], b[0]);
    } // color/fill等是gradient时


    if (GRADIENT_HASH$1.hasOwnProperty(k) && a.k === b.k && GRADIENT_TYPE$1.hasOwnProperty(a.k)) {
      var av = a.v;
      var bv = b.v;

      if (a.d !== b.d || av.length !== bv.length) {
        return false;
      }

      for (var _i3 = 0, _len3 = av.length; _i3 < _len3; _i3++) {
        var ai = av[_i3];
        var bi = bv[_i3];

        if (ai.length !== bi.length) {
          return false;
        }

        for (var j = 0; j < 4; j++) {
          if (ai[0][j] !== bi[0][j]) {
            return false;
          }
        }

        if (ai.length > 1) {
          if (ai[1][0] !== bi[1][0] || ai[1][1] !== bi[1][1]) {
            return false;
          }
        }
      }

      return true;
    } // multi都是纯值数组，equalArr本身即递归，非multi根据类型判断


    if (isGeom(target.tagName, k) && (target.isMulti || Array.isArray(a) && Array.isArray(b))) {
      return equalArr$1(a, b);
    }

    return a === b;
  }

  function isRelativeOrAbsolute(node) {
    var position = node.currentStyle[POSITION];
    return position === 'relative' || position === 'absolute';
  }

  var VALUE = (_VALUE = {}, _defineProperty(_VALUE, POSITION, true), _defineProperty(_VALUE, DISPLAY, true), _defineProperty(_VALUE, STYLE_KEY$3.BACKGROUND_REPEAT, true), _defineProperty(_VALUE, FLEX_DIRECTION, true), _defineProperty(_VALUE, FLEX_GROW, true), _defineProperty(_VALUE, FLEX_SHRINK, true), _defineProperty(_VALUE, FLEX_WRAP, true), _defineProperty(_VALUE, JUSTIFY_CONTENT, true), _defineProperty(_VALUE, ALIGN_ITEMS, true), _defineProperty(_VALUE, ALIGN_SELF, true), _defineProperty(_VALUE, STYLE_KEY$3.OVERFLOW, true), _defineProperty(_VALUE, STYLE_KEY$3.MIX_BLEND_MODE, true), _defineProperty(_VALUE, STYLE_KEY$3.STROKE_LINECAP, true), _defineProperty(_VALUE, STYLE_KEY$3.STROKE_LINEJOIN, true), _defineProperty(_VALUE, STYLE_KEY$3.STROKE_MITERLIMIT, true), _defineProperty(_VALUE, STYLE_KEY$3.FILL_RULE, true), _defineProperty(_VALUE, OPACITY, true), _defineProperty(_VALUE, Z_INDEX, true), _defineProperty(_VALUE, BACKGROUND_CLIP, true), _defineProperty(_VALUE, TEXT_OVERFLOW, true), _defineProperty(_VALUE, LINE_CLAMP, true), _VALUE); // 仅1维数组

  var ARRAY_0 = (_ARRAY_ = {}, _defineProperty(_ARRAY_, BACKGROUND_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$3.BORDER_TOP_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$3.BORDER_RIGHT_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$3.BORDER_BOTTOM_COLOR, true), _defineProperty(_ARRAY_, STYLE_KEY$3.BORDER_LEFT_COLOR, true), _ARRAY_); // 仅2维数组且只有2个值

  var ARRAY_0_1 = (_ARRAY_0_ = {}, _defineProperty(_ARRAY_0_, STYLE_KEY$3.BORDER_TOP_LEFT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$3.BORDER_TOP_RIGHT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$3.BORDER_BOTTOM_RIGHT_RADIUS, true), _defineProperty(_ARRAY_0_, STYLE_KEY$3.BORDER_BOTTOM_LEFT_RADIUS, true), _defineProperty(_ARRAY_0_, TRANSFORM_ORIGIN$1, true), _defineProperty(_ARRAY_0_, PERSPECTIVE_ORIGIN, true), _ARRAY_0_);

  function cloneStyle(style, keys) {
    if (!keys) {
      keys = Object.keys(style).map(function (i) {
        if (!GEOM$2.hasOwnProperty(i)) {
          i = parseInt(i);
        }

        return i;
      });
    }

    var res = {};

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      var v = style[k]; // 渐变特殊处理

      if (k === BACKGROUND_IMAGE) {
        res[k] = v.map(function (item) {
          if (item[1] === GRADIENT) {
            return [util.clone(item[0]), item[1]];
          } else {
            return item;
          }
        });
      } else if (k === FILL || k === STROKE) {
        res[k] = v.map(function (item) {
          // 渐变可能非法为空
          if (item[1] === GRADIENT) {
            return [util.clone(item[0]), item[1]];
          } // 颜色
          else if (item[1] === RGBA) {
            return [item[0].slice(0), item[1]];
          } // none
          else {
            return item;
          }
        });
      } else if (k === TRANSFORM) {
        if (v) {
          var n = v.slice(0);

          for (var _i4 = 0, _len4 = n.length; _i4 < _len4; _i4++) {
            n[_i4] = n[_i4].slice(0);
            n[_i4][1] = n[_i4][1].slice(0);
          }

          res[k] = n;
        }
      } else if (k === FILTER) {
        if (v) {
          var _n = v.slice(0);

          for (var _i5 = 0, _len5 = _n.length; _i5 < _len5; _i5++) {
            _n[_i5] = _n[_i5].slice(0);
            var _k4 = _n[_i5][0];
            _n[_i5][1] = _n[_i5][1].slice(0);

            if (_k4 === 'dropShadow') {
              (function () {
                var temp = _n[_i5][1];
                temp.forEach(function (item, j) {
                  temp[j] = temp[j].slice(0);
                });
              })();
            }
          }

          res[k] = _n;
        }
      } else if (k === BOX_SHADOW) {
        if (v) {
          v = v.map(function (item) {
            var n = item.slice(0);
            n[4] = n[4].slice(0);
            return n;
          });
          res[k] = v;
        }
      } else if (k === TRANSLATE_PATH) {
        if (v) {
          res[k] = v.map(function (item) {
            return item.slice(0);
          });
        }
      } else if (k === COLOR || k === TEXT_STROKE_COLOR) {
        if (v) {
          if (v[1] === GRADIENT) {
            res[k] = [util.clone(v[0]), v[1]];
          } else if (v[1] === RGBA) {
            res[k] = [v[0].slice(0), v[1]];
          } // inherit
          else {
            res[k] = v.slice(0);
          }
        }
      } // position等直接值类型赋值
      else if (VALUE.hasOwnProperty(k)) {
        res[k] = v;
      } // geom自定义属性
      else if (GEOM$2.hasOwnProperty(k)) {
        res[k] = util.clone(v);
      } // 其余皆是数组或空，默认是一维数组只需slice即可
      else if (v) {
        var _n2 = res[k] = v.slice(0); // 特殊引用里数组某项再次clone


        if (k === BACKGROUND_POSITION_X || k === BACKGROUND_POSITION_Y) {
          for (var _i6 = 0, _len6 = _n2.length; _i6 < _len6; _i6++) {
            _n2[_i6] = _n2[_i6].slice(0);
          }
        } else if (k === BACKGROUND_SIZE) {
          for (var _i7 = 0, _len7 = _n2.length; _i7 < _len7; _i7++) {
            _n2[_i7] = _n2[_i7].slice(0);
            _n2[_i7][0] = _n2[_i7][0].slice(0);
            _n2[_i7][1] = _n2[_i7][1].slice(0);
          }
        } else if (ARRAY_0.hasOwnProperty(k)) {
          _n2[0] = _n2[0].slice(0);
        } else if (ARRAY_0_1.hasOwnProperty(k)) {
          _n2[0] = _n2[0].slice(0);
          _n2[1] = _n2[1].slice(0);
        } else if (k === TRANSFORM) {
          for (var _i8 = 0, _len8 = _n2.length; _i8 < _len8; _i8++) {
            _n2[_i8] = _n2[_i8].slice(0);
          }
        } else if (k === ROTATE_3D) {
          _n2[3] = _n2[3].slice(0);
        }
      }
    }

    return res;
  }

  function spreadBoxShadow(bbox, boxShadow) {
    var _bbox = _slicedToArray(bbox, 4),
        x1 = _bbox[0],
        y1 = _bbox[1],
        x2 = _bbox[2],
        y2 = _bbox[3];

    if (Array.isArray(boxShadow)) {
      var xl = 0,
          yt = 0,
          xr = 0,
          yb = 0;
      boxShadow.forEach(function (item) {
        var _item2 = _slicedToArray(item, 6),
            x = _item2[0],
            y = _item2[1],
            sigma = _item2[2],
            spread = _item2[3],
            color = _item2[4],
            inset = _item2[5];

        if (inset !== 'inset' && color[3] > 0) {
          var d = blur.outerSize(sigma);
          d += spread;
          xl = Math.min(xl, x - d);
          yt = Math.min(yt, x - d);
          xr = Math.max(xr, x + d);
          yb = Math.max(yb, y + d);
        }
      });
      x1 += xl;
      y1 += yt;
      x2 += xr;
      y2 += yb;
    }

    return [x1, y1, x2, y2];
  }

  function spreadFilter(bbox, filter) {
    var _bbox2 = _slicedToArray(bbox, 4),
        x1 = _bbox2[0],
        y1 = _bbox2[1],
        x2 = _bbox2[2],
        y2 = _bbox2[3]; // filter对整体有影响，且filter子项可以先后多次重复出现，上面计算完后，依次处理


    if (Array.isArray(filter)) {
      filter.forEach(function (item) {
        var _item3 = _slicedToArray(item, 2),
            k = _item3[0],
            v = _item3[1];

        if (k === 'blur' && v > 0) {
          var d = blur.kernelSize(v);
          var spread = blur.outerSizeByD(d);

          if (spread) {
            x1 -= spread;
            y1 -= spread;
            x2 += spread;
            y2 += spread;
          }
        } else if (k === 'dropShadow') {
          var _d = blur.kernelSize(v[2]);

          var _spread = blur.outerSizeByD(_d); // x/y/blur，3个一起影响，要考虑正负号，spread一定为非负


          if (v[0] || v[1] || _spread) {
            if (v[0] <= 0 || v[0] > 0 && v[0] < _spread) {
              x1 += v[0] - _spread;
            }

            if (v[1] <= 0 || v[1] > 0 && v[1] < _spread) {
              y1 += v[1] - _spread;
            }

            if (v[0] < 0 && -v[0] < _spread || v[0] >= 0) {
              x2 += v[0] + _spread;
            }

            if (v[1] < 0 && -v[1] < _spread || v[1] >= 0) {
              y2 += v[1] + _spread;
            }
          }
        }
      });
    }

    return [x1, y1, x2, y2];
  }

  var css = {
    normalize: normalize,
    setFontStyle: setFontStyle,
    getFontFamily: getFontFamily,
    getBaseline: getBaseline,
    getVerticalBaseline: getVerticalBaseline,
    calRelative: calRelative,
    equalStyle: equalStyle,
    isRelativeOrAbsolute: isRelativeOrAbsolute,
    cloneStyle: cloneStyle,
    calNormalLineHeight: calNormalLineHeight,
    spreadBoxShadow: spreadBoxShadow,
    spreadFilter: spreadFilter
  };

  function calDeg(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    var atan = Math.atan(Math.abs(dy) / Math.abs(dx)); // 2象限

    if (dx < 0 && dy >= 0) {
      return Math.PI - atan;
    } // 3象限


    if (dx < 0 && dy < 0) {
      return atan - Math.PI;
    } // 1象限


    if (dx >= 0 && dy >= 0) {
      return atan;
    } // 4象限，顺时针正好


    return -atan;
  }

  function rotate(theta) {
    var sin = Math.sin(theta);
    var cos = Math.cos(theta);
    var t = mx.identity();
    t[0] = t[5] = cos;
    t[1] = sin;
    t[4] = -sin;
    return t;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param points
   */


  function pointIndex(points) {
    var _points = _slicedToArray(points, 6),
        x1 = _points[0],
        y1 = _points[1],
        x2 = _points[2],
        y2 = _points[3],
        x3 = _points[4],
        y3 = _points[5];

    var index = [0, 1, 2]; // 将a点放入最左

    if (x2 < x1 && x2 < x3) {
      var _ref = [x2, y2, x1, y1];
      x1 = _ref[0];
      y1 = _ref[1];
      x2 = _ref[2];
      y2 = _ref[3];
      index[0] = 1;
      index[1] = 0;
    } else if (x3 < x2 && x3 < x1) {
      var _ref2 = [x3, y3, x1, y1];
      x1 = _ref2[0];
      y1 = _ref2[1];
      x3 = _ref2[2];
      y3 = _ref2[3];
      index[0] = 2;
      index[2] = 0;
    } // 有可能出现2个并列的情况，判断取上面那个


    if (x1 === x2) {
      if (y1 > y2) {
        var _ref3 = [x2, y2, x1, y1];
        x1 = _ref3[0];
        y1 = _ref3[1];
        x2 = _ref3[2];
        y2 = _ref3[3];
        var t = index[0];
        index[0] = index[1];
        index[1] = t;
      }
    } else if (x1 === x3) {
      if (y1 > y3) {
        var _ref4 = [x3, y3, x1, y1];
        x1 = _ref4[0];
        y1 = _ref4[1];
        x3 = _ref4[2];
        y3 = _ref4[3];
        var _t = index[0];
        index[0] = index[2];
        index[2] = _t;
      }
    } // ab到ac要顺时针旋转，即2个向量夹角为正，用向量叉乘判断正负


    var cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);

    if (cross < 0) {
      var _ref5 = [x3, y3, x2, y2];
      x2 = _ref5[0];
      y2 = _ref5[1];
      x3 = _ref5[2];
      y3 = _ref5[3];
      var _t2 = index[1];
      index[1] = index[2];
      index[2] = _t2;
    }

    return [x1, y1, x2, y2, x3, y3, index];
  }
  /**
   * 第2个点根据第一个点的交换顺序交换
   * @param points
   * @param index
   * @returns {[]}
   */


  function pointByIndex(points, index) {
    var res = [];

    for (var i = 0, len = index.length; i < len; i++) {
      var j = index[i];
      res.push(points[j * 2]);
      res.push(points[j * 2 + 1]);
    }

    return res;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param source 源3个点
   * @param target 目标3个点
   * @returns 交换顺序后的点坐标
   */


  function exchangeOrder(source, target) {
    var _pointIndex = pointIndex(source),
        _pointIndex2 = _slicedToArray(_pointIndex, 7),
        sx1 = _pointIndex2[0],
        sy1 = _pointIndex2[1],
        sx2 = _pointIndex2[2],
        sy2 = _pointIndex2[3],
        sx3 = _pointIndex2[4],
        sy3 = _pointIndex2[5],
        index = _pointIndex2[6];

    var _pointByIndex = pointByIndex(target, index),
        _pointByIndex2 = _slicedToArray(_pointByIndex, 6),
        tx1 = _pointByIndex2[0],
        ty1 = _pointByIndex2[1],
        tx2 = _pointByIndex2[2],
        ty2 = _pointByIndex2[3],
        tx3 = _pointByIndex2[4],
        ty3 = _pointByIndex2[5];

    return [[sx1, sy1, sx2, sy2, sx3, sy3], [tx1, ty1, tx2, ty2, tx3, ty3]];
  }
  /**
   * 存在一种情况，变换结果使得三角形镜像相反了，即顶点a越过bc线，判断是否溢出
   * @param source
   * @param target
   * @returns {boolean}是否溢出
   */


  function isOverflow(source, target) {
    var _source = _slicedToArray(source, 6),
        sx1 = _source[0],
        sy1 = _source[1],
        sx2 = _source[2],
        sy2 = _source[3],
        sx3 = _source[4],
        sy3 = _source[5];

    var _target = _slicedToArray(target, 6),
        tx1 = _target[0],
        ty1 = _target[1],
        tx2 = _target[2],
        ty2 = _target[3],
        tx3 = _target[4],
        ty3 = _target[5];

    var cross1 = (sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1);
    var cross2 = (tx2 - tx1) * (ty3 - ty1) - (tx3 - tx1) * (ty2 - ty1);
    return cross1 > 0 && cross2 < 0 || cross1 < 0 && cross2 > 0;
  }

  function transform(source, target) {
    var _source2 = _slicedToArray(source, 6),
        sx1 = _source2[0],
        sy1 = _source2[1],
        sx2 = _source2[2],
        sy2 = _source2[3],
        sx3 = _source2[4],
        sy3 = _source2[5];

    var _target2 = _slicedToArray(target, 6),
        tx1 = _target2[0],
        ty1 = _target2[1],
        tx2 = _target2[2],
        ty2 = _target2[3],
        tx3 = _target2[4],
        ty3 = _target2[5]; // 记录翻转


    var overflow = isOverflow(source, target); // 第0步，将源三角第1个a点移到原点

    var m = mx.identity();
    m[12] = -sx1;
    m[13] = -sy1;
    var t; // 第1步，以第1条边ab为基准，将其贴合x轴上，为后续倾斜不干扰做准备

    var theta = calDeg(sx1, sy1, sx2, sy2);

    if (theta !== 0) {
      t = rotate(-theta);
      m = mx.multiply(t, m);
    } // 第2步，以第1条边AB为基准，缩放x轴ab至目标相同长度，可与4步合并


    var ls = geom.pointsDistance(sx1, sy1, sx2, sy2);
    var lt = geom.pointsDistance(tx1, ty1, tx2, ty2); // if(ls !== lt) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[0] = scale;
    // m = matrix.multiply(t, m);
    // }
    // 第3步，缩放y，先将目标三角形旋转到x轴平行，再变换坐标计算

    var n = mx.identity();
    n[12] = -tx1;
    n[13] = -ty1;
    theta = calDeg(tx1, ty1, tx2, ty2); // 记录下这个旋转角度，后面源三角形要反向旋转

    var alpha = theta;

    if (theta !== 0) {
      t = rotate(-theta);
      n = mx.multiply(t, n);
    } // 目标三角反向旋转至x轴后的坐标
    // 源三角目前的第3点坐标y值即为长度，因为a点在原点0无需减去


    var ls2 = Math.abs(mx.calPoint([sx3, sy3], m)[1]);
    var lt2 = Math.abs(mx.calPoint([tx3, ty3], n)[1]); // 缩放y
    // if(ls2 !== lt2) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[3] = scale;
    // m = matrix.multiply(t, m);
    // }

    if (ls !== lt || ls2 !== lt2) {
      t = mx.identity();

      if (ls !== lt) {
        t[0] = lt / ls;
      }

      if (ls2 !== lt2) {
        t[5] = lt2 / ls2;
      }

      m = mx.multiply(t, m);
    } // 第4步，x轴倾斜，用余弦定理求目前a和A的夹角


    n = m;

    var _matrix$calPoint = mx.calPoint([sx1, sy1], n),
        _matrix$calPoint2 = _slicedToArray(_matrix$calPoint, 2),
        ax1 = _matrix$calPoint2[0],
        ay1 = _matrix$calPoint2[1];

    var _matrix$calPoint3 = mx.calPoint([sx2, sy2], n),
        _matrix$calPoint4 = _slicedToArray(_matrix$calPoint3, 2),
        ax2 = _matrix$calPoint4[0],
        ay2 = _matrix$calPoint4[1];

    var _matrix$calPoint5 = mx.calPoint([sx3, sy3], n),
        _matrix$calPoint6 = _slicedToArray(_matrix$calPoint5, 2),
        ax3 = _matrix$calPoint6[0],
        ay3 = _matrix$calPoint6[1];

    var ab = geom.pointsDistance(ax1, ay1, ax2, ay2);
    var ac = geom.pointsDistance(ax1, ay1, ax3, ay3);
    var bc = geom.pointsDistance(ax3, ay3, ax2, ay2);
    var AB = geom.pointsDistance(tx1, ty1, tx2, ty2);
    var AC = geom.pointsDistance(tx1, ty1, tx3, ty3);
    var BC = geom.pointsDistance(tx3, ty3, tx2, ty2);
    var a = geom.angleBySide(bc, ab, ac);
    var A = geom.angleBySide(BC, AB, AC); // 先至90°，再旋转至目标角，可以合并成tan相加，不知道为什么不能直接tan倾斜差值角度

    if (a !== A) {
      t = mx.identity();
      t[4] = Math.tan(a - Math.PI * 0.5) + Math.tan(Math.PI * 0.5 - A);
      m = mx.multiply(t, m);
    } // 发生翻转时特殊处理按x轴垂直翻转


    if (overflow) {
      m[1] = -m[1];
      m[5] = -m[5];
      m[13] = -m[13];
    } // 第5步，再次旋转，角度为目标旋转到x轴的负值，可与下步合并


    if (alpha !== 0) {
      t = rotate(alpha); // m = matrix.multiply(t, m);
    } else {
      t = mx.identity();
    } // 第6步，移动第一个点的差值
    // t = matrix.identity();


    t[12] = tx1;
    t[13] = ty1;
    return mx.multiply(t, m);
  }

  var tar = {
    exchangeOrder: exchangeOrder,
    isOverflow: isOverflow,
    transform: transform
  };

  /**
   * martinez v0.7.3
   * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
   *
   * @author Alex Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   */
  function DEFAULT_COMPARE(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }

  var SplayTree = function SplayTree(compare, noDuplicates) {
    if (compare === void 0) compare = DEFAULT_COMPARE;
    if (noDuplicates === void 0) noDuplicates = false;
    this._compare = compare;
    this._root = null;
    this._size = 0;
    this._noDuplicates = !!noDuplicates;
  };

  var prototypeAccessors = {
    size: {
      configurable: true
    }
  };

  SplayTree.prototype.rotateLeft = function rotateLeft(x) {
    var y = x.right;

    if (y) {
      x.right = y.left;

      if (y.left) {
        y.left.parent = x;
      }

      y.parent = x.parent;
    }

    if (!x.parent) {
      this._root = y;
    } else if (x === x.parent.left) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }

    if (y) {
      y.left = x;
    }

    x.parent = y;
  };

  SplayTree.prototype.rotateRight = function rotateRight(x) {
    var y = x.left;

    if (y) {
      x.left = y.right;

      if (y.right) {
        y.right.parent = x;
      }

      y.parent = x.parent;
    }

    if (!x.parent) {
      this._root = y;
    } else if (x === x.parent.left) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }

    if (y) {
      y.right = x;
    }

    x.parent = y;
  };

  SplayTree.prototype._splay = function _splay(x) {
    while (x.parent) {
      var p = x.parent;

      if (!p.parent) {
        if (p.left === x) {
          this.rotateRight(p);
        } else {
          this.rotateLeft(p);
        }
      } else if (p.left === x && p.parent.left === p) {
        this.rotateRight(p.parent);
        this.rotateRight(p);
      } else if (p.right === x && p.parent.right === p) {
        this.rotateLeft(p.parent);
        this.rotateLeft(p);
      } else if (p.left === x && p.parent.right === p) {
        this.rotateRight(p);
        this.rotateLeft(p);
      } else {
        this.rotateLeft(p);
        this.rotateRight(p);
      }
    }
  };

  SplayTree.prototype.splay = function splay(x) {
    var p, gp, ggp, l, r;

    while (x.parent) {
      p = x.parent;
      gp = p.parent;

      if (gp && gp.parent) {
        ggp = gp.parent;

        if (ggp.left === gp) {
          ggp.left = x;
        } else {
          ggp.right = x;
        }

        x.parent = ggp;
      } else {
        x.parent = null;
        this._root = x;
      }

      l = x.left;
      r = x.right;

      if (x === p.left) {
        // left
        if (gp) {
          if (gp.left === p) {
            /* zig-zig */
            if (p.right) {
              gp.left = p.right;
              gp.left.parent = gp;
            } else {
              gp.left = null;
            }

            p.right = gp;
            gp.parent = p;
          } else {
            /* zig-zag */
            if (l) {
              gp.right = l;
              l.parent = gp;
            } else {
              gp.right = null;
            }

            x.left = gp;
            gp.parent = x;
          }
        }

        if (r) {
          p.left = r;
          r.parent = p;
        } else {
          p.left = null;
        }

        x.right = p;
        p.parent = x;
      } else {
        // right
        if (gp) {
          if (gp.right === p) {
            /* zig-zig */
            if (p.left) {
              gp.right = p.left;
              gp.right.parent = gp;
            } else {
              gp.right = null;
            }

            p.left = gp;
            gp.parent = p;
          } else {
            /* zig-zag */
            if (r) {
              gp.left = r;
              r.parent = gp;
            } else {
              gp.left = null;
            }

            x.right = gp;
            gp.parent = x;
          }
        }

        if (l) {
          p.right = l;
          l.parent = p;
        } else {
          p.right = null;
        }

        x.left = p;
        p.parent = x;
      }
    }
  };

  SplayTree.prototype.replace = function replace(u, v) {
    if (!u.parent) {
      this._root = v;
    } else if (u === u.parent.left) {
      u.parent.left = v;
    } else {
      u.parent.right = v;
    }

    if (v) {
      v.parent = u.parent;
    }
  };

  SplayTree.prototype.minNode = function minNode(u) {
    if (u === void 0) u = this._root;

    if (u) {
      while (u.left) {
        u = u.left;
      }
    }

    return u;
  };

  SplayTree.prototype.maxNode = function maxNode(u) {
    if (u === void 0) u = this._root;

    if (u) {
      while (u.right) {
        u = u.right;
      }
    }

    return u;
  };

  SplayTree.prototype.insert = function insert(key, data) {
    var z = this._root;
    var p = null;
    var comp = this._compare;
    var cmp;

    if (this._noDuplicates) {
      while (z) {
        p = z;
        cmp = comp(z.key, key);

        if (cmp === 0) {
          return;
        } else if (comp(z.key, key) < 0) {
          z = z.right;
        } else {
          z = z.left;
        }
      }
    } else {
      while (z) {
        p = z;

        if (comp(z.key, key) < 0) {
          z = z.right;
        } else {
          z = z.left;
        }
      }
    }

    z = {
      key: key,
      data: data,
      left: null,
      right: null,
      parent: p
    };

    if (!p) {
      this._root = z;
    } else if (comp(p.key, z.key) < 0) {
      p.right = z;
    } else {
      p.left = z;
    }

    this.splay(z);
    this._size++;
    return z;
  };

  SplayTree.prototype.find = function find(key) {
    var z = this._root;
    var comp = this._compare;

    while (z) {
      var cmp = comp(z.key, key);

      if (cmp < 0) {
        z = z.right;
      } else if (cmp > 0) {
        z = z.left;
      } else {
        return z;
      }
    }

    return null;
  };
  /**
   * Whether the tree contains a node with the given key
   * @param{Key} key
   * @return {boolean} true/false
   */


  SplayTree.prototype.contains = function contains(key) {
    var node = this._root;
    var comparator = this._compare;

    while (node) {
      var cmp = comparator(key, node.key);

      if (cmp === 0) {
        return true;
      } else if (cmp < 0) {
        node = node.left;
      } else {
        node = node.right;
      }
    }

    return false;
  };

  SplayTree.prototype.remove = function remove(key) {
    var z = this.find(key);

    if (!z) {
      return false;
    }

    this.splay(z);

    if (!z.left) {
      this.replace(z, z.right);
    } else if (!z.right) {
      this.replace(z, z.left);
    } else {
      var y = this.minNode(z.right);

      if (y.parent !== z) {
        this.replace(y, y.right);
        y.right = z.right;
        y.right.parent = y;
      }

      this.replace(z, y);
      y.left = z.left;
      y.left.parent = y;
    }

    this._size--;
    return true;
  };

  SplayTree.prototype.removeNode = function removeNode(z) {
    if (!z) {
      return false;
    }

    this.splay(z);

    if (!z.left) {
      this.replace(z, z.right);
    } else if (!z.right) {
      this.replace(z, z.left);
    } else {
      var y = this.minNode(z.right);

      if (y.parent !== z) {
        this.replace(y, y.right);
        y.right = z.right;
        y.right.parent = y;
      }

      this.replace(z, y);
      y.left = z.left;
      y.left.parent = y;
    }

    this._size--;
    return true;
  };

  SplayTree.prototype.erase = function erase(key) {
    var z = this.find(key);

    if (!z) {
      return;
    }

    this.splay(z);
    var s = z.left;
    var t = z.right;
    var sMax = null;

    if (s) {
      s.parent = null;
      sMax = this.maxNode(s);
      this.splay(sMax);
      this._root = sMax;
    }

    if (t) {
      if (s) {
        sMax.right = t;
      } else {
        this._root = t;
      }

      t.parent = sMax;
    }

    this._size--;
  };
  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */


  SplayTree.prototype.pop = function pop() {
    var node = this._root,
        returnValue = null;

    if (node) {
      while (node.left) {
        node = node.left;
      }

      returnValue = {
        key: node.key,
        data: node.data
      };
      this.remove(node.key);
    }

    return returnValue;
  };
  /* eslint-disable class-methods-use-this */

  /**
   * Successor node
   * @param{Node} node
   * @return {?Node}
   */


  SplayTree.prototype.next = function next(node) {
    var successor = node;

    if (successor) {
      if (successor.right) {
        successor = successor.right;

        while (successor && successor.left) {
          successor = successor.left;
        }
      } else {
        successor = node.parent;

        while (successor && successor.right === node) {
          node = successor;
          successor = successor.parent;
        }
      }
    }

    return successor;
  };
  /**
   * Predecessor node
   * @param{Node} node
   * @return {?Node}
   */


  SplayTree.prototype.prev = function prev(node) {
    var predecessor = node;

    if (predecessor) {
      if (predecessor.left) {
        predecessor = predecessor.left;

        while (predecessor && predecessor.right) {
          predecessor = predecessor.right;
        }
      } else {
        predecessor = node.parent;

        while (predecessor && predecessor.left === node) {
          node = predecessor;
          predecessor = predecessor.parent;
        }
      }
    }

    return predecessor;
  };
  /* eslint-enable class-methods-use-this */

  /**
   * @param{forEachCallback} callback
   * @return {SplayTree}
   */


  SplayTree.prototype.forEach = function forEach(callback) {
    var current = this._root;
    var s = [],
        done = false,
        i = 0;

    while (!done) {
      // Reach the left most Node of the current Node
      if (current) {
        // Place pointer to a tree node on the stack
        // before traversing the node's left subtree
        s.push(current);
        current = current.left;
      } else {
        // BackTrack from the empty subtree and visit the Node
        // at the top of the stack; however, if the stack is
        // empty you are done
        if (s.length > 0) {
          current = s.pop();
          callback(current, i++); // We have visited the node and its left
          // subtree. Now, it's right subtree's turn

          current = current.right;
        } else {
          done = true;
        }
      }
    }

    return this;
  };
  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param{Key}    low
   * @param{Key}    high
   * @param{Function} fn
   * @param{*?}     ctx
   * @return {SplayTree}
   */


  SplayTree.prototype.range = function range(low, high, fn, ctx) {
    var Q = [];
    var compare = this._compare;
    var node = this._root,
        cmp;

    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);

        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node)) {
            return this;
          } // stop if smth is returned

        }

        node = node.right;
      }
    }

    return this;
  };
  /**
   * Returns all keys in order
   * @return {Array<Key>}
   */


  SplayTree.prototype.keys = function keys() {
    var current = this._root;
    var s = [],
        r = [],
        done = false;

    while (!done) {
      if (current) {
        s.push(current);
        current = current.left;
      } else {
        if (s.length > 0) {
          current = s.pop();
          r.push(current.key);
          current = current.right;
        } else {
          done = true;
        }
      }
    }

    return r;
  };
  /**
   * Returns `data` fields of all nodes in order.
   * @return {Array<Value>}
   */


  SplayTree.prototype.values = function values() {
    var current = this._root;
    var s = [],
        r = [],
        done = false;

    while (!done) {
      if (current) {
        s.push(current);
        current = current.left;
      } else {
        if (s.length > 0) {
          current = s.pop();
          r.push(current.data);
          current = current.right;
        } else {
          done = true;
        }
      }
    }

    return r;
  };
  /**
   * Returns node at given index
   * @param{number} index
   * @return {?Node}
   */


  SplayTree.prototype.at = function at(index) {
    // removed after a consideration, more misleading than useful
    // index = index % this.size;
    // if (index < 0) index = this.size - index;
    var current = this._root;
    var s = [],
        done = false,
        i = 0;

    while (!done) {
      if (current) {
        s.push(current);
        current = current.left;
      } else {
        if (s.length > 0) {
          current = s.pop();

          if (i === index) {
            return current;
          }

          i++;
          current = current.right;
        } else {
          done = true;
        }
      }
    }

    return null;
  };
  /**
   * Bulk-load items. Both array have to be same size
   * @param{Array<Key>}  keys
   * @param{Array<Value>}[values]
   * @param{Boolean}     [presort=false] Pre-sort keys and values, using
   *                                       tree's comparator. Sorting is done
   *                                       in-place
   * @return {AVLTree}
   */


  SplayTree.prototype.load = function load(keys, values, presort) {
    if (keys === void 0) keys = [];
    if (values === void 0) values = [];
    if (presort === void 0) presort = false;

    if (this._size !== 0) {
      throw new Error('bulk-load: tree is not empty');
    }

    var size = keys.length;

    if (presort) {
      sort(keys, values, 0, size - 1, this._compare);
    }

    this._root = loadRecursive(null, keys, values, 0, size);
    this._size = size;
    return this;
  };

  SplayTree.prototype.min = function min() {
    var node = this.minNode(this._root);

    if (node) {
      return node.key;
    } else {
      return null;
    }
  };

  SplayTree.prototype.max = function max() {
    var node = this.maxNode(this._root);

    if (node) {
      return node.key;
    } else {
      return null;
    }
  };

  SplayTree.prototype.isEmpty = function isEmpty() {
    return this._root === null;
  };

  prototypeAccessors.size.get = function () {
    return this._size;
  };
  /**
   * Create a tree and load it with items
   * @param{Array<Key>}        keys
   * @param{Array<Value>?}      [values]

   * @param{Function?}          [comparator]
   * @param{Boolean?}           [presort=false] Pre-sort keys and values, using
   *                                             tree's comparator. Sorting is done
   *                                             in-place
   * @param{Boolean?}           [noDuplicates=false] Allow duplicates
   * @return {SplayTree}
   */


  SplayTree.createTree = function createTree(keys, values, comparator, presort, noDuplicates) {
    return new SplayTree(comparator, noDuplicates).load(keys, values, presort);
  };

  Object.defineProperties(SplayTree.prototype, prototypeAccessors);

  function loadRecursive(parent, keys, values, start, end) {
    var size = end - start;

    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key = keys[middle];
      var data = values[middle];
      var node = {
        key: key,
        data: data,
        parent: parent
      };
      node.left = loadRecursive(node, keys, values, start, middle);
      node.right = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }

    return null;
  }

  function sort(keys, values, left, right, compare) {
    if (left >= right) {
      return;
    }

    var pivot = keys[left + right >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do {
        i++;
      } while (compare(keys[i], pivot) < 0);

      do {
        j--;
      } while (compare(keys[j], pivot) > 0);

      if (i >= j) {
        break;
      }

      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;
      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values, left, j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  var NORMAL = 0;
  var NON_CONTRIBUTING = 1;
  var SAME_TRANSITION = 2;
  var DIFFERENT_TRANSITION = 3;
  var INTERSECTION = 0;
  var UNION = 1;
  var DIFFERENCE = 2;
  var XOR = 3;
  /**
   * @param  {SweepEvent} event
   * @param  {SweepEvent} prev
   * @param  {Operation} operation
   */

  function computeFields(event, prev, operation) {
    // compute inOut and otherInOut fields
    if (prev === null) {
      event.inOut = false;
      event.otherInOut = true; // previous line segment in sweepline belongs to the same polygon
    } else {
      if (event.isSubject === prev.isSubject) {
        event.inOut = !prev.inOut;
        event.otherInOut = prev.otherInOut; // previous line segment in sweepline belongs to the clipping polygon
      } else {
        event.inOut = !prev.otherInOut;
        event.otherInOut = prev.isVertical() ? !prev.inOut : prev.inOut;
      } // compute prevInResult field


      if (prev) {
        event.prevInResult = !inResult(prev, operation) || prev.isVertical() ? prev.prevInResult : prev;
      }
    } // check if the line segment belongs to the Boolean operation


    var isInResult = inResult(event, operation);

    if (isInResult) {
      event.resultTransition = determineResultTransition(event, operation);
    } else {
      event.resultTransition = 0;
    }
  }
  /* eslint-disable indent */


  function inResult(event, operation) {
    switch (event.type) {
      case NORMAL:
        switch (operation) {
          case INTERSECTION:
            return !event.otherInOut;

          case UNION:
            return event.otherInOut;

          case DIFFERENCE:
            // return (event.isSubject && !event.otherInOut) ||
            //         (!event.isSubject && event.otherInOut);
            return event.isSubject && event.otherInOut || !event.isSubject && !event.otherInOut;

          case XOR:
            return true;
        }

        break;

      case SAME_TRANSITION:
        return operation === INTERSECTION || operation === UNION;

      case DIFFERENT_TRANSITION:
        return operation === DIFFERENCE;

      case NON_CONTRIBUTING:
        return false;
    }

    return false;
  }
  /* eslint-enable indent */


  function determineResultTransition(event, operation) {
    var thisIn = !event.inOut;
    var thatIn = !event.otherInOut;
    var isIn;

    switch (operation) {
      case INTERSECTION:
        isIn = thisIn && thatIn;
        break;

      case UNION:
        isIn = thisIn || thatIn;
        break;

      case XOR:
        isIn = thisIn ^ thatIn;
        break;

      case DIFFERENCE:
        if (event.isSubject) {
          isIn = thisIn && !thatIn;
        } else {
          isIn = thatIn && !thisIn;
        }

        break;
    }

    return isIn ? +1 : -1;
  }

  var SweepEvent = function SweepEvent(point, left, otherEvent, isSubject, edgeType) {
    /**
     * Is left endpoint?
     * @type {Boolean}
     */
    this.left = left;
    /**
     * @type {Array.<Number>}
     */

    this.point = point;
    /**
     * Other edge reference
     * @type {SweepEvent}
     */

    this.otherEvent = otherEvent;
    /**
     * Belongs to source or clipping polygon
     * @type {Boolean}
     */

    this.isSubject = isSubject;
    /**
     * Edge contribution type
     * @type {Number}
     */

    this.type = edgeType || NORMAL;
    /**
     * In-out transition for the sweepline crossing polygon
     * @type {Boolean}
     */

    this.inOut = false;
    /**
     * @type {Boolean}
     */

    this.otherInOut = false;
    /**
     * Previous event in result?
     * @type {SweepEvent}
     */

    this.prevInResult = null;
    /**
     * Type of result transition (0 = not in result, +1 = out-in, -1, in-out)
     * @type {Number}
     */

    this.resultTransition = 0; // connection step

    /**
     * @type {Number}
     */

    this.otherPos = -1;
    /**
     * @type {Number}
     */

    this.outputContourId = -1;
    this.isExteriorRing = true; // TODO: Looks unused, remove?
  };

  var prototypeAccessors$1 = {
    inResult: {
      configurable: true
    }
  };
  /**
   * @param{Array.<Number>}p
   * @return {Boolean}
   */

  SweepEvent.prototype.isBelow = function isBelow(p) {
    var p0 = this.point,
        p1 = this.otherEvent.point;
    return this.left ? (p0[0] - p[0]) * (p1[1] - p[1]) - (p1[0] - p[0]) * (p0[1] - p[1]) > 0 // signedArea(this.point, this.otherEvent.point, p) > 0 :
    : (p1[0] - p[0]) * (p0[1] - p[1]) - (p0[0] - p[0]) * (p1[1] - p[1]) > 0; //signedArea(this.otherEvent.point, this.point, p) > 0;
  };
  /**
   * @param{Array.<Number>}p
   * @return {Boolean}
   */


  SweepEvent.prototype.isAbove = function isAbove(p) {
    return !this.isBelow(p);
  };
  /**
   * @return {Boolean}
   */


  SweepEvent.prototype.isVertical = function isVertical() {
    return this.point[0] === this.otherEvent.point[0];
  };
  /**
   * Does event belong to result?
   * @return {Boolean}
   */


  prototypeAccessors$1.inResult.get = function () {
    return this.resultTransition !== 0;
  };

  SweepEvent.prototype.clone = function clone() {
    var copy = new SweepEvent(this.point, this.left, this.otherEvent, this.isSubject, this.type);
    copy.contourId = this.contourId;
    copy.resultTransition = this.resultTransition;
    copy.prevInResult = this.prevInResult;
    copy.isExteriorRing = this.isExteriorRing;
    copy.inOut = this.inOut;
    copy.otherInOut = this.otherInOut;
    return copy;
  };

  Object.defineProperties(SweepEvent.prototype, prototypeAccessors$1);

  function equals(p1, p2) {
    if (p1[0] === p2[0]) {
      if (p1[1] === p2[1]) {
        return true;
      } else {
        return false;
      }
    }

    return false;
  } // const EPSILON = 1e-9;
  // const abs = Math.abs;
  // TODO https://github.com/w8r/martinez/issues/6#issuecomment-262847164
  // Precision problem.
  //
  // module.exports = function equals(p1, p2) {
  //   return abs(p1[0] - p2[0]) <= EPSILON && abs(p1[1] - p2[1]) <= EPSILON;
  // };


  var epsilon = 1.1102230246251565e-16;
  var splitter = 134217729;
  var resulterrbound = (3 + 8 * epsilon) * epsilon; // fast_expansion_sum_zeroelim routine from oritinal code

  function sum(elen, e, flen, f, h) {
    var Q, Qnew, hh, bvirt;
    var enow = e[0];
    var fnow = f[0];
    var eindex = 0;
    var findex = 0;

    if (fnow > enow === fnow > -enow) {
      Q = enow;
      enow = e[++eindex];
    } else {
      Q = fnow;
      fnow = f[++findex];
    }

    var hindex = 0;

    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q;
        hh = Q - (Qnew - enow);
        enow = e[++eindex];
      } else {
        Qnew = fnow + Q;
        hh = Q - (Qnew - fnow);
        fnow = f[++findex];
      }

      Q = Qnew;

      if (hh !== 0) {
        h[hindex++] = hh;
      }

      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q + enow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (enow - bvirt);
          enow = e[++eindex];
        } else {
          Qnew = Q + fnow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f[++findex];
        }

        Q = Qnew;

        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
    }

    while (eindex < elen) {
      Qnew = Q + enow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (enow - bvirt);
      enow = e[++eindex];
      Q = Qnew;

      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }

    while (findex < flen) {
      Qnew = Q + fnow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f[++findex];
      Q = Qnew;

      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }

    if (Q !== 0 || hindex === 0) {
      h[hindex++] = Q;
    }

    return hindex;
  }

  function estimate(elen, e) {
    var Q = e[0];

    for (var i = 1; i < elen; i++) {
      Q += e[i];
    }

    return Q;
  }

  function vec(n) {
    return new Float64Array(n);
  }

  var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
  var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
  var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
  var B = vec(4);
  var C1 = vec(8);
  var C2 = vec(12);
  var D = vec(16);
  var u = vec(4);

  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    var acxtail, acytail, bcxtail, bcytail;

    var bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

    var acx = ax - cx;
    var bcx = bx - cx;
    var acy = ay - cy;
    var bcy = by - cy;
    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;
    var det = estimate(4, B);
    var errbound = ccwerrboundB * detsum;

    if (det >= errbound || -det >= errbound) {
      return det;
    }

    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);

    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det;
    }

    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);

    if (det >= errbound || -det >= errbound) {
      return det;
    }

    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    var C1len = sum(4, B, 4, u, C1);
    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    var C2len = sum(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    var Dlen = sum(C2len, C2, 4, u, D);
    return D[Dlen - 1];
  }

  function orient2d(ax, ay, bx, by, cx, cy) {
    var detleft = (ay - cy) * (bx - cx);
    var detright = (ax - cx) * (by - cy);
    var det = detleft - detright;

    if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0) {
      return det;
    }

    var detsum = Math.abs(detleft + detright);

    if (Math.abs(det) >= ccwerrboundA * detsum) {
      return det;
    }

    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }
  /**
   * Signed area of the triangle (p0, p1, p2)
   * @param  {Array.<Number>} p0
   * @param  {Array.<Number>} p1
   * @param  {Array.<Number>} p2
   * @return {Number}
   */


  function signedArea(p0, p1, p2) {
    var res = orient2d(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]);

    if (res > 0) {
      return -1;
    }

    if (res < 0) {
      return 1;
    }

    return 0;
  }
  /**
   * @param  {SweepEvent} e1
   * @param  {SweepEvent} e2
   * @return {Number}
   */


  function compareEvents(e1, e2) {
    var p1 = e1.point;
    var p2 = e2.point; // Different x-coordinate

    if (p1[0] > p2[0]) {
      return 1;
    }

    if (p1[0] < p2[0]) {
      return -1;
    } // Different points, but same x-coordinate
    // Event with lower y-coordinate is processed first


    if (p1[1] !== p2[1]) {
      return p1[1] > p2[1] ? 1 : -1;
    }

    return specialCases(e1, e2, p1);
  }
  /* eslint-disable no-unused-vars */


  function specialCases(e1, e2, p1, p2) {
    // Same coordinates, but one is a left endpoint and the other is
    // a right endpoint. The right endpoint is processed first
    if (e1.left !== e2.left) {
      return e1.left ? 1 : -1;
    } // const p2 = e1.otherEvent.point, p3 = e2.otherEvent.point;
    // const sa = (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])
    // Same coordinates, both events
    // are left endpoints or right endpoints.
    // not collinear


    if (signedArea(p1, e1.otherEvent.point, e2.otherEvent.point) !== 0) {
      // the event associate to the bottom segment is processed first
      return !e1.isBelow(e2.otherEvent.point) ? 1 : -1;
    }

    return !e1.isSubject && e2.isSubject ? 1 : -1;
  }
  /* eslint-enable no-unused-vars */

  /**
   * @param  {SweepEvent} se
   * @param  {Array.<Number>} p
   * @param  {Queue} queue
   * @return {Queue}
   */


  function divideSegment(se, p, queue) {
    var r = new SweepEvent(p, false, se, se.isSubject);
    var l = new SweepEvent(p, true, se.otherEvent, se.isSubject);
    /* eslint-disable no-console */

    if (equals(se.point, se.otherEvent.point)) {
      console.warn('what is that, a collapsed segment?', se);
    }
    /* eslint-enable no-console */


    r.contourId = l.contourId = se.contourId; // avoid a rounding error. The left event would be processed after the right event

    if (compareEvents(l, se.otherEvent) > 0) {
      se.otherEvent.left = true;
      l.left = false;
    } // avoid a rounding error. The left event would be processed after the right event
    // if (compareEvents(se, r) > 0) {}


    se.otherEvent.otherEvent = l;
    se.otherEvent = r;
    queue.push(l);
    queue.push(r);
    return queue;
  } //const EPS = 1e-9;

  /**
   * Finds the magnitude of the cross product of two vectors (if we pretend
   * they're in three dimensions)
   *
   * @param {Object} a First vector
   * @param {Object} b Second vector
   * @private
   * @returns {Number} The magnitude of the cross product
   */


  function crossProduct$2(a, b) {
    return a[0] * b[1] - a[1] * b[0];
  }
  /**
   * Finds the dot product of two vectors.
   *
   * @param {Object} a First vector
   * @param {Object} b Second vector
   * @private
   * @returns {Number} The dot product
   */


  function dotProduct$1(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  /**
   * Finds the intersection (if any) between two line segments a and b, given the
   * line segments' end points a1, a2 and b1, b2.
   *
   * This algorithm is based on Schneider and Eberly.
   * http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf
   * Page 244.
   *
   * @param {Array.<Number>} a1 point of first line
   * @param {Array.<Number>} a2 point of first line
   * @param {Array.<Number>} b1 point of second line
   * @param {Array.<Number>} b2 point of second line
   * @param {Boolean=}       noEndpointTouch whether to skip single touchpoints
   *                                         (meaning connected segments) as
   *                                         intersections
   * @returns {Array.<Array.<Number>>|Null} If the lines intersect, the point of
   * intersection. If they overlap, the two end points of the overlapping segment.
   * Otherwise, null.
   */


  function intersection(a1, a2, b1, b2, noEndpointTouch) {
    // The algorithm expects our lines in the form P + sd, where P is a point,
    // s is on the interval [0, 1], and d is a vector.
    // We are passed two points. P can be the first point of each pair. The
    // vector, then, could be thought of as the distance (in x and y components)
    // from the first point to the second point.
    // So first, let's make our vectors:
    var va = [a2[0] - a1[0], a2[1] - a1[1]];
    var vb = [b2[0] - b1[0], b2[1] - b1[1]]; // We also define a function to convert back to regular point form:

    /* eslint-disable arrow-body-style */

    function toPoint(p, s, d) {
      return [p[0] + s * d[0], p[1] + s * d[1]];
    }
    /* eslint-enable arrow-body-style */
    // The rest is pretty much a straight port of the algorithm.


    var e = [b1[0] - a1[0], b1[1] - a1[1]];
    var kross = crossProduct$2(va, vb);
    var sqrKross = kross * kross;
    var sqrLenA = dotProduct$1(va, va); //const sqrLenB  = dotProduct(vb, vb);
    // Check for line intersection. This works because of the properties of the
    // cross product -- specifically, two vectors are parallel if and only if the
    // cross product is the 0 vector. The full calculation involves relative error
    // to account for possible very small line segments. See Schneider & Eberly
    // for details.

    if (sqrKross > 0
    /* EPS * sqrLenB * sqLenA */
    ) {
      // If they're not parallel, then (because these are line segments) they
      // still might not actually intersect. This code checks that the
      // intersection point of the lines is actually on both line segments.
      var s = crossProduct$2(e, vb) / kross;

      if (s < 0 || s > 1) {
        // not on line segment a
        return null;
      }

      var t = crossProduct$2(e, va) / kross;

      if (t < 0 || t > 1) {
        // not on line segment b
        return null;
      }

      if (s === 0 || s === 1) {
        // on an endpoint of line segment a
        return noEndpointTouch ? null : [toPoint(a1, s, va)];
      }

      if (t === 0 || t === 1) {
        // on an endpoint of line segment b
        return noEndpointTouch ? null : [toPoint(b1, t, vb)];
      }

      return [toPoint(a1, s, va)];
    } // If we've reached this point, then the lines are either parallel or the
    // same, but the segments could overlap partially or fully, or not at all.
    // So we need to find the overlap, if any. To do that, we can use e, which is
    // the (vector) difference between the two initial points. If this is parallel
    // with the line itself, then the two lines are the same line, and there will
    // be overlap.
    //const sqrLenE = dotProduct(e, e);


    kross = crossProduct$2(e, va);
    sqrKross = kross * kross;

    if (sqrKross > 0
    /* EPS * sqLenB * sqLenE */
    ) {
      // Lines are just parallel, not the same. No overlap.
      return null;
    }

    var sa = dotProduct$1(va, e) / sqrLenA;
    var sb = sa + dotProduct$1(va, vb) / sqrLenA;
    var smin = Math.min(sa, sb);
    var smax = Math.max(sa, sb); // this is, essentially, the FindIntersection acting on floats from
    // Schneider & Eberly, just inlined into this function.

    if (smin <= 1 && smax >= 0) {
      // overlap on an end point
      if (smin === 1) {
        return noEndpointTouch ? null : [toPoint(a1, smin > 0 ? smin : 0, va)];
      }

      if (smax === 0) {
        return noEndpointTouch ? null : [toPoint(a1, smax < 1 ? smax : 1, va)];
      }

      if (noEndpointTouch && smin === 0 && smax === 1) {
        return null;
      } // There's overlap on a segment -- two points of intersection. Return both.


      return [toPoint(a1, smin > 0 ? smin : 0, va), toPoint(a1, smax < 1 ? smax : 1, va)];
    }

    return null;
  }
  /**
   * @param  {SweepEvent} se1
   * @param  {SweepEvent} se2
   * @param  {Queue}      queue
   * @return {Number}
   */


  function possibleIntersection(se1, se2, queue) {
    // that disallows self-intersecting polygons,
    // did cost us half a day, so I'll leave it
    // out of respect
    // if (se1.isSubject === se2.isSubject) return;
    var inter = intersection(se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
    var nintersections = inter ? inter.length : 0;

    if (nintersections === 0) {
      return 0;
    } // no intersection
    // the line segments intersect at an endpoint of both line segments


    if (nintersections === 1 && (equals(se1.point, se2.point) || equals(se1.otherEvent.point, se2.otherEvent.point))) {
      return 0;
    }

    if (nintersections === 2 && se1.isSubject === se2.isSubject) {
      // if(se1.contourId === se2.contourId){
      // console.warn('Edges of the same polygon overlap',
      //   se1.point, se1.otherEvent.point, se2.point, se2.otherEvent.point);
      // }
      //throw new Error('Edges of the same polygon overlap');
      return 0;
    } // The line segments associated to se1 and se2 intersect


    if (nintersections === 1) {
      // if the intersection point is not an endpoint of se1
      if (!equals(se1.point, inter[0]) && !equals(se1.otherEvent.point, inter[0])) {
        divideSegment(se1, inter[0], queue);
      } // if the intersection point is not an endpoint of se2


      if (!equals(se2.point, inter[0]) && !equals(se2.otherEvent.point, inter[0])) {
        divideSegment(se2, inter[0], queue);
      }

      return 1;
    } // The line segments associated to se1 and se2 overlap


    var events = [];
    var leftCoincide = false;
    var rightCoincide = false;

    if (equals(se1.point, se2.point)) {
      leftCoincide = true; // linked
    } else if (compareEvents(se1, se2) === 1) {
      events.push(se2, se1);
    } else {
      events.push(se1, se2);
    }

    if (equals(se1.otherEvent.point, se2.otherEvent.point)) {
      rightCoincide = true;
    } else if (compareEvents(se1.otherEvent, se2.otherEvent) === 1) {
      events.push(se2.otherEvent, se1.otherEvent);
    } else {
      events.push(se1.otherEvent, se2.otherEvent);
    }

    if (leftCoincide && rightCoincide || leftCoincide) {
      // both line segments are equal or share the left endpoint
      se2.type = NON_CONTRIBUTING;
      se1.type = se2.inOut === se1.inOut ? SAME_TRANSITION : DIFFERENT_TRANSITION;

      if (leftCoincide && !rightCoincide) {
        // honestly no idea, but changing events selection from [2, 1]
        // to [0, 1] fixes the overlapping self-intersecting polygons issue
        divideSegment(events[1].otherEvent, events[0].point, queue);
      }

      return 2;
    } // the line segments share the right endpoint


    if (rightCoincide) {
      divideSegment(events[0], events[1].point, queue);
      return 3;
    } // no line segment includes totally the other one


    if (events[0] !== events[3].otherEvent) {
      divideSegment(events[0], events[1].point, queue);
      divideSegment(events[1], events[2].point, queue);
      return 3;
    } // one line segment includes the other one


    divideSegment(events[0], events[1].point, queue);
    divideSegment(events[3].otherEvent, events[2].point, queue);
    return 3;
  }
  /**
   * @param  {SweepEvent} le1
   * @param  {SweepEvent} le2
   * @return {Number}
   */


  function compareSegments(le1, le2) {
    if (le1 === le2) {
      return 0;
    } // Segments are not collinear


    if (signedArea(le1.point, le1.otherEvent.point, le2.point) !== 0 || signedArea(le1.point, le1.otherEvent.point, le2.otherEvent.point) !== 0) {
      // If they share their left endpoint use the right endpoint to sort
      if (equals(le1.point, le2.point)) {
        return le1.isBelow(le2.otherEvent.point) ? -1 : 1;
      } // Different left endpoint: use the left endpoint to sort


      if (le1.point[0] === le2.point[0]) {
        return le1.point[1] < le2.point[1] ? -1 : 1;
      } // has the line segment associated to e1 been inserted
      // into S after the line segment associated to e2 ?


      if (compareEvents(le1, le2) === 1) {
        return le2.isAbove(le1.point) ? -1 : 1;
      } // The line segment associated to e2 has been inserted
      // into S after the line segment associated to e1


      return le1.isBelow(le2.point) ? -1 : 1;
    }

    if (le1.isSubject === le2.isSubject) {
      // same polygon
      var p1 = le1.point,
          p2 = le2.point;

      if (p1[0] === p2[0] && p1[1] === p2[1]
      /*equals(le1.point, le2.point)*/
      ) {
        p1 = le1.otherEvent.point;
        p2 = le2.otherEvent.point;

        if (p1[0] === p2[0] && p1[1] === p2[1]) {
          return 0;
        } else {
          return le1.contourId > le2.contourId ? 1 : -1;
        }
      }
    } else {
      // Segments are collinear, but belong to separate polygons
      return le1.isSubject ? -1 : 1;
    }

    return compareEvents(le1, le2) === 1 ? 1 : -1;
  }

  function subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation) {
    var sweepLine = new SplayTree(compareSegments);
    var sortedEvents = [];
    var rightbound = Math.min(sbbox[2], cbbox[2]);
    var prev, next, begin;

    while (eventQueue.length !== 0) {
      var event = eventQueue.pop();
      sortedEvents.push(event); // optimization by bboxes for intersection and difference goes here

      if (operation === INTERSECTION && event.point[0] > rightbound || operation === DIFFERENCE && event.point[0] > sbbox[2]) {
        break;
      }

      if (event.left) {
        next = prev = sweepLine.insert(event);
        begin = sweepLine.minNode();

        if (prev !== begin) {
          prev = sweepLine.prev(prev);
        } else {
          prev = null;
        }

        next = sweepLine.next(next);
        var prevEvent = prev ? prev.key : null;
        var prevprevEvent = void 0;
        computeFields(event, prevEvent, operation);

        if (next) {
          if (possibleIntersection(event, next.key, eventQueue) === 2) {
            computeFields(event, prevEvent, operation);
            computeFields(next.key, event, operation);
          }
        }

        if (prev) {
          if (possibleIntersection(prev.key, event, eventQueue) === 2) {
            var prevprev = prev;

            if (prevprev !== begin) {
              prevprev = sweepLine.prev(prevprev);
            } else {
              prevprev = null;
            }

            prevprevEvent = prevprev ? prevprev.key : null;
            computeFields(prevEvent, prevprevEvent, operation);
            computeFields(event, prevEvent, operation);
          }
        }
      } else {
        event = event.otherEvent;
        next = prev = sweepLine.find(event);

        if (prev && next) {
          if (prev !== begin) {
            prev = sweepLine.prev(prev);
          } else {
            prev = null;
          }

          next = sweepLine.next(next);
          sweepLine.remove(event);

          if (next && prev) {
            possibleIntersection(prev.key, next.key, eventQueue);
          }
        }
      }
    }

    return sortedEvents;
  }

  var Contour = function Contour() {
    this.points = [];
    this.holeIds = [];
    this.holeOf = null;
    this.depth = null;
  };

  Contour.prototype.isExterior = function isExterior() {
    return this.holeOf == null;
  };
  /**
   * @param  {Array.<SweepEvent>} sortedEvents
   * @return {Array.<SweepEvent>}
   */


  function orderEvents(sortedEvents) {
    var event, i, len, tmp;
    var resultEvents = [];

    for (i = 0, len = sortedEvents.length; i < len; i++) {
      event = sortedEvents[i];

      if (event.left && event.inResult || !event.left && event.otherEvent.inResult) {
        resultEvents.push(event);
      }
    } // Due to overlapping edges the resultEvents array can be not wholly sorted


    var sorted = false;

    while (!sorted) {
      sorted = true;

      for (i = 0, len = resultEvents.length; i < len; i++) {
        if (i + 1 < len && compareEvents(resultEvents[i], resultEvents[i + 1]) === 1) {
          tmp = resultEvents[i];
          resultEvents[i] = resultEvents[i + 1];
          resultEvents[i + 1] = tmp;
          sorted = false;
        }
      }
    }

    for (i = 0, len = resultEvents.length; i < len; i++) {
      event = resultEvents[i];
      event.otherPos = i;
    } // imagine, the right event is found in the beginning of the queue,
    // when his left counterpart is not marked yet


    for (i = 0, len = resultEvents.length; i < len; i++) {
      event = resultEvents[i];

      if (!event.left) {
        tmp = event.otherPos;
        event.otherPos = event.otherEvent.otherPos;
        event.otherEvent.otherPos = tmp;
      }
    }

    return resultEvents;
  }
  /**
   * @param  {Number} pos
   * @param  {Array.<SweepEvent>} resultEvents
   * @param  {Object>}    processed
   * @return {Number}
   */


  function nextPos(pos, resultEvents, processed, origPos) {
    var newPos = pos + 1,
        p = resultEvents[pos].point,
        p1;
    var length = resultEvents.length;

    if (newPos < length) {
      p1 = resultEvents[newPos].point;
    }

    while (newPos < length && p1[0] === p[0] && p1[1] === p[1]) {
      if (!processed[newPos]) {
        return newPos;
      } else {
        newPos++;
      }

      if (newPos < length) {
        p1 = resultEvents[newPos].point;
      }
    }

    newPos = pos - 1;

    while (processed[newPos] && newPos > origPos) {
      newPos--;
    }

    return newPos;
  }

  function initializeContourFromContext(event, contours, contourId) {
    var contour = new Contour();

    if (event.prevInResult != null) {
      var prevInResult = event.prevInResult; // Note that it is valid to query the "previous in result" for its output contour id,
      // because we must have already processed it (i.e., assigned an output contour id)
      // in an earlier iteration, otherwise it wouldn't be possible that it is "previous in
      // result".

      var lowerContourId = prevInResult.outputContourId;
      var lowerResultTransition = prevInResult.resultTransition;

      if (lowerResultTransition > 0) {
        // We are inside. Now we have to check if the thing below us is another hole or
        // an exterior contour.
        var lowerContour = contours[lowerContourId];

        if (lowerContour.holeOf != null) {
          // The lower contour is a hole => Connect the new contour as a hole to its parent,
          // and use same depth.
          var parentContourId = lowerContour.holeOf;
          contours[parentContourId].holeIds.push(contourId);
          contour.holeOf = parentContourId;
          contour.depth = contours[lowerContourId].depth;
        } else {
          // The lower contour is an exterior contour => Connect the new contour as a hole,
          // and increment depth.
          contours[lowerContourId].holeIds.push(contourId);
          contour.holeOf = lowerContourId;
          contour.depth = contours[lowerContourId].depth + 1;
        }
      } else {
        // We are outside => this contour is an exterior contour of same depth.
        contour.holeOf = null;
        contour.depth = contours[lowerContourId].depth;
      }
    } else {
      // There is no lower/previous contour => this contour is an exterior contour of depth 0.
      contour.holeOf = null;
      contour.depth = 0;
    }

    return contour;
  }
  /**
   * @param  {Array.<SweepEvent>} sortedEvents
   * @return {Array.<*>} polygons
   */


  function connectEdges(sortedEvents) {
    var i, len;
    var resultEvents = orderEvents(sortedEvents); // "false"-filled array

    var processed = {};
    var contours = [];

    var loop = function loop() {
      if (processed[i]) {
        return;
      }

      var contourId = contours.length;
      var contour = initializeContourFromContext(resultEvents[i], contours, contourId); // Helper function that combines marking an event as processed with assigning its output contour ID

      var markAsProcessed = function markAsProcessed(pos) {
        processed[pos] = true;

        if (pos < resultEvents.length && resultEvents[pos]) {
          resultEvents[pos].outputContourId = contourId;
        }
      };

      var pos = i;
      var origPos = i;
      var initial = resultEvents[i].point;
      contour.points.push(initial);
      /* eslint no-constant-condition: "off" */

      while (true) {
        markAsProcessed(pos);
        pos = resultEvents[pos].otherPos;
        markAsProcessed(pos);
        contour.points.push(resultEvents[pos].point);
        pos = nextPos(pos, resultEvents, processed, origPos);

        if (pos == origPos || pos >= resultEvents.length || !resultEvents[pos]) {
          break;
        }
      }

      contours.push(contour);
    };

    for (i = 0, len = resultEvents.length; i < len; i++) {
      loop();
    }

    return contours;
  }

  var _tinyqueue_1_2_3_tinyqueue = TinyQueue;
  var default_1 = TinyQueue;

  function TinyQueue(data, compare) {
    if (!(this instanceof TinyQueue)) {
      return new TinyQueue(data, compare);
    }

    this.data = data || [];
    this.length = this.data.length;
    this.compare = compare || defaultCompare;

    if (this.length > 0) {
      for (var i = (this.length >> 1) - 1; i >= 0; i--) {
        this._down(i);
      }
    }
  }

  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }

  TinyQueue.prototype = {
    push: function push(item) {
      this.data.push(item);
      this.length++;

      this._up(this.length - 1);
    },
    pop: function pop() {
      if (this.length === 0) {
        return undefined;
      }

      var top = this.data[0];
      this.length--;

      if (this.length > 0) {
        this.data[0] = this.data[this.length];

        this._down(0);
      }

      this.data.pop();
      return top;
    },
    peek: function peek() {
      return this.data[0];
    },
    _up: function _up(pos) {
      var data = this.data;
      var compare = this.compare;
      var item = data[pos];

      while (pos > 0) {
        var parent = pos - 1 >> 1;
        var current = data[parent];

        if (compare(item, current) >= 0) {
          break;
        }

        data[pos] = current;
        pos = parent;
      }

      data[pos] = item;
    },
    _down: function _down(pos) {
      var data = this.data;
      var compare = this.compare;
      var halfLength = this.length >> 1;
      var item = data[pos];

      while (pos < halfLength) {
        var left = (pos << 1) + 1;
        var right = left + 1;
        var best = data[left];

        if (right < this.length && compare(data[right], best) < 0) {
          left = right;
          best = data[right];
        }

        if (compare(best, item) >= 0) {
          break;
        }

        data[pos] = best;
        pos = left;
      }

      data[pos] = item;
    }
  };
  _tinyqueue_1_2_3_tinyqueue["default"] = default_1;
  var max = Math.max;
  var min = Math.min;
  var contourId = 0;

  function processPolygon(contourOrHole, isSubject, depth, Q, bbox, isExteriorRing) {
    var i, len, s1, s2, e1, e2;

    for (i = 0, len = contourOrHole.length - 1; i < len; i++) {
      s1 = contourOrHole[i];
      s2 = contourOrHole[i + 1];
      e1 = new SweepEvent(s1, false, undefined, isSubject);
      e2 = new SweepEvent(s2, false, e1, isSubject);
      e1.otherEvent = e2;

      if (s1[0] === s2[0] && s1[1] === s2[1]) {
        continue; // skip collapsed edges, or it breaks
      }

      e1.contourId = e2.contourId = depth;

      if (!isExteriorRing) {
        e1.isExteriorRing = false;
        e2.isExteriorRing = false;
      }

      if (compareEvents(e1, e2) > 0) {
        e2.left = true;
      } else {
        e1.left = true;
      }

      var x = s1[0],
          y = s1[1];
      bbox[0] = min(bbox[0], x);
      bbox[1] = min(bbox[1], y);
      bbox[2] = max(bbox[2], x);
      bbox[3] = max(bbox[3], y); // Pushing it so the queue is sorted from left to right,
      // with object on the left having the highest priority.

      Q.push(e1);
      Q.push(e2);
    }
  }

  function fillQueue(subject, clipping, sbbox, cbbox, operation) {
    var eventQueue = new _tinyqueue_1_2_3_tinyqueue(null, compareEvents);
    var polygonSet, isExteriorRing, i, ii, j, jj; //, k, kk;

    for (i = 0, ii = subject.length; i < ii; i++) {
      polygonSet = subject[i];

      for (j = 0, jj = polygonSet.length; j < jj; j++) {
        isExteriorRing = j === 0;

        if (isExteriorRing) {
          contourId++;
        }

        processPolygon(polygonSet[j], true, contourId, eventQueue, sbbox, isExteriorRing);
      }
    }

    for (i = 0, ii = clipping.length; i < ii; i++) {
      polygonSet = clipping[i];

      for (j = 0, jj = polygonSet.length; j < jj; j++) {
        isExteriorRing = j === 0;

        if (operation === DIFFERENCE) {
          isExteriorRing = false;
        }

        if (isExteriorRing) {
          contourId++;
        }

        processPolygon(polygonSet[j], false, contourId, eventQueue, cbbox, isExteriorRing);
      }
    }

    return eventQueue;
  }

  var EMPTY = [];

  function trivialOperation(subject, clipping, operation) {
    var result = null;

    if (subject.length * clipping.length === 0) {
      if (operation === INTERSECTION) {
        result = EMPTY;
      } else if (operation === DIFFERENCE) {
        result = subject;
      } else if (operation === UNION || operation === XOR) {
        result = subject.length === 0 ? clipping : subject;
      }
    }

    return result;
  }

  function compareBBoxes(subject, clipping, sbbox, cbbox, operation) {
    var result = null;

    if (sbbox[0] > cbbox[2] || cbbox[0] > sbbox[2] || sbbox[1] > cbbox[3] || cbbox[1] > sbbox[3]) {
      if (operation === INTERSECTION) {
        result = EMPTY;
      } else if (operation === DIFFERENCE) {
        result = subject;
      } else if (operation === UNION || operation === XOR) {
        result = subject.concat(clipping);
      }
    }

    return result;
  }

  function _boolean(subject, clipping, operation) {
    if (typeof subject[0][0][0] === 'number') {
      subject = [subject];
    }

    if (typeof clipping[0][0][0] === 'number') {
      clipping = [clipping];
    }

    var trivial = trivialOperation(subject, clipping, operation);

    if (trivial) {
      return trivial === EMPTY ? null : trivial;
    }

    var sbbox = [Infinity, Infinity, -Infinity, -Infinity];
    var cbbox = [Infinity, Infinity, -Infinity, -Infinity]; // console.time('fill queue');

    var eventQueue = fillQueue(subject, clipping, sbbox, cbbox, operation); //console.timeEnd('fill queue');

    trivial = compareBBoxes(subject, clipping, sbbox, cbbox, operation);

    if (trivial) {
      return trivial === EMPTY ? null : trivial;
    } // console.time('subdivide edges');


    var sortedEvents = subdivide(eventQueue, subject, clipping, sbbox, cbbox, operation); //console.timeEnd('subdivide edges');
    // console.time('connect vertices');

    var contours = connectEdges(sortedEvents); //console.timeEnd('connect vertices');
    // Convert contours to polygons

    var polygons = [];

    for (var i = 0; i < contours.length; i++) {
      var contour = contours[i];

      if (contour.isExterior()) {
        // The exterior ring goes first
        var rings = [contour.points]; // Followed by holes if any

        for (var j = 0; j < contour.holeIds.length; j++) {
          var holeId = contour.holeIds[j];
          rings.push(contours[holeId].points);
        }

        polygons.push(rings);
      }
    }

    return polygons;
  }

  function union(subject, clipping) {
    return _boolean(subject, clipping, UNION);
  }

  function diff(subject, clipping) {
    return _boolean(subject, clipping, DIFFERENCE);
  }

  function xor(subject, clipping) {
    return _boolean(subject, clipping, XOR);
  }

  function intersection$1(subject, clipping) {
    return _boolean(subject, clipping, INTERSECTION);
  }

  var math = {
    matrix: mx,
    tar: tar,
    vector: vector,
    geom: geom,
    booleanOperations: {
      union: union,
      diff: diff,
      intersection: intersection$1,
      xor: xor
    }
  };

  var _enums$STYLE_KEY$3 = enums.STYLE_KEY,
      TRANSLATE_X$1 = _enums$STYLE_KEY$3.TRANSLATE_X,
      TRANSLATE_Y$1 = _enums$STYLE_KEY$3.TRANSLATE_Y,
      TRANSLATE_Z$1 = _enums$STYLE_KEY$3.TRANSLATE_Z,
      SCALE_X$1 = _enums$STYLE_KEY$3.SCALE_X,
      SCALE_Y$1 = _enums$STYLE_KEY$3.SCALE_Y,
      SCALE_Z$1 = _enums$STYLE_KEY$3.SCALE_Z,
      SKEW_X$1 = _enums$STYLE_KEY$3.SKEW_X,
      SKEW_Y$1 = _enums$STYLE_KEY$3.SKEW_Y,
      ROTATE_X$1 = _enums$STYLE_KEY$3.ROTATE_X,
      ROTATE_Y$1 = _enums$STYLE_KEY$3.ROTATE_Y,
      ROTATE_Z$1 = _enums$STYLE_KEY$3.ROTATE_Z,
      ROTATE_3D$1 = _enums$STYLE_KEY$3.ROTATE_3D,
      PERSPECTIVE$1 = _enums$STYLE_KEY$3.PERSPECTIVE,
      MATRIX$1 = _enums$STYLE_KEY$3.MATRIX,
      FONT_SIZE$3 = _enums$STYLE_KEY$3.FONT_SIZE;
  var PERCENT$3 = o.PERCENT,
      REM$3 = o.REM,
      VW$3 = o.VW,
      VH$3 = o.VH,
      VMAX$3 = o.VMAX,
      VMIN$3 = o.VMIN;
  var matrix = math.matrix,
      geom$1 = math.geom;
  var identity$1 = matrix.identity,
      multiply$1 = matrix.multiply,
      isE$2 = matrix.isE;
  var d2r$2 = geom$1.d2r;

  function calSingle(t, k, v) {
    if (k === TRANSLATE_X$1) {
      t[12] = v;
    } else if (k === TRANSLATE_Y$1) {
      t[13] = v;
    } else if (k === TRANSLATE_Z$1) {
      t[14] = v;
    } else if (k === SCALE_X$1) {
      t[0] = v;
    } else if (k === SCALE_Y$1) {
      t[5] = v;
    } else if (k === SCALE_Z$1) {
      t[10] = v;
    } else if (k === SKEW_X$1) {
      v = d2r$2(v);
      t[4] = Math.tan(v);
    } else if (k === SKEW_Y$1) {
      v = d2r$2(v);
      t[1] = Math.tan(v);
    } else if (k === ROTATE_X$1) {
      v = d2r$2(v);
      var sin = Math.sin(v);
      var cos = Math.cos(v);
      t[5] = t[10] = cos;
      t[6] = sin;
      t[9] = -sin;
    } else if (k === ROTATE_Y$1) {
      v = d2r$2(v);

      var _sin = Math.sin(v);

      var _cos = Math.cos(v);

      t[0] = t[10] = _cos;
      t[8] = _sin;
      t[2] = -_sin;
    } else if (k === ROTATE_Z$1) {
      v = d2r$2(v);

      var _sin2 = Math.sin(v);

      var _cos2 = Math.cos(v);

      t[0] = t[5] = _cos2;
      t[1] = _sin2;
      t[4] = -_sin2;
    } else if (k === ROTATE_3D$1) {
      var _v = v,
          _v2 = _slicedToArray(_v, 4),
          x = _v2[0],
          y = _v2[1],
          z = _v2[2],
          r = _v2[3];

      r = d2r$2(r[0]);
      var s = Math.sin(r);
      var c = Math.cos(r);

      if (x && !y && !z) {
        if (x < 0) {
          s = -s;
        }

        t[5] = c;
        t[9] = -s;
        t[6] = s;
        t[10] = c;
      } else if (y && !x && !z) {
        if (y < 0) {
          s = -s;
        }

        t[0] = c;
        t[8] = s;
        t[2] = -s;
        t[10] = c;
      } else if (z && !x && !y) {
        if (z < 0) {
          s = -s;
        }

        t[0] = c;
        t[4] = -s;
        t[1] = s;
        t[5] = c;
      } else {
        var len = Math.sqrt(x * x + y * y + z * z);

        if (len !== 1) {
          var rlen = 1 / len;
          x *= rlen;
          y *= rlen;
          z *= rlen;
        }

        var nc = 1 - c;
        var xy = x * y;
        var yz = y * z;
        var zx = z * x;
        var xs = x * s;
        var ys = y * s;
        var zs = z * s;
        t[0] = x * x * nc + c;
        t[1] = xy * nc + zs;
        t[2] = zx * nc - ys;
        t[3] = 0;
        t[4] = xy * nc - zs;
        t[5] = y * y * nc + c;
        t[6] = yz * nc + xs;
        t[7] = 0;
        t[8] = zx * nc + ys;
        t[9] = yz * nc - xs;
        t[10] = z * z * nc + c;
        t[11] = 0;
        t[12] = 0;
        t[13] = 0;
        t[14] = 0;
        t[15] = 1;
      }
    } else if (k === PERSPECTIVE$1 && v > 0) {
      v = Math.max(v, 1);
      t[11] = -1 / v;
    } else if (k === MATRIX$1) {
      util.assignMatrix(t, v);
    }
  }

  function calMatrix(transform, ow, oh, root) {
    var list = normalize$1(transform, ow, oh, root);
    var m = identity$1();
    list.forEach(function (item) {
      var _item = _slicedToArray(item, 2),
          k = _item[0],
          v = _item[1];

      var t = identity$1();
      calSingle(t, k, v);
      m = multiply$1(m, t);
    });
    return m;
  } // 已有计算好的变换矩阵，根据tfo原点计算最终的matrix


  function calMatrixByOrigin(m, transformOrigin) {
    var _transformOrigin = _slicedToArray(transformOrigin, 2),
        ox = _transformOrigin[0],
        oy = _transformOrigin[1];

    var res = m.slice(0);

    if (ox === 0 && oy === 0 || isE$2(m)) {
      return res;
    }

    res = multiply$1([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
    res = multiply$1(res, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -ox, -oy, 0, 1]);
    return res;
  } // img缩放svg下专用，无rem


  function calMatrixWithOrigin(transform, transformOrigin, ow, oh) {
    var m = calMatrix(transform, ow, oh);
    return calMatrixByOrigin(m, transformOrigin);
  }

  function normalizeSingle(k, v, ow, oh, root) {
    if (k === TRANSLATE_X$1 || k === TRANSLATE_Z$1) {
      if (v[1] === PERCENT$3) {
        return v[0] * ow * 0.01;
      } else if (v[1] === REM$3) {
        return v[0] * root.computedStyle[FONT_SIZE$3];
      } else if (v[1] === VW$3) {
        return v[0] * root.width * 0.01;
      } else if (v[1] === VH$3) {
        return v[0] * root.height * 0.01;
      } else if (v[1] === VMAX$3) {
        return v[0] * Math.max(root.width, root.height) * 0.01;
      } else if (v[1] === VMIN$3) {
        return v[0] * Math.min(root.width, root.height) * 0.01;
      }
    } else if (k === TRANSLATE_Y$1) {
      if (v[1] === PERCENT$3) {
        return v[0] * oh * 0.01;
      } else if (v[1] === REM$3) {
        return v[0] * root.computedStyle[FONT_SIZE$3];
      } else if (v[1] === VW$3) {
        return v[0] * root.width * 0.01;
      } else if (v[1] === VH$3) {
        return v[0] * root.height * 0.01;
      } else if (v[1] === VMAX$3) {
        return v[0] * Math.max(root.width, root.height) * 0.01;
      } else if (v[1] === VMIN$3) {
        return v[0] * Math.min(root.width, root.height) * 0.01;
      }
    } else if (k === MATRIX$1) {
      return v;
    } else if (k === ROTATE_3D$1) {
      return v;
    }

    return v[0];
  }

  function normalize$1(transform, ow, oh, root) {
    var res = [];
    transform.forEach(function (item) {
      var _item2 = _slicedToArray(item, 2),
          k = _item2[0],
          v = _item2[1];

      res.push([k, normalizeSingle(k, v, ow, oh, root)]);
    });
    return res;
  }

  function calMatrixByPerspective(m, pm) {
    if (!isE$2(pm)) {
      m = multiply$1(pm, m);
    }

    return m;
  }

  function calPerspectiveMatrix(ppt, po) {
    if (ppt && ppt > 0) {
      var res = identity$1();
      ppt = Math.max(ppt, 1);
      res[11] = -1 / ppt;

      var _po = _slicedToArray(po, 2),
          ox = _po[0],
          oy = _po[1];

      if (ox || oy) {
        res = multiply$1([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
        res = multiply$1(res, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -ox, -oy, 0, 1]);
      }

      return res;
    }
  } // 是否有透视矩阵应用


  function isPerspectiveMatrix(m) {
    if (!m) {
      return;
    }

    return !!(m[3] || m[7] || m[11]);
  }

  var transform$1 = {
    calMatrix: calMatrix,
    calMatrixByPerspective: calMatrixByPerspective,
    calPerspectiveMatrix: calPerspectiveMatrix,
    calMatrixByOrigin: calMatrixByOrigin,
    calMatrixWithOrigin: calMatrixWithOrigin,
    isPerspectiveMatrix: isPerspectiveMatrix
  };

  var _enums$STYLE_KEY$4 = enums.STYLE_KEY,
      COLOR$1 = _enums$STYLE_KEY$4.COLOR,
      FONT_WEIGHT$1 = _enums$STYLE_KEY$4.FONT_WEIGHT,
      FONT_FAMILY$1 = _enums$STYLE_KEY$4.FONT_FAMILY,
      FONT_SIZE$4 = _enums$STYLE_KEY$4.FONT_SIZE,
      FONT_STYLE$1 = _enums$STYLE_KEY$4.FONT_STYLE,
      LETTER_SPACING$1 = _enums$STYLE_KEY$4.LETTER_SPACING,
      TEXT_STROKE_COLOR$1 = _enums$STYLE_KEY$4.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$1 = _enums$STYLE_KEY$4.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$1 = _enums$STYLE_KEY$4.TEXT_STROKE_OVER,
      ROTATE_Z$2 = _enums$STYLE_KEY$4.ROTATE_Z,
      LINE_HEIGHT$1 = _enums$STYLE_KEY$4.LINE_HEIGHT;
  var DEG$2 = o.DEG;
  var CANVAS$1 = mode.CANVAS,
      SVG = mode.SVG,
      WEBGL$1 = mode.WEBGL;
  var TuOrU = /(?:[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u02EA\u02EB\u1100-\u11FF\u1401-\u167F\u18B0-\u18FF\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2065\u20DD-\u20E0\u20E2-\u20E4\u2100\u2101\u2103-\u2109\u210F\u2113\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u2135-\u213F\u2145-\u214A\u214C\u214D\u214F-\u2189\u218C-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2B97\u2BB8-\u2BD1\u2BD3-\u2BEB\u2BF0-\u2BFF\u2E50\u2E51\u2E80-\u3007\u3012\u3013\u3020-\u302F\u3031-\u309F\u30A1-\u30FB\u30FD-\uA4CF\uA960-\uA97F\uAC00-\uD7FF\uE000-\uFAFF\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF01-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7\uFFF0-\uFFF8\uFFFC\uFFFD]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|[\uD80C\uD81C-\uD822\uD83C\uD83D\uD840-\uD87E\uD880-\uD8BE][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC3F]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFFF]|\uD823[\uDC00-\uDD7F]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFF]|\uD833[\uDF00-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83E[\uDD00-\uDEFF]|[\uD87F\uD8BF][\uDC00-\uDFFD])/;
  /**
   * 表示一行文本的类，保存它的位置、内容、从属信息，在布局阶段生成，并在渲染阶段被Text调用render()
   * 关系上直属于Text类，一个Text类可能因为换行原因导致有多个TextBox，一行内容中也可能有不同Text从而不同TextBox
   * 另外本类还会被LineBoxManager添加到LineBox里，LineBox为一行中的inline/文本组合，之间需要进行垂直对齐
   * 在textOverflow为ellipsis时，可能会收到后面节点的向前回退（后面不足放下…），使得省略号发生在本节点
   */

  var TextBox = /*#__PURE__*/function () {
    function TextBox(parent, index, x, y, w, h, content) {
      var isUpright = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;

      _classCallCheck(this, TextBox);

      this.__parent = parent;
      this.__index = index;
      this.__x = x;
      this.__y = y;

      if (isUpright) {
        this.__width = h;
        this.__height = w;
      } else {
        this.__width = w;
        this.__height = h;
      }

      this.__content = content;
      this.__virtualDom = {};
      this.__parentLineBox = null;
      this.__isVertical = isUpright;
    }
    /**
     * 渲染阶段被Text类调用，多行Text会有多个TextBox，内容被分拆开
     * @param renderMode
     * @param ctx
     * @param computedStyle
     * @param cacheStyle Text父节点Dom的缓存样式，相比computedStyle可以直接用，比如color被缓存为style字符串
     * @param dx
     * @param dy
     */


    _createClass(TextBox, [{
      key: "render",
      value: function render(renderMode, ctx, computedStyle, cacheStyle, dx, dy) {
        var content = this.content,
            x = this.x,
            y = this.y,
            parent = this.parent,
            width = this.width,
            height = this.height,
            isUpright = this.isUpright;
        var ox = parent.ox,
            oy = parent.oy;
        var dom = parent.parent;
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle); // 垂直文本x/y互换，渲染时使用rotate模拟，因为是基于baseline绘制，顺时针90deg时tfo是文字左下角，
        // 它等同于lineHeight（现在的w）减去b

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += ox + dx;
        y += oy + dy;

        if (isUpright) {
          this.__endX = x;
          this.__endY = y + height;
        } else {
          this.__endX = x + width;
          this.__endY = y;
        }

        var letterSpacing = computedStyle[LETTER_SPACING$1],
            textStrokeWidth = computedStyle[TEXT_STROKE_WIDTH$1],
            textStrokeColor = computedStyle[TEXT_STROKE_COLOR$1],
            fontSize = computedStyle[FONT_SIZE$4],
            lineHeight = computedStyle[LINE_HEIGHT$1];
        var i = 0,
            length = content.length;

        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          var me = dom.matrixEvent,
              list;
          var dev1 = 0,
              dev2 = 0;

          if (isUpright) {
            list = [[ROTATE_Z$2, [90, DEG$2]]];
            dev1 = bv * 0.6;
            dev2 = bv * 0.2;
          }

          var overFill = computedStyle[TEXT_STROKE_OVER$1] === 'fill';

          if (letterSpacing) {
            for (; i < length; i++) {
              var c = content.charAt(i);

              if (isUpright) {
                var cjk = TuOrU.test(c);

                if (cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x - dev1, y - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }
                } else {
                  var tfo = [x, y];
                  var m = transform$1.calMatrixWithOrigin(list, tfo, 0, 0);
                  m = mx.multiply(me, m);
                  ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

                  if (overFill) {
                    ctx.fillText(c, x, y);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x, y);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x, y);
                  }
                }

                y += ctx.measureText(c).width + letterSpacing;
              } else {
                if (overFill) {
                  ctx.fillText(c, x, y);
                }

                if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                  ctx.strokeText(c, x, y);
                }

                if (!overFill) {
                  ctx.fillText(c, x, y);
                }

                x += ctx.measureText(c).width + letterSpacing;
              }
            }
          } else {
            if (isUpright) {
              var _cjk = TuOrU.test(content.charAt(0)),
                  last = 0,
                  count = 0,
                  len = content.length;

              for (var _i = 1; _i < len; _i++) {
                var nowCjk = TuOrU.test(content.charAt(_i)); // 不相等时cjk发生变化，输出之前的内容，记录当下的所有

                if (nowCjk !== _cjk) {
                  if (_cjk) {
                    ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);
                    var s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(s, x - dev1, y + count + b - dev2);
                    }

                    if (!overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    count += fontSize;
                  } else {
                    var _tfo = [x, y + count];

                    var _m = transform$1.calMatrixWithOrigin(list, _tfo, 0, 0);

                    _m = mx.multiply(me, _m);
                    ctx.setTransform(_m[0], _m[1], _m[4], _m[5], _m[12], _m[13]);

                    var _s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(_s, x, y + count);
                    }

                    if (!overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    count += ctx.measureText(_s).width;
                  }

                  last = _i;
                  _cjk = !_cjk;
                } // cjk单字符输出
                else if (nowCjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  var _s2 = content.slice(last, _i);

                  if (overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  count += fontSize;
                  last = _i;
                }
              }

              if (last < len) {
                var _s3 = content.slice(last, len); // 最后的cjk只可能是一个字符


                if (_cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }
                } else {
                  var _tfo2 = [x, y + count];

                  var _m2 = transform$1.calMatrixWithOrigin(list, _tfo2, 0, 0);

                  _m2 = mx.multiply(me, _m2);
                  ctx.setTransform(_m2[0], _m2[1], _m2[4], _m2[5], _m2[12], _m2[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x, y + count);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }
                }
              }
            } else {
              if (overFill) {
                ctx.fillText(content, x, y);
              }

              if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                ctx.strokeText(content, x, y);
              }

              if (!overFill) {
                ctx.fillText(content, x, y);
              }
            }
          }
        } else if (renderMode === SVG) {
          var color = cacheStyle[COLOR$1];

          if (color.k) {
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          } // 垂直的svg以中线为基线，需偏移baseline和中线的差值


          if (isUpright) {
            x += lineHeight * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$1]], ['font-weight', computedStyle[FONT_WEIGHT$1]], ['font-style', computedStyle[FONT_STYLE$1]], ['font-size', computedStyle[FONT_SIZE$4] + 'px']]; // svg无法定义stroke的over

          if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
            var _textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$1]; // 渐变

            if (_textStrokeColor.k) {
              _textStrokeColor = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, _textStrokeColor, dx, dy).v;
            }

            props.push(['stroke', _textStrokeColor]);
            props.push(['stroke-width', computedStyle[TEXT_STROKE_WIDTH$1]]);
          }

          if (letterSpacing) {
            props.push(['letter-spacing', letterSpacing]);
          }

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          this.__virtualDom = {
            type: 'item',
            tagName: 'text',
            props: props,
            content: util.encodeHtml(content)
          };
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.__x += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.__y += diff;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.__endX;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.__endY;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.parent.baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.parent.verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }]);

    return TextBox;
  }();

  var _enums$STYLE_KEY$5 = enums.STYLE_KEY,
      FONT_SIZE$5 = _enums$STYLE_KEY$5.FONT_SIZE,
      FONT_FAMILY$2 = _enums$STYLE_KEY$5.FONT_FAMILY,
      FONT_WEIGHT$2 = _enums$STYLE_KEY$5.FONT_WEIGHT,
      FONT_STYLE$2 = _enums$STYLE_KEY$5.FONT_STYLE,
      COLOR$2 = _enums$STYLE_KEY$5.COLOR,
      LINE_HEIGHT$2 = _enums$STYLE_KEY$5.LINE_HEIGHT,
      ROTATE_Z$3 = _enums$STYLE_KEY$5.ROTATE_Z,
      NODE_VIRTUAL_DOM = enums.NODE_KEY.NODE_VIRTUAL_DOM;
  var DEG$3 = o.DEG;
  var CANVAS$2 = mode.CANVAS,
      SVG$1 = mode.SVG,
      WEBGL$2 = mode.WEBGL;
  var CHAR = '…';

  var Ellipsis = /*#__PURE__*/function (_Node) {
    _inherits(Ellipsis, _Node);

    var _super = _createSuper(Ellipsis);

    function Ellipsis(x, y, width, parent, isUpright) {
      var _this;

      _classCallCheck(this, Ellipsis);

      _this = _super.call(this);
      _this.__x = _this.__sx1 = x;
      _this.__y = _this.__sy1 = y;
      _this.__width = width;
      _this.__parent = _this.__domParent = parent;
      parent.__ellipsis = _assertThisInitialized(_this);
      _this.__parentLineBox = null;
      _this.__baseline = css.getBaseline(parent.computedStyle);
      _this.__isVertical = isUpright;
      return _this;
    }

    _createClass(Ellipsis, [{
      key: "render",
      value: function render(renderMode, lv, ctx, cache) {
        var dx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var dy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var x = this.x,
            y = this.y,
            parent = this.parent,
            isUpright = this.isUpright;
        var ox = parent.ox,
            oy = parent.oy,
            computedStyle = parent.computedStyle,
            color = parent.cacheStyle[COLOR$2];
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle);

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += ox + dx;
        y += oy + dy;

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          if (isUpright) {
            var me = parent.matrixEvent,
                list = [[ROTATE_Z$3, [90, DEG$3]]];
            var tfo = [x, y];
            var m = transform$1.calMatrixWithOrigin(list, tfo, 0, 0);
            m = mx.multiply(me, m);
            ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
          }

          ctx.fillText(CHAR, x, y);
        } else if (renderMode === SVG$1) {
          // 垂直的svg以中线为基线，需偏移baseline和中线的差值
          if (isUpright) {
            x += computedStyle[LINE_HEIGHT$2] * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$2]], ['font-weight', computedStyle[FONT_WEIGHT$2]], ['font-style', computedStyle[FONT_STYLE$2]], ['font-size', computedStyle[FONT_SIZE$5] + 'px']];

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          var vd = this.__config[NODE_VIRTUAL_DOM] = this.__virtualDom = {
            type: 'text',
            children: [{
              type: 'item',
              tagName: 'text',
              props: props,
              content: CHAR
            }]
          };
          parent.virtualDom.children.push(vd);
        }
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "isEllipsis",
      get: function get() {
        return true;
      }
    }]);

    return Ellipsis;
  }(Node);

  var SIZE = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192];
  var NUMBER$2 = [128, 64, 32, 16, 8, 4, 2, 1, 1, 1, 1];
  var MAX = SIZE[SIZE.length - 1];
  var HASH_CANVAS = {};
  var uuid = 0;

  var Page = /*#__PURE__*/function () {
    function Page(size, number) {
      _classCallCheck(this, Page);

      this.__size = size;
      this.__number = number;
      this.__free = this.__total = number * number;
      size *= number;
      this.__width = size;
      this.__height = size;
      var offscreen = this.__canvas = inject.getCacheCanvas(size, size, null, number);

      if (offscreen) {
        this.__offscreen = offscreen;
      } // 1/0标识n*n个单元格是否空闲可用，一维数组表示


      this.__grid = [];

      for (var i = 0; i < this.__total; i++) {
        this.__grid.push(1);
      }

      this.__uuid = uuid++; // webgl贴图缓存使用，一旦更新则标识记录，绑定某号纹理单元查看变化才更新贴图

      this.__update = false;
      this.time = 0;
    }

    _createClass(Page, [{
      key: "add",
      value: function add() {
        var number = this.number,
            grid = this.grid;

        for (var i = 0; i < number; i++) {
          for (var j = 0; j < number; j++) {
            var index = i * number + j;

            if (grid[index]) {
              grid[index] = 0;
              this.__free--;
              return index;
            }
          }
        } // 理论不可能进入，除非bug


        throw new Error('Can not find free page');
      }
    }, {
      key: "del",
      value: function del(pos) {
        if (!this.grid[pos]) {
          this.grid[pos] = 1;
          this.__free++;
        }
      }
    }, {
      key: "getCoords",
      value: function getCoords(pos) {
        var size = this.size,
            number = this.number;
        var x = pos % number;
        var y = Math.floor(pos / number);
        return [x * size, y * size];
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__size;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "number",
      get: function get() {
        return this.__number;
      }
    }, {
      key: "total",
      get: function get() {
        return this.__total;
      }
    }, {
      key: "free",
      get: function get() {
        return this.__free;
      }
    }, {
      key: "grid",
      get: function get() {
        return this.__grid;
      }
    }, {
      key: "offscreen",
      get: function get() {
        return this.__offscreen;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.offscreen.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.offscreen.ctx;
      }
    }, {
      key: "update",
      get: function get() {
        return this.__update;
      },
      set: function set(v) {
        this.__update = v;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(size) {
        if (size > MAX) {
          return;
        }

        var s = SIZE[0];
        var n = NUMBER$2[0]; // 使用刚好满足的尺寸

        for (var i = 0, len = SIZE.length; i < len; i++) {
          s = SIZE[i];
          n = NUMBER$2[i];

          if (SIZE[i] >= size) {
            break;
          }
        }

        var list = HASH_CANVAS[s] = HASH_CANVAS[s] || []; // 从hash列表中尝试取可用的一页，找不到就生成新的页

        var page;

        for (var _i = 0, _len = list.length; _i < _len; _i++) {
          var item = list[_i];

          if (item.free) {
            page = item;
            break;
          }
        }

        if (!page) {
          page = new Page(s, n);

          if (!page.offscreen) {
            inject.error('Can not create off-screen for page');
            return;
          }

          list.push(page);
        }

        var pos = page.add();
        return {
          page: page,
          pos: pos
        };
      }
    }, {
      key: "CONFIG",
      get: function get() {
        return {
          SIZE: SIZE,
          NUMBER: NUMBER$2
        };
      },
      set: function set(v) {
        if (!v || !Array.isArray(v.SIZE) || !Array.isArray(v.NUMBER)) {
          return;
        }

        SIZE = v.SIZE;
        NUMBER$2 = v.NUMBER;
        MAX = SIZE[SIZE.length - 1];
      }
    }, {
      key: "MAX",
      get: function get() {
        return MAX;
      }
    }, {
      key: "genUuid",
      value: function genUuid() {
        return uuid++;
      }
    }]);

    return Page;
  }();

  var _enums$STYLE_KEY$6 = enums.STYLE_KEY,
      TRANSFORM_ORIGIN$2 = _enums$STYLE_KEY$6.TRANSFORM_ORIGIN,
      TRANSFORM$1 = _enums$STYLE_KEY$6.TRANSFORM;
  var spreadFilter$1 = css.spreadFilter; // 根据一个共享cache的信息，生成一个独立的离屏canvas，一般是filter,mask用，可能尺寸会发生变化

  function genSingle(cache, message, bboxNew) {
    var size = cache.size,
        sx1 = cache.sx1,
        sy1 = cache.sy1,
        bbox = cache.bbox;
    bboxNew = bboxNew || bbox;
    var width = bboxNew[2] - bboxNew[0];
    var height = bboxNew[3] - bboxNew[1];
    var dx = bboxNew[0] - bbox[0];
    var dy = bboxNew[1] - bbox[1];
    var offscreen = inject.getCacheCanvas(width, height, null, message);
    offscreen.x = 0;
    offscreen.y = 0;
    offscreen.bbox = bboxNew;
    offscreen.size = size;
    offscreen.sx1 = sx1;
    offscreen.sy1 = sy1;
    offscreen.dx = -bboxNew[0];
    offscreen.dy = -bboxNew[1];
    offscreen.dbx = cache.dbx - dx;
    offscreen.dby = cache.dby - dy;
    offscreen.width = width;
    offscreen.height = height;
    return offscreen;
  }

  var Cache = /*#__PURE__*/function () {
    function Cache(w, h, bbox, page, pos, x1, y1) {
      _classCallCheck(this, Cache);

      this.__init(w, h, bbox, page, pos, x1, y1);
    }

    _createClass(Cache, [{
      key: "__init",
      value: function __init(w, h, bbox, page, pos, x1, y1) {
        this.__width = w;
        this.__height = h;
        this.__bbox = bbox;
        this.__page = page;
        this.__pos = pos;

        var _page$getCoords = page.getCoords(pos),
            _page$getCoords2 = _slicedToArray(_page$getCoords, 2),
            x = _page$getCoords2[0],
            y = _page$getCoords2[1];

        this.__x = x;
        this.__y = y;

        this.__appendData(x1, y1);

        this.__isNew = true;

        if (page.canvas) {
          this.__enabled = true;
          var ctx = page.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.globalAlpha = 1;

          if (debug.flag) {
            page.canvas.setAttribute && page.canvas.setAttribute('size', page.size);
          }
        }
      }
    }, {
      key: "__appendData",
      value: function __appendData(sx1, sy1) {
        this.sx1 = sx1; // 去除margin的左上角原点坐标

        this.sy1 = sy1;
        var bbox = this.bbox;
        this.dx = this.x - bbox[0]; // cache坐标和box原点的差值

        this.dy = this.y - bbox[1];
        this.dbx = sx1 - bbox[0]; // 原始sx1/sy1和box原点的差值

        this.dby = sy1 - bbox[1];
        this.update();
      }
    }, {
      key: "update",
      value: function update() {
        this.page.update = true;
      }
    }, {
      key: "clear",
      value: function clear() {
        if (this.available) {
          var ctx = this.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          var size = this.page.size;
          ctx.clearRect(this.x, this.y, size, size);
          this.__available = false;
          this.__isNew = true;
        }
      }
    }, {
      key: "release",
      value: function release() {
        if (this.enabled) {
          this.clear();
          this.page.del(this.pos);
          this.__page = null;
          this.__enabled = false;
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1) {
        // 尺寸没变复用之前的并清空
        if (util.equalArr(this.bbox, bbox) && this.enabled) {
          this.clear();
          return;
        }

        this.release();
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var res = Page.getInstance(Math.max(w, h));

        if (!res) {
          this.__enabled = false;
          return;
        }

        var page = res.page,
            pos = res.pos;

        this.__init(w, h, bbox, page, pos, x1, y1);
      }
    }, {
      key: "resetBbox",
      value: function resetBbox(bbox) {} // 是否功能可用，生成离屏canvas及尺寸超限

    }, {
      key: "enabled",
      get: function get() {
        return this.__enabled;
      } // 是否有可用缓存内容

    }, {
      key: "available",
      get: function get() {
        return this.enabled && this.__available;
      }
    }, {
      key: "bbox",
      get: function get() {
        return this.__bbox;
      }
    }, {
      key: "page",
      get: function get() {
        return this.__page;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.page.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.page.ctx;
      }
    }, {
      key: "size",
      get: function get() {
        return this.page.size;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "pos",
      get: function get() {
        return this.__pos;
      }
    }, {
      key: "isNew",
      get: function get() {
        return this.__isNew;
      }
    }], [{
      key: "MAX",
      get: function get() {
        return Page.MAX;
      }
    }, {
      key: "getInstance",
      value: function getInstance(bbox, x1, y1) {
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var res = Page.getInstance(Math.max(w, h));

        if (!res) {
          return;
        }

        var page = res.page,
            pos = res.pos;
        return new Cache(w, h, bbox, page, pos, x1, y1);
      }
      /**
       * 复制cache的一块出来单独作为cacheFilter，尺寸边距保持一致，用浏览器原生ctx.filter滤镜
       * @param cache
       * @param filter
       * @returns {{canvas: *, ctx: *, release(): void, available: boolean, draw()}}
       */

    }, {
      key: "genFilter",
      value: function genFilter(cache, filter) {
        var x = cache.x,
            y = cache.y,
            size = cache.size,
            canvas = cache.canvas,
            sx1 = cache.sx1,
            sy1 = cache.sy1,
            width = cache.width,
            height = cache.height,
            bbox = cache.bbox;
        var oldX1 = bbox[0];
        bbox = spreadFilter$1(bbox, filter);
        var d = oldX1 - bbox[0];
        var widthNew = bbox[2] - bbox[0];
        var heightNew = bbox[3] - bbox[1];
        var offscreen = inject.getCacheCanvas(widthNew, heightNew, null, 'filter');
        offscreen.ctx.filter = painter.canvasFilter(filter);
        offscreen.ctx.drawImage(canvas, x, y, width, height, d, d, width, height);
        offscreen.ctx.filter = 'none';
        offscreen.draw();
        offscreen.bbox = bbox; // 单独的离屏，其dx/dy要重算

        offscreen.x = 0;
        offscreen.y = 0;
        offscreen.size = size;
        offscreen.sx1 = sx1;
        offscreen.sy1 = sy1;
        offscreen.dx = -bbox[0];
        offscreen.dy = -bbox[1];
        offscreen.dbx = cache.dbx + d;
        offscreen.dby = cache.dby + d;
        offscreen.width = widthNew;
        offscreen.height = heightNew;
        return offscreen;
      }
    }, {
      key: "genMask",
      value: function genMask(target, node, cb) {
        var cacheMask = genSingle(target, 'mask1');
        var list = [];
        var _node$computedStyle = node.computedStyle,
            transform = _node$computedStyle[TRANSFORM$1],
            tfo = _node$computedStyle[TRANSFORM_ORIGIN$2];
        var next = node.next;
        var isClip = next.isClip;

        while (next && next.isMask) {
          list.push(next);
          next = next.next;
        }

        var x = cacheMask.x,
            y = cacheMask.y,
            ctx = cacheMask.ctx,
            dbx = cacheMask.dbx,
            dby = cacheMask.dby;
        tfo[0] += x + dbx + node.__sx1 - target.sx1;
        tfo[1] += y + dby + node.__sy1 - target.sy1;
        var inverse = transform$1.calMatrixByOrigin(transform, tfo); // 先将mask本身绘制到cache上，再设置模式绘制dom本身，因为都是img所以1个就够了

        list.forEach(function (item) {
          cb(item, cacheMask, inverse);
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = isClip ? 'source-out' : 'source-in';
        Cache.drawCache(target, cacheMask);
        ctx.globalCompositeOperation = 'source-over';
        cacheMask.draw(ctx);
        return cacheMask;
      }
      /**
       * 如果不超过bbox，直接用已有的total/filter/mask，否则生成一个新的
       */

    }, {
      key: "genOverflow",
      value: function genOverflow(target, node) {
        var bbox = target.bbox;
        var __sx1 = node.__sx1,
            __sy1 = node.__sy1,
            clientWidth = node.clientWidth,
            clientHeight = node.clientHeight;
        var xe = __sx1 + clientWidth;
        var ye = __sy1 + clientHeight;

        if (bbox[0] < __sx1 || bbox[1] < __sy1 || bbox[2] > xe || bbox[3] > ye) {
          var bboxNew = [__sx1, __sy1, xe, ye];
          var cacheOverflow = genSingle(target, 'overflow', bboxNew);
          var ctx = cacheOverflow.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.globalAlpha = 1;
          Cache.drawCache(target, cacheOverflow);
          cacheOverflow.draw(ctx);
          ctx.globalCompositeOperation = 'destination-in';
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.rect(0, 0, clientWidth, clientHeight);
          ctx.fill();
          ctx.closePath();
          ctx.globalCompositeOperation = 'source-over';
          return cacheOverflow;
        }
      }
    }, {
      key: "drawCache",
      value: function drawCache(source, target, transform, matrix, tfo, parentMatrix, inverse) {
        var tx = target.x,
            ty = target.y,
            sx1 = target.sx1,
            sy1 = target.sy1,
            ctx = target.ctx,
            dbx = target.dbx,
            dby = target.dby;
        var x = source.x,
            y = source.y,
            canvas = source.canvas,
            sx2 = source.sx1,
            sy2 = source.sy1,
            dbx2 = source.dbx,
            dby2 = source.dby,
            width = source.width,
            height = source.height;
        var ox = tx + sx2 - sx1 + dbx - dbx2;
        var oy = ty + sy2 - sy1 + dby - dby2;

        if (transform && matrix && tfo) {
          tfo[0] += ox;
          tfo[1] += oy;
          var m = transform$1.calMatrixByOrigin(transform, tfo);
          matrix = mx.multiply(matrix, m);

          if (!mx.isE(parentMatrix)) {
            matrix = mx.multiply(parentMatrix, matrix);
          }

          if (inverse) {
            // 很多情况mask和target相同matrix，可简化计算
            if (util.equalArr(matrix, inverse)) {
              matrix = mx.identity();
            } else {
              inverse = mx.inverse(inverse);
              matrix = mx.multiply(inverse, matrix);
            }
          }

          ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        }

        ctx.drawImage(canvas, x, y, width, height, ox, oy, width, height);
      }
    }, {
      key: "draw",
      value: function draw(ctx, opacity, matrix, cache) {
        ctx.globalAlpha = opacity;
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        var x = cache.x,
            y = cache.y,
            canvas = cache.canvas,
            sx1 = cache.sx1,
            sy1 = cache.sy1,
            dbx = cache.dbx,
            dby = cache.dby,
            width = cache.width,
            height = cache.height;
        ctx.drawImage(canvas, x, y, width, height, sx1 - dbx, sy1 - dby, width, height);
      }
    }, {
      key: "getCache",
      value: function getCache(list) {
        for (var i = 0, len = list.length; i < len; i++) {
          var item = list[i];

          if (item && item.available) {
            return item;
          }
        }
      } // webgl专用

    }]);

    return Cache;
  }();

  _defineProperty(Cache, "NA", 0);

  _defineProperty(Cache, "LOCAL", 1);

  _defineProperty(Cache, "CHILD", 2);

  _defineProperty(Cache, "SELF", 3);

  var _TRANSFORMS;
  var STYLE_KEY$4 = enums.STYLE_KEY,
      _enums$STYLE_KEY$7 = enums.STYLE_KEY,
      TRANSLATE_X$2 = _enums$STYLE_KEY$7.TRANSLATE_X,
      TRANSLATE_Y$2 = _enums$STYLE_KEY$7.TRANSLATE_Y,
      TRANSLATE_Z$2 = _enums$STYLE_KEY$7.TRANSLATE_Z,
      OPACITY$1 = _enums$STYLE_KEY$7.OPACITY,
      FILTER$1 = _enums$STYLE_KEY$7.FILTER,
      PERSPECTIVE$2 = _enums$STYLE_KEY$7.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$1 = _enums$STYLE_KEY$7.PERSPECTIVE_ORIGIN;
  var ENUM = {
    // 低位表示<repaint级别
    NONE: 0,
    //                                          0
    TRANSLATE_X: 1,
    //                                   1
    TRANSLATE_Y: 2,
    //                                  10
    TRANSLATE_Z: 4,
    //                                 100
    TRANSFORM: 8,
    //                                  1000
    TRANSFORM_ALL: 15,
    //                             1111
    OPACITY: 16,
    //                                  10000
    FILTER: 32,
    //                                  100000
    MIX_BLEND_MODE: 64,
    //                         1000000
    PERSPECTIVE: 128,
    //                          10000000
    REPAINT: 256,
    //                             100000000
    // 高位表示reflow
    REFLOW: 512,
    //                             1000000000
    // 特殊高位表示rebuild
    REBUILD: 1024 //                          10000000000

  };
  var TRANSFORMS = (_TRANSFORMS = {}, _defineProperty(_TRANSFORMS, STYLE_KEY$4.SCALE_X, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.SCALE_Y, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.SCALE_Z, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.ROTATE_X, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.ROTATE_Y, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.ROTATE_Z, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.ROTATE_3D, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.TRANSFORM, true), _defineProperty(_TRANSFORMS, STYLE_KEY$4.TRANSFORM_ORIGIN, true), _TRANSFORMS);
  var o$3 = Object.assign({
    contain: function contain(lv, value) {
      return (lv & value) > 0;
    },

    /**
     * 得出等级
     * @param k
     * @returns {number|*}
     */
    getLevel: function getLevel(k) {
      if (o$2.isIgnore(k)) {
        return ENUM.NONE;
      }

      if (k === TRANSLATE_X$2) {
        return ENUM.TRANSLATE_X;
      } else if (k === TRANSLATE_Y$2) {
        return ENUM.TRANSLATE_Y;
      } else if (k === TRANSLATE_Z$2) {
        return ENUM.TRANSLATE_Z;
      } else if (TRANSFORMS.hasOwnProperty(k)) {
        return ENUM.TRANSFORM;
      } else if (k === OPACITY$1) {
        return ENUM.OPACITY;
      } else if (k === FILTER$1) {
        return ENUM.FILTER;
      } else if (k === PERSPECTIVE$2 || k === PERSPECTIVE_ORIGIN$1) {
        return ENUM.PERSPECTIVE;
      } else if (o$2.isRepaint(k)) {
        return ENUM.REPAINT;
      }

      return ENUM.REFLOW;
    },
    isReflow: function isReflow(lv) {
      return !this.isRepaint(lv);
    },
    isRepaint: function isRepaint(lv) {
      return lv < ENUM.REFLOW;
    },
    isRebuild: function isRebuild(lv) {
      return lv >= ENUM.REBUILD;
    }
  }, ENUM);
  o$3.TRANSFORMS = TRANSFORMS;

  var _enums$STYLE_KEY$8 = enums.STYLE_KEY,
      DISPLAY$1 = _enums$STYLE_KEY$8.DISPLAY,
      POSITION$1 = _enums$STYLE_KEY$8.POSITION,
      LINE_HEIGHT$3 = _enums$STYLE_KEY$8.LINE_HEIGHT,
      FONT_SIZE$6 = _enums$STYLE_KEY$8.FONT_SIZE,
      FONT_FAMILY$3 = _enums$STYLE_KEY$8.FONT_FAMILY,
      FONT_WEIGHT$3 = _enums$STYLE_KEY$8.FONT_WEIGHT,
      COLOR$3 = _enums$STYLE_KEY$8.COLOR,
      VISIBILITY$1 = _enums$STYLE_KEY$8.VISIBILITY,
      LETTER_SPACING$2 = _enums$STYLE_KEY$8.LETTER_SPACING,
      OVERFLOW = _enums$STYLE_KEY$8.OVERFLOW,
      WHITE_SPACE$1 = _enums$STYLE_KEY$8.WHITE_SPACE,
      TEXT_OVERFLOW$1 = _enums$STYLE_KEY$8.TEXT_OVERFLOW,
      WIDTH$2 = _enums$STYLE_KEY$8.WIDTH,
      HEIGHT$2 = _enums$STYLE_KEY$8.HEIGHT,
      TEXT_STROKE_COLOR$2 = _enums$STYLE_KEY$8.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$2 = _enums$STYLE_KEY$8.TEXT_STROKE_WIDTH,
      MARGIN_TOP = _enums$STYLE_KEY$8.MARGIN_TOP,
      MARGIN_BOTTOM = _enums$STYLE_KEY$8.MARGIN_BOTTOM,
      MARGIN_LEFT = _enums$STYLE_KEY$8.MARGIN_LEFT,
      MARGIN_RIGHT = _enums$STYLE_KEY$8.MARGIN_RIGHT,
      PADDING_TOP$1 = _enums$STYLE_KEY$8.PADDING_TOP,
      PADDING_BOTTOM$1 = _enums$STYLE_KEY$8.PADDING_BOTTOM,
      PADDING_LEFT$1 = _enums$STYLE_KEY$8.PADDING_LEFT,
      PADDING_RIGHT = _enums$STYLE_KEY$8.PADDING_RIGHT,
      BORDER_TOP_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$1 = _enums$STYLE_KEY$8.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH = _enums$STYLE_KEY$8.BORDER_RIGHT_WIDTH,
      FILTER$2 = _enums$STYLE_KEY$8.FILTER,
      _enums$NODE_KEY$1 = enums.NODE_KEY,
      NODE_CACHE = _enums$NODE_KEY$1.NODE_CACHE,
      NODE_LIMIT_CACHE = _enums$NODE_KEY$1.NODE_LIMIT_CACHE,
      NODE_DOM_PARENT = _enums$NODE_KEY$1.NODE_DOM_PARENT,
      NODE_MATRIX_EVENT = _enums$NODE_KEY$1.NODE_MATRIX_EVENT,
      NODE_OPACITY = _enums$NODE_KEY$1.NODE_OPACITY,
      NODE_VIRTUAL_DOM$1 = _enums$NODE_KEY$1.NODE_VIRTUAL_DOM,
      _enums$UPDATE_KEY = enums.UPDATE_KEY,
      UPDATE_NODE = _enums$UPDATE_KEY.UPDATE_NODE,
      UPDATE_FOCUS = _enums$UPDATE_KEY.UPDATE_FOCUS,
      UPDATE_CONFIG = _enums$UPDATE_KEY.UPDATE_CONFIG,
      ELLIPSIS = enums.ELLIPSIS;
  var AUTO$1 = o.AUTO;
  var CANVAS$3 = mode.CANVAS,
      SVG$2 = mode.SVG,
      WEBGL$3 = mode.WEBGL;
  /**
   * 在给定宽度w的情况下，测量文字content多少个满足塞下，只支持水平书写，从start的索引开始，content长length
   * 尽可能地少的次数调用canvas的measureText或svg的html节点的width，因为比较消耗性能
   * 这就需要一种算法，不能逐字遍历看总长度是否超过，也不能单字宽度相加因为有文本整形某些字体多个字宽度不等于每个之和
   * 简单的2分法实现简单，但是次数稍多，对于性能不是最佳，因为内容的slice裁剪和传递给canvas测量都随尺寸增加而加大
   * 由于知道w和fontSize，因此能推测出平均值为fontSize/w，即字的个数，
   * 进行测量后得出w2，和真实w对比，产生误差d，再看d和fontSize推测差距个数，如此反复
   * 返回内容和end索引和长度，最少也要1个字符
   * @param ctx
   * @param renderMode
   * @param start
   * @param length
   * @param content
   * @param w
   * @param perW
   * @param fontFamily
   * @param fontSize
   * @param fontWeight
   * @param letterSpacing
   * @param isUpright
   */

  function measureLineWidth(ctx, renderMode, start, length, content, w, perW, fontFamily, fontSize, fontWeight, letterSpacing, isUpright) {
    if (start >= length) {
      // 特殊情况不应该走进这里
      return [0, 0, false];
    }

    var i = start,
        j = length,
        rw = 0,
        newLine = false; // 特殊降级，有letterSpacing时，canvas无法完全兼容，只能采取单字测量的方式完成

    if (letterSpacing && [CANVAS$3, WEBGL$3].indexOf(renderMode) > -1) {
      var count = 0;

      for (; i < j; i++) {
        var mw = ctx.measureText(content.charAt(i)).width + letterSpacing;

        if (count + mw > w + 1e-10) {
          newLine = true;
          break;
        }

        count += mw;
      }

      return [i - start, count, newLine || count > w + 1e-10];
    } // 没有letterSpacing或者是svg模式可以完美获取TextMetrics


    var hypotheticalNum = Math.round(w / perW); // 不能增长0个字符，至少也要1个

    if (hypotheticalNum <= 0) {
      hypotheticalNum = 1;
    } // 超过内容长度范围也不行
    else if (hypotheticalNum > length - start) {
      hypotheticalNum = length - start;
    } // 类似2分的一个循环


    while (i < j) {
      var _mw = void 0,
          str = content.slice(start, start + hypotheticalNum);

      if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
        _mw = ctx.measureText(str).width;
      } else if (renderMode === SVG$2) {
        _mw = inject.measureTextSync(str, fontFamily, fontSize, fontWeight, isUpright);
      }

      if (letterSpacing) {
        _mw += hypotheticalNum * letterSpacing;
      }

      if (_mw === w) {
        rw = w;
        newLine = true;
        break;
      } // 超出，设置右边界，并根据余量推测减少个数，
      // 因为精度问题，固定宽度或者累加的剩余空间，不用相等判断，而是为原本w宽度加一点点冗余1e-10


      if (_mw > w + 1e-10) {
        newLine = true; // 限制至少1个

        if (hypotheticalNum === 1) {
          rw = _mw;
          break;
        } // 注意特殊判断i和j就差1个可直接得出结果，因为现在超了而-1不超肯定是-1的结果


        if (i === j - 1 || i - start === hypotheticalNum - 1) {
          hypotheticalNum = i - start;
          break;
        }

        j = hypotheticalNum - 1;
        var reduce = Math.round((_mw - w) / perW);

        if (reduce <= 0) {
          reduce = 1;
        }

        hypotheticalNum -= reduce;

        if (hypotheticalNum < i - start) {
          hypotheticalNum = i - start;
        }
      } // 还有空余，设置左边界，并根据余量推测增加的个数
      else {
        rw = _mw;

        if (hypotheticalNum === length - start) {
          break;
        }

        i = hypotheticalNum + start;
        var add = Math.round((w - _mw) / perW);

        if (add <= 0) {
          add = 1;
        }

        hypotheticalNum += add;

        if (hypotheticalNum > j - start) {
          hypotheticalNum = j - start;
        }
      }
    }

    return [hypotheticalNum, rw, newLine];
  }

  function getFontKey(ff, fs, fw, ls) {
    return ff + '_' + fs + '_' + fw + '_' + ls;
  }

  var Text = /*#__PURE__*/function (_Node) {
    _inherits(Text, _Node);

    var _super = _createSuper(Text);

    function Text(content) {
      var _this;

      _classCallCheck(this, Text);

      _this = _super.call(this);
      _this.__content = util.isNil(content) ? '' : content.toString();
      _this.__textBoxes = [];
      _this.__charWidth = 0; // 最小字符宽度（单个）

      _this.__textWidth = 0; // 整体宽度

      _this.__bp = null; // block父节点

      _this.__widthHash = {}; // 存储当前字体样式key下的charWidth/textWidth

      return _this;
    }
    /**
     * text在virtual时和普通一样，无需特殊处理
     * endSpace由外界inline布局控制，末尾最后一行的空白mpb，包含递归情况，递归为多个嵌套末尾节点的空白mpb之和
     * 即便宽度不足，每行还是强制渲染一个字符，换行依据lx开始，因为x可能是从中间开始的，非inline则两个相等
     * 最后一个字符排版时要考虑末尾mpb，排不下的话回退删掉这个字符，如果最后一个字符另起开头，排不下也强制排，每行至少1个字符
     * 在textOverflow时很特殊，多个inline同行，回退可能到前一个inline节点，这个通过x和lx判断是否行首，决定至少1个字符规则
     * @param data
     * @private
     */


    _createClass(Text, [{
      key: "__layout",
      value: function __layout(data) {
        var __cache = this.__config[NODE_CACHE];

        if (__cache) {
          __cache.release();
        }

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            _data$lx = data.lx,
            lx = _data$lx === void 0 ? x : _data$lx,
            _data$ly = data.ly,
            ly = _data$ly === void 0 ? y : _data$ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            _data$lineClamp = data.lineClamp,
            lineClamp = _data$lineClamp === void 0 ? 0 : _data$lineClamp,
            _data$lineClampCount = data.lineClampCount,
            lineClampCount = _data$lineClampCount === void 0 ? 0 : _data$lineClampCount,
            _data$isUpright = data.isUpright,
            isUpright = _data$isUpright === void 0 ? false : _data$isUpright;
        this.__x = this.__sx = this.__sx1 = x;
        this.__y = this.__sy = this.__sy1 = y;
        var isDestroyed = this.isDestroyed,
            content = this.content,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            root = this.root;
        textBoxes.splice(0);
        var __config = this.__config;
        __config[NODE_LIMIT_CACHE] = false; // 空内容w/h都为0可以提前跳出，lineClamp超出一般不会进这，但有特例flex文本垂直预计算时，所以也要跳出

        if (isDestroyed || computedStyle[DISPLAY$1] === 'none' || !content || lineClamp && lineClampCount >= lineClamp) {
          return lineClampCount;
        }

        this.__ox = this.__oy = 0; // 顺序尝试分割字符串为TextBox，形成多行，begin为每行起始索引，i是当前字符索引

        var i = 0;
        var length = content.length;
        var maxW = 0;
        var lineHeight = computedStyle[LINE_HEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2],
            whiteSpace = computedStyle[WHITE_SPACE$1],
            fontSize = computedStyle[FONT_SIZE$6],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            fontFamily = computedStyle[FONT_FAMILY$3];
        var size = isUpright ? h : w;
        var beginSpace = isUpright ? y - ly : x - lx; // x>=lx，当第一行非起始处时前面被prev节点占据，这个差值可认为是count宽度
        // 基于最近block父节点的样式

        var bp = this.domParent;

        while (bp.computedStyle[DISPLAY$1] === 'inline') {
          bp = bp.domParent;
        }

        this.__bp = bp;
        var textOverflow = bp.computedStyle[TEXT_OVERFLOW$1];
        css.getFontFamily(fontFamily); // 有检测过程必须执行
        // 布局测量前置，根据renderMode不同提供不同的测量方法

        var renderMode = root.renderMode;
        var ctx;

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          ctx = renderMode === WEBGL$3 ? inject.getFontCanvas().ctx : root.ctx;
          ctx.font = css.setFontStyle(computedStyle);
        } // fontSize在中文是正好1个字宽度，英文不一定，等宽为2个，不等宽可能1~2个，特殊字符甚至>2个，取预估均值然后倒数得每个均宽0.8


        var perW = fontSize * 0.8 + letterSpacing;
        var lineCount = 0;
        var mainCoords; // 根据书写模式指向不同x/y
        // 不换行特殊对待，同时考虑overflow和textOverflow

        if (whiteSpace === 'nowrap') {
          var isTextOverflow,
              textWidth = this.textWidth;
          var _bp$computedStyle = bp.computedStyle,
              position = _bp$computedStyle[POSITION$1],
              overflow = _bp$computedStyle[OVERFLOW];
          var containerSize = bp.currentStyle[isUpright ? HEIGHT$2 : WIDTH$2]; // 只要是overflow隐藏，不管textOverflow如何（默认是clip等同于overflow:hidden的功能）都截取

          if (overflow === 'hidden') {
            // abs自适应宽度时不裁剪
            if (position === 'absolute' && containerSize[1] === AUTO$1) {
              isTextOverflow = false;
            } else {
              isTextOverflow = textWidth > size + 1e-10 - beginSpace - endSpace;
            }
          } // ellipsis生效情况，本节点开始向前回退查找，尝试放下一部分字符


          if (isTextOverflow && textOverflow === 'ellipsis') {
            var _this$__lineBack = this.__lineBack(ctx, renderMode, i, length, content, size - endSpace - beginSpace, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

            var _this$__lineBack2 = _slicedToArray(_this$__lineBack, 1);

            mainCoords = _this$__lineBack2[0];
            lineCount++;

            if (isUpright) {
              x = mainCoords;
            } else {
              y = mainCoords;
            }
          } // 默认是否clip跟随overflow:hidden，无需感知，裁剪由dom做，这里不裁剪
          else {
            var textBox = new TextBox(this, textBoxes.length, x, y, textWidth, lineHeight, content, isUpright);
            textBoxes.push(textBox);
            lineBoxManager.addItem(textBox, false);

            if (isUpright) {
              x += lineHeight;
            } else {
              y += lineHeight;
            }

            if (isTextOverflow) {
              lineCount++;
            }
          } // 和html一样，maxW此时在html是满格


          maxW = textWidth;
        } // 普通换行，注意x和lx的区别，可能相同（block起始处）可能不同（非起始处），第1行从x开始，第2行及以后都从lx开始
        // 然后第一次换行还有特殊之处，可能同一行前半部行高很大，此时y增加并非自身的lineHeight，而是整体LineBox的
        else {
          while (i < length) {
            var limit = i ? size : size - beginSpace;

            if (lineClamp && lineCount + lineClampCount >= lineClamp - 1) {
              limit -= endSpace;
            }

            var _measureLineWidth = measureLineWidth(ctx, renderMode, i, length, content, limit, perW, fontFamily, fontSize, fontWeight, letterSpacing),
                _measureLineWidth2 = _slicedToArray(_measureLineWidth, 3),
                num = _measureLineWidth2[0],
                rw = _measureLineWidth2[1],
                newLine = _measureLineWidth2[2]; // 多行文本截断，这里肯定需要回退，注意防止恰好是最后一个字符，此时无需截取


            if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1 && i + num < length) {
              var _this$__lineBack3 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

              var _this$__lineBack4 = _slicedToArray(_this$__lineBack3, 2);

              mainCoords = _this$__lineBack4[0];
              maxW = _this$__lineBack4[1];
              lineCount++;

              if (isUpright) {
                x = mainCoords;
              } else {
                y = mainCoords;
              }

              break;
            } // 最后一行考虑endSpace，可能不够需要回退，但不能是1个字符


            if (i + num === length && endSpace && rw + endSpace > limit + 1e-10 && num > 1) {
              var _measureLineWidth3 = measureLineWidth(ctx, renderMode, i, length, content, limit - endSpace, perW, fontFamily, fontSize, fontWeight, letterSpacing);

              var _measureLineWidth4 = _slicedToArray(_measureLineWidth3, 3);

              num = _measureLineWidth4[0];
              rw = _measureLineWidth4[1];
              newLine = _measureLineWidth4[2];

              // 可能加上endSpace后超过了，还得再判断一次
              if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1) {
                var _this$__lineBack5 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

                var _this$__lineBack6 = _slicedToArray(_this$__lineBack5, 2);

                mainCoords = _this$__lineBack6[0];
                maxW = _this$__lineBack6[1];
                lineCount++;

                if (isUpright) {
                  x = mainCoords;
                } else {
                  y = mainCoords;
                }

                break;
              }
            }

            maxW = Math.max(maxW, rw); // 根据是否第一行分开处理行首空白

            var _textBox = new TextBox(this, textBoxes.length, lineCount && !isUpright ? lx : x, lineCount && isUpright ? ly : y, rw, lineHeight, content.slice(i, i + num), isUpright);

            textBoxes.push(_textBox);
            lineBoxManager.addItem(_textBox, newLine); // 竖排横排换行不一样

            if (isUpright) {
              x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
            } else {
              y += Math.max(lineHeight, lineBoxManager.lineHeight);
            } // 至少也要1个字符形成1行，哪怕是首行，因为是否放得下逻辑在dom中做过了


            i += num;

            if (newLine) {
              lineCount++;
            }
          } // 换行后Text的x重设为lx


          if (lineCount) {
            if (isUpright) {
              this.__y = this.__sy1 = ly;
            } else {
              this.__x = this.__sx1 = lx;
            }
          }
        }

        if (isUpright) {
          this.__width = x - data.x;
          this.__height = maxW;
          this.__verticalBaseline = css.getVerticalBaseline(computedStyle);
        } else {
          this.__width = maxW;
          this.__height = y - data.y;
          this.__baseline = css.getBaseline(computedStyle);
        }

        return lineClampCount + lineCount;
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        this.__width = this.__height = this.__baseline = this.__verticalBaseline = 0;

        this.__textBoxes.splice(0);
      } // 末尾行因ellipsis的缘故向前回退字符生成textBox，可能会因不满足宽度导致无法生成，此时向前继续回退TextBox

    }, {
      key: "__lineBack",
      value: function __lineBack(ctx, renderMode, i, length, content, limit, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright) {
        var ew,
            bp = this.__bp,
            computedStyle = bp.computedStyle; // 临时测量ELLIPSIS的尺寸

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          ew = ctx.measureText(ELLIPSIS).width;
        } else {
          ew = inject.measureTextSync(ELLIPSIS, computedStyle[FONT_FAMILY$3], computedStyle[FONT_SIZE$6], computedStyle[FONT_WEIGHT$3]);
        }

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          var _font = css.setFontStyle(this.computedStyle);

          if (ctx.font !== _font) {
            ctx.font = _font;
          }
        }

        var _measureLineWidth5 = measureLineWidth(ctx, renderMode, i, length, content, limit - ew - endSpace, perW, fontFamily, fontSize, fontWeight, letterSpacing),
            _measureLineWidth6 = _slicedToArray(_measureLineWidth5, 2),
            num = _measureLineWidth6[0],
            rw = _measureLineWidth6[1]; // 还是不够，需要回溯查找前一个inline节点继续回退，同时防止空行首，要至少一个textBox且一个字符


        if (rw + ew > limit + 1e-10 - endSpace) {
          // 向前回溯已有的tb，需注意可能是新行开头这时还没生成新的lineBox，而旧行则至少1个内容
          // 新行的话进不来，会添加上面num的内容，旧行不添加只修改之前的tb内容也有可能删除一些
          var lineBox = lineBoxManager.lineBox;

          if (!lineBoxManager.isNewLine && lineBox && lineBox.size) {
            var list = lineBox.list;

            for (var j = list.length - 1; j >= 0; j--) {
              var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

              if (!(tb instanceof TextBox)) {
                if (!j) {
                  break;
                }

                var _item = list.pop();

                if (isUpright) {
                  y -= _item.outerHeight;
                } else {
                  x -= _item.outerWidth;
                }

                limit += isUpright ? _item.outerHeight : _item.outerWidth;

                _item.__layoutNone();

                continue;
              } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


              var _content = tb.content,
                  width = tb.width,
                  height = tb.height,
                  parent = tb.parent;

              if (!j || limit >= width + ew + 1e-10 + endSpace) {
                var _length = _content.length;
                var _parent$computedStyle = parent.computedStyle,
                    _lineHeight = _parent$computedStyle[LINE_HEIGHT$3],
                    _letterSpacing = _parent$computedStyle[LETTER_SPACING$2],
                    _fontSize = _parent$computedStyle[FONT_SIZE$6],
                    _fontWeight = _parent$computedStyle[FONT_WEIGHT$3],
                    _fontFamily = _parent$computedStyle[FONT_FAMILY$3];

                if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
                  ctx.font = css.setFontStyle(parent.computedStyle);
                } // 再进行查找，这里也会有至少一个字符不用担心


                var _measureLineWidth7 = measureLineWidth(ctx, renderMode, 0, _length, _content, limit - ew + width - endSpace, perW, _fontFamily, _fontSize, _fontWeight, _letterSpacing),
                    _measureLineWidth8 = _slicedToArray(_measureLineWidth7, 2),
                    _num = _measureLineWidth8[0],
                    _rw = _measureLineWidth8[1]; // 可能发生x回退，当tb的内容产生减少时


                if (_num !== _content.length) {
                  tb.__content = _content.slice(0, _num);

                  if (isUpright) {
                    y -= height - _rw;
                    tb.__height = _rw;
                  } else {
                    x -= width - _rw;
                    tb.__width = _rw;
                  }
                } // 重新设置lineHeight和baseline，因为可能删除了东西


                lineBox.__resetLb(computedStyle[LINE_HEIGHT$3], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

                var _ep = isUpright ? new Ellipsis(x, y + _rw + endSpace, ew, bp, isUpright) : new Ellipsis(x + _rw + endSpace, y, ew, bp, isUpright);

                lineBoxManager.addItem(_ep, true);

                if (isUpright) {
                  x += Math.max(_lineHeight, lineBoxManager.verticalLineHeight);
                } else {
                  y += Math.max(_lineHeight, lineBoxManager.lineHeight);
                }

                maxW = Math.max(maxW, _rw + ew);
                return [y, maxW];
              } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


              var item = list.pop();

              if (isUpright) {
                limit += height;
                y -= height;
              } else {
                limit += width;
                x -= width;
              }

              var tbs = item.parent.textBoxes;
              var k = tbs.indexOf(item);

              if (k > -1) {
                tbs.splice(k, 1);
              } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


              var dom = item.parent.parent;
              var prev = list[list.length - 1];

              if (prev instanceof TextBox) {
                prev = prev.parent.parent;
              }

              while (dom !== bp && dom !== prev) {
                var _contentBoxList = dom.contentBoxList || [];

                var _i2 = _contentBoxList.indexOf(item);

                if (_i2 > -1) {
                  _contentBoxList.splice(_i2, 1);
                }

                var _computedStyle = dom.computedStyle;

                if (isUpright) {
                  var mbp = _computedStyle[MARGIN_TOP] + _computedStyle[MARGIN_BOTTOM] + _computedStyle[PADDING_TOP$1] + _computedStyle[PADDING_BOTTOM$1] + _computedStyle[BORDER_TOP_WIDTH$1] + _computedStyle[BORDER_BOTTOM_WIDTH$1];
                  y -= mbp;
                  limit += mbp;
                } else {
                  var _mbp = _computedStyle[MARGIN_LEFT] + _computedStyle[MARGIN_RIGHT] + _computedStyle[PADDING_LEFT$1] + _computedStyle[PADDING_RIGHT] + _computedStyle[BORDER_LEFT_WIDTH$1] + _computedStyle[BORDER_RIGHT_WIDTH];

                  x -= _mbp;
                  limit += _mbp;
                }

                dom.__layoutNone();

                dom = dom.domParent;
              }

              var contentBoxList = prev.contentBoxList || [];

              var _i = contentBoxList.indexOf(item);

              if (_i > -1) {
                contentBoxList.splice(_i, 1);
              }
            }
          }
        } // 本次回退不用向前追溯删除textBox会进这里，最少一个字符兜底


        var textBox = new TextBox(this, textBoxes.length, x, y, rw, lineHeight, content.slice(i, i + num), isUpright);
        textBoxes.push(textBox);
        lineBoxManager.addItem(textBox, false); // ELLIPSIS也作为内容加入，但特殊的是指向最近block使用其样式渲染

        var ep = isUpright ? new Ellipsis(x, y + rw + endSpace, ew, bp, isUpright) : new Ellipsis(x + rw + endSpace, y, ew, bp, isUpright);
        lineBoxManager.addItem(ep, true);

        if (isUpright) {
          x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
        } else {
          y += Math.max(lineHeight, lineBoxManager.lineHeight);
        }

        maxW = Math.max(maxW, rw + ew);
        return [isUpright ? x : y, maxW];
      } // 外部dom换行发现超行，且一定是ellipsis时，会进这里让上一行text回退，lineBox一定有值且最后一个一定是本text的最后的textBox

    }, {
      key: "__backtrack",
      value: function __backtrack(bp, lineBoxManager, lineBox, textBox, limit, endSpace, ew, computedStyle, ctx, renderMode, isUpright) {
        var list = lineBox.list;

        for (var j = list.length - 1; j >= 0; j--) {
          var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

          if (!(tb instanceof TextBox)) {
            if (!j) {
              break;
            }

            var _item2 = list.pop();

            limit += isUpright ? _item2.outerHeight : _item2.outerWidth;

            _item2.__layoutNone();

            continue;
          } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


          var content = tb.content,
              width = tb.width,
              height = tb.height,
              parent = tb.parent;

          if (!j || limit >= width + ew + 1e-10 + endSpace) {
            var length = content.length;
            var _parent$computedStyle2 = parent.computedStyle,
                letterSpacing = _parent$computedStyle2[LETTER_SPACING$2],
                fontSize = _parent$computedStyle2[FONT_SIZE$6],
                fontWeight = _parent$computedStyle2[FONT_WEIGHT$3],
                fontFamily = _parent$computedStyle2[FONT_FAMILY$3];

            if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
              ctx.font = css.setFontStyle(parent.computedStyle);
            }

            var perW = fontSize * 0.8 + letterSpacing; // 再进行查找，这里也会有至少一个字符不用担心

            var _measureLineWidth9 = measureLineWidth(ctx, renderMode, 0, length, content, limit - ew - endSpace + width, perW, fontFamily, fontSize, fontWeight, letterSpacing),
                _measureLineWidth10 = _slicedToArray(_measureLineWidth9, 2),
                num = _measureLineWidth10[0],
                rw = _measureLineWidth10[1]; // 可能发生x回退，当tb的内容产生减少时


            if (num !== content.length) {
              tb.__content = content.slice(0, num);

              if (isUpright) {
                tb.__height = rw;
              } else {
                tb.__width = rw;
              }
            } // 重新设置lineHeight和baseline，因为可能删除了东西


            lineBox.__resetLb(computedStyle[LINE_HEIGHT$3], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

            var ep = isUpright ? new Ellipsis(tb.x, tb.y + rw + endSpace, ew, bp, isUpright) : new Ellipsis(tb.x + rw + endSpace, tb.y, ew, bp, isUpright);
            lineBoxManager.addItem(ep, true);
            return;
          } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


          var item = list.pop();
          limit += isUpright ? height : width;
          var tbs = item.parent.textBoxes;
          var k = tbs.indexOf(item);

          if (k > -1) {
            tbs.splice(k, 1);
          } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


          var dom = item.parent.parent;
          var prev = list[list.length - 1];

          if (prev instanceof TextBox) {
            prev = prev.parent.parent;
          }

          while (dom !== bp && dom !== prev) {
            var _contentBoxList2 = dom.contentBoxList || [];

            var _i3 = _contentBoxList2.indexOf(item);

            if (_i3 > -1) {
              _contentBoxList2.splice(_i3, 1);
            }

            var _computedStyle2 = dom.computedStyle;

            if (isUpright) {
              var mbp = _computedStyle2[MARGIN_TOP] + _computedStyle2[MARGIN_BOTTOM] + _computedStyle2[PADDING_TOP$1] + _computedStyle2[PADDING_BOTTOM$1] + _computedStyle2[BORDER_TOP_WIDTH$1] + _computedStyle2[BORDER_BOTTOM_WIDTH$1];
              limit += mbp;
            } else {
              var _mbp2 = _computedStyle2[MARGIN_LEFT] + _computedStyle2[MARGIN_RIGHT] + _computedStyle2[PADDING_LEFT$1] + _computedStyle2[PADDING_RIGHT] + _computedStyle2[BORDER_LEFT_WIDTH$1] + _computedStyle2[BORDER_RIGHT_WIDTH];

              limit += _mbp2;
            }

            dom.__layoutNone();

            dom = dom.domParent;
          }

          var contentBoxList = prev.contentBoxList || [];
          var i = contentBoxList.indexOf(item);

          if (i > -1) {
            contentBoxList.splice(i, 1);
          }
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetX", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetX(diff);
          });
        }

        this.__sx1 += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetY", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetY(diff);
          });
        }

        this.__sy1 += diff;
      }
    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(total) {
        return total - this.firstCharWidth;
      }
    }, {
      key: "__inlineSize",
      value: function __inlineSize(isUpright) {
        var min, max;
        this.textBoxes.forEach(function (item, i) {
          if (i) {
            min = Math.min(min, isUpright ? item.y : item.x);
            max = Math.max(max, (isUpright ? item.y : item.x) + item.width);
          } else {
            min = isUpright ? item.y : item.x;
            max = (isUpright ? item.y : item.x) + item.width;
          }
        });

        if (isUpright) {
          this.__y = min;
          this.__sy = this.__sy1 = min + this.oy;
          this.__sx = this.__sx1;
          this.height = max - min;
        } else {
          this.__x = min;
          this.__sx = this.__sx1 = min + this.ox;
          this.__sy = this.__sy1;
          this.__width = max - min;
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache) {
        var dx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var dy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var isDestroyed = this.isDestroyed,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            cacheStyle = this.cacheStyle,
            __config = this.__config;

        if (renderMode === SVG$2) {
          __config[NODE_VIRTUAL_DOM$1] = this.__virtualDom = {
            type: 'text',
            children: []
          };
        } // >=REPAINT清空bbox


        if (lv >= o$3.REPAINT) {
          this.__bbox = null;
          this.__filterBbox = null;
        }

        if (isDestroyed || computedStyle[DISPLAY$1] === 'none' || computedStyle[VISIBILITY$1] === 'hidden' || !textBoxes.length) {
          return;
        }

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          // webgl借用离屏canvas绘制文本，cache标识为true是普通绘制，否则是超限降级情况
          if (renderMode === WEBGL$3) {
            if (cache) {
              var sx = this.sx,
                  sy = this.sy,
                  bbox = this.bbox;
              var __cache = __config[NODE_CACHE];

              if (__cache) {
                __cache.reset(bbox, sx, sy);
              } else {
                __cache = Cache.getInstance(bbox, sx, sy);
              }

              if (__cache && __cache.enabled) {
                __config[NODE_CACHE] = __cache;
                __cache.__available = true;
                ctx = __cache.ctx;
                dx += __cache.dx;
                dy += __cache.dy;
                __config[NODE_LIMIT_CACHE] = false;
              } else {
                __config[NODE_LIMIT_CACHE] = true;
                return;
              }
            } else {
              var _root = this.root;
              var c = inject.getCacheCanvas(_root.width, _root.height, '__$$OVERSIZE$$__');
              ctx = c.ctx;
              var _config$NODE_DOM_PAR = __config[NODE_DOM_PARENT].__config,
                  m = _config$NODE_DOM_PAR[NODE_MATRIX_EVENT],
                  opacity = _config$NODE_DOM_PAR[NODE_OPACITY];
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
              ctx.globalAlpha = opacity;
            }
          }

          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          var color = cacheStyle[COLOR$3]; // 渐变

          if (color.k) {
            var dom = this.parent;
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          var strokeWidth = computedStyle[TEXT_STROKE_WIDTH$2];

          if (ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          var textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$2]; // 渐变

          if (textStrokeColor.k) {
            var _dom = this.parent;
            textStrokeColor = _dom.__gradient(renderMode, ctx, _dom.__bx1, _dom.__by1, _dom.__bx2, _dom.__by2, textStrokeColor, dx, dy).v;
          }

          if (ctx.strokeStyle !== textStrokeColor) {
            ctx.strokeStyle = textStrokeColor;
          }
        } // 可能为空，整个是个ellipsis


        textBoxes.forEach(function (item) {
          item.render(renderMode, ctx, computedStyle, cacheStyle, dx, dy);
        });

        if (renderMode === SVG$2) {
          this.virtualDom.children = textBoxes.map(function (textBox) {
            return textBox.virtualDom;
          });
        }
      }
    }, {
      key: "__deepScan",
      value: function __deepScan(cb) {
        cb(this);
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        _get(_getPrototypeOf(Text.prototype), "__destroy", this).call(this);

        var __cache = this.__config[NODE_CACHE];

        if (__cache) {
          __cache.release();
        }
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        return this.domParent.getComputedStyle(key);
      }
    }, {
      key: "updateContent",
      value: function updateContent(s, cb) {
        var self = this;

        if (s === self.__content) {
          if (util.isFunction(cb)) {
            cb(-1);
          }

          return;
        }

        root.delRefreshTask(self.__task);
        root.addRefreshTask(self.__task = {
          __before: function __before() {
            self.__content = s;
            var res = {};
            var vd = self.domParent;
            res[UPDATE_NODE] = vd;
            res[UPDATE_FOCUS] = o$3.REFLOW;
            res[UPDATE_CONFIG] = vd.__config;
            var root = vd.root;

            root.__addUpdate(vd, vd.__config, root, root.__config, res);
          },
          __after: function __after(diff) {
            if (util.isFunction(cb)) {
              cb(diff);
            }
          }
        });
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      },
      set: function set(v) {
        this.__content = v;
      }
    }, {
      key: "textBoxes",
      get: function get() {
        return this.__textBoxes;
      }
    }, {
      key: "charWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root = this.root,
            ctx = _this$root.ctx,
            renderMode = _this$root.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$6],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('charWidth')) {
          var max = 0;

          if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
            if (renderMode === WEBGL$3) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);

            for (var i = 0, len = content.length; i < len; i++) {
              max = Math.max(max, ctx.measureText(content.charAt([i])).width);
            }
          } else if (renderMode === SVG$2) {
            max = inject.measureTextListMax(content, fontFamily, fontSize, fontWeight);
          }

          o.charWidth = max + letterSpacing;
        }

        return o.charWidth;
      }
    }, {
      key: "firstCharWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root2 = this.root,
            ctx = _this$root2.ctx,
            renderMode = _this$root2.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$6],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('firstCharWidth')) {
          if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
            if (renderMode === WEBGL$3) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);
            o.firstCharWidth = ctx.measureText(content.charAt(0)).width + letterSpacing;
          } else if (renderMode === SVG$2) {
            o.firstCharWidth = inject.measureTextSync(content.charAt(0), fontFamily, fontSize, fontWeight) + letterSpacing;
          }
        }

        return o.firstCharWidth;
      }
    }, {
      key: "textWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root3 = this.root,
            ctx = _this$root3.ctx,
            renderMode = _this$root3.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$6],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('textWidth')) {
          if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
            if (renderMode === WEBGL$3) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);
            o.textWidth = ctx.measureText(content).width + letterSpacing * content.length;
          } else if (renderMode === SVG$2) {
            o.textWidth = inject.measureTextSync(content, fontFamily, fontSize, fontWeight) + letterSpacing * content.length;
          }
        }

        return o.textWidth;
      }
    }, {
      key: "root",
      get: function get() {
        return this.domParent.root;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.domParent.currentStyle;
      }
    }, {
      key: "style",
      get: function get() {
        return this.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.domParent.computedStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.domParent.__cacheStyle;
      }
    }, {
      key: "bbox",
      get: function get() {
        var sx = this.__sx1,
            sy = this.__sy1,
            width = this.width,
            height = this.height,
            textStrokeWidth = this.computedStyle[TEXT_STROKE_WIDTH$2]; // TODO: 文字描边暂时不清楚最大值是多少，影响不确定，先按描边宽算，因为会出现>>0.5宽的情况

        var half = textStrokeWidth;
        return [sx - half, sy - half, sx + width + half, sy + height + half];
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.bbox;
          var filter = this.computedStyle[FILTER$2];
          this.__filterBbox = css.spreadFilter(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.parent && this.host && this.host !== this.root;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.domParent.matrix;
      }
    }, {
      key: "matrixEvent",
      get: function get() {
        return this.domParent.matrixEvent;
      }
    }]);

    return Text;
  }(Node);

  Text.prototype.__renderByMask = Text.prototype.render;

  var TYPE_VD$1 = $$type.TYPE_VD,
      TYPE_GM$1 = $$type.TYPE_GM,
      TYPE_CP$1 = $$type.TYPE_CP;
  /**
   * 2. 打平children中的数组，变成一维
   * 3. 合并相连的Text节点，即string内容
   */

  function flattenJson(parent) {
    if (Array.isArray(parent)) {
      return parent.map(function (item) {
        return flattenJson(item);
      });
    } else if (!parent || [TYPE_VD$1, TYPE_GM$1, TYPE_CP$1].indexOf(parent.$$type) === -1 || !Array.isArray(parent.children)) {
      return parent;
    }

    var list = [];
    traverseJson(list, parent.children, {
      lastText: null
    });
    parent.children = list;
    return parent;
  }

  function traverseJson(list, children, options) {
    if (Array.isArray(children)) {
      children.forEach(function (item) {
        traverseJson(list, item, options);
      });
    } else if (children && (children.$$type === TYPE_VD$1 || children.$$type === TYPE_GM$1)) {
      if (['canvas', 'svg', 'webgl'].indexOf(children.tagName) > -1) {
        throw new Error('Can not nest canvas/svg/webgl');
      }

      if (children.$$type === TYPE_VD$1) {
        flattenJson(children);
      }

      list.push(children);
      options.lastText = null;
    } else if (children && children.$$type === TYPE_CP$1) {
      list.push(children); // 强制component即便返回text也形成一个独立的节点，合并在layout布局中做

      options.lastText = null;
    } // 排除掉空的文本，连续的text合并
    else if (!util.isNil(children) && children !== '') {
      if (options.lastText !== null) {
        list[list.length - 1] = options.lastText += children;
      } else {
        list.push(children);
      }
    }
  }

  var _enums$NODE_KEY$2 = enums.NODE_KEY,
      NODE_DOM_PARENT$1 = _enums$NODE_KEY$2.NODE_DOM_PARENT,
      NODE_STYLE = _enums$NODE_KEY$2.NODE_STYLE,
      NODE_CURRENT_STYLE = _enums$NODE_KEY$2.NODE_CURRENT_STYLE,
      NODE_COMPUTED_STYLE = _enums$NODE_KEY$2.NODE_COMPUTED_STYLE,
      NODE_MATRIX = _enums$NODE_KEY$2.NODE_MATRIX,
      NODE_MATRIX_EVENT$1 = _enums$NODE_KEY$2.NODE_MATRIX_EVENT;
  var TYPE_VD$2 = $$type.TYPE_VD,
      TYPE_GM$2 = $$type.TYPE_GM,
      TYPE_CP$2 = $$type.TYPE_CP;
  var Xom, Dom, Img, Geom, Component;

  function initRoot(cd, root) {
    var c = flattenJson({
      tagName: root.tagName,
      props: {},
      children: cd,
      $$type: TYPE_VD$2
    });
    root.__json = c;
    root.__host = root;
    var children = build(c.children, root, root);
    return relation(root, children);
  }

  function initDom(json, root, host, parent) {
    var vd = build(json, root, host);
    return relation(parent, vd);
  }

  function initCp(json, root, host) {
    if (util.isObject(json)) {
      // cp的flatten在__init中自己做
      return build(json, root, host);
    } // text的relation会由上层如Root设置
    else {
      return new Text(json);
    }
  }

  function initCp2(json, root, host, parent) {
    var vd = new json.klass(json.props);
    vd.__tagName = json.tagName || vd.__tagName;
    vd.__root = root;
    vd.__host = host;
    vd.__json = json;

    vd.__init();

    return relation(parent, vd);
  }
  /**
   * 将初始json文件生成virtualDom
   * @param json
   * @param root
   * @param host
   * @param hasP 出现过p标签
   * @returns vd
   */


  function build(json, root, host, hasP) {
    if (Array.isArray(json)) {
      return json.map(function (item) {
        return build(item, root, host, hasP);
      });
    }

    var vd;

    if (util.isObject(json) && json.$$type) {
      var tagName = json.tagName,
          props = json.props,
          children = json.children,
          klass = json.klass,
          _$$type = json.$$type,
          __inheritAnimate = json.__inheritAnimate,
          __animateRecords = json.__animateRecords; // 更新过程中无变化的cp直接使用原来生成的

      if (_$$type === TYPE_CP$2 && json.__placeholder) {
        return json.__placeholder;
      }

      if (_$$type === TYPE_VD$2) {
        if (tagName === 'img') {
          vd = new Img(tagName, props);

          if (Array.isArray(children) && children.length) {
            throw new Error('Img can not contain children');
          }
        } else {
          vd = new Dom(tagName, props);
        } // 检查p不能包含div


        if (tagName === 'p') {
          hasP = true;
        } else if (tagName === 'div' && hasP) {
          throw new Error('Markup p can not contain div');
        }

        if (Array.isArray(children)) {
          children = relation(vd, build(children, root, host, hasP));
        } else {
          children = [];
        }

        vd.__children = children;
      } else if (_$$type === TYPE_GM$2) {
        if (util.isString(tagName)) {
          var _klass = Geom.getRegister(tagName);

          vd = new _klass(tagName, props);
        } else if (tagName) {
          vd = new tagName('$', props);
        }
      } else if (_$$type === TYPE_CP$2) {
        vd = new klass(props);
        vd.__tagName = tagName || vd.__tagName;
      } else {
        return new Text(json);
      } // 根parse需要用到真正的vd引用，然后vd也要引用json，用以做domApi


      json.vd = vd;
      vd.__json = json; // 递归parse中的动画记录需特殊处理，将target改为真正的vd引用

      if (__animateRecords) {
        vd.__animateRecords = __animateRecords;

        __animateRecords.list.forEach(function (item) {
          item.target = item.target.vd;
        });

        delete json.__animateRecords;
      } // 更新过程中key相同或者普通相同的vd继承动画


      if (__inheritAnimate) {
        util.extendAnimate(__inheritAnimate, vd);
        delete json.__inheritAnimate;
      }

      vd.__root = root;
      vd.__host = host;

      if (_$$type === TYPE_CP$2) {
        vd.__init();
      }

      var ref = props.ref;

      if (util.isString(ref) && ref || util.isNumber(ref)) {
        host.ref[ref] = vd;
      } else if (util.isFunction(ref)) {
        ref(vd);
      }

      return vd;
    }

    return new Text(json);
  }
  /**
   * 设置关系，父子和兄弟
   * @param parent
   * @param children
   * @param options
   * @returns {Xom|Text|Component}
   */


  function relation(parent, children) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (Array.isArray(children)) {
      children.forEach(function (item) {
        relation(parent, item, options);
      });
    } else if (children instanceof Xom || children instanceof Component || children instanceof Text) {
      children.__parent = parent;
      children.__domParent = parent; // 极为恶心，为了v8的性能优化，text复用parent的__config部分，但domParent重设

      if (children instanceof Text) {
        [NODE_STYLE, NODE_CURRENT_STYLE, NODE_COMPUTED_STYLE, NODE_MATRIX, NODE_MATRIX_EVENT$1].forEach(function (k) {
          children.__config[k] = parent.__config[k];
        });
      }

      if (children.__config) {
        children.__config[NODE_DOM_PARENT$1] = parent;
      }

      if (options.prev) {
        options.prev.__next = children;
        children.__prev = options.prev;
      }

      options.prev = children; // 文字视作为父节点的直接文字子节点

      if (children instanceof Component) {
        var sr = children.shadowRoot;

        if (sr instanceof Text) {
          sr.__parent = parent;
          [NODE_STYLE, NODE_CURRENT_STYLE, NODE_COMPUTED_STYLE, NODE_MATRIX, NODE_MATRIX_EVENT$1].forEach(function (k) {
            children.__config[k] = parent.__config[k];
          });
        }

        sr.__domParent = parent;

        if (sr.__config) {
          sr.__config[NODE_DOM_PARENT$1] = parent;
        }
      }
    }

    return children;
  }

  var builder = {
    ref: function ref(o) {
      Xom = o.Xom;
      Dom = o.Dom;
      Img = o.Img;
      Geom = o.Geom;
      Component = o.Component;
    },
    initRoot: initRoot,
    initDom: initDom,
    initCp: initCp,
    initCp2: initCp2,
    relation: relation
  };

  var isFunction$1 = util.isFunction;

  var Event = /*#__PURE__*/function () {
    function Event() {
      _classCallCheck(this, Event);

      this.__eHash = {};
    }

    _createClass(Event, [{
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$1(handle)) {
          return;
        }

        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.on(id[i], handle);
          }
        } else {
          if (!self.__eHash.hasOwnProperty(id)) {
            self.__eHash[id] = [];
          } // 遍历防止此handle被侦听过了


          for (var _i = 0, item = self.__eHash[id], _len = item.length; _i < _len; _i++) {
            if (item[_i] === handle) {
              return self;
            }
          }

          self.__eHash[id].push(handle);
        }

        return self;
      }
    }, {
      key: "once",
      value: function once(id, handle) {
        if (!isFunction$1(handle)) {
          return;
        }

        var self = this; // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比

        function cb() {
          for (var _len2 = arguments.length, data = new Array(_len2), _key = 0; _key < _len2; _key++) {
            data[_key] = arguments[_key];
          }

          handle.apply(self, data);
          self.off(id, cb);
        }

        cb.__karasEventCb = handle;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.once(id[i], handle);
          }
        } else if (handle) {
          self.on(id, cb);
        }

        return this;
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.off(id[i], handle);
          }
        } else if (self.__eHash.hasOwnProperty(id)) {
          if (handle) {
            for (var _i2 = 0, item = self.__eHash[id], _len3 = item.length; _i2 < _len3; _i2++) {
              // 需考虑once包裹的引用对比
              if (item[_i2] === handle || item[_i2].__karasEventCb === handle) {
                item.splice(_i2, 1);
                break;
              }
            }
          } // 未定义为全部清除
          else {
            delete self.__eHash[id];
          }
        }

        return this;
      }
    }, {
      key: "emit",
      value: function emit(id) {
        var self = this;

        for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key2 = 1; _key2 < _len4; _key2++) {
          data[_key2 - 1] = arguments[_key2];
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.emit(id[i], data);
          }
        } else {
          if (self.__eHash.hasOwnProperty(id)) {
            var list = self.__eHash[id];

            if (list.length) {
              list = list.slice();

              for (var _i3 = 0, _len5 = list.length; _i3 < _len5; _i3++) {
                var cb = list[_i3];

                if (isFunction$1(cb)) {
                  cb.apply(self, data);
                }
              }
            }
          }
        }

        return this;
      }
    }], [{
      key: "mix",
      value: function mix() {
        for (var i = arguments.length - 1; i >= 0; i--) {
          var o = i < 0 || arguments.length <= i ? undefined : arguments[i];
          var event = new Event();
          o.__eHash = {};
          var fns = ['on', 'once', 'off', 'emit'];

          for (var j = fns.length - 1; j >= 0; j--) {
            var fn = fns[j];
            o[fn] = event[fn];
          }
        }
      }
    }]);

    return Event;
  }();

  _defineProperty(Event, "REFRESH", 'refresh');

  _defineProperty(Event, "PAUSE", 'pause');

  _defineProperty(Event, "PLAY", 'play');

  _defineProperty(Event, "FRAME", 'frame');

  _defineProperty(Event, "FINISH", 'finish');

  _defineProperty(Event, "CANCEL", 'cancel');

  _defineProperty(Event, "BEGIN", 'begin');

  _defineProperty(Event, "END", 'end');

  var isNil$4 = util.isNil,
      isFunction$2 = util.isFunction,
      clone$1 = util.clone,
      extend$1 = util.extend;
  var REGISTER = {};
  /**
   * 向上设置cp类型叶子节点，表明从root到本节点这条链路有更新，使得无链路更新的节约递归
   * 在check时树递归会用到，判断是否需要查找cp更新
   * @param cp
   */

  function setUpdateFlag(cp) {
    // 去重
    if (cp.__hasCpUpdate) {
      return;
    }

    cp.__hasCpUpdate = true;
    var host = cp.host;

    if (host) {
      setUpdateFlag(host);
    }
  }

  var Component$1 = /*#__PURE__*/function (_Event) {
    _inherits(Component, _Event);

    var _super = _createSuper(Component);

    function Component() {
      var _this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Component);

      _this = _super.call(this);
      _this.__tagName = /(?:function|class)\s+([\w$]+)/.exec(_this.constructor.toString())[1]; // 构建工具中都是arr，手写可能出现hash情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__parent = null;
      _this.__host = null;
      _this.__ref = {};
      _this.state = {};
      _this.__isMounted = false;
      _this.__taskList = [];
      return _this;
    }

    _createClass(Component, [{
      key: "setState",
      value: function setState(n, cb) {
        var _this2 = this;

        var self = this;

        if (isNil$4(n)) {
          n = {};
        } else if (isFunction$2(n)) {
          return;
        } else {
          if (Object.keys(n).length === 0) {
            if (isFunction$2(cb)) {
              cb.call(self);
            }

            return;
          }

          var state = clone$1(self.state);
          n = extend$1(state, n);
        }

        var root = self.root;

        if (root && self.__isMounted) {
          // 一帧之内多次调用，需合并
          if (self.__nextState) {
            Object.assign(self.__nextState, n);

            self.__taskList.push(cb);
          } else {
            self.__nextState = n;
            self.__taskList = [cb]; // 回调更新列表，before执行时splice出来供after执行，防止中途产生的后续setState干扰

            var list = [];
            var t = self.__task = {
              __before: function __before() {
                list = self.__taskList.splice(0); // 标识更新

                setUpdateFlag(_this2);
              },
              __after: function __after() {
                // self.__nextState = null; 由updater.js每次refresh前同步执行清空，这里不能异步清除，否则frame动画会乱序
                list.forEach(function (cb) {
                  if (isFunction$2(cb)) {
                    cb.call(self);
                  }
                });
              }
            };
            root.addRefreshCp(t);
          }
        } // 构造函数中调用还未render，
        else if (isFunction$2(cb)) {
          self.state = n;
          cb.call(self);
        }
      }
      /**
       * build中调用初始化，json有值时是update过程才有，且处理过flatten
       * @param json
       * @private
       */

    }, {
      key: "__init",
      value: function __init(json) {
        var _this3 = this;

        this.__ref = {};
        var root = this.root;
        var cd = json || flattenJson(this.render());
        var sr = builder.initCp(cd, root, this);
        this.__cd = cd;

        if (sr instanceof Text) ; else if (sr instanceof Node) {
          var style = css.normalize(this.props.style);
          var keys = Object.keys(style);
          extend$1(sr.style, style, keys);
          extend$1(sr.currentStyle, style, keys); // 事件添加到sr

          Object.keys(this.props).forEach(function (k) {
            var v = _this3.props[k];

            if (/^on[a-zA-Z]/.test(k)) {
              k = k.slice(2).toLowerCase();
              sr.listener[k] = v;
            }
          });
        } else if (!(sr instanceof Component)) {
          // 本身build是递归的，子cp已经初始化了
          throw new Error('Component render() must return a dom/text: ' + this);
        } // 自定义事件无视返回强制添加


        Object.keys(this.props).forEach(function (k) {
          var v = _this3.props[k];

          if (/^on-[a-zA-Z\d_$]/.test(k)) {
            k = k.slice(3);

            _this3.on(k, v);
          }
        }); // shadow指向直接renderRoot，shadowRoot考虑到返回Component的递归即hoc高阶组件
        // host是直接所属，hostRoot同考虑到高阶组件

        this.__shadow = sr;
        sr.__host = this; // 递归下去，多层级时执行顺序由里到外，最终会被最上层执行替换

        while (sr instanceof Component) {
          sr.__hostRoot = this;
          sr.shadow.__host = sr;
          sr = sr.shadow;
        }

        this.__shadowRoot = sr;
        sr.__hostRoot = this;

        if (!this.__isMounted) {
          this.__isMounted = true;

          if (isFunction$2(this.componentDidMount)) {
            root.once(Event.REFRESH, function () {
              _this3.componentDidMount();
            });
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        inject.warn('Component must implement render()');
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        this.__isDestroyed = true;
        this.__isMounted = false;

        if (isFunction$2(this.componentWillUnmount)) {
          this.componentWillUnmount();
        }

        this.root.delRefreshTask(this.__task);

        if (this.shadowRoot) {
          this.shadowRoot.__destroy();
        }

        this.__parent = null;
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var sr = this.shadowRoot;

        if (sr instanceof Text) {
          return;
        }

        var res = sr.__emitEvent(e, force);

        if (res) {
          e.target = this;
          return true;
        }
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "shadow",
      get: function get() {
        return this.__shadow;
      }
    }, {
      key: "shadowRoot",
      get: function get() {
        return this.__shadowRoot;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__root;
      }
    }, {
      key: "host",
      get: function get() {
        return this.__host;
      }
    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      }
    }, {
      key: "state",
      get: function get() {
        return this.__state;
      },
      set: function set(v) {
        this.__state = v;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (!name || !util.isString(name) || !/^[A-Z]/.test(name)) {
          throw new Error('Invalid param');
        }

        if (!REGISTER.hasOwnProperty(name)) {
          throw new Error("Component has not register: ".concat(name));
        }

        return REGISTER[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || !/^[A-Z]/.test(name) || !obj.prototype || !(obj.prototype instanceof Component)) {
          throw new Error('Invalid param: Component register');
        }

        if (Component.hasRegister(name)) {
          throw new Error("Component has already register: ".concat(name));
        }

        REGISTER[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Component.hasRegister(name)) {
          delete REGISTER[name];
        }
      }
    }]);

    return Component;
  }(Event);

  Object.keys(o$2.GEOM).concat(['x', 'y', 'ox', 'oy', 'sx', 'sy', // '__sx1',
  // '__sx2',
  // '__sx3',
  // '__sx4',
  // '__sx5',
  // '__sx6',
  // '__sy1',
  // '__sy2',
  // '__sy3',
  // '__sy4',
  // '__sy5',
  // '__sy6',
  'width', 'height', 'outerWidth', 'outerHeight', 'clientWidth', 'clientHeight', 'offsetWidth', 'offsetHeight', 'style', 'animationList', 'animateStyle', 'currentStyle', 'computedStyle', 'currentProps', 'baseline', 'virtualDom', 'mask', 'maskId', 'textWidth', 'content', 'lineBoxes', 'charWidthList', 'charWidth', '__layoutData', 'availableAnimating', 'effectiveAnimating', 'displayAnimating', 'visibilityAnimating', 'bbox', '__config', 'contentBoxList', 'listener', 'matrix', 'matrixEvent']).forEach(function (fn) {
    Object.defineProperty(Component$1.prototype, fn, {
      get: function get() {
        var sr = this.shadowRoot;

        if (sr) {
          return sr[fn];
        }
      }
    });
  });
  ['__layout', '__layoutAbs', '__layoutNone', '__tryLayInline', '__offsetX', '__offsetY', '__calAutoBasis', '__computeReflow', '__renderAsMask', '__renderByMask', '__mp', 'animate', 'removeAnimate', 'clearAnimate', 'updateStyle', 'getBoundingClientRect', 'getComputedStyle', '__deepScan', 'clearCache', '__structure', '__modifyStruct', '__updateStruct', 'flowChildren', 'absChildren', '__isRealInline', '__calBasis', '__calMinMax', '__computeMeasure', 'appendChild', 'prependChild', 'insertBefore', 'insertAfter', 'removeChild', 'remove'].forEach(function (fn) {
    Component$1.prototype[fn] = function () {
      var sr = this.shadowRoot;

      if (sr && isFunction$2(sr[fn])) {
        return sr[fn].apply(sr, arguments);
      }
    };
  });

  var _enums$STYLE_KEY$9 = enums.STYLE_KEY,
      MARGIN_TOP$1 = _enums$STYLE_KEY$9.MARGIN_TOP,
      MARGIN_LEFT$1 = _enums$STYLE_KEY$9.MARGIN_LEFT,
      MARGIN_RIGHT$1 = _enums$STYLE_KEY$9.MARGIN_RIGHT,
      MARGIN_BOTTOM$1 = _enums$STYLE_KEY$9.MARGIN_BOTTOM,
      PADDING_TOP$2 = _enums$STYLE_KEY$9.PADDING_TOP,
      PADDING_LEFT$2 = _enums$STYLE_KEY$9.PADDING_LEFT,
      PADDING_RIGHT$1 = _enums$STYLE_KEY$9.PADDING_RIGHT,
      PADDING_BOTTOM$2 = _enums$STYLE_KEY$9.PADDING_BOTTOM,
      BORDER_TOP_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_TOP_WIDTH,
      BORDER_LEFT_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$1 = _enums$STYLE_KEY$9.BORDER_RIGHT_WIDTH,
      BORDER_BOTTOM_WIDTH$2 = _enums$STYLE_KEY$9.BORDER_BOTTOM_WIDTH;
  /**
   * 获取inline的每一行内容的矩形坐标4个点，同时附带上border的矩形，比前面4个点尺寸大或相等（有无border/padding）
   * @param xom
   * @param isUpright
   * @param contentBoxList
   * @param start
   * @param end
   * @param lineBox
   * @param baseline
   * @param lineHeight
   * @param leading
   * @param isStart
   * @param isEnd
   * @param backgroundClip
   * @param paddingTop
   * @param paddingRight
   * @param paddingBottom
   * @param paddingLeft
   * @param borderTopWidth
   * @param borderRightWidth
   * @param borderBottomWidth
   * @param borderLeftWidth
   * @returns {(*|number)[]}
   */

  function getInlineBox(xom, isUpright, contentBoxList, start, end, lineBox, baseline, lineHeight, leading, isStart, isEnd, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth) {
    // 根据bgClip确定y伸展范围，inline渲染bg扩展到pb的位置不影响布局
    var bcStart = 0,
        bcEnd = 0;
    var pbStart = isUpright ? paddingLeft + borderLeftWidth : paddingTop + borderTopWidth;
    var pbEnd = isUpright ? paddingRight + borderRightWidth : paddingBottom + borderBottomWidth;

    if (backgroundClip === 'paddingBox') {
      bcStart = isUpright ? paddingLeft : paddingTop;
      bcEnd = isUpright ? paddingRight : paddingBottom;
    } else if (backgroundClip === 'borderBox') {
      bcStart = pbStart;
      bcEnd = pbEnd;
    } // inline的baseline和lineBox的差值，不同lh时造成的偏移，一般为多个textBox时比较小的那个发生
    // 垂直排版不能简单算baseline差值，因为原点坐标系不一样


    var diff;

    if (isUpright) {
      diff = lineBox.verticalBaseline - baseline;
    } else {
      diff = lineBox.baseline - baseline;
    }

    var x1, y1, x2, y2, bx1, by1, bx2, by2; // x坐标取首尾contentBox的左右2侧，clip布局时已算好；y是根据lineHeight和lineBox的高度以及baseline对齐后计算的
    // 垂直排版则互换x/y逻辑

    if (isUpright) {
      x1 = lineBox.x + diff - bcStart + leading;
      y1 = start.y;
      bx1 = lineBox.x + diff - pbStart + leading;
    } else {
      x1 = start.x;
      y1 = lineBox.y + diff - bcStart + leading;
      by1 = lineBox.y + diff - pbStart + leading;
    } // 容器内包含的inline节点，需考虑行首水平mbp（垂直排版为垂直头mbp）


    var dom = start instanceof TextBox ? start.parent.domParent : start.domParent;

    while (dom !== xom) {
      var list = dom.contentBoxList;

      if (start === list[0]) {
        if (isUpright) {
          var _dom$computedStyle = dom.computedStyle,
              marginTop = _dom$computedStyle[MARGIN_TOP$1],
              _paddingTop = _dom$computedStyle[PADDING_TOP$2],
              _borderTopWidth = _dom$computedStyle[BORDER_TOP_WIDTH$2];
          y1 -= marginTop + _paddingTop + _borderTopWidth;
        } else {
          var _dom$computedStyle2 = dom.computedStyle,
              marginLeft = _dom$computedStyle2[MARGIN_LEFT$1],
              _paddingLeft = _dom$computedStyle2[PADDING_LEFT$2],
              _borderLeftWidth = _dom$computedStyle2[BORDER_LEFT_WIDTH$2];
          x1 -= marginLeft + _paddingLeft + _borderLeftWidth;
        }
      }

      dom = dom.domParent;
    } // 第一个需考虑容器本身的padding/border


    if (isUpright) {
      by1 = y1;

      if (isStart) {
        by1 -= paddingTop + borderTopWidth;

        if (backgroundClip === 'paddingBox') {
          y1 -= paddingTop;
        } else if (backgroundClip === 'borderBox') {
          y1 -= paddingTop + borderTopWidth;
        }
      }

      x2 = lineBox.x + diff + lineHeight + bcEnd - leading;
      bx2 = lineBox.x + diff + lineHeight + pbEnd - leading;
      y2 = end.y + end.outerHeight;
    } else {
      bx1 = x1;

      if (isStart) {
        bx1 -= paddingLeft + borderLeftWidth;

        if (backgroundClip === 'paddingBox') {
          x1 -= paddingLeft;
        } else if (backgroundClip === 'borderBox') {
          x1 -= paddingLeft + borderLeftWidth;
        }
      }

      x2 = end.x + end.outerWidth;
      y2 = lineBox.y + diff + lineHeight + bcEnd - leading;
      by2 = lineBox.y + diff + lineHeight + pbEnd - leading;
    } // TextBox的parent是Text，再是Dom，这里一定是inline，无嵌套就是xom本身，有则包含若干层最上层还是xom


    dom = end instanceof TextBox ? end.parent.domParent : end.domParent; // 从end开始，向上获取dom节点的尾部mpb进行累加，直到xom跳出

    while (dom !== xom) {
      var _list = dom.contentBoxList;

      if (end === _list[_list.length - 1]) {
        if (isUpright) {
          var _dom$computedStyle3 = dom.computedStyle,
              marginBottom = _dom$computedStyle3[MARGIN_BOTTOM$1],
              _paddingBottom = _dom$computedStyle3[PADDING_BOTTOM$2],
              _borderBottomWidth = _dom$computedStyle3[BORDER_BOTTOM_WIDTH$2];
          y2 += marginBottom + _paddingBottom + _borderBottomWidth;
        } else {
          var _dom$computedStyle4 = dom.computedStyle,
              marginRight = _dom$computedStyle4[MARGIN_RIGHT$1],
              _paddingRight = _dom$computedStyle4[PADDING_RIGHT$1],
              _borderRightWidth = _dom$computedStyle4[BORDER_RIGHT_WIDTH$1];
          x2 += marginRight + _paddingRight + _borderRightWidth;
        }
      }

      dom = dom.domParent;
    }

    if (isUpright) {
      by2 = y2;

      if (isEnd) {
        by2 += paddingBottom + borderBottomWidth;

        if (backgroundClip === 'paddingBox') {
          y2 += paddingBottom;
        } else if (backgroundClip === 'borderBox') {
          y2 += paddingBottom + borderBottomWidth;
        }
      }
    } else {
      bx2 = x2;

      if (isEnd) {
        bx2 += paddingRight + borderRightWidth;

        if (backgroundClip === 'paddingBox') {
          x2 += paddingRight;
        } else if (backgroundClip === 'borderBox') {
          x2 += paddingRight + borderRightWidth;
        }
      }
    } // 要考虑xom的ox/oy值


    x1 += xom.ox;
    x2 += xom.ox;
    bx1 += xom.ox;
    bx2 += xom.ox;
    y1 += xom.oy;
    y2 += xom.oy;
    by1 += xom.oy;
    by2 += xom.oy;
    return [x1, y1, x2, y2, bx1, by1, bx2, by2];
  }
  /**
   * 统计inline的所有contentBox排成一行时的总宽度，考虑嵌套的mpb
   * @param xom
   * @param contentBoxList
   * @param isUpright
   * @returns {number}
   */


  function getInlineWidth(xom, contentBoxList, isUpright) {
    var sum = 0;
    var length = contentBoxList.length;

    if (contentBoxList[length - 1] instanceof Ellipsis) {
      length--;
    }

    for (var i = 0; i < length; i++) {
      var contentBox = contentBoxList[i];

      if (isUpright) {
        sum += contentBox.height;
      } else {
        sum += contentBox.width;
      } // 嵌套时，首尾box考虑mpb


      var dom = contentBox instanceof TextBox ? contentBox.parent.domParent : contentBox.domParent;

      while (dom !== xom) {
        var list = dom.contentBoxList;

        if (contentBox === list[0]) {
          if (isUpright) {
            var _dom$computedStyle5 = dom.computedStyle,
                marginTop = _dom$computedStyle5[MARGIN_TOP$1],
                paddingTop = _dom$computedStyle5[PADDING_TOP$2],
                borderTopWidth = _dom$computedStyle5[BORDER_TOP_WIDTH$2];
            sum += marginTop + paddingTop + borderTopWidth;
          } else {
            var _dom$computedStyle6 = dom.computedStyle,
                marginLeft = _dom$computedStyle6[MARGIN_LEFT$1],
                paddingLeft = _dom$computedStyle6[PADDING_LEFT$2],
                borderLeftWidth = _dom$computedStyle6[BORDER_LEFT_WIDTH$2];
            sum += marginLeft + paddingLeft + borderLeftWidth;
          }
        }

        if (contentBox === list[list.length - 1]) {
          if (isUpright) {
            var _dom$computedStyle7 = dom.computedStyle,
                marginBottom = _dom$computedStyle7[MARGIN_BOTTOM$1],
                paddingBottom = _dom$computedStyle7[PADDING_BOTTOM$2],
                borderBottomWidth = _dom$computedStyle7[BORDER_BOTTOM_WIDTH$2];
            sum += marginBottom + paddingBottom + borderBottomWidth;
          } else {
            var _dom$computedStyle8 = dom.computedStyle,
                marginRight = _dom$computedStyle8[MARGIN_RIGHT$1],
                paddingRight = _dom$computedStyle8[PADDING_RIGHT$1],
                borderRightWidth = _dom$computedStyle8[BORDER_RIGHT_WIDTH$1];
            sum += marginRight + paddingRight + borderRightWidth;
          }
        }

        dom = dom.domParent;
      }
    }

    return sum;
  }

  var inline = {
    getInlineBox: getInlineBox,
    getInlineWidth: getInlineWidth
  };

  var _enums$STYLE_KEY$a = enums.STYLE_KEY,
      SCALE_X$2 = _enums$STYLE_KEY$a.SCALE_X,
      SCALE_Y$2 = _enums$STYLE_KEY$a.SCALE_Y;
  var NUMBER$3 = o.NUMBER;

  function matrixResize(imgWidth, imgHeight, targetWidth, targetHeight, x, y, w, h) {
    if (imgWidth === targetWidth && imgHeight === targetHeight) {
      return;
    }

    var list = [[SCALE_X$2, [targetWidth / imgWidth, NUMBER$3]], [SCALE_Y$2, [targetHeight / imgHeight, NUMBER$3]]];
    var tfo = [x, y];
    return transform$1.calMatrixWithOrigin(list, tfo, w, h);
  }

  var image = {
    matrixResize: matrixResize
  };

  var _enums$STYLE_KEY$b = enums.STYLE_KEY,
      BACKGROUND_POSITION_X$1 = _enums$STYLE_KEY$b.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$1 = _enums$STYLE_KEY$b.BACKGROUND_POSITION_Y,
      FONT_SIZE$7 = _enums$STYLE_KEY$b.FONT_SIZE,
      NODE_DEFS_CACHE = enums.NODE_KEY.NODE_DEFS_CACHE;
  var clone$2 = util.clone,
      joinArr$1 = util.joinArr;
  var canvasPolygon$3 = painter.canvasPolygon,
      svgPolygon$2 = painter.svgPolygon;

  function renderBgc(xom, renderMode, ctx, color, list, x, y, w, h, btlr, btrr, bbrr, bblr) {
    var method = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 'fill';
    var isInline = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : false;
    var dx = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0;
    var dy = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0;
    // radial渐变ellipse形状会有matrix，用以从圆缩放到椭圆
    var matrix, cx, cy;

    if (Array.isArray(color)) {
      matrix = color[1];
      cx = color[2];
      cy = color[3];
      color = color[0];
    } // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间


    list = list || border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    } // 椭圆有matrix，用逆矩阵变化点来完成


    if (matrix) {
      var tfo = [cx, cy];
      matrix = transform$1.calMatrixByOrigin(matrix, tfo);
      var t = mx.inverse(matrix);
      list = list.map(function (item) {
        if (!item || !item.length) {
          return null;
        }

        var arr = [];

        for (var i = 0, len = item.length; i < len; i += 2) {
          var p = mx.calPoint([item[i], item[i + 1]], t);
          arr.push(p[0]);
          arr.push(p[1]);
        }

        return arr;
      });
    }

    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      if (matrix) {
        ctx.save();
        var me = xom.matrixEvent;
        matrix = mx.multiply(me, matrix);
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      }

      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      canvasPolygon$3(ctx, list, dx, dy);
      ctx[method]();
      ctx.closePath();

      if (matrix) {
        ctx.restore();
      }
    } else if (renderMode === mode.SVG) {
      var d = svgPolygon$2(list);

      if (isInline) {
        var v = {
          tagName: 'symbol',
          props: [],
          children: [{
            type: 'item',
            tagName: 'path',
            props: [['d', d], ['fill', color]]
          }]
        };

        xom.__config[NODE_DEFS_CACHE].push(v);

        return ctx.add(v);
      } else {
        xom.virtualDom.bb.push({
          type: 'item',
          tagName: 'path',
          props: [['d', d], ['fill', color]]
        }); // 椭圆渐变独有

        if (matrix) {
          var bb = xom.virtualDom.bb;
          bb[bb.length - 1].props.push(['transform', "matrix(".concat(joinArr$1(mx.m2m6(matrix), ','), ")")]);
        }
      }
    }
  }

  function renderImage(xom, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, __config, isInline) {
    var dx = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : 0;
    var dy = arguments.length > 19 && arguments[19] !== undefined ? arguments[19] : 0;
    var source = loadBgi.source; // 无source不绘制，可能错误或加载中

    if (source) {
      bx1 += dx;
      by1 += dy;
      bx2 += dx;
      by2 += dy;
      var bgW = bx2 - bx1;
      var bgH = by2 - by1;
      var width = loadBgi.width,
          height = loadBgi.height;

      var _ref = backgroundSize[i] || [],
          _ref2 = _slicedToArray(_ref, 2),
          w = _ref2[0],
          h = _ref2[1]; // -1为auto，-2为contain，-3为cover


      if (w === -1 && h === -1) {
        w = width;
        h = height;
      } else if (w === -2) {
        if (width > bgW && height > bgH) {
          w = width / bgW;
          h = height / bgH;

          if (w >= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (width > bgW) {
          w = bgW;
          h = w * height / width;
        } else if (height > bgH) {
          h = bgH;
          w = h * width / height;
        } else {
          w = width;
          h = height;
        }
      } else if (w === -3) {
        if (bgW > width && bgH > height) {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (bgW > width) {
          w = bgW;
          h = w * height / width;
        } else if (bgH > height) {
          h = bgH;
          w = h * width / height;
        } else {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        }
      } else if (w === -1) {
        w = h * width / height;
      } else if (h === -1) {
        h = w * height / width;
      }

      var bgX = computedStyle[BACKGROUND_POSITION_X$1][i] || 0;

      if (/%/.test(bgX)) {
        bgX = (bgW - w) * parseFloat(bgX) * 0.01;
      }

      bgX += bx1;
      var bgY = computedStyle[BACKGROUND_POSITION_Y$1][i] || 0;

      if (/%/.test(bgY)) {
        bgY = (bgH - h) * parseFloat(bgY) * 0.01;
      }

      bgY += by1; // 超出尺寸模拟mask截取

      var needMask = bgX < bx1 || bgY < by1 || bgX + w > bx1 + bgW || bgY + h > by1 + bgH; // 计算因为repeat，需要向4个方向扩展渲染几个数量图片

      var xnl = 0;
      var xnr = 0;
      var ynt = 0;
      var ynb = 0; // repeat-x

      if (['repeatX', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var diff = bgX - bx1;

        if (diff > 0) {
          xnl = Math.ceil(diff / w);
        }

        diff = bx1 + bgW - bgX - w;

        if (diff > 0) {
          xnr = Math.ceil(diff / w);
        }
      } // repeat-y


      if (['repeatY', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var _diff = bgY - by1;

        if (_diff > 0) {
          ynt = Math.ceil(_diff / h);
        }

        _diff = by1 + bgH - bgY - h;

        if (_diff > 0) {
          ynb = Math.ceil(_diff / h);
        }
      } // 分同行列和4个角分别判断，先看同行同列，再看4个角的象限


      var repeat = [];

      if (xnl > 0) {
        for (var _i = 0; _i < xnl; _i++) {
          var x = bgX - (_i + 1) * w;
          repeat.push([x, bgY]); // 看最左边超过没有

          if (!needMask && _i === 0 && x < bx1) {
            needMask = true;
          }
        }
      }

      if (xnr > 0) {
        for (var _i2 = 0; _i2 < xnr; _i2++) {
          var _x = bgX + (_i2 + 1) * w;

          repeat.push([_x, bgY]); // 看最右边超过没有

          if (!needMask && _i2 === xnr - 1 && _x + w > bx1 + bgW) {
            needMask = true;
          }
        }
      }

      if (ynt > 0) {
        for (var _i3 = 0; _i3 < ynt; _i3++) {
          var y = bgY - (_i3 + 1) * h;
          repeat.push([bgX, y]); // 看最上边超过没有

          if (!needMask && _i3 === 0 && y < by1) {
            needMask = true;
          }
        }
      }

      if (ynb > 0) {
        for (var _i4 = 0; _i4 < ynb; _i4++) {
          var _y = bgY + (_i4 + 1) * h;

          repeat.push([bgX, _y]); // 看最下边超过没有

          if (!needMask && _i4 === ynb - 1 && _y + w > by1 + bgH) {
            needMask = true;
          }
        }
      } // 原点和同行列十字画完，看4个角的情况


      if (xnl > 0 && ynt > 0) {
        for (var _i5 = 0; _i5 < xnl; _i5++) {
          for (var j = 0; j < ynt; j++) {
            repeat.push([bgX - (_i5 + 1) * w, bgY - (j + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynt > 0) {
        for (var _i6 = 0; _i6 < xnr; _i6++) {
          for (var _j = 0; _j < ynt; _j++) {
            repeat.push([bgX + (_i6 + 1) * w, bgY - (_j + 1) * h]);
          }
        }
      }

      if (xnl > 0 && ynb > 0) {
        for (var _i7 = 0; _i7 < xnl; _i7++) {
          for (var _j2 = 0; _j2 < ynb; _j2++) {
            repeat.push([bgX - (_i7 + 1) * w, bgY + (_j2 + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynb > 0) {
        for (var _i8 = 0; _i8 < xnr; _i8++) {
          for (var _j3 = 0; _j3 < ynb; _j3++) {
            repeat.push([bgX + (_i8 + 1) * w, bgY + (_j3 + 1) * h]);
          }
        }
      }

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (needMask) {
          ctx.save();
          renderBgc(this, renderMode, ctx, '#FFF', null, bx1, by1, bgW, bgH, btlr, btrr, bbrr, bblr, 'clip');
        } // 先画不考虑repeat的中心声明的


        ctx.drawImage(source, bgX, bgY, w, h); // 再画重复的十字和4角象限

        repeat.forEach(function (item) {
          ctx.drawImage(source, item[0], item[1], w, h);
        });

        if (needMask) {
          ctx.restore();
        }
      } else if (renderMode === mode.SVG) {
        var matrix = image.matrixResize(width, height, w, h, bgX, bgY, bgW, bgH);
        var props = [['xlink:href', loadBgi.url], ['x', bgX], ['y', bgY], ['width', width], ['height', height]];
        var needResize;

        if (matrix && !mx.isE(matrix)) {
          needResize = true;
          props.push(['transform', 'matrix(' + joinArr$1(mx.m2m6(matrix), ',') + ')']);
        }

        if (needMask) {
          var p1 = [bx1, by1];
          var p2 = [bx2, by2];

          if (needResize) {
            var inverse = mx.inverse(matrix);
            p1 = mx.calPoint(p1, inverse);
            p2 = mx.calPoint(p2, inverse);
          }

          var v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', "M".concat(p1[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p1[1])], ['fill', '#FFF']]
            }]
          };
          var id = ctx.add(v);

          __config[NODE_DEFS_CACHE].push(v);

          props.push(['clip-path', 'url(#' + id + ')']);
        }

        if (isInline) {
          var _v = {
            tagName: 'symbol',
            props: [],
            children: [{
              type: 'img',
              tagName: 'image',
              props: props
            }]
          };

          xom.__config[NODE_DEFS_CACHE].push(_v);

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix && !mx.isE(_matrix)) {
                copy[5][1] = 'matrix(' + joinArr$1(mx.m2m6(_matrix), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];

            _v.children.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
          return ctx.add(_v);
        } else {
          // 先画不考虑repeat的中心声明的
          xom.virtualDom.bb.push({
            type: 'img',
            tagName: 'image',
            props: props
          }); // 再画重复的十字和4角象限

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix2 = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix2 && !mx.isE(_matrix2)) {
                copy[5][1] = 'matrix(' + joinArr$1(mx.m2m6(_matrix2), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];
            xom.virtualDom.bb.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
        }
      }
    }
  }

  var bg = {
    renderBgc: renderBgc,
    renderImage: renderImage
  };

  var isFunction$3 = util.isFunction;

  function traversal(list, length, diff, after) {
    if (after) {
      for (var i = 0; i < length; i++) {
        var item = list[i];

        if (item[1]) {
          item[1](diff);
        } else {
          item.__after && item.__after(diff);
        }
      }
    } else {
      for (var _i = 0; _i < length; _i++) {
        var _item = list[_i];

        if (_item[0]) {
          _item[0](diff);
        } else {
          _item.__before && _item.__before(diff);
        }
      }
    }
  }

  var isPause;

  var Frame = /*#__PURE__*/function () {
    function Frame() {
      _classCallCheck(this, Frame);

      this.__hookTask = []; // 动画刷新后，每个root注册的刷新回调执行

      this.__task = [];
      this.__taskCp = []; // 区别于task，component专用，和animate等其它不同流水线，在最后执行，防止混了 #122

      this.__now = null;
    }

    _createClass(Frame, [{
      key: "__init",
      value: function __init() {
        var self = this;
        var task = self.task,
            taskCp = self.taskCp;
        inject.cancelAnimationFrame(self.id);
        var last = self.__now = inject.now();

        function cb() {
          // 必须清除，可能会发生重复，当动画finish回调中gotoAndPlay(0)，下方结束判断发现aTask还有值会继续，新的init也会进入再次执行
          inject.cancelAnimationFrame(self.id);
          self.id = inject.requestAnimationFrame(function () {
            if (isPause || !task.length && !taskCp.length) {
              return;
            }

            var now = self.__now = inject.now();
            var diff = now - last;
            diff = Math.max(diff, 0); // let delta = diff * 0.06; // 比例是除以1/60s，等同于*0.06

            last = now; // 优先动画计算

            var clone = task.slice(0);
            var cloneCp = taskCp.splice(0); // task要常驻，taskCp只1次直接splice清空

            var length = clone.length;
            var lengthCp = cloneCp.length;
            traversal(clone, length, diff, false);
            traversal(cloneCp, lengthCp, diff, false); // 执行动画造成的每个Root的刷新并清空

            var list = self.__hookTask.splice(0);

            for (var i = 0, len = list.length; i < len; i++) {
              var item = list[i];
              item && item();
            } // 普通的before/after


            traversal(clone, length, diff, true);
            traversal(cloneCp, lengthCp, diff, true); // 还有则继续，没有则停止节省性能

            if (task.length || taskCp.length) {
              cb();
            }
          });
        }

        cb();
      }
    }, {
      key: "onFrame",
      value: function onFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        if (!task.length) {
          this.__init();
        }

        if (isFunction$3(handle)) {
          handle = {
            __after: handle,
            __karasFramecb: handle
          };
        }

        task.push(handle);
      }
    }, {
      key: "offFrame",
      value: function offFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        for (var i = 0, len = task.length; i < len; i++) {
          var item = task[i]; // 需考虑nextFrame包裹的引用对比

          if (item === handle || item.__karasFramecb === handle) {
            task.splice(i, 1);
            break;
          }
        }

        if (!task.length) {
          inject.cancelAnimationFrame(this.id);
          this.__now = null;
        }
      }
    }, {
      key: "nextFrame",
      value: function nextFrame(handle) {
        var _this = this;

        if (!handle) {
          return;
        } // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比


        var cb = isFunction$3(handle) ? {
          __after: function __after(diff) {
            handle(diff);

            _this.offFrame(cb);
          }
        } : {
          __before: handle.__before,
          __after: function __after(diff) {
            handle.__after && handle.__after(diff);

            _this.offFrame(cb);
          }
        };
        cb.__karasFramecb = handle;
        this.onFrame(cb);
      }
    }, {
      key: "__nextFrameCp",
      value: function __nextFrameCp(handle) {
        var task = this.task,
            taskCp = this.taskCp;

        if (!task.length && !taskCp.length) {
          this.__init();
        }

        taskCp.push(handle);
      }
    }, {
      key: "pause",
      value: function pause() {
        isPause = true;
      }
    }, {
      key: "resume",
      value: function resume() {
        if (isPause) {
          this.__init();

          isPause = false;
        }
      }
    }, {
      key: "task",
      get: function get() {
        return this.__task;
      }
    }, {
      key: "taskCp",
      get: function get() {
        return this.__taskCp;
      }
    }]);

    return Frame;
  }();

  var frame = new Frame();

  /**
   * https://github.com/gre/bezier-easing
   * BezierEasing - use bezier curve for transition easing function
   * by Gaëtan Renaudeau 2014 - 2015 – MIT License
   */
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B$1(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B$1(aA1, aA2)) * aT + C(aA1)) * aT;
  } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B$1(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function LinearEasing(x) {
    return x;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return LinearEasing;
    } // Precompute samples table


    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample; // Interpolate to provide an initial guess for t

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  var easing = {
    linear: bezier(1, 1, 0, 0),
    easeIn: bezier(0.42, 0, 1, 1),
    easeOut: bezier(0, 0, 0.58, 1),
    ease: bezier(0.25, 0.1, 0.25, 1),
    easeInOut: bezier(0.42, 0, 0.58, 1),
    cubicBezier: bezier,
    getEasing: function getEasing(v, v1, v2, v3) {
      if (arguments.length === 4) {
        return bezier(v, v1, v2, v3);
      } else if (Array.isArray(v) && v.length === 4) {
        return bezier(v[0], v[1], v[2], v[3]);
      } else if (v) {
        v = v.toString();
        var timingFunction;

        if (/^\s*(?:cubic-bezier\s*)?\(\s*[\d.]+\s*,\s*[-\d.]+\s*,\s*[\d.]+\s*,\s*[-\d.]+\s*\)\s*$/i.test(v)) {
          v = v.match(/[\d.]+/g);
          timingFunction = bezier(v[0], v[1], v[2], v[3]);
        } else if (v !== 'getEasing') {
          timingFunction = this[v];
        }

        return timingFunction;
      }
    }
  };
  easing['ease-in'] = easing.easeIn;
  easing['ease-out'] = easing.easeOut;
  easing['ease-in-out'] = easing.easeInOut;

  var _enums$STYLE_KEY$c = enums.STYLE_KEY,
      FILTER$3 = _enums$STYLE_KEY$c.FILTER,
      TRANSFORM_ORIGIN$3 = _enums$STYLE_KEY$c.TRANSFORM_ORIGIN,
      PERSPECTIVE_ORIGIN$2 = _enums$STYLE_KEY$c.PERSPECTIVE_ORIGIN,
      BACKGROUND_CLIP$1 = _enums$STYLE_KEY$c.BACKGROUND_CLIP,
      BACKGROUND_POSITION_X$2 = _enums$STYLE_KEY$c.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$2 = _enums$STYLE_KEY$c.BACKGROUND_POSITION_Y,
      BOX_SHADOW$1 = _enums$STYLE_KEY$c.BOX_SHADOW,
      TRANSLATE_X$3 = _enums$STYLE_KEY$c.TRANSLATE_X,
      TRANSLATE_Y$3 = _enums$STYLE_KEY$c.TRANSLATE_Y,
      TRANSLATE_Z$3 = _enums$STYLE_KEY$c.TRANSLATE_Z,
      BACKGROUND_SIZE$1 = _enums$STYLE_KEY$c.BACKGROUND_SIZE,
      FONT_SIZE$8 = _enums$STYLE_KEY$c.FONT_SIZE,
      FLEX_BASIS$1 = _enums$STYLE_KEY$c.FLEX_BASIS,
      FLEX_DIRECTION$1 = _enums$STYLE_KEY$c.FLEX_DIRECTION,
      WIDTH$3 = _enums$STYLE_KEY$c.WIDTH,
      HEIGHT$3 = _enums$STYLE_KEY$c.HEIGHT,
      TOP = _enums$STYLE_KEY$c.TOP,
      BOTTOM = _enums$STYLE_KEY$c.BOTTOM,
      LINE_HEIGHT$4 = _enums$STYLE_KEY$c.LINE_HEIGHT,
      OPACITY$2 = _enums$STYLE_KEY$c.OPACITY,
      Z_INDEX$1 = _enums$STYLE_KEY$c.Z_INDEX,
      TRANSFORM$2 = _enums$STYLE_KEY$c.TRANSFORM,
      COLOR$4 = _enums$STYLE_KEY$c.COLOR,
      FONT_WEIGHT$4 = _enums$STYLE_KEY$c.FONT_WEIGHT,
      FONT_STYLE$3 = _enums$STYLE_KEY$c.FONT_STYLE,
      FONT_FAMILY$4 = _enums$STYLE_KEY$c.FONT_FAMILY,
      TEXT_ALIGN$1 = _enums$STYLE_KEY$c.TEXT_ALIGN,
      MATRIX$2 = _enums$STYLE_KEY$c.MATRIX,
      ROTATE_3D$2 = _enums$STYLE_KEY$c.ROTATE_3D,
      TRANSLATE_PATH$1 = _enums$STYLE_KEY$c.TRANSLATE_PATH,
      TEXT_STROKE_COLOR$3 = _enums$STYLE_KEY$c.TEXT_STROKE_COLOR,
      TEXT_STROKE_OVER$2 = _enums$STYLE_KEY$c.TEXT_STROKE_OVER,
      _enums$UPDATE_KEY$1 = enums.UPDATE_KEY,
      UPDATE_NODE$1 = _enums$UPDATE_KEY$1.UPDATE_NODE,
      UPDATE_STYLE = _enums$UPDATE_KEY$1.UPDATE_STYLE,
      UPDATE_KEYS = _enums$UPDATE_KEY$1.UPDATE_KEYS,
      UPDATE_CONFIG$1 = _enums$UPDATE_KEY$1.UPDATE_CONFIG,
      _enums$KEY_FRAME_KEY = enums.KEY_FRAME_KEY,
      FRAME_STYLE = _enums$KEY_FRAME_KEY.FRAME_STYLE,
      FRAME_TIME = _enums$KEY_FRAME_KEY.FRAME_TIME,
      FRAME_EASING = _enums$KEY_FRAME_KEY.FRAME_EASING,
      FRAME_TRANSITION = _enums$KEY_FRAME_KEY.FRAME_TRANSITION,
      _enums$ANIMATE_KEY = enums.ANIMATE_KEY,
      I_ASSIGNING = _enums$ANIMATE_KEY.I_ASSIGNING,
      I_IN_FPS = _enums$ANIMATE_KEY.I_IN_FPS,
      I_IS_DELAY = _enums$ANIMATE_KEY.I_IS_DELAY,
      I_BEGIN = _enums$ANIMATE_KEY.I_BEGIN,
      I_END = _enums$ANIMATE_KEY.I_END,
      I_FINISHED = _enums$ANIMATE_KEY.I_FINISHED,
      I_NEXT_END = _enums$ANIMATE_KEY.I_NEXT_END,
      I_FIRST_PLAY = _enums$ANIMATE_KEY.I_FIRST_PLAY,
      I_PLAY_CB = _enums$ANIMATE_KEY.I_PLAY_CB,
      I_TARGET = _enums$ANIMATE_KEY.I_TARGET,
      I_ROOT = _enums$ANIMATE_KEY.I_ROOT,
      I_FRAMES = _enums$ANIMATE_KEY.I_FRAMES,
      I_FRAMES_R = _enums$ANIMATE_KEY.I_FRAMES_R,
      I_CURRENT_TIME = _enums$ANIMATE_KEY.I_CURRENT_TIME,
      I_NEXT_TIME = _enums$ANIMATE_KEY.I_NEXT_TIME,
      I_STYLE = _enums$ANIMATE_KEY.I_STYLE,
      I_DURATION = _enums$ANIMATE_KEY.I_DURATION,
      I_ITERATIONS = _enums$ANIMATE_KEY.I_ITERATIONS,
      I_FILL = _enums$ANIMATE_KEY.I_FILL,
      I_PLAYBACK_RATE = _enums$ANIMATE_KEY.I_PLAYBACK_RATE,
      I_PLAY_COUNT = _enums$ANIMATE_KEY.I_PLAY_COUNT,
      I_PLAY_STATE = _enums$ANIMATE_KEY.I_PLAY_STATE,
      I_DESTROYED = _enums$ANIMATE_KEY.I_DESTROYED,
      I_START_TIME = _enums$ANIMATE_KEY.I_START_TIME,
      I_FPS_TIME = _enums$ANIMATE_KEY.I_FPS_TIME,
      I_EASING = _enums$ANIMATE_KEY.I_EASING,
      I_ENTER_FRAME = _enums$ANIMATE_KEY.I_ENTER_FRAME,
      I_DELAY = _enums$ANIMATE_KEY.I_DELAY,
      I_END_DELAY = _enums$ANIMATE_KEY.I_END_DELAY,
      I_KEYS = _enums$ANIMATE_KEY.I_KEYS,
      I_ORIGIN_STYLE = _enums$ANIMATE_KEY.I_ORIGIN_STYLE,
      I_CURRENT_FRAMES = _enums$ANIMATE_KEY.I_CURRENT_FRAMES,
      I_CURRENT_FRAME = _enums$ANIMATE_KEY.I_CURRENT_FRAME,
      I_SPF_LIMIT = _enums$ANIMATE_KEY.I_SPF_LIMIT,
      I_FPS = _enums$ANIMATE_KEY.I_FPS,
      I_DIRECTION = _enums$ANIMATE_KEY.I_DIRECTION,
      I_FIRST_ENTER = _enums$ANIMATE_KEY.I_FIRST_ENTER,
      I_STAY_BEGIN = _enums$ANIMATE_KEY.I_STAY_BEGIN,
      I_STAY_END = _enums$ANIMATE_KEY.I_STAY_END,
      I_IS2 = _enums$ANIMATE_KEY.I_IS2,
      I_END_TIME = _enums$ANIMATE_KEY.I_END_TIME,
      I_NODE_CONFIG = _enums$ANIMATE_KEY.I_NODE_CONFIG,
      I_ROOT_CONFIG = _enums$ANIMATE_KEY.I_ROOT_CONFIG,
      I_OUT_BEGIN_DELAY = _enums$ANIMATE_KEY.I_OUT_BEGIN_DELAY,
      I_TIME_STAMP = _enums$ANIMATE_KEY.I_TIME_STAMP;
  var AUTO$2 = o.AUTO,
      PX$3 = o.PX,
      PERCENT$4 = o.PERCENT,
      INHERIT$2 = o.INHERIT,
      RGBA$1 = o.RGBA,
      STRING$1 = o.STRING,
      NUMBER$4 = o.NUMBER,
      REM$4 = o.REM,
      VW$4 = o.VW,
      VH$4 = o.VH,
      VMAX$4 = o.VMAX,
      VMIN$4 = o.VMIN,
      GRADIENT$1 = o.GRADIENT,
      calUnit$2 = o.calUnit;
  var isNil$5 = util.isNil,
      isFunction$4 = util.isFunction,
      isNumber$1 = util.isNumber,
      isObject$1 = util.isObject,
      clone$3 = util.clone,
      equalArr$2 = util.equalArr;
  var linear = easing.linear;
  var cloneStyle$1 = css.cloneStyle;
  var isGeom$1 = o$2.isGeom,
      GEOM$3 = o$2.GEOM;
  var COLOR_HASH$2 = key.COLOR_HASH,
      LENGTH_HASH$2 = key.LENGTH_HASH,
      RADIUS_HASH$2 = key.RADIUS_HASH,
      GRADIENT_HASH$2 = key.GRADIENT_HASH,
      EXPAND_HASH$2 = key.EXPAND_HASH,
      GRADIENT_TYPE$2 = key.GRADIENT_TYPE;
  var NUM_CAL_HASH = {};
  Object.assign(NUM_CAL_HASH, LENGTH_HASH$2);
  Object.assign(NUM_CAL_HASH, EXPAND_HASH$2);

  function unify(frames, target) {
    var hash = {};
    var keys = []; // 获取所有关键帧的属性

    frames.forEach(function (item) {
      var style = item[FRAME_STYLE];
      Object.keys(style).forEach(function (k) {
        var v = style[k]; // 未定义的过滤掉，null空有意义

        if (v !== undefined && !hash.hasOwnProperty(k)) {
          hash[k] = true; // geom为属性字符串，style都为枚举int

          if (!GEOM$3.hasOwnProperty(k)) {
            k = parseInt(k);
          } // path动画要转为translateXY，所以手动添加，使2帧之间存在过渡，有可能之前已存在这个动画，可忽视


          if (k === TRANSLATE_PATH$1) {
            if (!hash.hasOwnProperty(TRANSLATE_X$3)) {
              keys.push(TRANSLATE_X$3);
            }

            if (!hash.hasOwnProperty(TRANSLATE_Y$3)) {
              keys.push(TRANSLATE_Y$3);
            }

            hash[TRANSLATE_X$3] = hash[TRANSLATE_Y$3] = true;
          }

          keys.push(k);
        }
      });
    }); // 添补没有声明完全的关键帧属性为节点当前值

    frames.forEach(function (item) {
      var style = item[FRAME_STYLE];
      keys.forEach(function (k) {
        if (!style.hasOwnProperty(k) || isNil$5(style[k])) {
          if (GEOM$3.hasOwnProperty(k)) {
            style[k] = target.getProps(k);
          } else {
            style[k] = target.currentStyle[k];
          }
        }
      });
    });
    return keys;
  } // 每次初始化时处理继承值，以及转换transform为单matrix矩阵


  function inherit(frames, keys, target) {
    var computedStyle = target.computedStyle;
    frames.forEach(function (item) {
      var style = item[FRAME_STYLE];
      keys.forEach(function (k) {
        var v = style[k]; // geom的属性可能在帧中没有

        if (isNil$5(v)) {
          return;
        }

        if (k === TRANSFORM$2) {
          var ow = target.outerWidth;
          var oh = target.outerHeight;
          var m = transform$1.calMatrix(v, ow, oh);
          style[k] = [[MATRIX$2, m]];
        } else if (v[1] === INHERIT$2) {
          if (k === COLOR$4 || k === TEXT_STROKE_COLOR$3) {
            style[k] = [util.rgba2int(computedStyle[k]), RGBA$1];
          } else if (LENGTH_HASH$2.hasOwnProperty(k)) {
            style[k] = [computedStyle[k], PX$3];
          } else if (k === FONT_WEIGHT$4) {
            style[k] = [computedStyle[k], NUMBER$4];
          } else if (k === FONT_STYLE$3 || k === FONT_FAMILY$4 || k === TEXT_ALIGN$1 || k === TEXT_STROKE_OVER$2) {
            style[k] = [computedStyle[k], STRING$1];
          }
        }
      });
    });
  }
  /**
   * 通知root更新当前动画，需要根据frame的状态来决定是否是同步插入
   * 在异步时，因为动画本身是异步，需要addRefreshTask
   * 而如果此时frame在执行before过程中，说明帧动画本身是在before计算的，需要同步插入
   * @param style
   * @param keys 样式所有的key
   * @param __config
   * @param root
   * @param node
   */


  function genBeforeRefresh(style, keys, __config, root, node) {
    var res = {};
    res[UPDATE_NODE$1] = node;
    res[UPDATE_STYLE] = style;
    res[UPDATE_KEYS] = keys;
    res[UPDATE_CONFIG$1] = __config[I_NODE_CONFIG];

    root.__addUpdate(node, __config[I_NODE_CONFIG], root, __config[I_ROOT_CONFIG], res);

    __config[I_STYLE] = style;
    __config[I_ASSIGNING] = true; // frame每帧回调时，下方先执行计算好变更的样式，这里特殊插入一个hook，让root增加一个刷新操作
    // 多个动画调用因为相同root也只会插入一个，这样在所有动画执行完毕后frame里检查同步进行刷新，解决单异步问题

    root.__frameHook();
  }
  /**
   * 将每帧的样式格式化，提取出offset属性并转化为时间，提取出缓动曲线easing
   * @param style 关键帧样式
   * @param duration 动画时间长度
   * @param es options的easing曲线控制，frame没有自定义则使用全局的
   * @returns {{style: *, time: number, easing: *, transition: []}}
   */


  function framing(style, duration, es) {
    var _style = style,
        offset = _style.offset,
        easing = _style.easing; // 这两个特殊值提出来存储不干扰style

    delete style.offset;
    delete style.easing; // translatePath特殊对待，ae的曲线运动动画

    var translatePath = style.translatePath;
    style = css.normalize(style);

    if (Array.isArray(translatePath) && [6, 8].indexOf(translatePath.length) > -1) {
      style[TRANSLATE_PATH$1] = translatePath.map(function (item) {
        return calUnit$2(item);
      });
    }

    var res = [];
    res[FRAME_STYLE] = style;
    res[FRAME_TIME] = offset * duration;
    res[FRAME_EASING] = easing || es;
    res[FRAME_TRANSITION] = [];
    return res;
  }

  function calByUnit(p, n, container, root) {
    if (p[1] === PX$3) {
      if (n[1] === PERCENT$4) {
        return n[0] * 0.01 * container - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width * 0.01 - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height * 0.01 - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) * 0.01 - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) * 0.01 - p[0];
      }
    } else if (p[1] === PERCENT$4) {
      if (n[1] === PX$3) {
        return n[0] * 100 / container - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * root.computedStyle[FONT_SIZE$8] * 100 / container - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width / container - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height / container - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) / container - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) / container - p[0];
      }
    } else if (p[1] === REM$4) {
      if (n[1] === PX$3) {
        return n[0] / root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === PERCENT$4) {
        return n[0] * 0.01 * container / root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width * 0.01 / root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height * 0.01 / root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) * 0.01 / root.computedStyle[FONT_SIZE$8] - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) * 0.01 / root.computedStyle[FONT_SIZE$8] - p[0];
      }
    } else if (p[1] === VW$4) {
      if (n[1] === PX$3) {
        return n[0] * 100 / root.width - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * 100 * root.computedStyle[FONT_SIZE$8] / root.width - p[0];
      } else if (n[1] === PERCENT$4) {
        return n[0] * container / root.width - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height / root.width - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) / root.width - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) / root.width - p[0];
      }
    } else if (p[1] === VH$4) {
      if (n[1] === PX$3) {
        return n[0] * 100 / root.height - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * 100 * root.computedStyle[FONT_SIZE$8] / root.height - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width / root.height - p[0];
      } else if (n[1] === PERCENT$4) {
        return n[0] * container / root.height - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) / root.height - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) / root.height - p[0];
      }
    } else if (p[1] === VMAX$4) {
      if (n[1] === PX$3) {
        return n[0] * 100 / Math.max(root.width, root.height) - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * 100 * root.computedStyle[FONT_SIZE$8] / Math.max(root.width, root.height) - p[0];
      } else if (n[1] === PERCENT$4) {
        return n[0] * container / Math.max(root.width, root.height) - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width / Math.max(root.width, root.height) - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height / Math.max(root.width, root.height) - p[0];
      } else if (n[1] === VMIN$4) {
        return n[0] * Math.min(root.width, root.height) / Math.max(root.width, root.height) - p[0];
      }
    } else if (p[1] === VMIN$4) {
      if (n[1] === PX$3) {
        return n[0] * 100 / Math.min(root.width, root.height) - p[0];
      } else if (n[1] === REM$4) {
        return n[0] * 100 * root.computedStyle[FONT_SIZE$8] / Math.min(root.width, root.height) - p[0];
      } else if (n[1] === PERCENT$4) {
        return n[0] * container / Math.min(root.width, root.height) - p[0];
      } else if (n[1] === VW$4) {
        return n[0] * root.width / Math.min(root.width, root.height) - p[0];
      } else if (n[1] === VH$4) {
        return n[0] * root.height / Math.min(root.width, root.height) - p[0];
      } else if (n[1] === VMAX$4) {
        return n[0] * Math.max(root.width, root.height) / Math.min(root.width, root.height) - p[0];
      }
    }
  }
  /**
   * 计算两帧之间的差，单位不同的以后面为准，返回的v表示差值
   * 没有变化返回空
   * auto等无法比较的不参与计算，不返回来标识无过度效果
   * @param prev 上一帧样式
   * @param next 下一帧样式
   * @param k 比较的样式名
   * @param target dom对象
   * @param tagName dom名
   * @returns {{k: *, v: *}}
   */


  function calDiff(prev, next, k, target, tagName) {
    var res = [k];
    var p = prev[k];
    var n = next[k];

    if (k === TRANSFORM$2) {
      // transform因默认值null很特殊，不存在时需给默认矩阵
      if (!p && !n) {
        return;
      }

      var pm, nm;

      if (p) {
        pm = p[0][1];
      } else {
        pm = mx.identity();
      }

      if (n) {
        nm = n[0][1];
      } else {
        nm = mx.identity();
      } // transform特殊被初始化转成matrix矩阵，直接计算差值


      if (equalArr$2(pm, nm)) {
        return;
      }

      res[1] = [nm[0] - pm[0], nm[1] - pm[1], nm[2] - pm[2], nm[3] - pm[3], nm[4] - pm[4], nm[5] - pm[5], nm[6] - pm[6], nm[7] - pm[7], nm[8] - pm[8], nm[9] - pm[9], nm[10] - pm[10], nm[11] - pm[11], nm[12] - pm[12], nm[13] - pm[13], nm[14] - pm[14], nm[15] - pm[15]];
      return res;
    } else if (k === ROTATE_3D$2) {
      if (equalArr$2(p, n)) {
        return;
      }

      res[1] = [n[0] - n[0], n[1] - p[1], n[2] - p[2], [n[3][0] - p[3][0], n[3][1]]];
    } else if (k === FILTER$3) {
      // filter很特殊，里面有多个滤镜，按顺序计算，为空视为默认值，如blur默认0，brightness默认1
      var len = Math.max(p ? p.length : 0, n ? n.length : 0);
      var v = [];

      for (var i = 0; i < len; i++) {
        var pv = p ? p[i] : null,
            nv = n ? n[i] : null; // 空或key不等都无变化

        if (isNil$5(pv) || isNil$5(nv) || pv[0] !== nv[0]) {
          v.push(null);
        } else {
          var _k = pv[0];

          if (_k === 'blur') {
            if (pv[1][1] === nv[1][1]) {
              v.push(nv[1][0] - pv[1][0]);
            } else {
              var v2 = calByUnit(pv[1], nv[1], 0, target.root);
              v.push(v2);
            }
          } else if (_k === 'hueRotate' || _k === 'saturate' || _k === 'brightness' || _k === 'contrast' || _k === 'sepia' || _k === 'invert' || _k === 'grayscale') {
            v.push(nv[1][0] - pv[1][0]);
          } else if (_k === 'dropShadow') {
            var _v = [];

            for (var _i = 0; _i < 4; _i++) {
              var a = pv[1][_i],
                  b = nv[1][_i];

              if (a[1] === b[1]) {
                _v.push(b[0] - a[0]);
              } else {
                _v.push(calByUnit(a, b, _i === 1 ? taraget.clientHeight : target.clientWidth, target.root));
              }
            }

            _v.push([nv[1][4][0] - pv[1][4][0], nv[1][4][1] - pv[1][4][1], nv[1][4][2] - pv[1][4][2], nv[1][4][3] - pv[1][4][3]]);

            v.push(_v);
          }
        }
      }

      res[1] = v;
    } else if (k === TRANSFORM_ORIGIN$3 || k === PERSPECTIVE_ORIGIN$2) {
      res[1] = [];

      for (var _i2 = 0; _i2 < 2; _i2++) {
        var pi = p[_i2];
        var ni = n[_i2];

        if (pi[1] === ni[1]) {
          res[1].push(ni[0] - pi[0]);
        } else {
          var _v2 = calByUnit(pi, ni, target[_i2 ? 'outerHeight' : 'outerWidth'], target.root);

          res[1].push(_v2 || 0);
        }
      }

      if (equalArr$2(res[1], [0, 0])) {
        return;
      }
    } else if (k === BACKGROUND_POSITION_X$2 || k === BACKGROUND_POSITION_Y$2) {
      res[1] = [];
      var length = Math.min(p.length, n.length);

      for (var _i3 = 0; _i3 < length; _i3++) {
        var _pi = p[_i3],
            _ni = n[_i3];

        if (!_pi || !_ni) {
          res[1].push(null);
          continue;
        }

        if (_pi[1] === _ni[1]) {
          var _v3 = _ni[0] - _pi[0];

          if (!_v3) {
            res[1].push(null);
            return;
          }

          res[1].push(_v3);
        } else {
          var k2 = k === BACKGROUND_POSITION_X$2 ? 'offsetWidth' : 'offsetHeight';

          if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$2 ? 'clientWidth' : 'clientHeight';
          } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$2 ? 'width' : 'height';
          }

          var _v4 = calByUnit(_pi, _ni, target[k2], target.root);

          if (!_v4) {
            res[1].push(null);
            return;
          }

          res[1].push(_v4);
        }
      }
    } else if (k === BOX_SHADOW$1) {
      res[1] = [];

      for (var _i4 = 0, _len = Math.min(p.length, n.length); _i4 < _len; _i4++) {
        var _a = p[_i4];
        var _b = n[_i4];
        var _v5 = []; // x/y/blur/spread

        for (var j = 0; j < 4; j++) {
          _v5.push(_b[j] - _a[j]);
        } // rgba


        var c = [];

        for (var _j = 0; _j < 4; _j++) {
          c.push(_b[4][_j] - _a[4][_j]);
        }

        _v5.push(c);

        res[1].push(_v5);
      }
    } else if (EXPAND_HASH$2.hasOwnProperty(k)) {
      if (p[1] === n[1]) {
        var _v6 = n[0] - p[0];

        if (_v6 === 0) {
          return;
        }

        res[1] = _v6;
      } else {
        var _v7 = calByUnit(p, n, target[k === TRANSLATE_X$3 || k === TRANSLATE_Z$3 ? 'outerWidth' : 'outerHeight'], target.root);

        if (!_v7) {
          return;
        }

        res[1] = _v7;
      }
    } else if (k === BACKGROUND_SIZE$1) {
      res[1] = [];

      var _length = Math.min(p.length, n.length);

      var has;

      for (var _i5 = 0; _i5 < _length; _i5++) {
        var _pi2 = p[_i5],
            _ni2 = n[_i5];

        if (!_pi2 || !_ni2) {
          res[1].push(null);
          continue;
        }

        var temp = [];

        for (var _j2 = 0; _j2 < 2; _j2++) {
          var pp = _pi2[_j2],
              nn = _ni2[_j2];

          if (pp[1] === nn[1]) {
            temp.push(nn[0] - pp[0]);
          } else {
            var _k2 = _i5 ? 'offsetWidth' : 'offsetHeight';

            if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? 'clientWidth' : 'clientHeight';
            } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? 'width' : 'height';
            }

            var _v8 = calByUnit(pp, nn, target[_k2], target.root);

            temp.push(_v8 || 0);
          }
        }

        if (equalArr$2(temp, [0, 0])) {
          res[1].push(null);
        } else {
          res[1].push(temp);
          has = true;
        }
      }

      if (!has) {
        return;
      }
    } else if (GRADIENT_HASH$2.hasOwnProperty(k)) {
      // backgroundImage发生了渐变色和图片的变化，fill发生渐变色和纯色的变化等
      res[1] = [];

      var _length2 = Math.min(p.length, n.length);

      for (var _i6 = 0; _i6 < _length2; _i6++) {
        var _pi3 = p[_i6],
            _ni3 = n[_i6];

        if (!_pi3 || !_ni3 || _pi3[1] !== _ni3[1]) {
          res[1].push(null);
          continue;
        }

        var isGradient = _pi3[1] === GRADIENT$1;
        _pi3 = _pi3[0];
        _ni3 = _ni3[0];
        var _temp = []; // 渐变

        if (isGradient) {
          var r = calDiffGradient(_pi3, _ni3, target);

          if (!r) {
            res[1].push(null);
            continue;
          }

          _temp = r;
        } // 纯色
        else {
          if (equalArr$2(_ni3, _pi3)) {
            res[1].push(null);
          }

          _temp[0] = [_ni3[0] - _pi3[0], _ni3[1] - _pi3[1], _ni3[2] - _pi3[2], _ni3[3] - _pi3[3]];
        }

        res[1].push(_temp);
      }
    } else if (COLOR_HASH$2.hasOwnProperty(k)) {
      if (n[1] !== p[1]) {
        return;
      } // 特殊增加支持有gradient的先判断，仅color和textStrokeColor支持


      var _isGradient = n[1] === GRADIENT$1;

      n = n[0];
      p = p[0];

      if (_isGradient) {
        var _r = calDiffGradient(p, n, target);

        if (!_r) {
          return;
        }

        res[1] = _r;
      } else {
        // 透明变化无视
        if (equalArr$2(n, p) || n[3] === 0 && p[3] === 0) {
          return;
        }

        res[1] = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3] - p[3]];
      }
    } else if (RADIUS_HASH$2.hasOwnProperty(k)) {
      // x/y都相等无需
      if (n[0][0] === p[0][0] && n[0][1] === p[0][1] && n[1][0] === p[1][0] && n[1][1] === p[1][1]) {
        return;
      }

      res[1] = [];

      for (var _i7 = 0; _i7 < 2; _i7++) {
        if (n[_i7][1] === p[_i7][1]) {
          res[1].push(n[_i7][0] - p[_i7][0]);
        } else {
          var _v9 = calByUnit(p[_i7], n[_i7], target[_i7 ? 'outerHeight' : 'outerWidth'], target.root);

          res[1].push(_v9 || 0);
        }
      }
    } else if (LENGTH_HASH$2.hasOwnProperty(k)) {
      // auto不做动画
      if (p[1] === AUTO$2 || n[1] === AUTO$2) {
        return;
      }

      var computedStyle = target.computedStyle;
      var parentComputedStyle = (target.domParent || target).computedStyle;
      var diff = 0;

      if (p[1] === n[1]) {
        diff = n[0] - p[0];
      } // lineHeight奇怪的单位变化，%相对于fontSize
      else if (k === LINE_HEIGHT$4) {
        diff = calByUnit(p, n, computedStyle[FONT_SIZE$8], target.root);
      } // fontSize的%相对于parent的
      else if (k === FONT_SIZE$8) {
        diff = calByUnit(p, n, parentComputedStyle[FONT_SIZE$8], target.root);
      } // 相对于父height的特殊属性
      else if (k === FLEX_BASIS$1 && ['column', 'column-reverse', 'columnReverse'].indexOf(computedStyle[FLEX_DIRECTION$1]) > -1 || [HEIGHT$3, TOP, BOTTOM].indexOf(k) > -1) {
        if (p[1] !== AUTO$2 && n[1] !== AUTO$2) {
          diff = calByUnit(p, n, parentComputedStyle[HEIGHT$3], target.root);
        }
      } // 其余都是相对于父width的
      else {
        if (p[1] !== AUTO$2 && n[1] !== AUTO$2) {
          diff = calByUnit(p, n, parentComputedStyle[WIDTH$3], target.root);
        }
      } // 兜底NaN非法


      if (diff === 0 || isNaN(diff)) {
        return;
      }

      res[1] = diff;
    } else if (GEOM$3.hasOwnProperty(k)) {
      if (isNil$5(p)) {
        return;
      } else if (GEOM$3[k][tagName] && isFunction$4(GEOM$3[k][tagName].calDiff)) {
        var fn = GEOM$3[k][tagName].calDiff;

        if (target.isMulti) {
          var arr = [];

          for (var _i8 = 0, _len2 = Math.min(p.length, n.length); _i8 < _len2; _i8++) {
            arr.push(fn(p[_i8], n[_i8]));
          }

          return arr;
        } else {
          res[1] = fn(p, n);
        }
      } // 特殊处理multi
      else if (target.isMulti) {
        if (k === 'points' || k === 'controls') {
          if (isNil$5(n) || !n.length || isNil$5(p) || !p.length || equalArr$2(p, n)) {
            return;
          }

          res[1] = [];

          for (var _i9 = 0, _len3 = Math.min(p.length, n.length); _i9 < _len3; _i9++) {
            var _pv = p[_i9];
            var _nv = n[_i9];

            if (isNil$5(_pv) || !_pv.length || isNil$5(_nv) || !_nv.length) {
              res[1].push(null);
            } else {
              var _v10 = [];

              for (var _j3 = 0, len2 = Math.min(_pv.length, _nv.length); _j3 < len2; _j3++) {
                var pv2 = _pv[_j3];
                var nv2 = _nv[_j3];

                if (isNil$5(pv2) || isNil$5(nv2)) {
                  _v10.push(null);
                } else {
                  var v3 = [];

                  for (var _k3 = 0, len3 = Math.max(pv2.length, nv2.length); _k3 < len3; _k3++) {
                    var pv3 = pv2[_k3];
                    var nv3 = nv2[_k3]; // control由4点变2点

                    if (isNil$5(pv3) || isNil$5(nv3)) {
                      v3.push(0);
                    } else {
                      v3.push(nv3 - pv3);
                    }
                  }

                  _v10.push(v3);
                }
              }

              res[1].push(_v10);
            }
          }
        } else if (k === 'controlA' || k === 'controlB') {
          if (isNil$5(n) || !n.length || isNil$5(p) || !p.length || equalArr$2(p, n)) {
            return;
          }

          res[1] = [];

          for (var _i10 = 0, _len4 = Math.min(p.length, n.length); _i10 < _len4; _i10++) {
            var _pv2 = p[_i10];
            var _nv2 = n[_i10];

            if (isNil$5(_pv2) || !_pv2.length || isNil$5(_nv2) || !_nv2.length) {
              res[1].push(null);
            } else {
              res[1].push([_nv2[0] - _pv2[0], _nv2[1] - _pv2[1]]);
            }
          }
        } else {
          if (n === p || equalArr$2(n, p) || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
            return;
          }

          var _v11 = [];

          for (var _i11 = 0, _len5 = Math.min(p.length, n.length); _i11 < _len5; _i11++) {
            var _pv3 = p[_i11];
            var _nv3 = n[_i11];

            if (isNil$5(_pv3) || isNil$5(_nv3)) {
              _v11.push(0);
            }

            _v11.push(_nv3 - _pv3);
          }

          res[1] = _v11;
        }
      } // 非multi特殊处理这几类数组类型数据
      else if (k === 'points' || k === 'controls') {
        if (isNil$5(n) || !n.length || isNil$5(p) || !p.length || equalArr$2(p, n)) {
          return;
        }

        res[1] = [];

        for (var _i12 = 0, _len6 = Math.min(p.length, n.length); _i12 < _len6; _i12++) {
          var _pv4 = p[_i12];
          var _nv4 = n[_i12];

          if (isNil$5(_pv4) || !_pv4.length || isNil$5(_nv4) || !_nv4.length) {
            res[1].push(null);
          } else {
            var _v12 = [];

            for (var _j4 = 0, _len7 = Math.max(_pv4.length, _nv4.length); _j4 < _len7; _j4++) {
              var _pv5 = _pv4[_j4];
              var _nv5 = _nv4[_j4]; // control由4点变2点

              if (isNil$5(_pv5) || isNil$5(_nv5)) {
                _v12.push(0);
              } else {
                _v12.push(_nv5 - _pv5);
              }
            }

            res[1].push(_v12);
          }
        }
      } else if (k === 'controlA' || k === 'controlB') {
        if (isNil$5(n) || !n.length || isNil$5(p) || !p.length || equalArr$2(p, n)) {
          return;
        }

        res[1] = [n[0] - p[0], n[1] - p[1]];
      } // 其它简单数据，除了edge/closure/booleanOperations没有增量
      else {
        if (n === p || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
          return;
        } else {
          res[1] = n - p;
        }
      }
    } else if (k === OPACITY$2 || k === Z_INDEX$1) {
      if (n === p) {
        return;
      }

      res[1] = n - p;
    } // 特殊的path，不存在style中但在动画某帧中，不会统一化所以可能反向计算frameR时后一帧没有
    else if (k === TRANSLATE_PATH$1 && p) {
      var k1 = 'offsetWidth',
          _k4 = 'offsetHeight';

      if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
        k1 = 'clientWidth';
        _k4 = 'clientHeight';
      } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
        k1 = 'width';
        _k4 = 'height';
      }

      res[1] = p.map(function (item, i) {
        var _item = _slicedToArray(item, 2),
            v = _item[0],
            u = _item[1];

        if (u === PERCENT$4) {
          if (i % 2 === 0) {
            return [(parseFloat(v) || 0) * 0.01 * target[k1], PX$3];
          } else {
            return [(parseFloat(v) || 0) * 0.01 * target[_k4], PX$3];
          }
        } else if (u === REM$4) {
          return [(parseFloat(v) || 0) * root.computedStyle[FONT_SIZE$8] * 100, PX$3];
        } else if (u === VW$4) {
          return [(parseFloat(v) || 0) * 0.01 * root.width, PX$3];
        } else if (u === VH$4) {
          return [(parseFloat(v) || 0) * 0.01 * root.height, PX$3];
        } else if (u === VMAX$4) {
          return [(parseFloat(v) || 0) * 0.01 * Math.max(root.width, root.height), PX$3];
        } else if (u === VMIN$4) {
          return [(parseFloat(v) || 0) * 0.01 * Math.min(root.width, root.height), PX$3];
        } else {
          return [parseFloat(v) || 0, PX$3];
        }
      });
    } // display等不能有增量过程的
    else {
      return;
    }

    return res;
  } // 渐变的差异计算


  function calDiffGradient(p, n, target) {
    if (p.k !== n.k || !GRADIENT_TYPE$2.hasOwnProperty(p.k)) {
      return;
    }

    var pv = p.v;
    var nv = n.v;
    var temp = [[]];
    var eq = equalArr$2(pv, nv); // 渐变值部分是通用的

    for (var i = 0, len = Math.min(pv.length, nv.length); i < len; i++) {
      var a = pv[i];
      var b = nv[i];
      var t = [];
      t.push([b[0][0] - a[0][0], b[0][1] - a[0][1], b[0][2] - a[0][2], b[0][3] - a[0][3]]);

      if (a[1] && b[1]) {
        if (a[1][1] === b[1][1]) {
          t.push(b[1][0] - a[1][0]);
        } else {
          var v = calByUnit(a[1], b[1], target.clientWidth, target.root);
          t.push(v || 0);
        }
      }

      temp[0].push(t);
    }

    if (p.k === 'linear') {
      var isArrP = Array.isArray(p.d);
      var isArrN = Array.isArray(n.d);

      if (isArrN !== isArrP) {
        return;
      }

      if (isArrP) {
        var _v13 = [n.d[0] - p.d[0], n.d[1] - p.d[1], n.d[2] - p.d[2], n.d[3] - p.d[3]];

        if (eq && equalArr$2(_v13, [0, 0, 0, 0])) {
          return;
        }

        temp[1] = _v13;
      } else {
        var _v14 = n.d - p.d; // 颜色角度都没变化


        if (eq && _v14 === 0) {
          return;
        }

        temp[1] = _v14;
      }
    } else if (p.k === 'radial') {
      var _isArrP = Array.isArray(p.z);

      var _isArrN = Array.isArray(n.z);

      if (_isArrN !== _isArrP) {
        return;
      }

      temp[2] = []; // sketch中a点到b点特殊格式表达，z是数组忽略p和s

      if (_isArrP) {
        // 距离中心外形全等
        if (eq && equalArr$2(p.z, n.z)) {
          return;
        }

        for (var _i13 = 0; _i13 < 5; _i13++) {
          var pz = p.z[_i13]; // 半径比例省略为1

          if (pz === undefined) {
            pz = 1;
          }

          var nz = n.z[_i13];

          if (nz === undefined) {
            nz = 1;
          }

          temp[2].push(nz - pz);
        }
      } else {
        if (eq && p.z === n.z && p.s === n.s && equalArr$2(p.p, n.p)) {
          return;
        }

        for (var _i14 = 0; _i14 < 2; _i14++) {
          var pp = p.p[_i14];
          var np = n.p[_i14];

          if (pp[1] === np[1]) {
            temp[2].push(np[0] - pp[0]);
          } else {
            var _v15 = calByUnit(pp, np, target[_i14 ? 'clientWidth' : 'clientHeight'], target.root);

            temp[2].push(_v15 || 0);
          }
        }
      }
    } else if (p.k === 'conic') {
      if (eq && p.d === n.d && equalArr$2(p.p, n.p)) {
        return;
      }

      temp[1] = n.d - p.d;
      temp[2] = [];

      for (var _i15 = 0; _i15 < 2; _i15++) {
        var _pp = p.p[_i15];
        var _np = n.p[_i15];

        if (_pp[1] === _np[1]) {
          temp[2].push(_np[0] - _pp[0]);
        } else {
          var _v16 = calByUnit(_pp, _np, target[_i15 ? 'clientWidth' : 'clientHeight'], target.root);

          temp[2].push(_v16 || 0);
        }
      }
    }

    return temp;
  } // 计算两帧之间不相同的变化，存入transition，相同的忽略


  function calFrame(prev, next, keys, target, tagName) {
    keys.forEach(function (k) {
      var ts = calDiff(prev[FRAME_STYLE], next[FRAME_STYLE], k, target, tagName); // 可以形成过渡的才会产生结果返回

      if (ts) {
        prev[FRAME_TRANSITION].push(ts);
      }
    });
    return next;
  }

  function binarySearch(i, j, time, frames) {
    if (i === j) {
      var _frame = frames[i];

      if (_frame[FRAME_TIME] > time) {
        return i - 1;
      }

      return i;
    } else {
      var middle = i + (j - i >> 1);
      var _frame2 = frames[middle];

      if (_frame2[FRAME_TIME] === time) {
        return middle;
      } else if (_frame2[FRAME_TIME] > time) {
        return binarySearch(i, Math.max(middle - 1, i), time, frames);
      } else {
        return binarySearch(Math.min(middle + 1, j), j, time, frames);
      }
    }
  }

  function getEasing(ea) {
    var timingFunction;

    if (ea) {
      if (timingFunction = /^\s*steps\s*\(\s*(\d+)(?:\s*,\s*(\w+))?\s*\)/i.exec(ea)) {
        var steps = parseInt(timingFunction[1]);
        var stepsD = timingFunction[2];

        timingFunction = function timingFunction(percent) {
          // steps有效定义正整数
          if (steps && steps > 0) {
            var per = 1 / steps;
            var n = stepsD === 'start' ? Math.ceil(percent / per) : Math.floor(percent / per);
            return n / steps;
          }

          return percent;
        };
      } else {
        timingFunction = easing.getEasing(ea);
      }
    }

    return timingFunction;
  }
  /**
   * 根据百分比和缓动函数计算中间态样式
   * 当easing定义为steps时，优先计算
   * @param frame 当前帧
   * @param keys 所有样式key
   * @param percent 到下一帧时间的百分比
   * @param target vd
   * @returns {*}
   */


  function calIntermediateStyle(frame, keys, percent, target) {
    var style = cloneStyle$1(frame[FRAME_STYLE], keys);
    var timingFunction = getEasing(frame[FRAME_EASING]);

    if (timingFunction && timingFunction !== linear) {
      percent = timingFunction(percent);
    }

    var transition = frame[FRAME_TRANSITION];

    var _loop = function _loop(i, len) {
      var _transition$i = _slicedToArray(transition[i], 2),
          k = _transition$i[0],
          v = _transition$i[1];

      var st = style[k]; // transform特殊处理，只有1个matrix，有可能不存在，需给默认矩阵

      if (k === TRANSFORM$2) {
        if (!st) {
          st = style[k] = [[MATRIX$2, mx.identity()]];
        }

        for (var _i16 = 0; _i16 < 16; _i16++) {
          st[0][1][_i16] += v[_i16] * percent;
        }
      } // 特殊的曲线运动计算，转换为translateXY，出现在最后一定会覆盖原本的translate防重
      else if (k === TRANSLATE_PATH$1) {
        var t = 1 - percent;

        if (v.length === 8) {
          style[TRANSLATE_X$3] = [v[0][0] * t * t * t + 3 * v[2][0] * percent * t * t + 3 * v[4][0] * percent * percent * t + v[6][0] * percent * percent * percent, PX$3];
          style[TRANSLATE_Y$3] = [v[1][0] * t * t * t + 3 * v[3][0] * percent * t * t + 3 * v[5][0] * percent * percent * t + v[7][0] * percent * percent * percent, PX$3];
        } else if (v.length === 6) {
          style[TRANSLATE_X$3] = [v[0][0] * t * t + 2 * v[2][0] * percent * t + v[4][0] * percent * percent, PX$3];
          style[TRANSLATE_Y$3] = [v[1][0] * t * t + 3 * v[3][0] * percent * t + v[5][0] * percent * percent, PX$3];
        }
      } else if (k === ROTATE_3D$2) {
        st[0] += v[0] * percent;
        st[1] += v[1] * percent;
        st[2] += v[2] * percent;
        st[3][0] += v[3][0] * percent;
      } else if (NUM_CAL_HASH.hasOwnProperty(k)) {
        if (v) {
          st[0] += v * percent;
        }
      } else if (k === FILTER$3) {
        // 只有1个样式声明了filter另外一个为空，会造成无样式，需初始化数组并在下面计算出样式存入
        if (!st) {
          st = style[k] = [];
        }

        for (var _i17 = 0, _len8 = v.length; _i17 < _len8; _i17++) {
          var item = v[_i17];

          if (item) {
            var k2 = st[_i17][0],
                v2 = st[_i17][1]; // 只有dropShadow是多个数组，存放x/y/blur/spread/color

            if (k2 === 'dropShadow') {
              v2[0][0] += item[0] * percent;
              v2[1][0] += item[1] * percent;
              v2[2][0] += item[2] * percent;
              v2[3][0] += item[3] * percent;
              var c1 = v2[4],
                  c2 = item[4];
              c1[0] += c2[0] * percent;
              c1[1] += c2[1] * percent;
              c1[2] += c2[2] * percent;
              c1[3] += c2[3] * percent;
            } // 其它都是带单位单值
            else {
              v2[0] += item * percent;
            }
          }
        }
      } else if (RADIUS_HASH$2.hasOwnProperty(k)) {
        for (var _i18 = 0; _i18 < 2; _i18++) {
          st[_i18][0] += v[_i18] * percent;
        }
      } else if (k === TRANSFORM_ORIGIN$3 || k === PERSPECTIVE_ORIGIN$2) {
        if (v[0] !== 0) {
          st[0][0] += v[0] * percent;
        }

        if (v[1] !== 0) {
          st[1][0] += v[1] * percent;
        }
      } else if (k === BOX_SHADOW$1) {
        for (var _i19 = 0, _len9 = Math.min(st.length, v.length); _i19 < _len9; _i19++) {
          // x/y/blur/spread
          for (var j = 0; j < 4; j++) {
            st[_i19][j] += v[_i19][j] * percent;
          } // rgba


          for (var _j5 = 0; _j5 < 4; _j5++) {
            st[_i19][4][_j5] += v[_i19][4][_j5] * percent;
          }
        }
      } else if (k === BACKGROUND_SIZE$1) {
        st.forEach(function (item, i) {
          if (v[i]) {
            item[0][0] += v[i][0] * percent;
            item[1][0] += v[i][1] * percent;
          }
        });
      } else if (k === BACKGROUND_POSITION_X$2 || k === BACKGROUND_POSITION_Y$2) {
        st.forEach(function (item, i) {
          if (v[i]) {
            item[0] += v[i] * percent;
          }
        });
      } else if (GRADIENT_HASH$2.hasOwnProperty(k)) {
        st.forEach(function (st2, i) {
          var v2 = v[i];

          if (!v2) {
            return;
          }

          if (st2[1] === GRADIENT$1 && GRADIENT_TYPE$2.hasOwnProperty(st2[0].k)) {
            st2 = st2[0];

            var _v17 = _slicedToArray(v2, 4),
                c = _v17[0],
                d = _v17[1],
                p = _v17[2],
                z = _v17[3];

            for (var _i20 = 0, _len10 = Math.min(st2.v.length, c.length); _i20 < _len10; _i20++) {
              var a = st2.v[_i20];
              var b = c[_i20];
              a[0][0] += b[0][0] * percent;
              a[0][1] += b[0][1] * percent;
              a[0][2] += b[0][2] * percent;
              a[0][3] += b[0][3] * percent;

              if (a[1] && b[1]) {
                a[1][0] += b[1] * percent;
              }
            }

            if (st2.k === 'linear' && st2.d !== undefined && d !== undefined) {
              if (Array.isArray(d)) {
                st2.d[0] += d[0] * percent;
                st2.d[1] += d[1] * percent;
                st2.d[2] += d[2] * percent;
                st2.d[3] += d[3] * percent;
              } else {
                st2.d += d * percent;
              }
            }

            if (st2.k === 'radial') {
              if (st2.z !== undefined && z !== undefined) {
                st2.z[0] += z[0] * percent;
                st2.z[1] += z[1] * percent;
                st2.z[2] += z[2] * percent;
                st2.z[3] += z[3] * percent;
                st2.z[4] += z[4] * percent;
              } else if (st2.p !== undefined && p !== undefined) {
                st2.p[0][0] += p[0] * percent;
                st2.p[1][0] += p[1] * percent;
              }
            } else if (st2.k === 'conic' && st2.d !== undefined && d !== undefined) {
              st2.d += d * percent;
              st2.p[0][0] += p[0] * percent;
              st2.p[1][0] += p[1] * percent;
            }
          } // fill纯色
          else {
            st2 = st2[0];
            var _c = v2[0];
            st2[0] += _c[0] * percent;
            st2[1] += _c[1] * percent;
            st2[2] += _c[2] * percent;
            st2[3] += _c[3] * percent;
          }
        });
      } // color可能超限[0,255]，但浏览器已经做了限制，无需关心
      else if (COLOR_HASH$2.hasOwnProperty(k)) {
        st = st[0];
        st[0] += v[0] * percent;
        st[1] += v[1] * percent;
        st[2] += v[2] * percent;
        st[3] += v[3] * percent;
      } else if (GEOM$3.hasOwnProperty(k)) {
        var _st = style[k];
        var tagName = target.tagName;

        if (GEOM$3[k][tagName] && isFunction$4(GEOM$3[k][tagName].calIncrease)) {
          var fn = GEOM$3[k][tagName].calIncrease;

          if (target.isMulti) {
            style[k] = _st.map(function (item, i) {
              return fn(item, v[i], percent);
            });
          } else {
            style[k] = fn(_st, v, percent);
          }
        } else if (target.isMulti) {
          if (k === 'points' || k === 'controls') {
            for (var _i21 = 0, _len11 = Math.min(_st.length, v.length); _i21 < _len11; _i21++) {
              var o = _st[_i21];
              var n = v[_i21];

              if (!isNil$5(o) && !isNil$5(n)) {
                for (var _j6 = 0, len2 = Math.min(o.length, n.length); _j6 < len2; _j6++) {
                  var o2 = o[_j6];
                  var n2 = n[_j6];

                  if (!isNil$5(o2) && !isNil$5(n2)) {
                    for (var _k5 = 0, len3 = Math.min(o2.length, n2.length); _k5 < len3; _k5++) {
                      if (!isNil$5(o2[_k5]) && !isNil$5(n2[_k5])) {
                        o2[_k5] += n2[_k5] * percent;
                      }
                    }
                  }
                }
              }
            }
          } else if (k === 'controlA' || k === 'controlB') {
            v.forEach(function (item, i) {
              var st2 = _st[i];

              if (!isNil$5(item) && !isNil$5(st2)) {
                for (var _i22 = 0, _len12 = Math.min(st2.length, item.length); _i22 < _len12; _i22++) {
                  var _o = st2[_i22];
                  var _n = item[_i22];

                  if (!isNil$5(_o) && !isNil$5(_n)) {
                    st2[_i22] += _n * percent;
                  }
                }
              }
            });
          } else {
            v.forEach(function (item, i) {
              if (!isNil$5(item) && !isNil$5(_st[i])) {
                _st[i] += item * percent;
              }
            });
          }
        } else {
          if (k === 'points' || k === 'controls') {
            for (var _i23 = 0, _len13 = Math.min(_st.length, v.length); _i23 < _len13; _i23++) {
              var _o2 = _st[_i23];
              var _n2 = v[_i23];

              if (!isNil$5(_o2) && !isNil$5(_n2)) {
                for (var _j7 = 0, _len14 = Math.min(_o2.length, _n2.length); _j7 < _len14; _j7++) {
                  if (!isNil$5(_o2[_j7]) && !isNil$5(_n2[_j7])) {
                    _o2[_j7] += _n2[_j7] * percent;
                  }
                }
              }
            }
          } else if (k === 'controlA' || k === 'controlB') {
            if (!isNil$5(_st[0]) && !isNil$5(v[0])) {
              _st[0] += v[0] * percent;
            }

            if (!isNil$5(_st[1]) && !isNil$5(v[1])) {
              _st[1] += v[1] * percent;
            }
          } else {
            if (!isNil$5(_st) && !isNil$5(v)) {
              style[k] += v * percent;
            }
          }
        }
      } else if (k === OPACITY$2 || k === Z_INDEX$1) {
        style[k] += v * percent; // 精度问题可能会超过[0,1]区间

        if (k === OPACITY$2) {
          if (style[k] < 0) {
            style[k] = 0;
          } else if (style[k] > 1) {
            style[k] = 1;
          }
        }
      }
    };

    for (var i = 0, len = transition.length; i < len; i++) {
      _loop(i);
    }

    return style;
  }

  function gotoOverload(options, cb) {
    if (isFunction$4(options)) {
      cb = options;
      options = {};
    }

    return [options || {}, cb];
  }

  function calDiffTime(__config, diff) {
    var playbackRate = __config[I_PLAYBACK_RATE];
    var spfLimit = __config[I_SPF_LIMIT];
    var fps = __config[I_FPS];
    var v = __config[I_CURRENT_TIME] = __config[I_NEXT_TIME]; // 定帧限制每帧时间间隔最大为spf

    if (spfLimit) {
      if (spfLimit === true) {
        diff = Math.min(diff, 1000 / fps);
      } else if (spfLimit > 0) {
        diff = Math.min(diff, spfLimit);
      }
    } // 播放时间累加，并且考虑播放速度加成


    if (playbackRate !== 1 && playbackRate > 0) {
      diff *= playbackRate;
    }

    __config[I_NEXT_TIME] += diff;
    return [v, diff];
  }

  function frameCb(self, __config, diff, isDelay) {
    self.emit(Event.FRAME, diff, isDelay);

    if (__config[I_FIRST_PLAY]) {
      __config[I_FIRST_PLAY] = false;
      self.emit(Event.PLAY);
    }

    var cb = __config[I_PLAY_CB];

    if (isFunction$4(cb)) {
      cb.call(self, diff, isDelay); // 清理要检查，gotoAndStop()这种cb回调中直接再次调用goto的话cb会不一致不能删除

      if (__config[I_PLAY_CB] === cb) {
        __config[I_PLAY_CB] = null;
      }
    }
  }

  var uuid$1 = 0;

  var Animation = /*#__PURE__*/function (_Event) {
    _inherits(Animation, _Event);

    var _super = _createSuper(Animation);

    function Animation(target, list, options) {
      var _this;

      _classCallCheck(this, Animation);

      _this = _super.call(this);
      _this.__id = uuid$1++;
      list = clone$3(list || []);

      if (Array.isArray(list)) {
        list = list.filter(function (item) {
          return item && isObject$1(item);
        });
      } // 动画过程另外一种形式，object描述k-v形式
      else if (list && isObject$1(list)) {
        var nl = [];
        Object.keys(list).forEach(function (k) {
          var v = list[k];

          if (Array.isArray(v)) {
            for (var i = 0, len = v.length; i < len; i++) {
              var o = nl[i] = nl[i] || {
                offset: i / (len - 1)
              };
              o[k] = v[i];
            }
          }
        });
        list = nl;
      } else {
        list = [];
      }

      if (isNumber$1(options)) {
        _this.__options = {
          duration: options
        };
        options = _this.__options;
      }

      var op = _this.__options = options || {
        duration: 0
      };
      var root = target.root;
      var config = _this.__config = [false, // assigning
      false, // inFps
      false, // isDelay
      true, // begin
      false, // end
      false, // finished
      false, // nextBegin
      true, // firstPlay
      null, // playCb
      target, root, null, // frames
      null, // framesR
      0, // currentTime
      0, // nextTime
      {}, // style
      0, // duration
      1, // iterations
      'none', // fill
      1, // playbackRate
      0, // playCount
      'idle', false, // destroy
      0, // startTime
      0, // fpsTime
      op.easing, false, // enterFrame
      0, // delay
      0, // endDelay
      null, // keys,
      null, // originStyle,
      null, // currentFrames
      null, // currentFrame
      false, // spfLimit
      60, // fps
      'normal', // direction
      true, // firstEnter,
      false, // stayBegin
      false, // stayEnd
      false, // is2
      0, // endTime
      target.__config, // nodeConfig
      root && root.__config, // rootConfig，destroy后root可能为空
      false // outBeginDelay
      ];
      var iterations = _this.iterations = op.iterations;
      var duration = _this.duration = op.duration;

      var _this$__init = _this.__init(list, iterations, duration, op.easing, target),
          _this$__init2 = _slicedToArray(_this$__init, 4),
          frames = _this$__init2[0],
          framesR = _this$__init2[1],
          keys = _this$__init2[2],
          originStyle = _this$__init2[3];

      config[I_FRAMES] = frames;
      config[I_FRAMES_R] = framesR;
      config[I_KEYS] = keys;
      config[I_ORIGIN_STYLE] = originStyle;

      if (frames.length === 2) {
        config[I_IS2] = true;
        config[I_END_TIME] = frames[1][FRAME_TIME];
      }

      var fps = parseInt(op.fps) || 0;

      if (fps <= 0) {
        fps = 60;
      }

      _this.fps = fps;
      _this.spfLimit = op.spfLimit;
      _this.delay = op.delay;
      _this.endDelay = op.endDelay;
      _this.playbackRate = op.playbackRate;
      _this.fill = op.fill;
      _this.iterations = op.iterations;
      _this.direction = op.direction;
      config[I_CURRENT_FRAMES] = {
        reverse: true,
        'alternate-reverse': true
      }.hasOwnProperty(op.direction) ? framesR : frames; // 时间戳

      config[I_TIME_STAMP] = frame.__now; // 性能优化访问

      _this[0] = _this.__before;
      _this[1] = _this.__after;
      return _this;
    }

    _createClass(Animation, [{
      key: "__init",
      value: function __init(list, iterations, duration, easing, target) {
        if (list.length < 1) {
          return [[], [], [], {}];
        } // 过滤时间非法的，过滤后续offset<=前面的


        var offset = -1;
        var tagName = target.tagName;

        var _loop2 = function _loop2(_i24, _len15) {
          var current = list[_i24];

          if (current.hasOwnProperty('offset')) {
            current.offset = parseFloat(current.offset) || 0;
            current.offset = Math.max(0, current.offset);
            current.offset = Math.min(1, current.offset); // 超过区间[0,1]

            if (isNaN(current.offset) || current.offset < 0 || current.offset > 1) {
              list.splice(_i24, 1);
              _i24--;
              _len15--;
              i = _i24;
              len = _len15;
              return "continue";
            } // <=前面的
            else if (current.offset <= offset) {
              list.splice(_i24, 1);
              _i24--;
              _len15--;
              i = _i24;
              len = _len15;
              return "continue";
            }
          } // 缩写处理


          Object.keys(current).forEach(function (k) {
            if (abbr.hasOwnProperty(k)) {
              abbr.toFull(current, k);
            }
          }); // 检查key合法性

          Object.keys(current).forEach(function (k) {
            if (k !== 'easing' && k !== 'offset' && !o$2.isValid(tagName, k)) {
              delete current[k];
            }
          });
          i = _i24;
          len = _len15;
        };

        for (var i = 0, len = list.length; i < len; i++) {
          var _ret = _loop2(i, len);

          if (_ret === "continue") continue;
        } // 只有1帧复制出来变成2帧方便运行


        if (list.length === 1) {
          list[0] = clone$3(list[0]);

          if (list[0].offset === 1) {
            list.unshift({
              offset: 0
            });
          } else {
            var copy = clone$3(list[0]);
            copy.offset = 1;
            list.push(copy);
          }
        } // 强制clone防止同引用
        else {
          list.forEach(function (item, i) {
            list[i] = clone$3(item);
          });
        } // 首尾时间偏移强制为[0, 1]，不是的话前后加空帧


        var first = list[0];

        if (first.hasOwnProperty('offset') && first.offset > 0) {
          first = {
            offset: 0
          };
          list.unshift(first);
        } else {
          first.offset = 0;
        }

        var last = list[list.length - 1];

        if (last.hasOwnProperty('offset') && last.offset < 1) {
          last = {
            offset: 1
          };
          list.push(last);
        } else {
          last.offset = 1;
        } // 计算没有设置offset的时间


        for (var _i25 = 1, _len16 = list.length; _i25 < _len16; _i25++) {
          var start = list[_i25]; // 从i=1开始offset一定>0，找到下一个有offset的，均分中间无声明的

          if (!start.hasOwnProperty('offset')) {
            var end = void 0;
            var j = _i25 + 1;

            for (; j < _len16; j++) {
              end = list[j];

              if (end.hasOwnProperty('offset')) {
                break;
              }
            }

            var num = j - _i25 + 1;
            start = list[_i25 - 1];
            var per = (end.offset - start.offset) / num;

            for (var k = _i25; k < j; k++) {
              var item = list[k];
              item.offset = start.offset + per * (k + 1 - _i25);
            }

            _i25 = j;
          }
        }

        var frames = []; // 换算每一关键帧样式标准化

        list.forEach(function (item) {
          frames.push(framing(item, duration, easing));
        }); // 为方便两帧之间计算变化，强制统一所有帧的css属性相同，没有写的为节点的当前样式currentStyle

        var keys = unify(frames, target);
        inherit(frames, keys, target);
        var framesR = clone$3(frames).reverse(); // 存储原本样式以便恢复用

        var style = target.style,
            props = target.props;
        var originStyle = {};
        keys.forEach(function (k) {
          if (isGeom$1(tagName, k)) {
            originStyle[k] = props[k];
          }

          originStyle[k] = style[k];
        }); // 再计算两帧之间的变化，存入transition属性

        var length = frames.length;
        var prev = frames[0];

        for (var _i26 = 1; _i26 < length; _i26++) {
          var next = frames[_i26];
          prev = calFrame(prev, next, keys, target, tagName);
        } // 反向存储帧的倒排结果


        framesR.forEach(function (item) {
          item[FRAME_TIME] = duration - item[FRAME_TIME];
          item[FRAME_TRANSITION] = [];
        });
        prev = framesR[0];

        for (var _i27 = 1; _i27 < length; _i27++) {
          var _next = framesR[_i27];
          prev = calFrame(prev, _next, keys, target, tagName);
        }

        return [frames, framesR, keys, originStyle];
      }
    }, {
      key: "__clean",
      value: function __clean(isFinish) {
        var __config = this.__config;

        this.__cancelTask();

        __config[I_NEXT_TIME] = 0;
        var restore;
        var style = __config[I_STYLE];
        var keys = __config[I_KEYS];
        var target = __config[I_TARGET];

        if (isFinish) {
          // gotoAndStop到一个很大的时间的话，也需要防止超过
          __config[I_CURRENT_TIME] = __config[I_DELAY] + __config[I_DURATION] * __config[I_ITERATIONS] + __config[I_END_DELAY];

          if (__config[I_PLAY_STATE] === 'finish') {
            return;
          }

          __config[I_PLAY_STATE] = 'finish'; // cancel需要清除finish根据情况保留

          if (!__config[I_STAY_END]) {
            __config[I_STYLE] = {};
            restore = true;
          }
        } else {
          __config[I_PLAY_COUNT] = __config[I_CURRENT_TIME] = 0;

          if (__config[I_PLAY_STATE] === 'idle') {
            return;
          }

          __config[I_PLAY_STATE] = 'idle';
          __config[I_STYLE] = {};
          restore = true;
        } // 动画取消结束不停留在最后一帧需要还原target原本的样式，需要对比目前是否是由本动画赋值的


        if (restore) {
          keys.forEach(function (k) {
            if (GEOM$3.hasOwnProperty(k)) {
              if (target.__currentProps[k] === style[k]) {
                target.__currentProps[k] = target.props[k];
              }
            } else {
              if (target.__currentStyle[k] === style[k]) {
                target.__currentStyle[k] = target.style[k];
              }
            }
          });
        }
      }
    }, {
      key: "play",
      value: function play(cb) {
        var __config = this.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var playState = __config[I_PLAY_STATE];
        var frames = __config[I_FRAMES];

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'running') {
          return this;
        }

        this.__cancelTask();

        __config[I_PLAY_CB] = cb;
        __config[I_PLAY_STATE] = 'running'; // 每次play调用标识第一次运行，需响应play事件和回调

        __config[I_FIRST_PLAY] = true; // 防止finish/cancel事件重复触发，每次播放重置

        this.__hasFin = false;
        this.__hasCancel = false; // 只有第一次调用会进初始化，另外finish/cancel视为销毁也会重新初始化

        if (!__config[I_ENTER_FRAME]) {
          __config[I_ENTER_FRAME] = true;
          var framesR = __config[I_FRAMES_R];
          var direction = __config[I_DIRECTION]; // 初始化根据方向确定帧序列

          __config[I_CURRENT_FRAMES] = {
            reverse: true,
            'alternate-reverse': true
          }.hasOwnProperty(direction) ? framesR : frames;
          __config[I_CURRENT_TIME] = __config[I_NEXT_TIME] = __config[I_FPS_TIME] = 0;
        } // 添加每帧回调且立刻执行，本次执行调用refreshTask也是下一帧再渲染，frame的每帧都是下一帧
        // frame.offFrame(this);


        frame.onFrame(this);
        __config[I_START_TIME] = frame.__now;
        __config[I_END] = false;
        return this;
      }
    }, {
      key: "__before",
      value: function __before(diff) {
        var __config = this.__config;
        __config[I_TIME_STAMP] = frame.__now;
        var target = __config[I_TARGET];
        var fps = __config[I_FPS];
        var playCount = 0;
        var currentFrames = __config[I_CURRENT_FRAMES];
        var iterations = __config[I_ITERATIONS];
        var stayBegin = __config[I_STAY_BEGIN];
        var stayEnd = __config[I_STAY_END];
        var delay = __config[I_DELAY];
        var root = __config[I_ROOT];
        var is2 = __config[I_IS2];
        var endTime = __config[I_END_TIME];
        var duration = __config[I_DURATION];
        var endDelay = __config[I_END_DELAY];
        var length = currentFrames.length; // 用本帧和上帧时间差，计算累加运行时间currentTime，以便定位当前应该处于哪个时刻

        var _calDiffTime = calDiffTime(__config, diff),
            _calDiffTime2 = _slicedToArray(_calDiffTime, 2),
            currentTime = _calDiffTime2[0],
            d = _calDiffTime2[1];

        diff = d; // 增加的fps功能，当<60时计算跳帧，每帧运行依旧累加时间，达到fps时重置，第一帧强制不跳

        if (!__config[I_FIRST_ENTER] && fps < 60) {
          diff = __config[I_FPS_TIME] += diff;

          if (diff < 1000 / fps) {
            __config[I_IN_FPS] = true;
            return;
          }

          __config[I_FPS_TIME] = 0;
        }

        __config[I_FIRST_ENTER] = false; // delay仅第一次生效等待

        if (currentTime < delay) {
          if (stayBegin) {
            var _currentFrame = __config[I_CURRENT_FRAME] = currentFrames[0];

            var _current = _currentFrame[FRAME_STYLE];
            genBeforeRefresh(_current, __config[I_KEYS], __config, root, target);
          }

          __config[I_BEGIN] = false; // 默认是true，delay置false防触发
          // 即便不刷新，依旧执行帧回调，同时标明让后续第一帧响应begin

          __config[I_OUT_BEGIN_DELAY] = true;
          __config[I_IS_DELAY] = true;
          return;
        } // 减去delay，计算在哪一帧


        currentTime -= delay;

        if (__config[I_OUT_BEGIN_DELAY]) {
          __config[I_OUT_BEGIN_DELAY] = false;
          __config[I_BEGIN] = true;
        } // 超过duration非尾轮需处理回到开头，触发新一轮动画事件，这里可能时间间隔非常大直接跳过几轮


        var round;

        while (currentTime >= duration && playCount < iterations - 1) {
          currentTime -= duration;
          playCount++;
        }

        if (__config[I_PLAY_COUNT] < playCount) {
          __config[I_BEGIN] = true;
          round = true;
        }

        __config[I_PLAY_COUNT] = playCount; // 如果发生轮换，需重新确定正反向

        if (round) {
          var direction = __config[I_DIRECTION];
          var frames = __config[I_FRAMES];
          var framesR = __config[I_FRAMES_R];
          var isAlternate = {
            alternate: true,
            'alternate-reverse': true
          }.hasOwnProperty(direction); // 有正反向播放需要重设帧序列

          if (isAlternate) {
            var isEven = playCount % 2 === 0;

            if (direction === 'alternate') {
              currentFrames = __config[I_CURRENT_FRAMES] = isEven ? frames : framesR;
            } else {
              currentFrames = __config[I_CURRENT_FRAMES] = isEven ? framesR : frames;
            }
          }
        }

        var isLastCount = playCount >= iterations - 1; // 只有2帧可优化，否则2分查找当前帧

        var i, frameTime;

        if (is2) {
          i = currentTime < endTime ? 0 : 1;
          frameTime = endTime;
        } else {
          i = binarySearch(0, length - 1, currentTime, currentFrames);
          frameTime = currentFrames[i][FRAME_TIME];
        } // 最后一帧结束动画，仅最后一轮才会进入，需处理endDelay


        var isLastFrame = isLastCount && i === length - 1;
        var percent = 0;

        if (isLastFrame) ; // 否则根据目前到下一帧的时间差，计算百分比，再反馈到变化数值上
        else if (is2) {
          percent = currentTime / duration;
        } else {
          var total = currentFrames[i + 1][FRAME_TIME] - frameTime;
          percent = (currentTime - frameTime) / total;
        }

        var inEndDelay,
            currentFrame = currentFrames[i],
            current;
        __config[I_CURRENT_FRAME] = currentFrame;
        /** 这里要考虑全几种场景：
         * 1. 单次播放无endDelay且fill不停留（有/无差异，下同）
         * 2. 单次播放无endDelay且fill停留
         * 3. 单次播放有endDelay且fill不停留
         * 4. 单次播放有endDelay且fill停留
         * 5. 多次播放无endDelay且fill不停留（尾次/非尾次，下同）
         * 6. 多次播放无endDelay且fill停留
         * 7. 多次播放有endDelay且fill不停留
         * 8. 多次播放有endDelay且fill停留
         */

        var needClean;

        if (isLastFrame) {
          inEndDelay = currentTime < duration + endDelay; // 停留对比最后一帧，endDelay可能会多次进入这里，第二次进入样式相等不再重绘

          if (stayEnd) {
            current = cloneStyle$1(currentFrame[FRAME_STYLE], __config[I_KEYS]);
          } // 不停留或超过endDelay则计算还原，有endDelay且fill模式不停留会再次进入这里
          else {
            current = cloneStyle$1(__config[I_ORIGIN_STYLE], __config[I_KEYS]);
          } // 进入endDelay或结束阶段触发end事件，注意只触发一次，防重在触发的地方做


          __config[I_NEXT_END] = true;

          if (!inEndDelay) {
            __config[I_PLAY_COUNT]++;
            __config[I_FINISHED] = true;
            frame.offFrame(this);
            needClean = true;
            __config[I_NEXT_TIME] = 0;
          }
        } else {
          current = calIntermediateStyle(currentFrame, __config[I_KEYS], percent, target);
        } // 无论两帧之间是否有变化，都生成计算结果赋给style，去重在root做


        genBeforeRefresh(current, __config[I_KEYS], __config, root, target);

        if (needClean) {
          var playCb = __config[I_PLAY_CB];

          this.__clean(true); // 丑陋的做法，防止gotoAndStop()这样的cb被clean()掉


          if (playCb) {
            __config[I_PLAY_CB] = playCb;
          }
        }
      }
    }, {
      key: "__after",
      value: function __after(diff) {
        var __config = this.__config;
        __config[I_ASSIGNING] = false;

        if (__config[I_IN_FPS]) {
          __config[I_IN_FPS] = false;
          return;
        }

        frameCb(this, __config, diff, __config[I_IS_DELAY]);
        __config[I_IS_DELAY] = false;

        if (__config[I_BEGIN]) {
          __config[I_BEGIN] = false;
          this.emit(Event.BEGIN, __config[I_PLAY_COUNT]);
        } // end事件只触发一次，末轮进入endDelay或直接结束时


        if (__config[I_NEXT_END] && !__config[I_END]) {
          __config[I_END] = true;
          this.emit(Event.END, __config[I_PLAY_COUNT] - 1);
        }

        if (__config[I_FINISHED]) {
          __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
          __config[I_PLAY_STATE] = 'finished';
          this.emit(Event.FINISH);
        }
      }
    }, {
      key: "pause",
      value: function pause(silence) {
        var __config = this.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var pending = this.pending;

        if (isDestroyed || duration <= 0 || pending) {
          return this;
        }

        __config[I_PLAY_STATE] = 'paused';

        this.__cancelTask();

        if (!silence) {
          this.emit(Event.PAUSE);
        }

        return this;
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var __config = this.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var playState = __config[I_PLAY_STATE];

        if (isDestroyed || duration <= 0 || playState !== 'paused') {
          return this;
        }

        return this.play(cb);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        var self = this;
        var __config = self.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var playState = __config[I_PLAY_STATE];
        var frames = __config[I_FRAMES];

        if (isDestroyed || duration <= 0 || frames.length < 1 || playState === 'finished' || playState === 'idle') {
          return self;
        } // 先清除所有回调任务，多次调用finish也会清除只留最后一次


        self.__cancelTask();

        var root = __config[I_ROOT];
        var originStyle = __config[I_ORIGIN_STYLE];

        if (root) {
          var current; // 停留在最后一帧

          if (__config[I_STAY_END]) {
            __config[I_CURRENT_FRAME] = frames[frames.length - 1];
            current = frames[frames.length - 1][FRAME_STYLE];
          } else {
            current = originStyle;
          }

          root.addRefreshTask({
            __before: function __before() {
              __config[I_ASSIGNING] = true;
              genBeforeRefresh(current, __config[I_KEYS], __config, root, __config[I_TARGET]);

              self.__clean(true);
            },
            __after: function __after(diff) {
              if (!self.__hasFin) {
                self.__hasFin = true;
                __config[I_ASSIGNING] = false;
                frameCb(self, __config, diff);
                __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
                self.emit(Event.FINISH);
              }

              if (isFunction$4(cb)) {
                cb.call(self, diff);
              }
            }
          });
        }

        return self;
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        var self = this;
        var __config = self.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var playState = __config[I_PLAY_STATE];
        var frames = __config[I_FRAMES];

        if (isDestroyed || duration <= 0 || playState === 'idle' || frames.length < 1) {
          return self;
        }

        self.__cancelTask();

        var root = __config[I_ROOT];
        var originStyle = __config[I_ORIGIN_STYLE];

        if (root) {
          root.addRefreshTask({
            __before: function __before() {
              __config[I_ASSIGNING] = true;
              genBeforeRefresh(originStyle, __config[I_KEYS], __config, root, __config[I_TARGET]);

              self.__clean();
            },
            __after: function __after(diff) {
              if (!self.__hasCancel) {
                self.__hasCancel = true;
                __config[I_ASSIGNING] = false;
                frameCb(self, __config, diff);
                __config[I_BEGIN] = __config[I_END] = __config[I_IS_DELAY] = __config[I_FINISHED] = __config[I_IN_FPS] = __config[I_ENTER_FRAME] = false;
                self.emit(Event.CANCEL);
              }

              if (isFunction$4(cb)) {
                cb.call(self, diff);
              }
            }
          });
        }

        return self;
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        var __config = this.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var frames = __config[I_FRAMES];
        var delay = __config[I_DELAY];
        var endDelay = __config[I_END_DELAY];

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        var _gotoOverload = gotoOverload(options, cb);

        var _gotoOverload2 = _slicedToArray(_gotoOverload, 2);

        options = _gotoOverload2[0];
        cb = _gotoOverload2[1];

        // 计算出时间点直接累加播放
        this.__goto(v, options.isFrame, options.excludeDelay);

        if (v > duration + delay + endDelay) {
          return this.finish(cb);
        }

        return this.play(cb);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        var _this2 = this;

        var __config = this.__config;
        var isDestroyed = __config[I_DESTROYED];
        var duration = __config[I_DURATION];
        var frames = __config[I_FRAMES];
        var delay = __config[I_DELAY];
        var endDelay = __config[I_END_DELAY];

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        var _gotoOverload3 = gotoOverload(options, cb);

        var _gotoOverload4 = _slicedToArray(_gotoOverload3, 2);

        options = _gotoOverload4[0];
        cb = _gotoOverload4[1];
        v = this.__goto(v, options.isFrame, options.excludeDelay);

        if (v > duration + delay + endDelay) {
          return this.finish(cb);
        } // 先play一帧，回调里模拟暂停


        return this.play(function (diff) {
          __config[I_PLAY_STATE] = 'paused';

          _this2.__cancelTask();

          if (isFunction$4(cb)) {
            cb.call(_this2, diff);
          }
        });
      } // 同步赋予，用在extendAnimate

    }, {
      key: "assignCurrentStyle",
      value: function assignCurrentStyle() {
        var __config = this.__config;
        var style = __config[I_STYLE];
        var target = __config[I_TARGET];
        var keys = __config[I_KEYS];
        keys.forEach(function (i) {
          if (style.hasOwnProperty(i)) {
            var v = style[i]; // geom的属性变化

            if (GEOM$3.hasOwnProperty(i)) {
              target.currentProps[i] = v;
            } // 样式
            else {
              // 将动画样式直接赋给currentStyle
              target.currentStyle[i] = v;
            }
          }
        });
      } // 返回不包含delay且去除多轮的时间

    }, {
      key: "__goto",
      value: function __goto(v, isFrame, excludeDelay) {
        var __config = this.__config;
        var iterations = __config[I_ITERATIONS];
        var duration = __config[I_DURATION];
        __config[I_PLAY_STATE] = 'paused'; // this.__cancelTask(); // 应该不需要，gotoAndXxx都会调用play()，里面有

        if (isNaN(v) || v < 0) {
          throw new Error('Param of gotoAnd(Play/Stop) is illegal: ' + v);
        }

        if (isFrame) {
          v = (v - 1) / this.spf;
        }

        if (excludeDelay) {
          v += __config[I_DELAY];
        } // 在时间范围内设置好时间，复用play直接跳到播放点


        __config[I_NEXT_TIME] = v;
        v -= __config[I_DELAY]; // 超过时间长度需要累加次数，这里可以超过iterations，因为设定也许会非常大

        var playCount = 0;

        while (v >= duration && playCount < iterations - 1) {
          playCount++;
          v -= duration;
        }

        __config[I_PLAY_COUNT] = playCount; // 防止play()重置时间和当前帧组，提前计算好

        __config[I_ENTER_FRAME] = true;
        var frames = __config[I_FRAMES];
        var framesR = __config[I_FRAMES_R];
        var direction = __config[I_DIRECTION];

        if ({
          alternate: true,
          'alternate-reverse': true
        }.hasOwnProperty(direction)) {
          var isEven = playCount % 2 === 0;

          if (direction === 'alternate') {
            __config[I_CURRENT_FRAMES] = isEven ? frames : framesR;
          } else {
            __config[I_CURRENT_FRAMES] = isEven ? framesR : frames;
          }
        }

        return v;
      }
    }, {
      key: "addControl",
      value: function addControl() {
        var ac = this.root.animateController;

        if (ac) {
          ac.add(this);
        }
      }
    }, {
      key: "removeControl",
      value: function removeControl() {
        var ac = this.root.animateController;

        if (ac) {
          ac.remove(this);
        }
      }
    }, {
      key: "__stayBegin",
      value: function __stayBegin() {
        return {
          backwards: true,
          both: true
        }.hasOwnProperty(this.fill);
      }
    }, {
      key: "__stayEnd",
      value: function __stayEnd() {
        return {
          forwards: true,
          both: true
        }.hasOwnProperty(this.fill);
      }
    }, {
      key: "__setTarget",
      value: function __setTarget(target) {
        this.__target = target;
        this.__config[I_TARGET] = target;
        this.__config[I_NODE_CONFIG] = target.__config;
      }
    }, {
      key: "__cancelTask",
      value: function __cancelTask() {
        frame.offFrame(this);
        this.__config[I_PLAY_CB] = null;
      }
    }, {
      key: "__destroy",
      value: function __destroy(sync) {
        var self = this;
        var __config = self.__config;

        if (__config[I_DESTROYED]) {
          return;
        }

        self.removeControl(); // clean异步执行，因为里面的样式还原需要等到下一帧，否则同步执行清除后，紧接着的新同步动画获取不到currentStyle

        if (sync) {
          self.__clean();

          __config[I_TARGET] = null;
        } else {
          frame.nextFrame({
            __before: function __before() {
              self.__clean();

              __config[I_TARGET] = null;
            }
          });
        }

        __config[I_START_TIME] = 0;
        __config[I_DESTROYED] = true;
      }
    }, {
      key: "__checkModify",
      value: function __checkModify() {
        var __config = this.__config;

        if (__config[I_PLAY_STATE] !== 'idle' && __config[I_PLAY_STATE] !== 'finished') {
          inject.warn('Modification will not come into effect when animation is running');
        }
      }
    }, {
      key: "id",
      get: function get() {
        return this.__id;
      }
    }, {
      key: "target",
      get: function get() {
        return this.__config[I_TARGET];
      }
    }, {
      key: "root",
      get: function get() {
        return this.__config[I_ROOT];
      }
    }, {
      key: "keys",
      get: function get() {
        return this.__config[I_KEYS];
      }
    }, {
      key: "style",
      get: function get() {
        return this.__config[I_STYLE];
      }
    }, {
      key: "options",
      get: function get() {
        return this.__options;
      }
    }, {
      key: "duration",
      get: function get() {
        return this.__config[I_DURATION];
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var __config = this.__config;

        if (__config[I_DURATION] !== v) {
          __config[I_DURATION] = v;
          __config[I_END_TIME] = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "delay",
      get: function get() {
        return this.__config[I_DELAY];
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var __config = this.__config;

        if (__config[I_DELAY] !== v) {
          __config[I_DELAY] = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "endDelay",
      get: function get() {
        return this.__config[I_END_DELAY];
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var __config = this.__config;

        if (__config[I_END_DELAY] !== v) {
          __config[I_END_DELAY] = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "fps",
      get: function get() {
        return this.__config[I_FPS];
      },
      set: function set(v) {
        v = parseInt(v) || 60;
        var __config = this.__config;

        if (__config[I_FPS] !== v) {
          if (v <= 0) {
            v = 60;
          }

          __config[I_FPS] = v;
        }

        return v;
      }
    }, {
      key: "spf",
      get: function get() {
        return 1 / this.fps;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this.__config[I_ITERATIONS];
      },
      set: function set(v) {
        if (v === Infinity || util.isString(v) && v.toLowerCase() === 'infinity') {
          v = Infinity;
        } else {
          v = parseInt(v);

          if (isNaN(v) || v < 0) {
            v = 1;
          }
        }

        var __config = this.__config;

        if (__config[I_ITERATIONS] !== v) {
          __config[I_ITERATIONS] = v;
        }

        return v;
      }
    }, {
      key: "fill",
      get: function get() {
        return this.__config[I_FILL];
      },
      set: function set(v) {
        v = v || 'none';
        var __config = this.__config;

        if (__config[I_FILL] !== v) {
          __config[I_FILL] = v;

          this.__checkModify();
        }

        __config[I_STAY_BEGIN] = {
          backwards: true,
          both: true
        }.hasOwnProperty(v);
        __config[I_STAY_END] = {
          forwards: true,
          both: true
        }.hasOwnProperty(v);
        return v;
      }
    }, {
      key: "direction",
      get: function get() {
        return this.__config[I_DIRECTION];
      },
      set: function set(v) {
        v = v || 'normal';
        var __config = this.__config;

        if (__config[I_DIRECTION] !== v) {
          __config[I_DIRECTION] = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "frames",
      get: function get() {
        return this.__config[I_FRAMES];
      }
    }, {
      key: "framesR",
      get: function get() {
        return this.__config[I_FRAMES_R];
      }
    }, {
      key: "playbackRate",
      get: function get() {
        return this.__config[I_PLAYBACK_RATE];
      },
      set: function set(v) {
        v = parseFloat(v) || 1;

        if (v <= 0) {
          v = 1;
        }

        var __config = this.__config;

        if (__config[I_PLAYBACK_RATE] !== v) {
          __config[I_PLAYBACK_RATE] = v;
        }

        return v;
      }
    }, {
      key: "easing",
      get: function get() {
        return this.__config[I_EASING];
      }
    }, {
      key: "startTime",
      get: function get() {
        return this.__config[I_START_TIME];
      }
    }, {
      key: "currentTime",
      get: function get() {
        return this.__config[I_CURRENT_TIME];
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var __config = this.__config;

        if (__config[I_CURRENT_TIME] !== v) {
          __config[I_CURRENT_TIME] = v;
          __config[I_NEXT_TIME] = v;
        }

        return v;
      }
    }, {
      key: "nextTime",
      get: function get() {
        return this.__config[I_NEXT_TIME];
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var __config = this.__config;

        if (__config[I_NEXT_TIME] !== v) {
          __config[I_NEXT_TIME] = v;
        }

        return v;
      }
    }, {
      key: "timestamp",
      get: function get() {
        return this.__config[I_TIME_STAMP];
      }
    }, {
      key: "pending",
      get: function get() {
        return this.__config[I_PLAY_STATE] !== 'running';
      }
    }, {
      key: "finished",
      get: function get() {
        return this.__config[I_PLAY_STATE] === 'finished';
      }
    }, {
      key: "playState",
      get: function get() {
        return this.__config[I_PLAY_STATE];
      }
    }, {
      key: "playCount",
      get: function get() {
        return this.__config[I_PLAY_COUNT];
      },
      set: function set(v) {
        v = Math.max(0, parseInt(v) || 0);
        var __config = this.__config;

        if (__config[I_PLAY_COUNT] !== v) {
          __config[I_PLAY_COUNT] = v;
        }

        return v;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__config[I_DESTROYED];
      }
    }, {
      key: "animating",
      get: function get() {
        var __config = this.__config;
        var playState = __config[I_PLAY_STATE];

        if (playState === 'idle') {
          return false;
        }

        return playState !== 'finished' || __config[I_STAY_END] || __config[I_STAY_BEGIN];
      }
    }, {
      key: "spfLimit",
      get: function get() {
        var __config = this.__config;
        return __config[I_SPF_LIMIT];
      },
      set: function set(v) {
        if (util.isNumber(v) || /^\d/.test(v)) {
          v = Math.max(0, parseInt(v) || 0);
        } else {
          v = !!v;
        }

        var __config = this.__config;

        if (__config[I_SPF_LIMIT] !== v) {
          __config[I_SPF_LIMIT] = v;
        }

        return v;
      }
    }, {
      key: "assigning",
      get: function get() {
        return this.__config[I_ASSIGNING];
      }
    }]);

    return Animation;
  }(Event);

  var NODE_DEFS_CACHE$1 = enums.NODE_KEY.NODE_DEFS_CACHE;
  var int2rgba$2 = util.int2rgba;
  var canvasPolygon$4 = painter.canvasPolygon,
      svgPolygon$3 = painter.svgPolygon;

  function renderBoxShadow(xom, renderMode, ctx, data, x1, y1, x2, y2, w, h) {
    var dx = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var dy = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _data = _slicedToArray(data, 6),
        x = _data[0],
        y = _data[1],
        sigma = _data[2],
        spread = _data[3],
        color = _data[4],
        inset = _data[5];

    var c = int2rgba$2(color);
    var n = Math.abs(sigma) * 2 + Math.abs(spread) * 2 + Math.abs(x) * 2 + Math.abs(y) * 2; // box本身坐标顺时针

    var box = [[x1, y1], [x2, y1], [x2, y2], [x1, y2], [x1, y1]]; // 算上各种偏移/扩散的最外层坐标，且逆时针

    var outer = [[x1 - n, y1 - n], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n]];

    if (color[3] > 0) {
      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        ctx.save();
        ctx.beginPath(); // inset裁剪box外面

        if (inset === 'inset') {
          var xa = x1 + x + spread;
          var ya = y1 + y + spread;
          var xb = x2 + x - spread;
          var yb = y2 + y - spread;
          var spreadBox = [[xa, ya], [xb, ya], [xb, yb], [xa, yb]]; // 是否相交判断需要绘制

          var cross = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [spreadBox[0][0], spreadBox[0][1], spreadBox[2][0], spreadBox[2][1]]);

          if (!cross) {
            return;
          }

          cross = [[cross[0], cross[1]], [cross[2], cross[1]], [cross[2], cross[3]], [cross[0], cross[3]], [cross[0], cross[1]]]; // 扩散区域类似边框填充

          if (spread) {
            canvasPolygon$4(ctx, cross);
            canvasPolygon$4(ctx, box.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$4(ctx, box);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath();
            canvasPolygon$4(ctx, cross);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma; // 画在外围的空心矩形，宽度要比blur大，n考虑了这一情况取了最大值

            canvasPolygon$4(ctx, [[xa, ya], [xb, ya], [xb, yb], [x1 - n, yb], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, yb], [xa, yb], [xa, ya]]);
          } else {
            canvasPolygon$4(ctx, box);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$4(ctx, [[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]]);
          }
        } // outset需裁减掉box本身的内容，clip()非零环绕显示box外的阴影内容，fill()绘制在内无效
        else {
          var _xa = x1 + x - spread;

          var _ya = y1 + y - spread;

          var _xb = x2 + x + spread;

          var _yb = y2 + y + spread;

          var blurBox = [[_xa, _ya], [_xb, _ya], [_xb, _yb], [_xa, _yb]];

          var _cross = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [blurBox[0][0], blurBox[0][1], blurBox[2][0], blurBox[2][1]]); // 分为是否有spread，因模糊成本spread区域将没有模糊


          if (spread) {
            // 扩散区域类似边框填充
            canvasPolygon$4(ctx, box);
            canvasPolygon$4(ctx, blurBox.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$4(ctx, blurBox);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath(); // 阴影部分看相交情况裁剪，有相交时逆时针绘制相交区域即可排除之

            if (_cross) {
              canvasPolygon$4(ctx, [[_cross[0], _cross[1]], [_cross[2], _cross[1]], [_cross[2], _cross[3]], [_cross[0], _cross[3]], [_cross[0], _cross[1]]].reverse());
            }

            canvasPolygon$4(ctx, box);
            canvasPolygon$4(ctx, blurBox);
            canvasPolygon$4(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$4(ctx, blurBox);
          } else {
            canvasPolygon$4(ctx, box);
            canvasPolygon$4(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$4(ctx, box);
          }
        }

        ctx.fill();
        ctx.closePath();
        ctx.restore();
      } else if (renderMode === mode.SVG) {
        var d = blur.outerSize(sigma);

        if (inset === 'inset') {
          var _xa2 = x1 + x + spread;

          var _ya2 = y1 + y + spread;

          var _xb2 = x2 + x - spread;

          var _yb2 = y2 + y - spread;

          var _spreadBox = [[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [_xa2, _yb2]];

          var _cross2 = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_spreadBox[0][0], _spreadBox[0][1], _spreadBox[2][0], _spreadBox[2][1]]);

          if (!_cross2) {
            return;
          }

          _cross2 = [[_cross2[0], _cross2[1]], [_cross2[2], _cross2[1]], [_cross2[2], _cross2[3]], [_cross2[0], _cross2[3]], [_cross2[0], _cross2[1]]];

          if (spread) {
            var v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            xom.__config[NODE_DEFS_CACHE$1].push(v);

            var filter = ctx.add(v);
            var v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2) + svgPolygon$3(box.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };
            var clip = ctx.add(v2);

            xom.__config[NODE_DEFS_CACHE$1].push(v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', c], ['clip-path', 'url(#' + clip + ')']]
            });
            v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2)], ['fill', '#FFF']]
              }]
            };
            clip = ctx.add(v);

            xom.__config[NODE_DEFS_CACHE$1].push(v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [x1 - n, _yb2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, _yb2], [_xa2, _yb2], [_xa2, _ya2]])], ['fill', '#FFF'], ['filter', 'url(#' + filter + ')'], ['clip-path', 'url(#' + clip + ')']]
            });
          } else {
            var _v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter = ctx.add(_v);

            xom.__config[NODE_DEFS_CACHE$1].push(_v);

            _v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box)], ['fill', '#FFF']]
              }]
            };

            var _clip = ctx.add(_v);

            xom.__config[NODE_DEFS_CACHE$1].push(_v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]])], ['fill', '#FFF'], ['filter', 'url(#' + _filter + ')'], ['clip-path', 'url(#' + _clip + ')']]
            });
          }
        } else {
          var _xa3 = x1 + x - spread;

          var _ya3 = y1 + y - spread;

          var _xb3 = x2 + x + spread;

          var _yb3 = y2 + y + spread;

          var _blurBox = [[_xa3, _ya3], [_xb3, _ya3], [_xb3, _yb3], [_xa3, _yb3]];

          var _cross3 = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_blurBox[0][0], _blurBox[0][1], _blurBox[2][0], _blurBox[2][1]]);

          if (spread) {
            var _v2 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter2 = ctx.add(_v2);

            xom.__config[NODE_DEFS_CACHE$1].push(_v2);

            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(_blurBox.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };

            var _clip2 = ctx.add(_v2);

            xom.__config[NODE_DEFS_CACHE$1].push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', c], ['clip-path', 'url(#' + _clip2 + ')']]
            });
            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', (_cross3 ? svgPolygon$3([[_cross3[0], _cross3[1]], [_cross3[2], _cross3[1]], [_cross3[2], _cross3[3]], [_cross3[0], _cross3[3]], [_cross3[0], _cross3[1]]].reverse()) : '') + svgPolygon$3(box) + svgPolygon$3(_blurBox) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };
            _clip2 = ctx.add(_v2);

            xom.__config[NODE_DEFS_CACHE$1].push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', '#FFF'], ['filter', 'url(#' + _filter2 + ')'], ['clip-path', 'url(#' + _clip2 + ')']]
            });
          } else {
            var _v3 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter3 = ctx.add(_v3);

            xom.__config[NODE_DEFS_CACHE$1].push(_v3);

            _v3 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };

            var _clip3 = ctx.add(_v3);

            xom.__config[NODE_DEFS_CACHE$1].push(_v3);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', '#FFF'], ['filter', 'url(#' + _filter3 + ')'], ['clip-path', 'url(#' + _clip3 + ')']]
            });
          }
        }
      }
    }
  }

  var bs = {
    renderBoxShadow: renderBoxShadow
  };

  var MBM_HASH = {
    multiply: true,
    screen: true,
    overlay: true,
    darken: true,
    lighten: true,
    colorDodge: true,
    colorBurn: true,
    hardLight: true,
    softLight: true,
    difference: true,
    exclusion: true,
    hue: true,
    saturation: true,
    color: true,
    luminosity: true
  };

  function mbmName(v) {
    if (v) {
      return v.replace(/[A-Z]/, function ($0) {
        return '-' + $0.toLowerCase();
      });
    }
  }

  function isValidMbm(v) {
    return MBM_HASH.hasOwnProperty(v);
  }

  var mbm = {
    mbmName: mbmName,
    isValidMbm: isValidMbm
  };

  var svgPolygon$4 = painter.svgPolygon;
  var CANVAS$4 = mode.CANVAS,
      SVG$3 = mode.SVG,
      WEBGL$4 = mode.WEBGL;
  var LOCAL = Cache.LOCAL;
  var STYLE_KEY$5 = enums.STYLE_KEY,
      STYLE_RV_KEY$1 = enums.STYLE_RV_KEY,
      style2Upper$2 = enums.style2Upper,
      _enums$STYLE_KEY$d = enums.STYLE_KEY,
      BORDER_TOP_LEFT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$1 = _enums$STYLE_KEY$d.BORDER_BOTTOM_RIGHT_RADIUS,
      PADDING_LEFT$3 = _enums$STYLE_KEY$d.PADDING_LEFT,
      PADDING_RIGHT$2 = _enums$STYLE_KEY$d.PADDING_RIGHT,
      PADDING_TOP$3 = _enums$STYLE_KEY$d.PADDING_TOP,
      PADDING_BOTTOM$3 = _enums$STYLE_KEY$d.PADDING_BOTTOM,
      MARGIN_LEFT$2 = _enums$STYLE_KEY$d.MARGIN_LEFT,
      MARGIN_TOP$2 = _enums$STYLE_KEY$d.MARGIN_TOP,
      MARGIN_BOTTOM$2 = _enums$STYLE_KEY$d.MARGIN_BOTTOM,
      MARGIN_RIGHT$2 = _enums$STYLE_KEY$d.MARGIN_RIGHT,
      BORDER_LEFT_WIDTH$3 = _enums$STYLE_KEY$d.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH$3 = _enums$STYLE_KEY$d.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$3 = _enums$STYLE_KEY$d.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$2 = _enums$STYLE_KEY$d.BORDER_RIGHT_WIDTH,
      TOP$1 = _enums$STYLE_KEY$d.TOP,
      RIGHT = _enums$STYLE_KEY$d.RIGHT,
      BOTTOM$1 = _enums$STYLE_KEY$d.BOTTOM,
      LEFT = _enums$STYLE_KEY$d.LEFT,
      POSITION$2 = _enums$STYLE_KEY$d.POSITION,
      DISPLAY$2 = _enums$STYLE_KEY$d.DISPLAY,
      WIDTH$4 = _enums$STYLE_KEY$d.WIDTH,
      HEIGHT$4 = _enums$STYLE_KEY$d.HEIGHT,
      MATRIX$3 = _enums$STYLE_KEY$d.MATRIX,
      TRANSLATE_X$4 = _enums$STYLE_KEY$d.TRANSLATE_X,
      TRANSLATE_Y$4 = _enums$STYLE_KEY$d.TRANSLATE_Y,
      TRANSLATE_Z$4 = _enums$STYLE_KEY$d.TRANSLATE_Z,
      TRANSFORM$3 = _enums$STYLE_KEY$d.TRANSFORM,
      SCALE_X$3 = _enums$STYLE_KEY$d.SCALE_X,
      SCALE_Y$3 = _enums$STYLE_KEY$d.SCALE_Y,
      SCALE_Z$2 = _enums$STYLE_KEY$d.SCALE_Z,
      ROTATE_X$2 = _enums$STYLE_KEY$d.ROTATE_X,
      ROTATE_Y$2 = _enums$STYLE_KEY$d.ROTATE_Y,
      ROTATE_Z$4 = _enums$STYLE_KEY$d.ROTATE_Z,
      SKEW_X$2 = _enums$STYLE_KEY$d.SKEW_X,
      SKEW_Y$2 = _enums$STYLE_KEY$d.SKEW_Y,
      PERSPECTIVE$3 = _enums$STYLE_KEY$d.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$3 = _enums$STYLE_KEY$d.PERSPECTIVE_ORIGIN,
      ROTATE_3D$3 = _enums$STYLE_KEY$d.ROTATE_3D,
      TRANSFORM_ORIGIN$4 = _enums$STYLE_KEY$d.TRANSFORM_ORIGIN,
      BACKGROUND_POSITION_X$3 = _enums$STYLE_KEY$d.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$3 = _enums$STYLE_KEY$d.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE$2 = _enums$STYLE_KEY$d.BACKGROUND_SIZE,
      BACKGROUND_COLOR$1 = _enums$STYLE_KEY$d.BACKGROUND_COLOR,
      BACKGROUND_IMAGE$1 = _enums$STYLE_KEY$d.BACKGROUND_IMAGE,
      BACKGROUND_REPEAT = _enums$STYLE_KEY$d.BACKGROUND_REPEAT,
      BOX_SHADOW$2 = _enums$STYLE_KEY$d.BOX_SHADOW,
      OPACITY$3 = _enums$STYLE_KEY$d.OPACITY,
      Z_INDEX$2 = _enums$STYLE_KEY$d.Z_INDEX,
      BORDER_TOP_STYLE = _enums$STYLE_KEY$d.BORDER_TOP_STYLE,
      BORDER_RIGHT_STYLE = _enums$STYLE_KEY$d.BORDER_RIGHT_STYLE,
      BORDER_BOTTOM_STYLE = _enums$STYLE_KEY$d.BORDER_BOTTOM_STYLE,
      BORDER_LEFT_STYLE = _enums$STYLE_KEY$d.BORDER_LEFT_STYLE,
      FILTER$4 = _enums$STYLE_KEY$d.FILTER,
      OVERFLOW$1 = _enums$STYLE_KEY$d.OVERFLOW,
      MIX_BLEND_MODE = _enums$STYLE_KEY$d.MIX_BLEND_MODE,
      TEXT_OVERFLOW$2 = _enums$STYLE_KEY$d.TEXT_OVERFLOW,
      BORDER_TOP_COLOR = _enums$STYLE_KEY$d.BORDER_TOP_COLOR,
      BORDER_BOTTOM_COLOR = _enums$STYLE_KEY$d.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR = _enums$STYLE_KEY$d.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR = _enums$STYLE_KEY$d.BORDER_RIGHT_COLOR,
      FONT_STYLE$4 = _enums$STYLE_KEY$d.FONT_STYLE,
      COLOR$5 = _enums$STYLE_KEY$d.COLOR,
      VISIBILITY$2 = _enums$STYLE_KEY$d.VISIBILITY,
      POINTER_EVENTS$1 = _enums$STYLE_KEY$d.POINTER_EVENTS,
      BORDER_TOP = _enums$STYLE_KEY$d.BORDER_TOP,
      BORDER_RIGHT = _enums$STYLE_KEY$d.BORDER_RIGHT,
      BORDER_BOTTOM = _enums$STYLE_KEY$d.BORDER_BOTTOM,
      BORDER_LEFT = _enums$STYLE_KEY$d.BORDER_LEFT,
      BACKGROUND_CLIP$2 = _enums$STYLE_KEY$d.BACKGROUND_CLIP,
      FONT_SIZE$9 = _enums$STYLE_KEY$d.FONT_SIZE,
      FONT_FAMILY$5 = _enums$STYLE_KEY$d.FONT_FAMILY,
      LINE_HEIGHT$5 = _enums$STYLE_KEY$d.LINE_HEIGHT,
      TEXT_STROKE_COLOR$4 = _enums$STYLE_KEY$d.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$3 = _enums$STYLE_KEY$d.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$3 = _enums$STYLE_KEY$d.TEXT_STROKE_OVER,
      FONT_WEIGHT$5 = _enums$STYLE_KEY$d.FONT_WEIGHT,
      FLEX_DIRECTION$2 = _enums$STYLE_KEY$d.FLEX_DIRECTION,
      JUSTIFY_CONTENT$1 = _enums$STYLE_KEY$d.JUSTIFY_CONTENT,
      ALIGN_ITEMS$1 = _enums$STYLE_KEY$d.ALIGN_ITEMS,
      ALIGN_SELF$1 = _enums$STYLE_KEY$d.ALIGN_SELF,
      FLEX_GROW$1 = _enums$STYLE_KEY$d.FLEX_GROW,
      FLEX_SHRINK$1 = _enums$STYLE_KEY$d.FLEX_SHRINK,
      LINE_CLAMP$1 = _enums$STYLE_KEY$d.LINE_CLAMP,
      ORDER$1 = _enums$STYLE_KEY$d.ORDER,
      FLEX_WRAP$1 = _enums$STYLE_KEY$d.FLEX_WRAP,
      ALIGN_CONTENT = _enums$STYLE_KEY$d.ALIGN_CONTENT,
      TEXT_ALIGN$2 = _enums$STYLE_KEY$d.TEXT_ALIGN,
      LETTER_SPACING$3 = _enums$STYLE_KEY$d.LETTER_SPACING,
      WHITE_SPACE$2 = _enums$STYLE_KEY$d.WHITE_SPACE,
      WRITING_MODE$1 = _enums$STYLE_KEY$d.WRITING_MODE,
      _enums$UPDATE_KEY$2 = enums.UPDATE_KEY,
      UPDATE_NODE$2 = _enums$UPDATE_KEY$2.UPDATE_NODE,
      UPDATE_FOCUS$1 = _enums$UPDATE_KEY$2.UPDATE_FOCUS,
      UPDATE_STYLE$1 = _enums$UPDATE_KEY$2.UPDATE_STYLE,
      UPDATE_OVERWRITE = _enums$UPDATE_KEY$2.UPDATE_OVERWRITE,
      UPDATE_KEYS$1 = _enums$UPDATE_KEY$2.UPDATE_KEYS,
      UPDATE_CONFIG$2 = _enums$UPDATE_KEY$2.UPDATE_CONFIG,
      UPDATE_REMOVE_DOM = _enums$UPDATE_KEY$2.UPDATE_REMOVE_DOM,
      STRUCT_HAS_MASK = enums.STRUCT_KEY.STRUCT_HAS_MASK,
      _enums$NODE_KEY$3 = enums.NODE_KEY,
      NODE_TAG_NAME = _enums$NODE_KEY$3.NODE_TAG_NAME,
      NODE_CACHE_STYLE = _enums$NODE_KEY$3.NODE_CACHE_STYLE,
      NODE_CURRENT_STYLE$1 = _enums$NODE_KEY$3.NODE_CURRENT_STYLE,
      NODE_COMPUTED_STYLE$1 = _enums$NODE_KEY$3.NODE_COMPUTED_STYLE,
      NODE_STYLE$1 = _enums$NODE_KEY$3.NODE_STYLE,
      NODE_STRUCT$1 = _enums$NODE_KEY$3.NODE_STRUCT,
      NODE_OPACITY$1 = _enums$NODE_KEY$3.NODE_OPACITY,
      NODE_MATRIX_EVENT$2 = _enums$NODE_KEY$3.NODE_MATRIX_EVENT,
      NODE_MATRIX$1 = _enums$NODE_KEY$3.NODE_MATRIX,
      NODE_LIMIT_CACHE$1 = _enums$NODE_KEY$3.NODE_LIMIT_CACHE,
      NODE_HAS_CONTENT = _enums$NODE_KEY$3.NODE_HAS_CONTENT,
      NODE_REFRESH_LV = _enums$NODE_KEY$3.NODE_REFRESH_LV,
      NODE_CACHE$1 = _enums$NODE_KEY$3.NODE_CACHE,
      NODE_CACHE_TOTAL = _enums$NODE_KEY$3.NODE_CACHE_TOTAL,
      NODE_CACHE_FILTER = _enums$NODE_KEY$3.NODE_CACHE_FILTER,
      NODE_CACHE_MASK = _enums$NODE_KEY$3.NODE_CACHE_MASK,
      NODE_CACHE_OVERFLOW = _enums$NODE_KEY$3.NODE_CACHE_OVERFLOW,
      NODE_IS_DESTROYED$1 = _enums$NODE_KEY$3.NODE_IS_DESTROYED,
      NODE_DEFS_CACHE$2 = _enums$NODE_KEY$3.NODE_DEFS_CACHE,
      NODE_DOM_PARENT$2 = _enums$NODE_KEY$3.NODE_DOM_PARENT,
      NODE_IS_INLINE = _enums$NODE_KEY$3.NODE_IS_INLINE,
      NODE_PERSPECTIVE_MATRIX = _enums$NODE_KEY$3.NODE_PERSPECTIVE_MATRIX,
      NODE_IS_MASK = _enums$NODE_KEY$3.NODE_IS_MASK,
      NODE_VIRTUAL_DOM$2 = _enums$NODE_KEY$3.NODE_VIRTUAL_DOM,
      NODE_CACHE_AS_BITMAP = _enums$NODE_KEY$3.NODE_CACHE_AS_BITMAP;
  var AUTO$3 = o.AUTO,
      PX$4 = o.PX,
      PERCENT$5 = o.PERCENT,
      INHERIT$3 = o.INHERIT,
      NUMBER$5 = o.NUMBER,
      RGBA$2 = o.RGBA,
      STRING$2 = o.STRING,
      REM$5 = o.REM,
      VW$5 = o.VW,
      VH$5 = o.VH,
      VMAX$5 = o.VMAX,
      VMIN$5 = o.VMIN,
      DEG$4 = o.DEG,
      GRADIENT$2 = o.GRADIENT;
  var int2rgba$3 = util.int2rgba,
      rgba2int$3 = util.rgba2int,
      joinArr$2 = util.joinArr,
      isNil$6 = util.isNil,
      isFunction$5 = util.isFunction;
  var calRelative$1 = css.calRelative,
      getFontFamily$1 = css.getFontFamily,
      calNormalLineHeight$1 = css.calNormalLineHeight,
      spreadBoxShadow$1 = css.spreadBoxShadow,
      spreadFilter$2 = css.spreadFilter;
  var GEOM$4 = o$2.GEOM;
  var mbmName$1 = mbm.mbmName,
      isValidMbm$1 = mbm.isValidMbm;
  var point2d$1 = mx.point2d;
  var contain = o$3.contain,
      NONE = o$3.NONE,
      TF = o$3.TRANSFORM,
      REFLOW = o$3.REFLOW,
      REPAINT$1 = o$3.REPAINT,
      TX = o$3.TRANSLATE_X,
      TY = o$3.TRANSLATE_Y,
      TZ = o$3.TRANSLATE_Z;

  function getFirstEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = 0; i < length; i++) {
      var child = flowChildren[i];

      if (child instanceof Xom$1 || child instanceof Component$1 && child.shadowRoot instanceof Xom$1) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getFirstEmptyInlineWidth(child);
          break;
        } else if (child.__config[NODE_IS_INLINE]) {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  function getLastEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = length - 1; i >= 0; i--) {
      var child = flowChildren[i];

      if (child instanceof Xom$1 || child instanceof Component$1 && child.shadowRoot instanceof Xom$1) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getLastEmptyInlineWidth(child);
          break;
        } else {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  var Xom$1 = /*#__PURE__*/function (_Node) {
    _inherits(Xom, _Node);

    var _super = _createSuper(Xom);

    function Xom(tagName) {
      var _this;

      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Xom);

      _this = _super.call(this); // 构建工具中都是arr，手写可能出现hash情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__tagName = tagName;
      _this.__style = _this.props.style || {}; // style被解析后的k-v形式

      _this.__currentStyle = {}; // 动画过程中绘制一开始会merge动画样式

      _this.__computedStyle = {}; // 类似getComputedStyle()将currentStyle计算好数值赋给

      _this.__listener = {};
      Object.keys(_this.props).forEach(function (k) {
        var v = _this.props[k];

        if (/^on[a-zA-Z]/.test(k)) {
          k = k.slice(2).toLowerCase();
          _this.listener[k] = v;
        }
      });
      _this.__animationList = [];
      _this.__loadBgi = {
        // 刷新回调函数，用以destroy取消用
        cb: function cb() {}
      };
      _this.__cacheStyle = {}; // 是否缓存重新计算computedStyle的样式key

      _this.__cacheDefs = []; // svg专用，缓存渲染时使用已有的defs，diff过程用，否则会defs被清空

      var isClip = _this.__isClip = !!_this.props.clip;
      var isMask = _this.__isMask = isClip || !!_this.props.mask;
      var config = _this.__config;
      config[NODE_TAG_NAME] = tagName;
      config[NODE_CACHE_STYLE] = _this.__cacheStyle;
      config[NODE_CURRENT_STYLE$1] = _this.__currentStyle;
      config[NODE_COMPUTED_STYLE$1] = _this.__computedStyle;
      config[NODE_REFRESH_LV] = REFLOW;
      config[NODE_STYLE$1] = _this.__style;
      config[NODE_MATRIX$1] = [];
      config[NODE_MATRIX_EVENT$2] = [];
      config[NODE_DEFS_CACHE$2] = _this.__cacheDefs;
      config[NODE_IS_MASK] = isMask;
      _this.__frameAnimateList = [];
      _this.__contentBoxList = []; // inline存储内容用
      // this.__json domApi需要获取生成时的json引用，builder过程添加，如appendChild时json也需要跟着变更

      config[NODE_CACHE_AS_BITMAP] = _this.__cacheAsBitmap = !!_this.props.cacheAsBitmap;
      _this.__layoutData = null; // 缓存上次布局x/y/w/h数据

      _this.__hasComputeReflow = false; // 每次布局计算缓存标，使得每次开始只computeReflow一次

      _this.__parentLineBox = null; // inline时指向

      return _this;
    }

    _createClass(Xom, [{
      key: "__structure",
      value: function __structure(i, lv, j) {
        var res = _get(_getPrototypeOf(Xom.prototype), "__structure", this).call(this, i, lv, j);

        if (this.__hasMask) {
          res[STRUCT_HAS_MASK] = this.__hasMask;
        }

        this.__config[NODE_STRUCT$1] = res;
        return res;
      } // 设置margin/padding的实际值，layout时执行，inline的垂直方向仍然计算值，但在布局时被忽略

    }, {
      key: "__mp",
      value: function __mp(currentStyle, computedStyle, w) {
        var _this2 = this;

        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          var a = STYLE_KEY$5[style2Upper$2('margin' + k)];
          var b = STYLE_KEY$5[style2Upper$2('padding' + k)];
          computedStyle[a] = _this2.__calSize(currentStyle[a], w, true);
          computedStyle[b] = _this2.__calSize(currentStyle[b], w, true);
        });
      }
    }, {
      key: "__calSize",
      value: function __calSize(v, w, includePercent) {
        if (v[1] === PX$4) {
          return v[0];
        } else if (v[1] === PERCENT$5 && includePercent) {
          return v[0] * w * 0.01;
        } else if (v[1] === REM$5) {
          return v[0] * this.root.computedStyle[FONT_SIZE$9];
        } else if (v[1] === VW$5) {
          return v[0] * this.root.width * 0.01;
        } else if (v[1] === VH$5) {
          return v[0] * this.root.height * 0.01;
        } else if (v[1] === VMAX$5) {
          return v[0] * Math.max(this.root.width, this.root.height) * 0.01;
        } else if (v[1] === VMIN$5) {
          return v[0] * Math.min(this.root.width, this.root.height) * 0.01;
        }

        return 0;
      }
    }, {
      key: "__computeReflow",
      value: function __computeReflow() {
        var _this3 = this;

        if (this.__hasComputeReflow) {
          return;
        }

        this.__hasComputeReflow = true;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            parent = this.domParent;
        var isRoot = !parent;
        var parentComputedStyle = parent && parent.computedStyle;
        [FONT_SIZE$9, FONT_FAMILY$5, FONT_WEIGHT$5, WRITING_MODE$1].forEach(function (k) {
          var v = currentStyle[k]; // ff特殊处理

          if (k === FONT_FAMILY$5) {
            if (v[1] === INHERIT$3) {
              computedStyle[k] = getFontFamily$1(isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k]);
            } else {
              computedStyle[k] = getFontFamily$1(v[0]);
            }
          } else if (v[1] === INHERIT$3) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k];
          } // 只有fontSize会有%
          else if (v[1] === PERCENT$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : parentComputedStyle[k] * v[0] * 0.01;
          } else if (v[1] === REM$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : _this3.root.computedStyle[FONT_SIZE$9] * v[0];
          } else if (v[1] === VW$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : _this3.root.width * 0.01 * v[0];
          } else if (v[1] === VH$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : _this3.root.height * 0.01 * v[0];
          } else if (v[1] === VMAX$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : Math.max(_this3.root.width, _this3.root.height) * 0.01 * v[0];
          } else if (v[1] === VMIN$5) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY$1[k]] : Math.min(_this3.root.width, _this3.root.height) * 0.01 * v[0];
          } else {
            computedStyle[k] = v[0];
          }
        });
        [BORDER_TOP_WIDTH$3, BORDER_RIGHT_WIDTH$2, BORDER_BOTTOM_WIDTH$3, BORDER_LEFT_WIDTH$3].forEach(function (k) {
          // border-width不支持百分比
          var item = currentStyle[k];
          computedStyle[k] = _this3.__calSize(item, 0, false);
        });
        [POSITION$2, DISPLAY$2, FLEX_DIRECTION$2, JUSTIFY_CONTENT$1, ALIGN_ITEMS$1, ALIGN_SELF$1, FLEX_GROW$1, FLEX_SHRINK$1, LINE_CLAMP$1, ORDER$1, FLEX_WRAP$1, ALIGN_CONTENT, OVERFLOW$1, TEXT_OVERFLOW$2].forEach(function (k) {
          computedStyle[k] = currentStyle[k];
        }); // writingMode特殊判断inline

        if (parentComputedStyle && computedStyle[WRITING_MODE$1] !== parentComputedStyle[WRITING_MODE$1] && computedStyle[DISPLAY$2] === 'inline') {
          computedStyle[DISPLAY$2] = 'inlineBlock';
        } // 匿名块对象


        if (computedStyle[POSITION$2] === 'absolute' || parentComputedStyle && parentComputedStyle[DISPLAY$2] === 'flex') {
          if (['block', 'flex'].indexOf(computedStyle[DISPLAY$2]) === -1) {
            computedStyle[DISPLAY$2] = 'block';
          }
        }

        var textAlign = currentStyle[TEXT_ALIGN$2];

        if (textAlign[1] === INHERIT$3) {
          computedStyle[TEXT_ALIGN$2] = isRoot ? 'left' : parentComputedStyle[TEXT_ALIGN$2];
        } else {
          computedStyle[TEXT_ALIGN$2] = textAlign[0];
        }

        var fontSize = computedStyle[FONT_SIZE$9];
        var lineHeight = currentStyle[LINE_HEIGHT$5]; // lineHeight继承很特殊，数字和normal不同于普通单位

        if (lineHeight[1] === INHERIT$3) {
          if (isRoot) {
            computedStyle[LINE_HEIGHT$5] = calNormalLineHeight$1(computedStyle, null);
          } else {
            var p = parent;
            var ph;

            while (p) {
              ph = p.currentStyle[LINE_HEIGHT$5];

              if (ph[1] !== INHERIT$3) {
                break;
              }

              p = p.domParent;
            } // 到root还是inherit或normal，或者中途遇到了normal，使用normal


            if ([AUTO$3, INHERIT$3].indexOf(ph[1]) > -1) {
              computedStyle[LINE_HEIGHT$5] = calNormalLineHeight$1(computedStyle, null);
            } // 数字继承
            else if (ph[1] === NUMBER$5) {
              computedStyle[LINE_HEIGHT$5] = Math.max(ph[0], 0) * fontSize;
            } // 单位继承
            else {
              computedStyle[LINE_HEIGHT$5] = parentComputedStyle[LINE_HEIGHT$5];
            }
          }
        } else if (lineHeight[1] === NUMBER$5) {
          computedStyle[LINE_HEIGHT$5] = Math.max(lineHeight[0], 0) * fontSize || calNormalLineHeight$1(computedStyle, null);
        } // 防止为0
        else {
          var v = Math.max(this.__calSize(lineHeight, fontSize, true), 0);
          computedStyle[LINE_HEIGHT$5] = v || calNormalLineHeight$1(computedStyle, null);
        }

        var letterSpacing = currentStyle[LETTER_SPACING$3];

        if (letterSpacing[1] === INHERIT$3) {
          computedStyle[LETTER_SPACING$3] = isRoot ? 0 : parentComputedStyle[LETTER_SPACING$3];
        } else {
          computedStyle[LETTER_SPACING$3] = this.__calSize(letterSpacing, fontSize, true);
        } //whiteSpace


        var whiteSpace = currentStyle[WHITE_SPACE$2];

        if (whiteSpace[1] === INHERIT$3) {
          computedStyle[WHITE_SPACE$2] = isRoot ? 'normal' : parentComputedStyle[WHITE_SPACE$2];
        } else {
          computedStyle[WHITE_SPACE$2] = whiteSpace[0];
        }
      } // dom常用的几种尺寸赋值

    }, {
      key: "__ioSize",
      value: function __ioSize(w, h) {
        var computedStyle = this.computedStyle; // 可能不传，在虚拟布局时用不到

        if (!isNil$6(w)) {
          this.__width = computedStyle[WIDTH$4] = w;
          this.__clientWidth = w += computedStyle[PADDING_LEFT$3] + computedStyle[PADDING_RIGHT$2];
          this.__offsetWidth = w += computedStyle[BORDER_LEFT_WIDTH$3] + computedStyle[BORDER_RIGHT_WIDTH$2];
          this.__outerWidth = w + computedStyle[MARGIN_LEFT$2] + computedStyle[MARGIN_RIGHT$2];
        }

        if (!isNil$6(h)) {
          this.__height = computedStyle[HEIGHT$4] = h;
          this.__clientHeight = h += computedStyle[PADDING_TOP$3] + computedStyle[PADDING_BOTTOM$3];
          this.__offsetHeight = h += computedStyle[BORDER_TOP_WIDTH$3] + computedStyle[BORDER_BOTTOM_WIDTH$3];
          this.__outerHeight = h + computedStyle[MARGIN_TOP$2] + computedStyle[MARGIN_BOTTOM$2];
        }
      } // 为basis的b/min/max添加mpb，只有当b未显示指定等于w/content时才加，同时返回mpb值

    }, {
      key: "__addMBP",
      value: function __addMBP(isDirectionRow, w, currentStyle, computedStyle, res, isDirectItem) {
        var marginLeft = currentStyle[MARGIN_LEFT$2],
            marginTop = currentStyle[MARGIN_TOP$2],
            marginRight = currentStyle[MARGIN_RIGHT$2],
            marginBottom = currentStyle[MARGIN_BOTTOM$2],
            paddingLeft = currentStyle[PADDING_LEFT$3],
            paddingTop = currentStyle[PADDING_TOP$3],
            paddingRight = currentStyle[PADDING_RIGHT$2],
            paddingBottom = currentStyle[PADDING_BOTTOM$3];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$2],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$3],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3];
        var mbp = this.__calSize(marginLeft, w, isDirectItem) + this.__calSize(marginRight, w, isDirectItem) + this.__calSize(paddingLeft, w, isDirectItem) + this.__calSize(paddingRight, w, isDirectItem) + borderLeftWidth + borderRightWidth;

        if (isDirectionRow) {
          res = res.map(function (item) {
            return item + mbp;
          });
        } else {
          var _mbp = this.__calSize(marginTop, w, isDirectItem) + this.__calSize(marginBottom, w, isDirectItem) + this.__calSize(paddingTop, w, isDirectItem) + this.__calSize(paddingBottom, w, isDirectItem) + borderTopWidth + borderBottomWidth;

          res = res.map(function (item) {
            return item + _mbp;
          });
        }

        return res;
      } // absolute且无尺寸时，isAbs标明先假布局一次计算尺寸，还有flex列计算时isColumn假布局，flex横计算时writingMode垂直假布局

    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        this.__computeReflow();

        var w = data.w;
        var isDestroyed = this.isDestroyed,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __config = this.__config,
            __ellipsis = this.__ellipsis; // 虚拟省略号每次清除

        if (__ellipsis) {
          this.__ellipsis = null;
        }

        this.__parentLineBox = null;
        this.__isIbFull = false;
        var display = computedStyle[DISPLAY$2],
            position = computedStyle[POSITION$2];
        this.__layoutData = {
          x: data.x,
          y: data.y,
          w: w,
          h: data.h,
          lx: data.lx,
          ly: data.ly,
          isUpright: data.isUpright // 从Root开始，父级的书写模式需每层传递

        }; // 防止display:none不统计mask，isVirtual忽略，abs/flex布局后续会真正来走一遍

        if (!isAbs && !isColumn && !isRow) {
          this.clearCache();
          __config[NODE_REFRESH_LV] = REFLOW;
          __config[NODE_LIMIT_CACHE$1] = false;
          __config[NODE_IS_INLINE] = false;
          var next = this.next; // mask关系只有布局才会变更，普通渲染关系不会改变，clip也是mask的一种

          if (!this.isMask && next && next.isMask) {
            var count = 0;

            while (next) {
              if (next.isMask) {
                count++;
              } else {
                break;
              }

              next = next.next;
            }

            this.__hasMask = count;
          }
        }

        this.__ox = this.__oy = 0;

        if (isDestroyed || display === 'none') {
          this.__width = this.__height = this.__clientWidth = this.__clientHeight = this.__offsetWidth = this.__offsetHeight = this.__outerWidth = this.__outerHeight = computedStyle[WIDTH$4] = computedStyle[HEIGHT$4] = 0;
          this.__x = data.x;
          this.__y = data.y;

          this.__layoutNone();

          this.__hasComputeReflow = false;
          return;
        } // absolute特殊，在自己布局时已计算相对于容器的mbp


        if (position !== 'absolute') {
          this.__mp(currentStyle, computedStyle, w);
        } // 只有inline会继承计算行数，其它都是原样返回


        var lineClampCount = data.lineClampCount || 0; // 4种布局，默认block，inlineBlock基本可以复用inline逻辑，除了尺寸

        if (display === 'flex') {
          data.lineClampCount = 0;

          this.__layoutFlex(data, isAbs, isColumn, isRow);
        } else if (display === 'inlineBlock') {
          data.lineClampCount = 0;

          this.__layoutInline(data, isAbs, isColumn, isRow);
        } else if (display === 'inline') {
          lineClampCount = this.__layoutInline(data, isAbs, isColumn, isRow, true);
        } else {
          data.lineClampCount = 0;

          this.__layoutBlock(data, isAbs, isColumn, isRow);
        } // relative渲染时做偏移，百分比基于父元素，若父元素没有定高则为0


        if (!isAbs && !isColumn && !isRow) {
          if (position === 'relative') {
            var top = currentStyle[TOP$1],
                right = currentStyle[RIGHT],
                bottom = currentStyle[BOTTOM$1],
                left = currentStyle[LEFT];
            var parent = this.parent;

            if (top[1] !== AUTO$3) {
              var n = calRelative$1(currentStyle, TOP$1, top, parent);

              this.__offsetY(n);

              computedStyle[TOP$1] = n;
              computedStyle[BOTTOM$1] = 'auto';
            } else if (bottom[1] !== AUTO$3) {
              var _n = calRelative$1(currentStyle, BOTTOM$1, bottom, parent);

              this.__offsetY(-_n);

              computedStyle[BOTTOM$1] = _n;
              computedStyle[TOP$1] = 'auto';
            } else {
              computedStyle[TOP$1] = computedStyle[BOTTOM$1] = 'auto';
            }

            if (left[1] !== AUTO$3) {
              var _n2 = calRelative$1(currentStyle, LEFT, left, parent, true);

              this.__offsetX(_n2);

              computedStyle[LEFT] = _n2;
              computedStyle[RIGHT] = 'auto';
            } else if (right[1] !== AUTO$3) {
              var _n3 = calRelative$1(currentStyle, RIGHT, right, parent, true);

              this.__offsetX(-_n3);

              computedStyle[RIGHT] = _n3;
              computedStyle[LEFT] = 'auto';
            } else {
              computedStyle[LEFT] = computedStyle[RIGHT] = 'auto';
            }
          } else if (position !== 'absolute') {
            computedStyle[TOP$1] = computedStyle[BOTTOM$1] = computedStyle[LEFT] = computedStyle[RIGHT] = 'auto';
          } // 计算结果存入computedStyle和6个坐标，inline在其inlineSize特殊处理


          var x = this.__sx = this.x + this.ox;
          var y = this.__sy = this.y + this.oy;

          if (!__config[NODE_IS_INLINE]) {
            x = this.__sx1 = x + computedStyle[MARGIN_LEFT$2];
            x = this.__sx2 = x + computedStyle[BORDER_LEFT_WIDTH$3];
            x = this.__sx3 = x + computedStyle[PADDING_LEFT$3];
            x = this.__sx4 = x + this.width;
            x = this.__sx5 = x + computedStyle[PADDING_RIGHT$2];
            this.__sx6 = x + computedStyle[BORDER_RIGHT_WIDTH$2];
            y = this.__sy1 = y + computedStyle[MARGIN_TOP$2];
            y = this.__sy2 = y + computedStyle[BORDER_TOP_WIDTH$3];
            y = this.__sy3 = y + computedStyle[PADDING_TOP$3];
            y = this.__sy4 = y + this.height;
            y = this.__sy5 = y + computedStyle[PADDING_BOTTOM$3];
            this.__sy6 = y + computedStyle[BORDER_BOTTOM_WIDTH$3];
          }

          computedStyle[WIDTH$4] = this.width;
          computedStyle[HEIGHT$4] = this.height; // abs为parse的根节点时特殊自己执行，前提是真布局

          if (position !== 'absolute') {
            this.__execAr();
          }

          this.__hasComputeReflow = false;
        }

        return lineClampCount;
      }
    }, {
      key: "__execAr",
      value: function __execAr() {
        // 动态json引用时动画暂存，第一次布局时处理这些动画到root的animateController上
        var ar = this.__animateRecords;

        if (ar) {
          this.__animateRecords = null; // parse没有dom时，animate的target引用都是json，vd后生成需重新赋值

          ar.list.forEach(function (item) {
            if (item.target.vd instanceof Xom) {
              item.target = item.target.vd;
            }
          });
          var ac = ar.controller || this.root.animateController; // 不自动播放进入记录列表，初始化并等待手动调用

          if (ar.options && ar.options.autoPlay === false) {
            ac.__records2 = ac.__records2.concat(ar.list);
            ac.init(ac.__records2, ac.list2);
          } else {
            ac.__records = ac.__records.concat(ar.list);

            ac.__playAuto();
          }
        }
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        var computedStyle = this.computedStyle;
        computedStyle[DISPLAY$2] = 'none';
        computedStyle[MARGIN_TOP$2] = computedStyle[MARGIN_RIGHT$2] = computedStyle[MARGIN_BOTTOM$2] = computedStyle[MARGIN_LEFT$2] = computedStyle[BORDER_TOP_WIDTH$3] = computedStyle[BORDER_RIGHT_WIDTH$2] = computedStyle[BORDER_BOTTOM_WIDTH$3] = computedStyle[BORDER_LEFT_WIDTH$3] = computedStyle[PADDING_TOP$3] = computedStyle[PADDING_RIGHT$2] = computedStyle[PADDING_BOTTOM$3] = computedStyle[PADDING_LEFT$3] = computedStyle[WIDTH$4] = computedStyle[HEIGHT$4] = this.__width = this.__height = 0;
      } // 预先计算是否是固定宽高，布局点位和尺寸考虑margin/border/padding

    }, {
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            w2 = data.w2,
            h2 = data.h2,
            w3 = data.w3,
            h3 = data.h3,
            lx = data.lx,
            ly = data.ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            isParentVertical = data.isUpright;
        this.__x = x;
        this.__y = y;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var width = currentStyle[WIDTH$4],
            height = currentStyle[HEIGHT$4];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$2],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$3],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3],
            marginTop = computedStyle[MARGIN_TOP$2],
            marginRight = computedStyle[MARGIN_RIGHT$2],
            marginBottom = computedStyle[MARGIN_BOTTOM$2],
            marginLeft = computedStyle[MARGIN_LEFT$2],
            paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$2],
            paddingBottom = computedStyle[PADDING_BOTTOM$3],
            paddingLeft = computedStyle[PADDING_LEFT$3],
            writingMode = computedStyle[WRITING_MODE$1];
        var isUpright = writingMode.indexOf('vertical') === 0; // 除了auto外都是固定宽高度

        var fixedWidth;
        var fixedHeight; // 绝对定位是left+right这种其实等于定义了width，但不能修改原始style，存入特殊变量标识

        if (w2 !== undefined) {
          fixedWidth = true;
          w = w2;
        } // flex时也会用到，子级得出目标主尺寸后按这个来
        else if (w3 !== undefined) {
          fixedWidth = true;
          w = w3;
        } else if (width[1] !== AUTO$3 && !isInline) {
          fixedWidth = true;
          w = this.__calSize(width, w, true);
        }

        if (h2 !== undefined) {
          fixedHeight = true;
          h = h2;
        } else if (h3 !== undefined) {
          fixedHeight = true;
          h = h3;
        } else if (height[1] !== AUTO$3 && !isInline) {
          fixedHeight = true;
          h = this.__calSize(height, h, true);
        } // margin/border/padding影响x和y和尺寸，注意inline的y不受mpb影响（垂直模式则是x）


        if (!isInline) {
          x += borderLeftWidth + marginLeft + paddingLeft;
          y += borderTopWidth + marginTop + paddingTop;
        } else {
          if (isUpright) {
            y += borderTopWidth + marginTop + paddingTop;
          } else {
            x += borderLeftWidth + marginLeft + paddingLeft;
          }
        }

        data.x = x;
        data.y = y; // inline的w/h很特殊，需不考虑inline自身水平的mpb以便换行，因为mpb只在首尾行生效，所以首尾需特殊处理中间忽略
        // 当嵌套inline时更加复杂，假如inline有尾部mpb，最后一行需考虑，如果此inline是父的最后一个且父有mpb需叠加

        var selfEndSpace = 0;

        if (isInline) {
          if (isUpright) {
            selfEndSpace = paddingBottom + borderBottomWidth + marginBottom;
          } else {
            selfEndSpace = paddingRight + borderRightWidth + marginRight;
          }
        } // 传入w3/h3时，flex的item已知目标主尺寸，需减去mbp，其一定是block，和inline互斥


        if (!isInline) {
          if (width[1] === AUTO$3 || w3 !== undefined) {
            w -= borderLeftWidth + borderRightWidth + marginLeft + marginRight + paddingLeft + paddingRight;
          }

          if (height[1] === AUTO$3 || h3 !== undefined) {
            h -= borderTopWidth + borderBottomWidth + marginTop + marginBottom + paddingTop + paddingBottom;
          }
        }

        return {
          fixedWidth: fixedWidth,
          fixedHeight: fixedHeight,
          x: x,
          y: y,
          w: w,
          h: h,
          lx: lx,
          ly: ly,
          lineBoxManager: lineBoxManager,
          endSpace: endSpace,
          selfEndSpace: selfEndSpace,
          isParentVertical: isParentVertical,
          isUpright: isUpright
        };
      } // 处理margin:xx auto居中对齐或右对齐

    }, {
      key: "__marginAuto",
      value: function __marginAuto(style, data, isUpright) {
        var position = style[POSITION$2],
            display = style[DISPLAY$2],
            marginTop = style[MARGIN_TOP$2],
            marginBottom = style[MARGIN_BOTTOM$2],
            marginLeft = style[MARGIN_LEFT$2],
            marginRight = style[MARGIN_RIGHT$2],
            width = style[WIDTH$4],
            height = style[HEIGHT$4];

        if (position !== 'absolute' && (display === 'block' || display === 'flex')) {
          if (isUpright) {
            if ((height[1] !== AUTO$3 || this.isReplaced) && marginTop[1] === AUTO$3 && marginBottom[1] === AUTO$3) {
              var oh = this.outerHeight;

              if (oh < data.h) {
                this.__offsetY((data.h - oh) * 0.5, true);
              }
            }
          } else {
            if ((width[1] !== AUTO$3 || this.isReplaced) && marginLeft[1] === AUTO$3 && marginRight[1] === AUTO$3) {
              var ow = this.outerWidth;

              if (ow < data.w) {
                this.__offsetX((data.w - ow) * 0.5, true);
              }
            }
          }
        }
      }
    }, {
      key: "__calMatrix",
      value: function __calMatrix(lv, __cacheStyle, currentStyle, computedStyle, __config, sx1, sy1, offsetWidth, offsetHeight) {
        var _this4 = this;

        if (__config[NODE_IS_INLINE]) {
          computedStyle[TRANSFORM_ORIGIN$4] = [sx1, sy1];
          return __cacheStyle[MATRIX$3] = mx.identity();
        }

        var matrixCache = __cacheStyle[MATRIX$3]; // tx/ty变化特殊优化

        if (matrixCache && lv < REFLOW && !contain(lv, TF)) {
          var x = 0,
              y = 0,
              z = 0;

          if (contain(lv, TX)) {
            var v = currentStyle[TRANSLATE_X$4];

            if (isNil$6(v)) {
              v = 0;
            } else {
              v = this.__calSize(v, this.offsetWidth, true);
            }

            x = v - (computedStyle[TRANSLATE_X$4] || 0);
            computedStyle[TRANSLATE_X$4] = v;
            computedStyle[TRANSFORM$3][12] += x;
            matrixCache[12] += x;
          }

          if (contain(lv, TY)) {
            var _v = currentStyle[TRANSLATE_Y$4];

            if (isNil$6(_v)) {
              _v = 0;
            } else {
              _v = this.__calSize(_v, this.offsetHeight, true);
            }

            y = _v - (computedStyle[TRANSLATE_Y$4] || 0);
            computedStyle[TRANSLATE_Y$4] = _v;
            computedStyle[TRANSFORM$3][13] += y;
            matrixCache[13] += y;
          }

          if (contain(lv, TZ)) {
            var _v2 = currentStyle[TRANSLATE_Z$4];

            if (isNil$6(_v2)) {
              _v2 = 0;
            } else {
              _v2 = this.__calSize(_v2, this.offsetWidth, true);
            }

            z = _v2 - (computedStyle[TRANSLATE_Z$4] || 0);
            computedStyle[TRANSLATE_Z$4] = _v2;
            computedStyle[TRANSFORM$3][14] += z;
            matrixCache[14] += z;
          }

          __cacheStyle[MATRIX$3] = matrixCache;
        } // 先根据cache计算需要重新计算的computedStyle
        else {
          if (sx1 === undefined) {
            sx1 = this.__sx1;
            sy1 = this.__sy1;
            offsetWidth = this.offsetWidth;
            offsetHeight = this.offsetHeight;
          }

          if (__cacheStyle[TRANSFORM_ORIGIN$4] === undefined) {
            __cacheStyle[TRANSFORM_ORIGIN$4] = true;
            matrixCache = null;
            computedStyle[TRANSFORM_ORIGIN$4] = currentStyle[TRANSFORM_ORIGIN$4].map(function (item, i) {
              return _this4.__calSize(item, i ? offsetHeight : offsetWidth, true);
            });
          }

          if (__cacheStyle[TRANSFORM$3] === undefined || __cacheStyle[TRANSLATE_X$4] === undefined || __cacheStyle[TRANSLATE_Y$4] === undefined || __cacheStyle[TRANSLATE_Z$4] === undefined || __cacheStyle[ROTATE_X$2] === undefined || __cacheStyle[ROTATE_Y$2] === undefined || __cacheStyle[ROTATE_Z$4] === undefined || __cacheStyle[ROTATE_3D$3] === undefined || __cacheStyle[SCALE_X$3] === undefined || __cacheStyle[SCALE_Y$3] === undefined || __cacheStyle[SCALE_Z$2] === undefined || __cacheStyle[SKEW_X$2] === undefined || __cacheStyle[SKEW_Y$2] === undefined) {
            __cacheStyle[TRANSFORM$3] = __cacheStyle[TRANSLATE_X$4] = __cacheStyle[TRANSLATE_Y$4] = __cacheStyle[TRANSLATE_Z$4] = __cacheStyle[ROTATE_X$2] = __cacheStyle[ROTATE_Y$2] = __cacheStyle[ROTATE_Z$4] = __cacheStyle[SCALE_X$3] = __cacheStyle[SCALE_Y$3] = __cacheStyle[SCALE_Z$2] = __cacheStyle[SKEW_X$2] = __cacheStyle[SKEW_Y$2] = true;
            matrixCache = null;
            var matrix; // transform相对于自身

            if (currentStyle[TRANSFORM$3]) {
              matrix = transform$1.calMatrix(currentStyle[TRANSFORM$3], offsetWidth, offsetHeight, this.root);
            } // 没有transform则看是否有扩展的css独立变换属性
            else {
              var temp = [];
              [TRANSLATE_X$4, TRANSLATE_Y$4, TRANSLATE_Z$4, ROTATE_X$2, ROTATE_Y$2, ROTATE_Z$4, ROTATE_3D$3, SKEW_X$2, SKEW_Y$2, SCALE_X$3, SCALE_Y$3, SCALE_Z$2].forEach(function (k) {
                // 删除之前遗留的
                delete computedStyle[k];
                var v = currentStyle[k];

                if (isNil$6(v)) {
                  return;
                }

                if (k === ROTATE_3D$3) {
                  computedStyle[k] = [v[0], v[1], v[2], v[3][0]];

                  if (v[3][0] === 0) {
                    return;
                  }

                  temp.push([k, v]);
                  return;
                }

                computedStyle[k] = v[0]; // scale为1和其它为0避免计算浪费

                var isScale = k === SCALE_X$3 || k === SCALE_Y$3 || k === SCALE_Z$2;

                if (v[0] === 1 && isScale || !isScale && v[0] === 0) {
                  return;
                }

                var p = k === TRANSLATE_X$4 || k === TRANSLATE_Z$4 ? offsetWidth : offsetHeight;
                computedStyle[k] = _this4.__calSize(v, p, true);
                temp.push([k, v]);
              });

              if (temp.length) {
                matrix = transform$1.calMatrix(temp, offsetWidth, offsetHeight, this.root);
              }
            }

            computedStyle[TRANSFORM$3] = matrix || mx.identity();
          }

          if (!matrixCache) {
            var m = computedStyle[TRANSFORM$3];
            var tfo = computedStyle[TRANSFORM_ORIGIN$4].slice(0);
            tfo[0] += sx1 || 0;
            tfo[1] += sy1 || 0;
            matrixCache = __cacheStyle[MATRIX$3] = transform$1.calMatrixByOrigin(m, tfo);
          }
        }

        return matrixCache;
      }
      /**
       * 将currentStyle计算为computedStyle，同时存入cacheStyle可缓存的结果防止无变更重复计算
       * @param renderMode
       * @param ctx
       * @param parent
       * @param __cacheStyle
       * @param currentStyle
       * @param computedStyle
       * @param clientWidth
       * @param clientHeight
       * @param offsetWidth
       * @param offsetHeight
       * @param borderTopWidth
       * @param borderRightWidth
       * @param borderBottomWidth
       * @param borderLeftWidth
       * @param paddingTop
       * @param paddingRight
       * @param paddingBottom
       * @param paddingLeft
       * @param x1
       * @param x2
       * @param x3
       * @param x4
       * @param x5
       * @param x6
       * @param y1
       * @param y2
       * @param y3
       * @param y4
       * @param y5
       * @param y6
       * @returns {*[]}
       * @private
       */

    }, {
      key: "__calCache",
      value: function __calCache(renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6) {
        var _this5 = this;

        var bx1 = x1,
            by1 = y1,
            bx2 = x6,
            by2 = y6;
        var backgroundClip = computedStyle[BACKGROUND_CLIP$2] = currentStyle[BACKGROUND_CLIP$2]; // 默认border-box

        if (backgroundClip === 'paddingBox') {
          bx1 = x2;
          by1 = y2;
          bx2 = x5;
          by2 = y5;
        } else if (backgroundClip === 'contentBox') {
          bx1 = x3;
          by1 = y3;
          bx2 = x4;
          by2 = y4;
        }

        var isInline = this.__config[NODE_IS_INLINE];

        if (isInline && !this.contentBoxList.length) {
          isInline = false;
        } // 这些直接赋值的不需要再算缓存


        [OPACITY$3, Z_INDEX$2, BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE, BORDER_LEFT_STYLE, BACKGROUND_REPEAT, OVERFLOW$1, MIX_BLEND_MODE, TEXT_OVERFLOW$2, BACKGROUND_CLIP$2].forEach(function (k) {
          computedStyle[k] = currentStyle[k];
        });

        if (isNil$6(__cacheStyle[FILTER$4])) {
          __cacheStyle[FILTER$4] = true;

          this.__calFilter(currentStyle, computedStyle);
        }

        if (isNil$6(__cacheStyle[BACKGROUND_POSITION_X$3])) {
          __cacheStyle[BACKGROUND_POSITION_X$3] = true;
          var bgX = currentStyle[BACKGROUND_POSITION_X$3];
          computedStyle[BACKGROUND_POSITION_X$3] = (bgX || []).map(function (item) {
            if (item[1] === PERCENT$5) {
              return item[0] + '%';
            }

            return _this5.__calSize(item, bx2 - bx1, true);
          });
        }

        if (isNil$6(__cacheStyle[BACKGROUND_POSITION_Y$3])) {
          __cacheStyle[BACKGROUND_POSITION_Y$3] = true;
          var bgY = currentStyle[BACKGROUND_POSITION_Y$3];
          computedStyle[BACKGROUND_POSITION_Y$3] = (bgY || []).map(function (item) {
            if (item[1] === PERCENT$5) {
              return item[0] + '%';
            }

            return _this5.__calSize(item, by2 - by1, true);
          });
        }

        if (isNil$6(__cacheStyle[BACKGROUND_SIZE$2])) {
          __cacheStyle[BACKGROUND_SIZE$2] = true;
          computedStyle[BACKGROUND_SIZE$2] = (currentStyle[BACKGROUND_SIZE$2] || []).map(function (item) {
            if (Array.isArray(item)) {
              // 每项是x/y2个
              return item.map(function (item2, i) {
                if (item2[1] === AUTO$3) {
                  return -1;
                } else if (item2[1] === STRING$2) {
                  return item2[0] === 'contain' ? -2 : -3;
                }

                return _this5.__calSize(item2, i ? by2 - by1 : bx2 - bx1, true);
              });
            }
          });
        }

        if (isNil$6(__cacheStyle[BACKGROUND_IMAGE$1])) {
          var bgI = currentStyle[BACKGROUND_IMAGE$1];
          computedStyle[BACKGROUND_IMAGE$1] = bgI.map(function (item) {
            if (item) {
              return item[0];
            }

            return null;
          });
          __cacheStyle[BACKGROUND_IMAGE$1] = bgI.map(function (bgi, i) {
            if (!bgi) {
              return null;
            } // 防止隐藏不加载背景图


            if (bgi[1] === STRING$2) {
              var loadBgi = _this5.__loadBgi[i] = _this5.__loadBgi[i] || {};
              var cache = inject.IMG[bgi[0]];

              if (cache && cache.state === inject.LOADED) {
                loadBgi.url = bgi[0];
                loadBgi.source = cache.source;
                loadBgi.width = cache.width;
                loadBgi.height = cache.height;
              } else if (loadBgi.url !== bgi[0]) {
                // 可能改变导致多次加载，每次清空，成功后还要比对url是否相同
                loadBgi.url = bgi[0];
                loadBgi.source = null;
                var node = _this5;
                var root = node.root;
                inject.measureImg(bgi[0], function (data) {
                  // 还需判断url，防止重复加载时老的替换新的，失败不绘制bgi
                  if (data.success && data.url === loadBgi.url && !_this5.isDestroyed) {
                    loadBgi.source = data.source;
                    loadBgi.width = data.width;
                    loadBgi.height = data.height;
                    root.delRefreshTask(loadBgi.cb);
                    root.addRefreshTask(loadBgi.cb = {
                      __before: function __before() {
                        __cacheStyle[BACKGROUND_IMAGE$1] = undefined;
                        var res = {};
                        res[UPDATE_NODE$2] = node;
                        res[UPDATE_FOCUS$1] = REPAINT$1;
                        res[UPDATE_CONFIG$2] = node.__config;

                        root.__addUpdate(node, node.__config, root, root.__config, res);
                      }
                    });
                  }
                }, {
                  ctx: ctx,
                  root: root,
                  width: bx2 - bx1,
                  height: by2 - by1
                });
              }

              return true;
            } else if (!isInline && bgi[0] && bgi[1] === GRADIENT$2) {
              // gradient在渲染时才生成
              return true;
            }
          });
        }

        if (isNil$6(__cacheStyle[BOX_SHADOW$2])) {
          __cacheStyle[BOX_SHADOW$2] = true;
          computedStyle[BOX_SHADOW$2] = (currentStyle[BOX_SHADOW$2] || []).map(function (item) {
            return item.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this5.__calSize(item2, i === 0 ? bx2 - bx1 : by2 - by1, true);
            });
          });
        }

        [BACKGROUND_COLOR$1, BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR, BORDER_LEFT_COLOR].forEach(function (k) {
          if (isNil$6(__cacheStyle[k])) {
            __cacheStyle[k] = int2rgba$3(computedStyle[k] = currentStyle[k][0]);
          }
        }); // 圆角边计算

        if (isNil$6(__cacheStyle[BORDER_TOP_LEFT_RADIUS$1]) || isNil$6(__cacheStyle[BORDER_TOP_RIGHT_RADIUS$1]) || isNil$6(__cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1]) || isNil$6(__cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1])) {
          __cacheStyle[BORDER_TOP_LEFT_RADIUS$1] = __cacheStyle[BORDER_TOP_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1] = true; // 非替代的inline计算看contentBox首尾

          if (isInline) {
            border.calBorderRadiusInline(this.contentBoxList, currentStyle, computedStyle, this.root);
          } // 普通block整体计算
          else {
            border.calBorderRadius(offsetWidth, offsetHeight, currentStyle, computedStyle, this.root);
          }
        } // width/style/radius影响border，color不影响渲染缓存


        var btlr = computedStyle[BORDER_TOP_LEFT_RADIUS$1];
        var btrr = computedStyle[BORDER_TOP_RIGHT_RADIUS$1];
        var bbrr = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1];
        var bblr = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1];
        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          k = 'border' + k;
          var k2 = STYLE_KEY$5[style2Upper$2(k)];
          var kw = STYLE_KEY$5[style2Upper$2(k + 'Width')];
          var ks = STYLE_KEY$5[style2Upper$2(k + 'Style')]; // width/style变更影响border重新计算

          if (isNil$6(__cacheStyle[kw])) {
            __cacheStyle[kw] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$6(__cacheStyle[ks])) {
            __cacheStyle[ks] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$6(__cacheStyle[k2])) {
            if (k2 === BORDER_TOP) {
              if (borderTopWidth > 0) {
                if (!isInline) {
                  var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                  var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                  __cacheStyle[k2] = border.calPoints(borderTopWidth, computedStyle[ks], deg1, deg2, x1, x2, x5, x6, y1, y2, y5, y6, 0, btlr, btrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_RIGHT) {
              if (borderRightWidth > 0) {
                if (!isInline) {
                  var _deg = Math.atan(borderRightWidth / borderTopWidth);

                  var _deg2 = Math.atan(borderRightWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderRightWidth, computedStyle[ks], _deg, _deg2, x1, x2, x5, x6, y1, y2, y5, y6, 1, btrr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_BOTTOM) {
              if (borderBottomWidth > 0) {
                if (!isInline) {
                  var _deg3 = Math.atan(borderBottomWidth / borderLeftWidth);

                  var _deg4 = Math.atan(borderBottomWidth / borderRightWidth);

                  __cacheStyle[k2] = border.calPoints(borderBottomWidth, computedStyle[ks], _deg3, _deg4, x1, x2, x5, x6, y1, y2, y5, y6, 2, bblr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_LEFT) {
              if (borderLeftWidth > 0) {
                if (!isInline) {
                  var _deg5 = Math.atan(borderLeftWidth / borderTopWidth);

                  var _deg6 = Math.atan(borderLeftWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderLeftWidth, computedStyle[ks], _deg5, _deg6, x1, x2, x5, x6, y1, y2, y5, y6, 3, btlr, bblr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            }
          }
        }); // 强制计算继承性的

        var parentComputedStyle = parent && parent.computedStyle;

        if (currentStyle[FONT_STYLE$4][1] === INHERIT$3) {
          computedStyle[FONT_STYLE$4] = parent ? parentComputedStyle[FONT_STYLE$4] : 'normal';
        } else if (isNil$6(__cacheStyle[FONT_STYLE$4])) {
          computedStyle[FONT_STYLE$4] = currentStyle[FONT_STYLE$4][0];
        }

        __cacheStyle[FONT_STYLE$4] = computedStyle[FONT_STYLE$4];
        var color = currentStyle[COLOR$5];

        if (color[1] === INHERIT$3) {
          var v = computedStyle[COLOR$5] = parent ? parentComputedStyle[COLOR$5] : [0, 0, 0, 1];

          if (v.k) {
            __cacheStyle[COLOR$5] = v;
          } else {
            __cacheStyle[COLOR$5] = int2rgba$3(computedStyle[COLOR$5]);
          }
        } else if (isNil$6(__cacheStyle[COLOR$5])) {
          if (color[1] === GRADIENT$2) {
            __cacheStyle[COLOR$5] = computedStyle[COLOR$5] = color[0];
          } else if (color[1] === RGBA$2) {
            __cacheStyle[COLOR$5] = int2rgba$3(computedStyle[COLOR$5] = rgba2int$3(color[0]));
          }
        }

        var textStrokeColor = currentStyle[TEXT_STROKE_COLOR$4];

        if (textStrokeColor[1] === INHERIT$3) {
          var _v3 = computedStyle[TEXT_STROKE_COLOR$4] = parent ? parentComputedStyle[TEXT_STROKE_COLOR$4] : [0, 0, 0, 1];

          if (_v3.k) {
            __cacheStyle[TEXT_STROKE_COLOR$4] = _v3;
          } else {
            __cacheStyle[TEXT_STROKE_COLOR$4] = int2rgba$3(computedStyle[TEXT_STROKE_COLOR$4]);
          }
        } else if (isNil$6(__cacheStyle[TEXT_STROKE_COLOR$4])) {
          if (textStrokeColor[1] === GRADIENT$2) {
            __cacheStyle[TEXT_STROKE_COLOR$4] = computedStyle[TEXT_STROKE_COLOR$4] = textStrokeColor[0];
          } else if (textStrokeColor[1] === RGBA$2) {
            __cacheStyle[TEXT_STROKE_COLOR$4] = int2rgba$3(computedStyle[TEXT_STROKE_COLOR$4] = rgba2int$3(textStrokeColor[0]));
          }
        }

        if (currentStyle[TEXT_STROKE_WIDTH$3][1] === INHERIT$3) {
          computedStyle[TEXT_STROKE_WIDTH$3] = parent ? parentComputedStyle[TEXT_STROKE_WIDTH$3] : 0;
          __cacheStyle[TEXT_STROKE_WIDTH$3] = true;
        } else if (isNil$6(__cacheStyle[TEXT_STROKE_WIDTH$3])) {
          var _v4 = currentStyle[TEXT_STROKE_WIDTH$3];

          if (_v4[1] === REM$5) {
            _v4 = _v4[0] * this.root.computedStyle[FONT_SIZE$9];
          } else if (_v4[1] === VW$5) {
            _v4 = _v4[0] * this.root.width * 0.01;
          } else if (_v4[1] === VH$5) {
            _v4 = _v4[0] * this.root.height * 0.01;
          } else if (_v4[1] === VMAX$5) {
            _v4 = _v4[0] * Math.max(this.root.width, this.root.height) * 0.01;
          } else if (_v4[1] === VMIN$5) {
            _v4 = _v4[0] * Math.min(this.root.width, this.root.height) * 0.01;
          } else {
            _v4 = _v4[0];
          }

          computedStyle[TEXT_STROKE_WIDTH$3] = _v4;
          __cacheStyle[TEXT_STROKE_WIDTH$3] = true;
        }

        if (currentStyle[TEXT_STROKE_OVER$3][1] === INHERIT$3) {
          __cacheStyle[TEXT_STROKE_OVER$3] = computedStyle[TEXT_STROKE_OVER$3] = parent ? parentComputedStyle[TEXT_STROKE_OVER$3] : 'none';
        } else {
          __cacheStyle[TEXT_STROKE_OVER$3] = computedStyle[TEXT_STROKE_OVER$3] = currentStyle[TEXT_STROKE_OVER$3][0];
        }

        if (currentStyle[VISIBILITY$2][1] === INHERIT$3) {
          computedStyle[VISIBILITY$2] = parent ? parentComputedStyle[VISIBILITY$2] : 'visible';
        } else if (isNil$6(__cacheStyle[VISIBILITY$2])) {
          computedStyle[VISIBILITY$2] = currentStyle[VISIBILITY$2][0];
        }

        __cacheStyle[VISIBILITY$2] = computedStyle[VISIBILITY$2];

        if (currentStyle[POINTER_EVENTS$1][1] === INHERIT$3) {
          computedStyle[POINTER_EVENTS$1] = parent ? parentComputedStyle[POINTER_EVENTS$1] : 'auto';
        } else if (isNil$6(__cacheStyle[POINTER_EVENTS$1])) {
          computedStyle[POINTER_EVENTS$1] = currentStyle[POINTER_EVENTS$1][0];
        }

        __cacheStyle[POINTER_EVENTS$1] = computedStyle[POINTER_EVENTS$1];
        this.__bx1 = bx1;
        this.__bx2 = bx2;
        this.__by1 = by1;
        this.__by2 = by2;
        return [bx1, by1, bx2, by2];
      }
    }, {
      key: "__calPerspective",
      value: function __calPerspective(__cacheStyle, currentStyle, computedStyle, __config, sx1, sy1) {
        var _this6 = this;

        var rebuild;

        if (isNil$6(__cacheStyle[PERSPECTIVE$3])) {
          __cacheStyle[PERSPECTIVE$3] = true;
          rebuild = true;
          var v = currentStyle[PERSPECTIVE$3];

          var ppt = this.__calSize(v, this.clientWidth, true);

          computedStyle[PERSPECTIVE$3] = ppt;
        }

        if (isNil$6(__cacheStyle[PERSPECTIVE_ORIGIN$3])) {
          __cacheStyle[PERSPECTIVE_ORIGIN$3] = true;
          rebuild = true;
          computedStyle[PERSPECTIVE_ORIGIN$3] = currentStyle[PERSPECTIVE_ORIGIN$3].map(function (item, i) {
            return _this6.__calSize(item, i ? _this6.offsetHeight : _this6.offsetWidth, true);
          });
        }

        if (rebuild) {
          if (sx1 === undefined) {
            sx1 = this.__sx1;
            sy1 = this.__sy1;
          }

          var po = computedStyle[PERSPECTIVE_ORIGIN$3].slice(0);
          po[0] += sx1 || 0;
          po[1] += sy1 || 0;
          __config[NODE_PERSPECTIVE_MATRIX] = transform$1.calPerspectiveMatrix(computedStyle[PERSPECTIVE$3], po);
        }
      }
    }, {
      key: "__calFilter",
      value: function __calFilter(currentStyle, computedStyle) {
        var _this7 = this;

        return computedStyle[FILTER$4] = (currentStyle[FILTER$4] || []).map(function (item) {
          var _item = _slicedToArray(item, 2),
              k = _item[0],
              v = _item[1];

          if (k === 'dropShadow') {
            var v2 = v.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this7.__calSize(item2, i === 0 ? _this7.__bx2 - _this7.__bx1 : _this7.__by2 - _this7.__by1, true);
            });
            return [k, v2];
          } else {
            // 部分%单位的滤镜强制使用数字
            if (v[1] === DEG$4 || v[1] === PERCENT$5 || v[1] === NUMBER$5) {
              v = v[0];
            } else {
              v = _this7.__calSize(v, _this7.root.width, false);
            }

            return [k, v];
          }
        });
      }
    }, {
      key: "__calContent",
      value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
        if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          if (lv < REPAINT$1) {
            return this.__hasContent;
          }

          var visibility = currentStyle[VISIBILITY$2];

          if (visibility !== 'hidden') {
            var bgI = currentStyle[BACKGROUND_IMAGE$1];

            if (Array.isArray(bgI)) {
              for (var i = 0, len = bgI.length; i < len; i++) {
                if (bgI[i]) {
                  return true;
                }
              }
            }

            if (currentStyle[BACKGROUND_COLOR$1][0][3] > 0) {
              var width = computedStyle[WIDTH$4],
                  height = computedStyle[HEIGHT$4],
                  paddingTop = computedStyle[PADDING_TOP$3],
                  paddingRight = computedStyle[PADDING_RIGHT$2],
                  paddingBottom = computedStyle[PADDING_BOTTOM$3],
                  paddingLeft = computedStyle[PADDING_LEFT$3];

              if (width && height || paddingTop || paddingRight || paddingBottom || paddingLeft) {
                return true;
              }
            }

            for (var list = ['Top', 'Right', 'Bottom', 'Left'], _i = 0, _len = list.length; _i < _len; _i++) {
              var k = list[_i];

              if (computedStyle[STYLE_KEY$5[style2Upper$2('border' + k + 'Width')]] > 0 && currentStyle[STYLE_KEY$5[style2Upper$2('border' + k + 'Color')]][0][3] > 0) {
                return true;
              }
            }

            var _bs = currentStyle[BOX_SHADOW$2];

            if (Array.isArray(_bs)) {
              for (var _i2 = 0, _len2 = _bs.length; _i2 < _len2; _i2++) {
                var item = _bs[_i2];

                if (item && item[4][3] > 0) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      }
      /**
       * 渲染基础方法，Dom/Geom公用
       * @param renderMode
       * @see node/mode
       * @param lv
       * @see refresh/level
       * @param ctx canvas/svg/webgl共用
       * @param cache 是否是局部根节点缓存模式下的绘制
       * @see refresh/Cache.NA
       * @param dx cache时偏移x
       * @param dy cache时偏移y
       * @return Object
       * x1/x2/x3/x4/y1/y2/y3/y4 坐标
       * break svg判断无变化提前跳出
       * cacheError 离屏申请失败，仅canvas
       * offscreenBlend 无cache时的离屏canvas，仅canvas
       * offscreenFilter 无cache时的离屏canvas，仅canvas
       * offscreenOverflow 无cache时的离屏canvas，仅canvas
       * offscreenMask 无cache时的离屏canvas，仅canvas
       */

    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache) {
        var _this8 = this;

        var dx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var dy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        var isDestroyed = this.isDestroyed,
            root = this.root,
            __config = this.__config;
        var __cache = __config[NODE_CACHE$1];
        var __cacheStyle = __config[NODE_CACHE_STYLE];
        var currentStyle = __config[NODE_CURRENT_STYLE$1];
        var computedStyle = __config[NODE_COMPUTED_STYLE$1]; // 渲染完认为完全无变更，等布局/动画/更新重置

        __config[NODE_REFRESH_LV] = NONE; // >=REPAINT清空bbox

        if (lv >= REPAINT$1) {
          this.__bbox = null;
          this.__filterBbox = null;
        }

        if (isDestroyed) {
          return {
            isDestroyed: isDestroyed,
            "break": true
          };
        }

        var virtualDom; // svg设置vd上的lv属性标明<REPAINT时应用缓存，初始化肯定没有

        if (renderMode === SVG$3) {
          virtualDom = __config[NODE_VIRTUAL_DOM$2] = this.__virtualDom = {
            bb: [],
            children: [],
            visibility: 'visible'
          }; // svg mock，每次都生成，每个节点都是局部根，更新时自底向上清除

          if (!__config[NODE_CACHE_TOTAL]) {
            __config[NODE_CACHE_TOTAL] = {
              available: true,
              release: function release() {
                this.available = false;
                delete virtualDom.cache;
              }
            };
          } else if (!__config[NODE_CACHE_TOTAL].available) {
            __config[NODE_CACHE_TOTAL].available = true;
          }
        }

        var display = computedStyle[DISPLAY$2]; // canvas返回信息，svg已经初始化好了vd

        if (display === 'none') {
          return {
            "break": true
          };
        } // 使用sx和sy渲染位置，考虑了relative和translate影响


        var clientWidth = this.clientWidth,
            clientHeight = this.clientHeight,
            offsetWidth = this.offsetWidth,
            offsetHeight = this.offsetHeight,
            __hasMask = this.__hasMask;
        var paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$2],
            paddingBottom = computedStyle[PADDING_BOTTOM$3],
            paddingLeft = computedStyle[PADDING_LEFT$3],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$2],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$3];
        var isRealInline = __config[NODE_IS_INLINE]; // 考虑mpb的6个坐标，inline比较特殊单独计算

        var x1 = this.__sx1;
        var x2 = this.__sx2;
        var x3 = this.__sx3;
        var x4 = this.__sx4;
        var x5 = this.__sx5;
        var x6 = this.__sx6;
        var y1 = this.__sy1;
        var y2 = this.__sy2;
        var y3 = this.__sy3;
        var y4 = this.__sy4;
        var y5 = this.__sy5;
        var y6 = this.__sy6;
        var res = {
          ctx: ctx,
          x1: x1,
          x2: x2,
          x3: x3,
          x4: x4,
          x5: x5,
          x6: x6,
          y1: y1,
          y2: y2,
          y3: y3,
          y4: y4,
          y5: y5,
          y6: y6,
          sx1: x1,
          sx2: x2,
          sx3: x3,
          sx4: x4,
          sx5: x5,
          sx6: x6,
          sy1: y1,
          sy2: y2,
          sy3: y3,
          sy4: y4,
          sy5: y5,
          sy6: y6,
          dx: dx,
          dy: dy
        }; // 防止cp直接返回cp嵌套，拿到真实dom的parent

        var p = __config[NODE_DOM_PARENT$2];

        if (renderMode === WEBGL$4) {
          this.__calPerspective(__cacheStyle, currentStyle, computedStyle, __config);
        } // cache的canvas模式已经提前计算好了，其它需要现在计算


        var matrix;

        if (cache && renderMode === CANVAS$4) {
          matrix = __config[NODE_MATRIX$1];
        } else {
          matrix = this.__calMatrix(lv, __cacheStyle, currentStyle, computedStyle, __config, x1, y1, offsetWidth, offsetHeight);
        } // 计算好cacheStyle的内容，在cache且canvas模式时已经提前算好


        var bx1, by1, bx2, by2;

        if (cache && renderMode === CANVAS$4) {
          bx1 = this.__bx1;
          bx2 = this.__bx2;
          by1 = this.__by1;
          by2 = this.__by2;
        } else {
          var _this$__calCache = this.__calCache(renderMode, ctx, p, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6);

          var _this$__calCache2 = _slicedToArray(_this$__calCache, 4);

          bx1 = _this$__calCache2[0];
          by1 = _this$__calCache2[1];
          bx2 = _this$__calCache2[2];
          by2 = _this$__calCache2[3];
        }

        res.bx1 = bx1;
        res.by1 = by1;
        res.bx2 = bx2;
        res.by2 = by2;

        var hasContent = this.__hasContent = __config[NODE_HAS_CONTENT] = this.__calContent(renderMode, lv, currentStyle, computedStyle); // webgl特殊申请离屏缓存


        if (cache && renderMode === WEBGL$4) {
          // 无内容可释放并提前跳出，geom覆盖特殊判断，因为后面子类会绘制矢量，img也覆盖特殊判断，加载完肯定有内容
          if (!hasContent && this.__releaseWhenEmpty(__cache, computedStyle)) {
            res["break"] = true;
            __config[NODE_LIMIT_CACHE$1] = false;
          } // 新生成根据最大尺寸，排除margin从border开始还要考虑阴影滤镜等，geom单独在dom里做
          else if (!__config[NODE_LIMIT_CACHE$1]) {
            var bbox = this.bbox;

            if (__cache) {
              __cache.reset(bbox, x1, y1);
            } else {
              __cache = Cache.getInstance(bbox, x1, y1);
            } // cache成功设置坐标偏移，否则为超过最大尺寸限制不使用缓存


            if (__cache && __cache.enabled) {
              __cache.__bbox = bbox;
              ctx = __cache.ctx;
              dx += __cache.dx;
              dy += __cache.dy;
              res.ctx = ctx;
            } else {
              __config[NODE_LIMIT_CACHE$1] = true;
              __cache = null;
              res.limitCache = res["break"] = true;
            }

            __config[NODE_CACHE$1] = __cache;
          }
        } // 降级的webgl绘制
        else if (renderMode === WEBGL$4) {
          var c = inject.getCacheCanvas(root.width, root.height, '__$$OVERSIZE$$__');
          res.ctx = ctx = c.ctx;
        } // webgl的偏移


        res.dx = dx;
        res.dy = dy; // 渲染样式

        var backgroundColor = computedStyle[BACKGROUND_COLOR$1],
            borderTopColor = computedStyle[BORDER_TOP_COLOR],
            borderRightColor = computedStyle[BORDER_RIGHT_COLOR],
            borderBottomColor = computedStyle[BORDER_BOTTOM_COLOR],
            borderLeftColor = computedStyle[BORDER_LEFT_COLOR],
            borderTopLeftRadius = computedStyle[BORDER_TOP_LEFT_RADIUS$1],
            borderTopRightRadius = computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
            borderBottomRightRadius = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
            borderBottomLeftRadius = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
            visibility = computedStyle[VISIBILITY$2],
            backgroundRepeat = computedStyle[BACKGROUND_REPEAT],
            backgroundImage = computedStyle[BACKGROUND_IMAGE$1],
            opacity = computedStyle[OPACITY$3],
            filter = computedStyle[FILTER$4],
            backgroundSize = computedStyle[BACKGROUND_SIZE$2],
            boxShadow = computedStyle[BOX_SHADOW$2],
            overflow = computedStyle[OVERFLOW$1],
            mixBlendMode = computedStyle[MIX_BLEND_MODE],
            backgroundClip = computedStyle[BACKGROUND_CLIP$2],
            writingMode = computedStyle[WRITING_MODE$1];
        var isUpright = writingMode.indexOf('vertical') === 0; // 先设置透明度，canvas可以向上累积，cache模式外部已计算好

        if (cache && renderMode === CANVAS$4) {
          opacity = __config[NODE_OPACITY$1];
        } else if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          if (p) {
            opacity *= p.__config[NODE_OPACITY$1];
          }

          __config[NODE_OPACITY$1] = opacity;
        } else if (renderMode === SVG$3) {
          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        } // canvas/svg/事件需要3种不同的matrix


        if (renderMode === SVG$3) {
          if (!mx.isE(matrix)) {
            virtualDom.transform = 'matrix(' + joinArr$2(mx.m2m6(matrix), ',') + ')';
          } else {
            delete virtualDom.transform;
          }

          virtualDom.visibility = visibility;
        } // cache模式的canvas的matrix计算在外部做好了，且perspective无效


        if (renderMode === CANVAS$4 && cache) {
          matrix = __config[NODE_MATRIX_EVENT$2];
        } else {
          var m = __config[NODE_MATRIX$1];
          util.assignMatrix(m, matrix); // 变换和canvas要以父元素matrixEvent为基础，svg使用自身即css规则，webgl在struct渲染时另算

          if (p) {
            if (p.perspectiveMatrix) {
              matrix = mx.multiply(p.perspectiveMatrix, matrix);
            }

            matrix = mx.multiply(p.matrixEvent, matrix);
          } // 为了引用不变，防止变化后text子节点获取不到，恶心的v8优化，初始化在构造函数中空数组


          m = __config[NODE_MATRIX_EVENT$2];
          util.assignMatrix(m, matrix);
        } // 无离屏功能或超限视为不可缓存本身，等降级无cache再次绘制，webgl一样


        if (res.limitCache) {
          return res;
        } // 按照顺序依次检查生成offscreen离屏功能，顺序在structs中渲染离屏时用到，多个离屏时隔离并且后面有前面的ctx引用


        var offscreenBlend;

        if (mixBlendMode !== 'normal' && isValidMbm$1(mixBlendMode)) {
          mixBlendMode = mbmName$1(mixBlendMode);

          if (renderMode === CANVAS$4 && cache !== LOCAL) {
            var width = root.width,
                height = root.height;

            var _c = inject.getCacheCanvas(width, height, null, 'blend');

            offscreenBlend = {
              ctx: ctx,
              target: _c,
              mixBlendMode: mixBlendMode,
              matrix: matrix
            };
            ctx = _c.ctx;
          } else if (renderMode === SVG$3) {
            virtualDom.mixBlendMode = mixBlendMode;
          }
        } // svg特殊没有mbm删除
        else if (renderMode === SVG$3) {
          delete virtualDom.mixBlendMode;
        }

        var offscreenMask;

        if (__hasMask) {
          if (renderMode === CANVAS$4 && cache !== LOCAL) {
            var _width = root.width,
                _height = root.height;

            var _c2 = inject.getCacheCanvas(_width, _height, null, 'mask1');

            offscreenMask = {
              ctx: ctx,
              target: _c2,
              matrix: matrix
            };
            ctx = _c2.ctx;
          }
        } // 无cache时canvas的blur需绘制到离屏上应用后反向绘制回来，有cache在Dom里另生成一个filter的cache


        var hasFilter = filter && filter.length;
        var offscreenFilter;

        if (hasFilter) {
          if (renderMode === CANVAS$4 && cache !== LOCAL) {
            var _width2 = root.width,
                _height2 = root.height;

            var _c3 = inject.getCacheCanvas(_width2, _height2, null, 'filter');

            offscreenFilter = {
              ctx: ctx,
              filter: filter,
              target: _c3,
              matrix: matrix
            };
            ctx = _c3.ctx;
          } else if (renderMode === SVG$3) {
            virtualDom.filter = painter.svgFilter(filter);
          }
        } else if (renderMode === SVG$3) {
          delete virtualDom.filter;
        } // 根据backgroundClip的不同值要调整bg渲染坐标尺寸，也会影响borderRadius


        var btlr = borderTopLeftRadius.slice(0);
        var btrr = borderTopRightRadius.slice(0);
        var bbrr = borderBottomRightRadius.slice(0);
        var bblr = borderBottomLeftRadius.slice(0);

        if (backgroundClip === 'paddingBox') {
          btlr[0] -= borderLeftWidth;
          btlr[1] -= borderTopWidth;
          btrr[0] -= borderRightWidth;
          btrr[1] -= borderTopWidth;
          bbrr[0] -= borderRightWidth;
          bbrr[1] -= borderBottomWidth;
          bblr[0] -= borderLeftWidth;
          bblr[1] -= borderBottomWidth;
        } else if (backgroundClip === 'contentBox') {
          btlr[0] -= borderLeftWidth + paddingLeft;
          btlr[1] -= borderTopWidth + paddingTop;
          btrr[0] -= borderRightWidth + paddingRight;
          btrr[1] -= borderTopWidth + paddingTop;
          bbrr[0] -= borderRightWidth + paddingRight;
          bbrr[1] -= borderBottomWidth + paddingBottom;
          bblr[0] -= borderLeftWidth + paddingLeft;
          bblr[1] -= borderBottomWidth + paddingBottom;
        } // overflow:hidden，最后判断，filter/mask优先


        var offscreenOverflow, borderList;

        if (overflow === 'hidden' && display !== 'inline') {
          borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);

          if (renderMode === CANVAS$4 && cache !== LOCAL) {
            var _width3 = root.width,
                _height3 = root.height;

            var _c4 = inject.getCacheCanvas(_width3, _height3, null, 'overflow');

            offscreenOverflow = {
              ctx: ctx,
              target: _c4,
              matrix: matrix
            };
            ctx = _c4.ctx;
            offscreenOverflow.x = x1;
            offscreenOverflow.y = y1;
            offscreenOverflow.offsetWidth = offsetWidth;
            offscreenOverflow.offsetHeight = offsetHeight;
            offscreenOverflow.list = borderList;
          } else if (renderMode === SVG$3) {
            var d = svgPolygon$4(borderList) || "M".concat(x1, ",").concat(y1, "L").concat(x1 + offsetWidth, ",").concat(y1, "L").concat(x1 + offsetWidth, ",").concat(y1 + offsetHeight, "L").concat(x1, ",").concat(y1 + offsetHeight, ",L").concat(x1, ",").concat(y1);
            var v = {
              tagName: 'clipPath',
              props: [],
              children: [{
                tagName: 'path',
                props: [['d', d]]
              }]
            };
            var id = ctx.add(v);

            __config[NODE_DEFS_CACHE$2].push(v);

            virtualDom.overflow = 'url(#' + id + ')';
          }
        } else if (renderMode === SVG$3) {
          delete virtualDom.overflow;
        } // 无法使用缓存时主画布直接绘制需设置


        if (renderMode === CANVAS$4) {
          res.offscreenBlend = offscreenBlend;
          res.offscreenMask = offscreenMask;
          res.offscreenFilter = offscreenFilter;
          res.offscreenOverflow = offscreenOverflow;
          res.ctx = ctx;
          ctx.globalAlpha = opacity; // cache模式在外面设置

          if (!cache) {
            ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
          }
        } // 隐藏不渲染


        if ((visibility === 'hidden' || res["break"]) && (renderMode === CANVAS$4 || renderMode === WEBGL$4)) {
          res["break"] = true;
          return res;
        } // 仅webgl有用


        if (__cache && __cache.enabled) {
          __cache.__available = true;
        }
        /**
         * inline的渲染同block/ib不一样，不是一个矩形区域
         * 它根据内部的contentBox渲染，contentBox是指lineBox中的内容，即TextBox/inline/ib元素
         * 首尾可能不满行，比如从一半开始或一半结束，甚至可能没有内容
         * 两行之间可能不满，如果lineBox的高度>lineHeight的话，另外特殊字体如arial拥有lineGap也会产生间隙，背景色不绘制这个间隙
         * x轴根据contentBox的范围坐标，y则固定和font/lineHeight相关
         * 圆角发生在首尾lineBox处，中间不会有，bgi则产生类似bgc作为mask的效果
         * 另外要注意多个时的顺序，必须依次渲染，后面的bb可能会覆盖前面行的
         */


        if (isRealInline) {
          var contentBoxList = this.contentBoxList;
          var length = contentBoxList.length;

          if (contentBoxList[length - 1] instanceof Ellipsis) {
            length--;
          }

          var hasBgi = backgroundImage.some(function (item) {
            return item;
          });

          if (length) {
            var _ret = function () {
              var fontSize = computedStyle[FONT_SIZE$9],
                  fontFamily = computedStyle[FONT_FAMILY$5],
                  lineHeight = computedStyle[LINE_HEIGHT$5];
              var iw = 0,
                  ih = 0;
              var offscreen,
                  svgBgSymbol = []; // bgi视作inline排满一行绘制，然后按分行拆开给每行

              if (hasBgi) {
                iw = inline.getInlineWidth(_this8, contentBoxList, isUpright);
                ih = lineHeight; // 垂直模式互换，计算时始终按照宽度为主轴计算的

                if (isUpright) {
                  var _ref = [ih, iw];
                  iw = _ref[0];
                  ih = _ref[1];
                }

                if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom;
                    ih += paddingLeft + paddingRight;
                  } else {
                    iw += paddingLeft + paddingRight;
                    ih += paddingTop + paddingBottom;
                  }
                } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                    ih += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                  } else {
                    iw += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                    ih += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                  }
                }

                if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
                  offscreen = inject.getCacheCanvas(iw, ih, '__$$INLINE_BGI$$__');
                }

                var _length = backgroundImage.length;
                backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
                  if (!bgi) {
                    return;
                  }

                  i = _length - 1 - i;

                  if (util.isString(bgi)) {
                    var loadBgi = _this8.__loadBgi[i];

                    if (loadBgi.url === bgi) {
                      var uuid = bg.renderImage(_this8, renderMode, offscreen && offscreen.ctx || ctx, loadBgi, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, __config, true, dx, dy);

                      if (renderMode === SVG$3 && uuid) {
                        svgBgSymbol.push(uuid);
                      }
                    }
                  } else if (bgi.k) {
                    var gd = _this8.__gradient(renderMode, ctx, 0, 0, iw, ih, bgi, dx, dy);

                    if (gd) {
                      if (gd.k === 'conic') {
                        gradient$1.renderConic(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, 0, 0, iw, lineHeight, btlr, btrr, bbrr, bblr, true);
                      } else {
                        var _uuid = bg.renderBgc(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, null, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, 'fill', true);

                        if (renderMode === SVG$3 && _uuid) {
                          svgBgSymbol.push(_uuid);
                        }
                      }
                    }
                  }
                });
              } // 获取当前dom的baseline，再减去lineBox的baseline得出差值，这样渲染范围y就是lineBox的y+差值为起始，lineHeight为高


              var ff = css.getFontFamily(fontFamily); // lineGap，一般为0，某些字体如arial有，渲染高度需减去它，最终是lineHeight - leading，上下均分

              var leading = fontSize * (o$1.info[ff].lgr || 0) * 0.5;
              var baseline = isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle); // 注意只有1个的时候特殊情况，圆角只在首尾行出现

              var isFirst = true;
              var lastContentBox = contentBoxList[0],
                  lastLineBox = lastContentBox.parentLineBox; // bgi需统计宽度累计值，将当前行所处理想单行的x范围位置计算出来，并进行bgi贴图绘制，svg还需统计第几行

              var count = 0;

              for (var i = 0; i < length; i++) {
                var contentBox = contentBoxList[i];

                if (contentBox.parentLineBox !== lastLineBox) {
                  (function () {
                    // 上一行
                    var _inline$getInlineBox = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i - 1], lastLineBox, baseline, lineHeight, leading, isFirst, false, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox2 = _slicedToArray(_inline$getInlineBox, 8),
                        ix1 = _inline$getInlineBox2[0],
                        iy1 = _inline$getInlineBox2[1],
                        ix2 = _inline$getInlineBox2[2],
                        iy2 = _inline$getInlineBox2[3],
                        bx1 = _inline$getInlineBox2[4],
                        by1 = _inline$getInlineBox2[5],
                        bx2 = _inline$getInlineBox2[6],
                        by2 = _inline$getInlineBox2[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var n = getFirstEmptyInlineWidth(_this8);
                      ix1 -= n;
                      bx1 -= n;
                    }

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], null, ix1, iy1, ix2 - ix1, iy2 - iy1, btlr, [0, 0], [0, 0], bblr, 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // 世界参考系的宽高，根据writingMode不同取值使用
                    // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$4 || renderMode === WEBGL$4) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$3 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v5 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v5);

                          __config[NODE_DEFS_CACHE$2].push(_v5);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    count += isUpright ? h : w; // 增加主轴方向的一行/列尺寸

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], [0, 0]);
                      border.renderBorder(_this8, renderMode, ctx, list, __cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    }

                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg7 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg8 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg7, _deg8, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], [0, 0]);

                      border.renderBorder(_this8, renderMode, ctx, _list, __cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg9 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg10 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list2 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg9, _deg10, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list2, __cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }

                    isFirst = false;
                    lastContentBox = contentBox;
                    lastLineBox = contentBox.parentLineBox;
                  })();
                } // 最后一个特殊判断


                if (i === length - 1) {
                  (function () {
                    var _inline$getInlineBox3 = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i], lastLineBox, baseline, lineHeight, leading, isFirst, true, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox4 = _slicedToArray(_inline$getInlineBox3, 8),
                        ix1 = _inline$getInlineBox4[0],
                        iy1 = _inline$getInlineBox4[1],
                        ix2 = _inline$getInlineBox4[2],
                        iy2 = _inline$getInlineBox4[3],
                        bx1 = _inline$getInlineBox4[4],
                        by1 = _inline$getInlineBox4[5],
                        bx2 = _inline$getInlineBox4[6],
                        by2 = _inline$getInlineBox4[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var _n4 = getFirstEmptyInlineWidth(_this8);

                      ix1 -= _n4;
                      bx1 -= _n4;
                    } // 要算上末尾空白inline，可能有多个和递归嵌套


                    var n = getLastEmptyInlineWidth(_this8);
                    ix2 += n;
                    bx2 += n;

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], null, ix1, iy1, ix2 - ix1, iy2 - iy1, isFirst ? btlr : [0, 0], btrr, bbrr, isFirst ? bblr : [0, 0], 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$4 || renderMode === WEBGL$4) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$3 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v6 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v6);

                          __config[NODE_DEFS_CACHE$2].push(_v6);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], btrr);
                      border.renderBorder(_this8, renderMode, ctx, list, __cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    }

                    if (borderRightWidth > 0 && borderRightColor[3] > 0) {
                      var _deg11 = Math.atan(borderRightWidth / borderTopWidth);

                      var _deg12 = Math.atan(borderRightWidth / borderBottomWidth);

                      var _list3 = border.calPoints(borderRightWidth, computedStyle[BORDER_RIGHT_STYLE], _deg11, _deg12, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 1, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list3, __cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
                    }

                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg13 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg14 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list4 = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg13, _deg14, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list4, __cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg15 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg16 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list5 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg15, _deg16, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list5, __cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }
                  })();
                }
              }

              if (offscreen) {
                offscreen.ctx.clearRect(0, 0, iw, ih);
              }

              return {
                v: res
              };
            }();

            if (_typeof(_ret) === "object") return _ret.v;
          } // 无内容且无尺寸的无需渲染
          else if (bx1 === bx2 || by1 === by2) {
            return res;
          }
        } // block渲染，bgc垫底


        if (backgroundColor[3] > 0) {
          bg.renderBgc(this, renderMode, ctx, __cacheStyle[BACKGROUND_COLOR$1], borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
        } // 渐变或图片叠加


        if (backgroundImage) {
          var _length2 = backgroundImage.length;
          backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
            if (!bgi) {
              return;
            }

            i = _length2 - 1 - i;

            if (util.isString(bgi)) {
              var loadBgi = _this8.__loadBgi[i];

              if (loadBgi.url === bgi) {
                bg.renderImage(_this8, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, __config, false, dx, dy);
              }
            } else if (bgi.k) {
              var gd = _this8.__gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi, dx, dy);

              if (gd) {
                if (gd.k === 'conic') {
                  gradient$1.renderConic(_this8, renderMode, ctx, gd.v, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
                } else {
                  bg.renderBgc(_this8, renderMode, ctx, gd.v, borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
                }
              }
            }
          });
        } // boxShadow可能会有多个


        if (boxShadow) {
          boxShadow.forEach(function (item) {
            bs.renderBoxShadow(_this8, renderMode, ctx, item, x1, y1, x6, y6, x6 - x1, y6 - y1, dx, dy);
          });
        } // 边框需考虑尖角，两条相交边平分45°夹角


        if (borderTopWidth > 0 && borderTopColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_TOP], __cacheStyle[BORDER_TOP_COLOR], dx, dy);
        }

        if (borderRightWidth > 0 && borderRightColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_RIGHT], __cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
        }

        if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_BOTTOM], __cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
        }

        if (borderLeftWidth > 0 && borderLeftColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, __cacheStyle[BORDER_LEFT], __cacheStyle[BORDER_LEFT_COLOR], dx, dy);
        }

        return res;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__destroy", this).call(this);

        var root = this.root;
        this.clearAnimate();
        this.clearFrameAnimate(); // root在没有初始化到真实dom渲染的情况下没有

        root && root.delRefreshTask(this.__loadBgi.cb);
        root && root.delRefreshTask(this.__task);
        this.__task = null;
        this.__root = null;
        this.clearCache();
      } // 先查找到注册了事件的节点，再捕获冒泡判断增加性能

    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var isDestroyed = this.isDestroyed,
            computedStyle = this.computedStyle,
            isMask = this.isMask;

        if (isDestroyed || computedStyle[DISPLAY$2] === 'none' || e.__stopPropagation || isMask) {
          return;
        }

        var type = e.event.type;
        var listener = this.listener,
            __hasMask = this.__hasMask;
        var cb;

        if (listener.hasOwnProperty(type)) {
          cb = listener[type];
        } // touchmove之类强制的直接由Root通知即可


        if (force) {
          if (computedStyle[POINTER_EVENTS$1] !== 'none' && isFunction$5(cb) && !e.__stopImmediatePropagation) {
            cb.call(this, e);
          }

          return true;
        } // 非force的判断事件坐标是否在节点内


        if (this.willResponseEvent(e)) {
          // 如果有mask，点在mask上才行，点在clip外才行
          if (__hasMask) {
            var next = this.next;
            var isClip = next.isClip;
            var hasEmitMask;

            while (next && next.isMask) {
              if (next.willResponseEvent(e, true)) {
                hasEmitMask = true;
                break;
              }

              next = next.next;
            }

            if (!isClip && !hasEmitMask) {
              return;
            }
          }

          if (isFunction$5(cb) && !e.__stopImmediatePropagation) {
            cb.call(this, e);
          }

          return true;
        }
      }
    }, {
      key: "willResponseEvent",
      value: function willResponseEvent(e, ignore) {
        var x = e.x,
            y = e.y;
        var __sx1 = this.__sx1,
            __sy1 = this.__sy1,
            offsetWidth = this.offsetWidth,
            offsetHeight = this.offsetHeight,
            matrixEvent = this.matrixEvent,
            computedStyle = this.computedStyle;

        if (computedStyle[POINTER_EVENTS$1] === 'none') {
          return;
        }

        var inThis = geom.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + offsetWidth, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight, __sx1, __sy1 + offsetHeight, matrixEvent);

        if (inThis) {
          if (!e.target && !ignore) {
            e.target = this; // 缓存target给move用

            if (e.event.type === 'touchstart') {
              this.root && (this.root.__touchstartTarget = this);
            }
          }

          return true;
        }
      }
    }, {
      key: "__gradient",
      value: function __gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi) {
        var dx = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var dy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var iw = bx2 - bx1;
        var ih = by2 - by1; // 无尺寸无需创建渐变

        if (!iw || !ih) {
          return;
        }

        var k = bgi.k,
            v = bgi.v,
            d = bgi.d,
            s = bgi.s,
            z = bgi.z,
            p = bgi.p;
        var cx = bx1 + iw * 0.5;
        var cy = by1 + ih * 0.5;
        var res = {
          k: k
        };

        if (k === 'linear') {
          var gd = gradient$1.getLinear(v, d, bx1, by1, cx, cy, iw, ih, this.root, dx, dy);
          res.v = this.__getLg(renderMode, ctx, gd);
        } else if (k === 'radial') {
          var _gd = gradient$1.getRadial(v, s, z, p, bx1, by1, bx2, by2, this.root, dx, dy);

          if (_gd) {
            res.v = this.__getRg(renderMode, ctx, _gd);

            if (_gd.matrix) {
              res.v = [res.v, _gd.matrix, _gd.cx, _gd.cy];
            }
          }
        } else if (k === 'conic') {
          var bbox = this.bbox;
          var m1 = Math.max(Math.abs(bbox[2] - bbox[0]), Math.abs(bbox[3] - bbox[1]));
          var m2 = Math.max(Math.abs(iw), Math.abs(ih));

          var _gd2 = gradient$1.getConic(v, d, p, bx1, by1, bx2, by2, m1 / m2, this.root, dx, dy);

          res.v = this.__getCg(renderMode, ctx, _gd2);
        }

        return res;
      }
    }, {
      key: "__getLg",
      value: function __getLg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          var lg = ctx.createLinearGradient(gd.x1, gd.y1, gd.x2, gd.y2);
          gd.stop.forEach(function (item) {
            lg.addColorStop(item[1], int2rgba$3(item[0]));
          });
          return lg;
        } else if (renderMode === SVG$3) {
          var v = {
            tagName: 'linearGradient',
            props: [['x1', gd.x1], ['y1', gd.y1], ['x2', gd.x2], ['y2', gd.y2]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$3(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };
          var uuid = ctx.add(v);

          this.__config[NODE_DEFS_CACHE$2].push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getRg",
      value: function __getRg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          var rg = ctx.createRadialGradient(gd.cx, gd.cy, 0, gd.tx, gd.ty, gd.r);
          gd.stop.forEach(function (item) {
            rg.addColorStop(item[1], int2rgba$3(item[0]));
          });
          return rg;
        } else if (renderMode === SVG$3) {
          var v = {
            tagName: 'radialGradient',
            props: [['cx', gd.tx], ['cy', gd.ty], ['r', gd.r]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$3(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };

          if (gd.tx !== gd.cx) {
            v.props.push(['fx', gd.cx]);
          }

          if (gd.ty !== gd.cy) {
            v.props.push(['fy', gd.cy]);
          }

          var uuid = ctx.add(v);

          this.__config[NODE_DEFS_CACHE$2].push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getCg",
      value: function __getCg(renderMode, ctx, gd) {
        var stop = gd.stop;
        var len = stop.length - 1;

        if (stop[len][1] < 1) {
          stop.push([stop[len][0].slice(0), 1]);
        }

        if (stop[0][1] > 0) {
          stop.unshift([stop[0][0].slice(0), 0]);
        } // canvas采用点色值计算法，svg则分360度画块


        var res = [];

        if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          return gd;
        }

        return res;
      } // canvas清空自身cache，cacheTotal在Root的自底向上逻辑做，svg仅有cacheTotal

    }, {
      key: "clearCache",
      value: function clearCache(onlyTotal) {
        var __config = this.__config;
        var __cacheTotal = __config[NODE_CACHE_TOTAL];
        var __cacheFilter = __config[NODE_CACHE_FILTER];
        var __cacheMask = __config[NODE_CACHE_MASK];
        var __cacheOverflow = __config[NODE_CACHE_OVERFLOW];

        if (!onlyTotal) {
          __config[NODE_CACHE_STYLE] = this.__cacheStyle = {};
          var __cache = __config[NODE_CACHE$1];

          if (__cache) {
            __cache.release();
          }
        }

        if (__cacheTotal) {
          __cacheTotal.release();
        }

        if (__cacheFilter) {
          __cacheFilter.release();
        }

        if (__cacheMask) {
          __cacheMask.release();
        }

        if (__cacheOverflow) {
          __cacheOverflow.release();
        }
      }
    }, {
      key: "updateStyle",
      value: function updateStyle(style, cb) {
        var node = this;
        var root = node.root,
            __config = node.__config;
        var formatStyle = css.normalize(style); // 有root说明被添加渲染过了

        if (root) {
          root.addRefreshTask(node.__task = {
            __before: function __before() {
              node.__task = null;

              if (__config[NODE_IS_DESTROYED$1]) {
                return;
              } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


              var res = {};
              res[UPDATE_NODE$2] = node;
              res[UPDATE_STYLE$1] = formatStyle;
              res[UPDATE_OVERWRITE] = style; // 标识盖原有style样式不仅仅是修改currentStyle，不同于animate

              res[UPDATE_KEYS$1] = Object.keys(formatStyle).map(function (i) {
                if (!GEOM$4.hasOwnProperty(i)) {
                  i = parseInt(i);
                }

                return i;
              });
              res[UPDATE_CONFIG$2] = __config;

              root.__addUpdate(node, __config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (isFunction$5(cb)) {
                cb.call(node, diff);
              }
            }
          });
        } // 没有是在如parse()还未添加的时候，可以直接同步覆盖
        else {
          Object.assign(this.currentStyle, formatStyle);

          if (isFunction$5(cb)) {
            cb.call(node, -1);
          }
        }
      } // 传入格式化好key/value的样式

    }, {
      key: "updateFormatStyle",
      value: function updateFormatStyle(style, cb) {
        var node = this;
        var root = node.root,
            __config = node.__config;

        if (root) {
          root.addRefreshTask(node.__task = {
            __before: function __before() {
              node.__task = null; // 清除在before，防止after的回调增加新的task误删

              if (__config[NODE_IS_DESTROYED$1]) {
                return;
              } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


              var res = {};
              res[UPDATE_NODE$2] = node;
              res[UPDATE_STYLE$1] = style;
              res[UPDATE_KEYS$1] = Object.keys(style).map(function (i) {
                if (!GEOM$4.hasOwnProperty(i)) {
                  i = parseInt(i);
                }

                return i;
              });
              res[UPDATE_CONFIG$2] = __config;

              root.__addUpdate(node, __config, root, root.__config, res);
            },
            __after: function __after(diff) {
              if (isFunction$5(cb)) {
                cb.call(node, diff);
              }
            }
          });
        } // 没有是在如parse()还未添加的时候，可以直接同步覆盖
        else {
          Object.assign(this.currentStyle, style);

          if (isFunction$5(cb)) {
            cb.call(node, -1);
          }
        }
      }
    }, {
      key: "animate",
      value: function animate(list) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var animation = new Animation(this, list, options);

        if (this.isDestroyed) {
          animation.__destroy(true);

          return animation;
        }

        this.animationList.push(animation);

        if (options.autoPlay === false) {
          return animation;
        }

        return animation.play();
      }
    }, {
      key: "removeAnimate",
      value: function removeAnimate(o) {
        if (o instanceof Animation) {
          var i = this.animationList.indexOf(o);

          if (i > -1) {
            o.cancel();

            o.__destroy();

            this.animationList.splice(i, 1);
          }
        }
      }
    }, {
      key: "clearAnimate",
      value: function clearAnimate() {
        this.animationList.splice(0).forEach(function (o) {
          o.cancel();

          o.__destroy();
        });
      }
    }, {
      key: "frameAnimate",
      value: function frameAnimate(cb) {
        if (isFunction$5(cb)) {
          var list = this.__frameAnimateList; // 防止重复

          for (var i = 0, len = list.length; i < len; i++) {
            if (list[i].__karasFramecb === cb) {
              return cb;
            }
          }

          var enter = {
            __after: function __after(diff) {
              cb(diff);
            },
            __karasFramecb: cb
          };
          list.push(enter);
          frame.onFrame(enter);
          return cb;
        }
      }
    }, {
      key: "removeFrameAnimate",
      value: function removeFrameAnimate(cb) {
        for (var i = 0, list = this.__frameAnimateList, len = list.length; i < len; i++) {
          if (list[i].__karasFramecb === cb) {
            list.splice(i, 1);
            frame.offFrame(cb);
            return;
          }
        }
      }
    }, {
      key: "clearFrameAnimate",
      value: function clearFrameAnimate() {
        this.__frameAnimateList.splice(0).forEach(function (o) {
          frame.offFrame(o);
        });
      }
    }, {
      key: "__deepScan",
      value: function __deepScan(cb, options) {
        return cb(this, options);
      } // isLayout为false时，为relative/margin/flex/vertical等
      // 注意所有的offset/resize都要避免display:none的，比如合并margin导致block的孩子inline因clamp为none时没有layoutData

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        if (this.computedStyle[DISPLAY$2] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetX", this).call(this, diff, isLayout);

        if (isLayout) {
          this.__layoutData.x += diff;
          this.clearCache();
        }

        if (lv !== undefined) {
          this.__config[NODE_REFRESH_LV] |= lv;
        }

        this.__sx1 += diff;
        this.__sx2 += diff;
        this.__sx3 += diff;
        this.__sx4 += diff;
        this.__sx5 += diff;
        this.__sx6 += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        if (this.computedStyle[DISPLAY$2] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetY", this).call(this, diff, isLayout);

        if (isLayout) {
          this.__layoutData && (this.__layoutData.y += diff);
          this.clearCache();
        }

        if (lv !== undefined) {
          this.__config[NODE_REFRESH_LV] |= lv;
        }

        this.__sy1 += diff;
        this.__sy2 += diff;
        this.__sy3 += diff;
        this.__sy4 += diff;
        this.__sy5 += diff;
        this.__sy6 += diff;
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        if (this.computedStyle[DISPLAY$2] === 'none') {
          return;
        }

        this.computedStyle.width = this.__width += diff;
        this.__clientWidth += diff;
        this.__offsetWidth += diff;
        this.__outerWidth += diff;
        this.__layoutData && (this.__layoutData.w += diff);
        this.__sx4 += diff;
        this.__sx5 += diff;
        this.__sx6 += diff;

        if (diff < 0) {
          this.__config[NODE_LIMIT_CACHE$1] = false;
        }

        if (lv !== undefined) {
          this.__config[NODE_REFRESH_LV] |= lv;
        }

        this.clearCache();
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        if (this.computedStyle[DISPLAY$2] === 'none') {
          return;
        }

        this.computedStyle.height = this.__height += diff;
        this.__clientHeight += diff;
        this.__offsetHeight += diff;
        this.__outerHeight += diff;
        this.__layoutData.h += diff;
        this.__sy4 += diff;
        this.__sy5 += diff;
        this.__sy6 += diff;

        if (diff < 0) {
          this.__config[NODE_LIMIT_CACHE$1] = false;
        }

        if (lv !== undefined) {
          this.__config[NODE_REFRESH_LV] |= lv;
        }

        this.clearCache();
      }
    }, {
      key: "__releaseWhenEmpty",
      value: function __releaseWhenEmpty(__cache) {
        if (__cache && __cache.available) {
          __cache.release();
        }

        return true;
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        var computedStyle = this.computedStyle;
        var res = {};
        var keys;

        if (key) {
          if (Array.isArray(key)) {
            keys = key;
          } else {
            keys = [key];
          }

          keys = keys.map(function (s) {
            return STYLE_KEY$5[style2Upper$2(s)];
          });
        } else {
          keys = Object.keys(computedStyle);
        }

        keys.forEach(function (k) {
          if (GEOM$4.hasOwnProperty(k)) {
            res[k] = computedStyle[k];
          } else {
            res[STYLE_RV_KEY$1[k]] = computedStyle[k];
          }
        });
        return res;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(includeBbox) {
        var box = [];

        if (includeBbox) {
          box = this.bbox;
        } else {
          var __sx1 = this.__sx1,
              __sy1 = this.__sy1,
              offsetWidth = this.offsetWidth,
              offsetHeight = this.offsetHeight;
          box = [__sx1, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight];
        }

        var matrixEvent = this.matrixEvent;
        var p1 = point2d$1(mx.calPoint([box[0], box[1]], matrixEvent));
        var p2 = point2d$1(mx.calPoint([box[2], box[1]], matrixEvent));
        var p3 = point2d$1(mx.calPoint([box[2], box[3]], matrixEvent));
        var p4 = point2d$1(mx.calPoint([box[0], box[3]], matrixEvent));
        return {
          left: Math.min(p1[0], Math.min(p2[0], Math.min(p3[0], p4[0]))),
          top: Math.min(p1[1], Math.min(p2[1], Math.min(p3[1], p4[1]))),
          right: Math.max(p1[0], Math.max(p2[0], Math.max(p3[0], p4[0]))),
          bottom: Math.max(p1[1], Math.max(p2[1], Math.max(p3[1], p4[1]))),
          points: [p1, p2, p3, p4]
        };
      } // img和geom返回false，在inline布局时判断是否是真的inline

    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return true;
      }
    }, {
      key: "remove",
      value: function remove(cb) {
        var self = this;

        if (self.isDestroyed) {
          inject.warn('Remove target is destroyed.');

          if (isFunction$5(cb)) {
            cb();
          }

          return;
        }

        var root = self.root,
            domParent = self.domParent;
        var target = self.isShadowRoot ? self.hostRoot : self; // 特殊情况连续append/remove时候，还未被添加进来找不到所以无需删除

        if (domParent.children.indexOf(target) === -1) {
          if (isFunction$5(cb)) {
            cb();
          }

          return;
        }

        root.delRefreshTask(self.__task);
        root.addRefreshTask(self.__task = {
          __before: function __before() {
            self.__task = null; // 清除在before，防止after的回调增加新的task误删

            var pJson = domParent.__json;
            var i = pJson.children.indexOf(self.isShadowRoot ? self.hostRoot.__json : self.__json);
            var zChildren = domParent.zIndexChildren;
            var j = zChildren.indexOf(self.isShadowRoot ? self.hostRoot : self);

            if (i === -1 || j === -1) {
              throw new Error('Remove index Exception.');
            }

            pJson.children.splice(i, 1);
            domParent.children.splice(i, 1);
            zChildren.splice(j, 1);

            if (self.__prev) {
              self.__prev.__next = self.__next;
            } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


            var res = {};
            res[UPDATE_NODE$2] = self;
            res[UPDATE_FOCUS$1] = REFLOW;
            res[UPDATE_REMOVE_DOM] = true;
            res[UPDATE_CONFIG$2] = self.__config;

            root.__addUpdate(self, self.__config, root, root.__config, res);
          },
          __after: function __after(diff) {
            self.isShadowRoot ? self.hostRoot.__destroy() : self.__destroy();

            if (isFunction$5(cb)) {
              cb.call(self, diff);
            }
          }
        });
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "sx",
      get: function get() {
        return this.__sx;
      }
    }, {
      key: "sy",
      get: function get() {
        return this.__sy;
      }
    }, {
      key: "clientWidth",
      get: function get() {
        return this.__clientWidth || 0;
      }
    }, {
      key: "clientHeight",
      get: function get() {
        return this.__clientHeight || 0;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__offsetWidth || 0;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__offsetHeight || 0;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__outerWidth || 0;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__outerHeight || 0;
      } // 相对自身原点，不考虑margin的范围，>=REPAINT渲染或个别有影响的渲染改变（如blur）清空缓存

    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var __sx1 = this.__sx1,
              __sy1 = this.__sy1,
              offsetWidth = this.offsetWidth,
              offsetHeight = this.offsetHeight,
              boxShadow = this.computedStyle[BOX_SHADOW$2];
          this.__bbox = spreadBoxShadow$1([__sx1, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight], boxShadow);
        }

        return this.__bbox;
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.bbox;
          var filter = this.computedStyle[FILTER$4];
          this.__filterBbox = spreadFilter$2(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "listener",
      get: function get() {
        return this.__listener;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.__config[NODE_MATRIX$1];
      }
    }, {
      key: "matrixEvent",
      get: function get() {
        return this.__config[NODE_MATRIX_EVENT$2];
      }
    }, {
      key: "perspectiveMatrix",
      get: function get() {
        return this.__config[NODE_PERSPECTIVE_MATRIX];
      }
    }, {
      key: "style",
      get: function get() {
        return this.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.__computedStyle;
      }
    }, {
      key: "animationList",
      get: function get() {
        return this.__animationList;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.__currentStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.__cacheStyle;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.parent && this.host && this.host !== this.root;
      }
    }, {
      key: "contentBoxList",
      get: function get() {
        return this.__contentBoxList;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.offsetHeight;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        return this.offsetHeight;
      }
    }, {
      key: "isMask",
      get: function get() {
        return this.__isMask;
      }
    }, {
      key: "isClip",
      get: function get() {
        return this.__isClip;
      }
    }, {
      key: "cacheAsBitmap",
      get: function get() {
        return this.__cacheAsBitmap;
      },
      set: function set(v) {
        this.__config[NODE_CACHE_AS_BITMAP] = this.__cacheAsBitmap = !!v;
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }]);

    return Xom;
  }(Node);

  var _enums$STYLE_KEY$e = enums.STYLE_KEY,
      DISPLAY$3 = _enums$STYLE_KEY$e.DISPLAY,
      MARGIN_TOP$3 = _enums$STYLE_KEY$e.MARGIN_TOP,
      MARGIN_BOTTOM$3 = _enums$STYLE_KEY$e.MARGIN_BOTTOM,
      MARGIN_LEFT$3 = _enums$STYLE_KEY$e.MARGIN_LEFT,
      MARGIN_RIGHT$3 = _enums$STYLE_KEY$e.MARGIN_RIGHT,
      BORDER_TOP_WIDTH$4 = _enums$STYLE_KEY$e.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$4 = _enums$STYLE_KEY$e.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$4 = _enums$STYLE_KEY$e.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$3 = _enums$STYLE_KEY$e.BORDER_RIGHT_WIDTH,
      PADDING_TOP$4 = _enums$STYLE_KEY$e.PADDING_TOP,
      PADDING_BOTTOM$4 = _enums$STYLE_KEY$e.PADDING_BOTTOM,
      PADDING_LEFT$4 = _enums$STYLE_KEY$e.PADDING_LEFT,
      PADDING_RIGHT$3 = _enums$STYLE_KEY$e.PADDING_RIGHT,
      LINE_HEIGHT$6 = _enums$STYLE_KEY$e.LINE_HEIGHT;
  /**
   * css中常见的概念，一行内容，里面可能有若干不同的内容，仅在布局阶段出现，不参与渲染逻辑
   * 本类是个抽象逻辑概念，会包含Text的内容TextBox和inlineBlock等节点，而内容TextBox则属于Text
   * 一个Text可能因为换行产生多个TextBox，从而形成不同行的内容就属于不同的LineBox
   * 本类属于block（包含flex和inlineBlock，下同）节点下，一个dom会有个专门列表，
   * 包含若干个LineBox保存着若干行文本内容TextBox，不直接关联Text，
   * inline则不会有此对象和列表，其复用最近block父层的，这样解决嵌套问题，
   * block在布局时将列表向孩子传递下去，每遇到block会重新生成
   * 每当发生换行时，专门列表中会新生成一个LineBox，让后续内容继续跟随新的LB
   * LB内部要进行垂直对齐，Text内容较简单x字符底部为baseline，inlineBlock等节点按最后一行baseline
   */

  var LineBox = /*#__PURE__*/function () {
    function LineBox(x, y, lineHeight, baseline, isUpright) {
      _classCallCheck(this, LineBox);

      this.__list = [];
      this.__x = x;
      this.__y = y;
      this.__lineHeight = lineHeight; // 可能出现空的inline，因此一个inline进入布局时先设置当前lineBox的最小lineHeight/baseline

      this.__baseline = baseline;
      this.__isUpright = isUpright;
      this.__bOffset = 0;
    }

    _createClass(LineBox, [{
      key: "add",
      value: function add(item) {
        this.list.push(item);
        item.__parentLineBox = this;
      }
    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var baseline = isUpright ? this.verticalBaseline : this.baseline;
        var lineHeight = isUpright ? this.verticalLineHeight : this.lineHeight;
        var increase = lineHeight; // 只有1个也需要对齐，因为可能内嵌了空inline使得baseline发生变化

        if (this.list.length) {
          this.list.forEach(function (item) {
            if (item.isEllipsis) {
              return;
            } // 垂直排版计算不太一样，因为原点坐标系不一样


            if (isUpright) {
              var n = item.verticalBaseline;

              if (n !== baseline) {
                var d = baseline - n;

                item.__offsetX(d, true); // 同下方


                increase = Math.max(increase, item.offsetWidth + d);
              }
            } else {
              var _n = item.baseline;

              if (_n !== baseline) {
                var _d = baseline - _n;

                item.__offsetY(_d, true); // text的话对齐下移可能影响整体高度，在同行有img/ib这样的替换元素下，需记录最大偏移导致的高度调整值
                // 比如一个字符和img，字符下调y即字符的baseline和图片底部对齐，导致高度增加lineHeight和baseline的差值


                increase = Math.max(increase, item.offsetHeight + _d);
              }
            }
          }); // 特殊情况，有img这样的替换元素时，要参与这一行和baseline的对齐扩充，常见于css的img底部额外4px问题
          // 先计算总体baseline和本身baseline差值得出偏移，然后加到本身lineHeight上得出尺寸，再和其它扩充取最大值

          var diff = baseline - this.__baseline;
          increase = Math.max(increase, this.__lineHeight + diff);
        }

        return Math.max(0, increase - lineHeight);
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isAlign) {
        this.__x += diff; // vertical-align或水平情况特殊对齐，可能替换元素img和text导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetX(diff, true);
          });
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isAlign) {
        this.__y += diff; // vertical-align情况或水平特殊对齐，可能替换元素img和textBox导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetY(diff, true);
          });
        }
      }
      /**
       * 防止非行首空inline，每当遇到inline就设置当前lineBox的lineHeight/baseline，这样有最小值兜底
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "__setLB",
      value: function __setLB(l, b) {
        this.__lineHeight = Math.max(l, this.__lineHeight);
        this.__baseline = Math.max(b, this.__baseline);
      }
    }, {
      key: "__resetLb",
      value: function __resetLb(l, b) {
        this.list.forEach(function (item) {
          var dom = item;

          if (item instanceof TextBox) {
            dom = item.parent.parent;
          }

          var computedStyle = dom.computedStyle;

          while (computedStyle[DISPLAY$3] === 'inline') {
            l = Math.max(l, computedStyle[LINE_HEIGHT$6]);
            b = Math.max(b, css.getBaseline(computedStyle));
            dom = dom.domParent;
            computedStyle = dom.computedStyle;
          }
        });
        this.__lineHeight = l;
        this.__baseline = b;
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__list.length;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.x + this.width;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.y + this.height;
      }
    }, {
      key: "width",
      get: function get() {
        if (this.isUpright) {
          return this.verticalLineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var x1 = first.x;
          var dom = first instanceof TextBox ? first.parent.domParent : first.domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list = dom.contentBoxList;
            var _dom$computedStyle = dom.computedStyle,
                display = _dom$computedStyle[DISPLAY$3],
                marginLeft = _dom$computedStyle[MARGIN_LEFT$3],
                borderLeftWidth = _dom$computedStyle[BORDER_LEFT_WIDTH$4],
                paddingLeft = _dom$computedStyle[PADDING_LEFT$4];

            if (display !== 'inline') {
              break;
            }

            if (first === _list[0]) {
              x1 -= marginLeft + borderLeftWidth + paddingLeft;
            }

            dom = dom.domParent;
          }

          var x2 = last.x + last.outerWidth;
          dom = last instanceof TextBox ? last.parent.domParent : last.domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list2 = dom.contentBoxList;
            var _dom$computedStyle2 = dom.computedStyle,
                _display = _dom$computedStyle2[DISPLAY$3],
                marginRight = _dom$computedStyle2[MARGIN_RIGHT$3],
                borderRightWidth = _dom$computedStyle2[BORDER_RIGHT_WIDTH$3],
                paddingRight = _dom$computedStyle2[PADDING_RIGHT$3];

            if (_display !== 'inline') {
              break;
            }

            if (first === _list2[_list2.length - 1]) {
              x2 += marginRight + borderRightWidth + paddingRight;
            }

            dom = dom.domParent;
          }

          return x2 - x1;
        }

        return 0;
      }
    }, {
      key: "height",
      get: function get() {
        if (!this.isUpright) {
          return this.lineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var y1 = first.y;
          var dom = first instanceof TextBox ? first.parent.domParent : first.domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list3 = dom.contentBoxList;
            var _dom$computedStyle3 = dom.computedStyle,
                display = _dom$computedStyle3[DISPLAY$3],
                marginTop = _dom$computedStyle3[MARGIN_TOP$3],
                borderTopWidth = _dom$computedStyle3[BORDER_TOP_WIDTH$4],
                paddingTop = _dom$computedStyle3[PADDING_TOP$4];

            if (display !== 'inline') {
              break;
            }

            if (first === _list3[0]) {
              y1 -= marginTop + borderTopWidth + paddingTop;
            }

            dom = dom.domParent;
          }

          var y2 = last.y + last.outerHeight;
          dom = last instanceof TextBox ? last.parent.domParent : last.domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list4 = dom.contentBoxList;
            var _dom$computedStyle4 = dom.computedStyle,
                _display2 = _dom$computedStyle4[DISPLAY$3],
                marginBottom = _dom$computedStyle4[MARGIN_BOTTOM$3],
                borderBottomWidth = _dom$computedStyle4[BORDER_BOTTOM_WIDTH$4],
                paddingBottom = _dom$computedStyle4[PADDING_BOTTOM$4];

            if (_display2 !== 'inline') {
              break;
            }

            if (first === _list4[_list4.length - 1]) {
              y2 += marginBottom + borderBottomWidth + paddingBottom;
            }

            dom = dom.domParent;
          }

          return y2 - y1;
        }

        return 0;
      }
    }, {
      key: "bOffset",
      get: function get() {
        return this.__bOffset;
      }
    }, {
      key: "baseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.baseline);
        });
        return baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.verticalBaseline);
        });
        return baseline;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerHeight);
        });
        return lineHeight;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerWidth);
        });
        return lineHeight;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isUpright;
      }
    }]);

    return LineBox;
  }();

  /**
   * 维护一个上下文的LineBox，向LineBox中添加Item以及新增下一行的LineBox，多个LineBox组成一个区域
   * 一个block/inlineBlock拥有一个本类对象，上下文即对应这个dom流，而inline则复用最近非inline父元素的
   * 同时LineBox可能连续也可能不连续，不连续的是中间有block之类的隔离开来
   */

  var LineBoxManager = /*#__PURE__*/function () {
    function LineBoxManager(x, y, lineHeight, baseline, isUpright) {
      _classCallCheck(this, LineBoxManager);

      this.__x = this.__lastX = x; // last存储目前最后一行LineBox的结尾位置，供后续inline使用

      this.__y = this.__lastY = y;
      this.__max = isUpright ? y : x;
      this.__domList = [];
      this.__domStack = [];
      this.__list = []; // 包含若干LineBox

      this.__isNewLine = true; // 区域内是否是新行，容器dom（block）开头肯定是

      this.__lineHeight = lineHeight;
      this.__baseline = baseline;
      this.__isEnd = true; // 在dom中是否一个区域处在结尾，外部控制

      this.__spreadList = []; // verticalAlign时每个区域增加的y高度

      this.__isVertical = isUpright;
    }
    /**
     * 每次换行时重新生成LineBox存入列表，同时由于flow流当前一定是流（dom）的结尾，设置isEnd
     * @returns {LineBox}
     */


    _createClass(LineBoxManager, [{
      key: "genLineBox",
      value: function genLineBox(x, y) {
        var lineBox = new LineBox(x, y, this.__lineHeight, this.__baseline, this.isUpright);
        this.list.push(lineBox);
        this.__isEnd = true;
        return lineBox;
      }
      /**
       * inline的特殊调用，防止空内容但有mbp的inline不占位，放入一个有lineHeight的空lineBox
       * 只有新行开头时需要，后面的无论是否有内容都会影响lineHeight
       * @param x
       * @param y
       * @param l
       * @param b
       * @returns {LineBox}
       */

    }, {
      key: "genLineBoxByInlineIfNewLine",
      value: function genLineBoxByInlineIfNewLine(x, y, l, b) {
        var lineHeight = Math.max(this.__lineHeight, l);
        var baseline = Math.max(this.__baseline, b);

        if (this.__isNewLine) {
          var lineBox = new LineBox(x, y, lineHeight, baseline, this.isUpright);
          this.list.push(lineBox);
          this.__isEnd = true;
          this.__isNewLine = false;
          return lineBox;
        }
      }
      /**
       * 外部设置为结尾，如一个LineBox后出现一个block，此时会被隔断，不再作为流的末尾
       */

    }, {
      key: "setNotEnd",
      value: function setNotEnd() {
        this.__isEnd = false;
      }
      /**
       * 外部设置新行，下次新生成LineBox
       */

    }, {
      key: "setNewLine",
      value: function setNewLine() {
        this.__isNewLine = true;
      }
      /**
       * 当前LineBox放入一个新项，当新行时（如第一行）产生一个新的LineBox并存入列表
       * 是否新区域和新行都是可以被外部控制，默认第一行是新
       * 当被隔断后会被外部重置新行，这样会生成新的来作为新加项的LineBox
       * 当换行时外部也会调用新行，这样再次添加Item时会自动生成新的LineBox而不是用之前的
       * @param o TextBox/Inline/InlineBlock
       * @param nextNewLine 是否设置newLine，标明下次添加新生成LineBox
       * @returns {LineBox}
       */

    }, {
      key: "addItem",
      value: function addItem(o, nextNewLine) {
        var lineBox,
            isUpright = this.isUpright; // 新行新的lineBox，否则复用最后一个

        if (this.__isNewLine) {
          this.__isNewLine = false;
          lineBox = this.genLineBox(o.x, o.y);
        } else {
          var list = this.list;
          var length = list.length;
          lineBox = list[length - 1];
        } // inline递归过程中所有inline父子顺序列表，每个dom都需要对当前内容保存


        this.__domStack.forEach(function (item) {
          item.__contentBoxList.push(o);
        });

        lineBox.add(o); // 设置结束x的位置给next的inline标记用，o可能是TextBox或inlineBlock，当next新行时注意位置

        if (nextNewLine) {
          this.__isNewLine = true;
          this.__lastX = o.x;
          this.__lastY = o.y + o.outerHeight;
        } else {
          if (isUpright) {
            this.__lastX = o.x;
            this.__lastY = o.y + o.outerHeight;
          } else {
            this.__lastX = o.x + o.outerWidth;
            this.__lastY = o.y;
          }
        }

        this.__max = Math.max(this.__max, isUpright ? o.y + o.outerHeight : o.x + o.outerWidth);
        return lineBox;
      }
    }, {
      key: "horizonAlign",
      value: function horizonAlign(size, textAlign, isUpright) {
        this.list.forEach(function (lineBox) {
          var diff = size - (isUpright ? lineBox.height : lineBox.width);

          if (diff > 0) {
            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (isUpright) {
              lineBox.__offsetY(diff, true);
            } else {
              lineBox.__offsetX(diff, true);
            }
          }
        });
      }
      /**
       * 垂直对齐过程中，如果遇到占位元素如img，可能会导致每行lineBox高度增加，需返回增加量，
       * next行也需要y偏移
       * @returns {number}
       */

    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var spreadList = this.__spreadList;
        spreadList.splice(0);
        var spread = 0;
        this.list.forEach(function (lineBox) {
          if (spread) {
            lineBox.__bOffset = spread; // 对齐造成的误差需记录给baseline修正

            if (isUpright) {
              lineBox.__offsetX(spread, true);
            } else {
              lineBox.__offsetY(spread, true);
            }
          }

          spread += lineBox.verticalAlign(isUpright);
          spreadList.push(spread);
        });
        return spread;
      }
    }, {
      key: "addX",
      value: function addX(n) {
        this.__lastX += n;
      }
    }, {
      key: "addY",
      value: function addY(n) {
        this.__lastY += n;
      }
      /**
       * inline递归过程中布局调用，不断出入栈dom对象，获取当前行状态下有哪些dom还在
       * @param dom
       */

    }, {
      key: "pushContentBoxList",
      value: function pushContentBoxList(dom) {
        this.__domList.push(dom);

        this.__domStack.push(dom);
      }
    }, {
      key: "popContentBoxList",
      value: function popContentBoxList() {
        this.__domStack.pop();
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetX(diff);
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetY(diff);
        });
      }
      /**
       * inline的特殊调用，非行首无论是否有内容都设置lineBox的lineHeight
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "setLbByInlineIfNotNewLine",
      value: function setLbByInlineIfNotNewLine(l, b) {
        var length = this.list.length;

        if (length && !this.isNewLine) {
          this.list[length - 1].__setLB(l, b, false);
        }
      }
    }, {
      key: "size",
      get: function get() {
        return this.list.length;
      }
    }, {
      key: "lastX",
      get: function get() {
        return this.__lastX;
      }
    }, {
      key: "lastY",
      get: function get() {
        return this.__lastY;
      }
    }, {
      key: "endX",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endX;
        }

        return this.__x;
      }
    }, {
      key: "endY",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endY;
        }

        return this.__y;
      }
    }, {
      key: "isEnd",
      get: function get() {
        return this.__isEnd;
      }
    }, {
      key: "isNewLine",
      get: function get() {
        return this.__isNewLine;
      }
    }, {
      key: "breakLine",
      get: function get() {
        return this.list.length > 1;
      }
    }, {
      key: "domList",
      get: function get() {
        return this.__domList;
      }
    }, {
      key: "baseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          var n = 0;

          for (var i = 0; i < length - 1; i++) {
            n += list[i].height;
          } // 需考虑因为verticalAlign造成的lineBox偏移offset值，修正计算正确的baseline


          return n + list[length - 1].baseline + list[length - 1].bOffset;
        }

        return 0;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline;
        }

        return 0;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline + list[0].bOffset;
        }

        return 0;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].lineHeight;
        }

        return 0;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].verticalLineHeight;
        }

        return 0;
      }
    }, {
      key: "lineBox",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1];
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "width",
      get: function get() {
        var w = 0;
        this.list.forEach(function (item) {
          w = Math.max(w, item.width);
        });
        return w;
      }
    }, {
      key: "spreadList",
      get: function get() {
        return this.__spreadList;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "max",
      get: function get() {
        return this.__max;
      }
    }]);

    return LineBoxManager;
  }();

  var TAG_NAME = {
    'div': true,
    'p': true,
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var INLINE = {
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var BOLD = {
    'b': true,
    'strong': true
  };
  var tag = {
    TAG_NAME: TAG_NAME,
    INLINE: INLINE,
    BOLD: BOLD
  };

  var _enums$STYLE_KEY$f = enums.STYLE_KEY,
      DISPLAY$4 = _enums$STYLE_KEY$f.DISPLAY,
      TOP$2 = _enums$STYLE_KEY$f.TOP,
      BOTTOM$2 = _enums$STYLE_KEY$f.BOTTOM,
      POSITION$3 = _enums$STYLE_KEY$f.POSITION,
      HEIGHT$5 = _enums$STYLE_KEY$f.HEIGHT;
  var AUTO$4 = o.AUTO,
      PX$5 = o.PX,
      PERCENT$6 = o.PERCENT;
  var REFLOW$1 = o$3.REFLOW;

  function offsetAndResizeByNodeOnY(node, root, reflowHash, dy, inDirectAbsList) {
    if (dy) {
      var last;

      do {
        // component的sr没有next兄弟，视为component的next
        while (node.isShadowRoot) {
          node = node.host;
        }

        last = node;
        var isContainer = void 0,
            parent = node.domParent;

        if (parent) {
          var cs = parent.computedStyle;
          var ps = cs[POSITION$3];
          isContainer = parent === root || parent.isShadowRoot || ps === 'relative' || ps === 'absolute';
        } // 先偏移next，忽略有定位的absolute，本身非container也忽略


        var next = node.next;
        var container = void 0;

        while (next) {
          if (next.computedStyle[DISPLAY$4] !== 'none') {
            if (next.currentStyle[POSITION$3] === 'absolute') {
              var _next$currentStyle = next.currentStyle,
                  top = _next$currentStyle[TOP$2],
                  bottom = _next$currentStyle[BOTTOM$2],
                  height = _next$currentStyle[HEIGHT$5];

              if (top[1] === AUTO$4) {
                if (bottom[1] === AUTO$4 || bottom[1] === PX$5) {
                  next.__offsetY(dy, true, REFLOW$1);

                  next.clearCache();
                } else if (bottom[1] === PERCENT$6) {
                  var v = (1 - bottom[0] * 0.01) * dy;

                  next.__offsetY(v, true, REFLOW$1);

                  next.clearCache();
                }
              } else if (top[1] === PERCENT$6) {
                var _v = top[0] * 0.01 * dy;

                next.__offsetY(_v, true, REFLOW$1);

                next.clearCache();
              } // 高度百分比需发生变化的重新布局，需要在容器内


              if (height[1] === PERCENT$6) {
                if (isContainer) {
                  parent.__layoutAbs(parent, parent.__layoutData, next);
                } else {
                  if (!container) {
                    container = parent;

                    while (container) {
                      if (container === root || container.isShadowRoot) {
                        break;
                      }

                      var _cs = container.currentStyle;

                      if (_cs[POSITION$3] === 'absolute' || _cs[POSITION$3] === 'relative') {
                        break;
                      }

                      container = container.domParent;
                    }
                  }

                  inDirectAbsList.push([parent, container, next]);
                }
              }
            } else {
              next.__offsetY(dy, true, REFLOW$1);

              next.clearCache();
            }
          }

          next = next.next;
        } // root本身没domParent


        if (!parent) {
          break;
        }

        node = parent; // parent判断是否要resize

        var _node = node,
            currentStyle = _node.currentStyle;
        var isAbs = currentStyle[POSITION$3] === 'absolute';
        var need = void 0;

        if (isAbs) {
          if (currentStyle[HEIGHT$5][1] === AUTO$4 && (currentStyle[TOP$2][1] === AUTO$4 || currentStyle[BOTTOM$2][1] === AUTO$4)) {
            need = true;
          }
        } // height不定则需要
        else if (currentStyle[HEIGHT$5][1] === AUTO$4) {
          need = true;
        }

        if (need) {
          node.__resizeY(dy, REFLOW$1);

          node.clearCache();
        } // abs或者高度不需要继续向上调整提前跳出
        else {
          break;
        }

        if (node === root) {
          break;
        }
      } while (true); // 最后一个递归向上取消总缓存，防止过程中重复next多次无用递归


      while (last) {
        last.clearCache(true);
        last = last.domParent;
      }
    }
  }

  function clearUniqueReflowId(hash) {
    for (var i in hash) {
      if (hash.hasOwnProperty(i)) {
        var node = hash[i].node;
        delete node.__uniqueReflowId;
      }
    }
  }

  function getMergeMargin(topList, bottomList) {
    var total = 0;
    var max = topList[0];
    var min = topList[0];
    topList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    });
    bottomList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    }); // 正数取最大，负数取最小，正负则相加

    var diff = 0;

    if (max > 0 && min > 0) {
      diff = Math.max(max, min) - total;
    } else if (max < 0 && min < 0) {
      diff = Math.min(max, min) - total;
    } else if (max !== 0 || min !== 0) {
      diff = max + min - total;
    }

    return diff;
  }

  var reflow = {
    offsetAndResizeByNodeOnY: offsetAndResizeByNodeOnY,
    clearUniqueReflowId: clearUniqueReflowId,
    getMergeMargin: getMergeMargin
  };

  var _enums$STYLE_KEY$g = enums.STYLE_KEY,
      POSITION$4 = _enums$STYLE_KEY$g.POSITION,
      DISPLAY$5 = _enums$STYLE_KEY$g.DISPLAY,
      MARGIN_LEFT$4 = _enums$STYLE_KEY$g.MARGIN_LEFT,
      MARGIN_TOP$4 = _enums$STYLE_KEY$g.MARGIN_TOP,
      MARGIN_RIGHT$4 = _enums$STYLE_KEY$g.MARGIN_RIGHT,
      MARGIN_BOTTOM$4 = _enums$STYLE_KEY$g.MARGIN_BOTTOM,
      PADDING_LEFT$5 = _enums$STYLE_KEY$g.PADDING_LEFT,
      PADDING_BOTTOM$5 = _enums$STYLE_KEY$g.PADDING_BOTTOM,
      PADDING_RIGHT$4 = _enums$STYLE_KEY$g.PADDING_RIGHT,
      PADDING_TOP$5 = _enums$STYLE_KEY$g.PADDING_TOP,
      BORDER_TOP_WIDTH$5 = _enums$STYLE_KEY$g.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$5 = _enums$STYLE_KEY$g.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$4 = _enums$STYLE_KEY$g.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$5 = _enums$STYLE_KEY$g.BORDER_LEFT_WIDTH,
      TOP$3 = _enums$STYLE_KEY$g.TOP,
      RIGHT$1 = _enums$STYLE_KEY$g.RIGHT,
      BOTTOM$3 = _enums$STYLE_KEY$g.BOTTOM,
      LEFT$1 = _enums$STYLE_KEY$g.LEFT,
      WIDTH$5 = _enums$STYLE_KEY$g.WIDTH,
      HEIGHT$6 = _enums$STYLE_KEY$g.HEIGHT,
      TEXT_ALIGN$3 = _enums$STYLE_KEY$g.TEXT_ALIGN,
      FLEX_DIRECTION$3 = _enums$STYLE_KEY$g.FLEX_DIRECTION,
      FLEX_BASIS$2 = _enums$STYLE_KEY$g.FLEX_BASIS,
      FLEX_SHRINK$2 = _enums$STYLE_KEY$g.FLEX_SHRINK,
      FLEX_GROW$2 = _enums$STYLE_KEY$g.FLEX_GROW,
      ALIGN_SELF$2 = _enums$STYLE_KEY$g.ALIGN_SELF,
      ALIGN_ITEMS$2 = _enums$STYLE_KEY$g.ALIGN_ITEMS,
      JUSTIFY_CONTENT$2 = _enums$STYLE_KEY$g.JUSTIFY_CONTENT,
      Z_INDEX$3 = _enums$STYLE_KEY$g.Z_INDEX,
      WHITE_SPACE$3 = _enums$STYLE_KEY$g.WHITE_SPACE,
      LINE_HEIGHT$7 = _enums$STYLE_KEY$g.LINE_HEIGHT,
      LINE_CLAMP$2 = _enums$STYLE_KEY$g.LINE_CLAMP,
      ORDER$2 = _enums$STYLE_KEY$g.ORDER,
      FLEX_WRAP$2 = _enums$STYLE_KEY$g.FLEX_WRAP,
      ALIGN_CONTENT$1 = _enums$STYLE_KEY$g.ALIGN_CONTENT,
      OVERFLOW$2 = _enums$STYLE_KEY$g.OVERFLOW,
      FONT_SIZE$a = _enums$STYLE_KEY$g.FONT_SIZE,
      FONT_FAMILY$6 = _enums$STYLE_KEY$g.FONT_FAMILY,
      FONT_WEIGHT$6 = _enums$STYLE_KEY$g.FONT_WEIGHT,
      WRITING_MODE$2 = _enums$STYLE_KEY$g.WRITING_MODE,
      _enums$NODE_KEY$4 = enums.NODE_KEY,
      NODE_CURRENT_STYLE$2 = _enums$NODE_KEY$4.NODE_CURRENT_STYLE,
      NODE_STYLE$2 = _enums$NODE_KEY$4.NODE_STYLE,
      NODE_STRUCT$2 = _enums$NODE_KEY$4.NODE_STRUCT,
      NODE_DOM_PARENT$3 = _enums$NODE_KEY$4.NODE_DOM_PARENT,
      NODE_IS_INLINE$1 = _enums$NODE_KEY$4.NODE_IS_INLINE,
      _enums$UPDATE_KEY$3 = enums.UPDATE_KEY,
      UPDATE_NODE$3 = _enums$UPDATE_KEY$3.UPDATE_NODE,
      UPDATE_FOCUS$2 = _enums$UPDATE_KEY$3.UPDATE_FOCUS,
      UPDATE_ADD_DOM = _enums$UPDATE_KEY$3.UPDATE_ADD_DOM,
      UPDATE_CONFIG$3 = _enums$UPDATE_KEY$3.UPDATE_CONFIG,
      _enums$STRUCT_KEY$1 = enums.STRUCT_KEY,
      STRUCT_NUM = _enums$STRUCT_KEY$1.STRUCT_NUM,
      STRUCT_LV$1 = _enums$STRUCT_KEY$1.STRUCT_LV,
      STRUCT_TOTAL = _enums$STRUCT_KEY$1.STRUCT_TOTAL,
      STRUCT_CHILD_INDEX$1 = _enums$STRUCT_KEY$1.STRUCT_CHILD_INDEX,
      STRUCT_INDEX$1 = _enums$STRUCT_KEY$1.STRUCT_INDEX,
      ELLIPSIS$1 = enums.ELLIPSIS;
  var AUTO$5 = o.AUTO,
      PX$6 = o.PX,
      PERCENT$7 = o.PERCENT,
      REM$6 = o.REM,
      VW$6 = o.VW,
      VH$6 = o.VH,
      VMAX$6 = o.VMAX,
      VMIN$6 = o.VMIN;
  var isRelativeOrAbsolute$1 = css.isRelativeOrAbsolute,
      getBaseline$1 = css.getBaseline,
      getVerticalBaseline$1 = css.getVerticalBaseline;
  var extend$2 = util.extend,
      isNil$7 = util.isNil,
      isFunction$6 = util.isFunction;
  var CANVAS$5 = mode.CANVAS,
      SVG$4 = mode.SVG,
      WEBGL$5 = mode.WEBGL; // 渲染获取zIndex顺序

  function genZIndexChildren(dom) {
    var normal = [];
    var hasMc;
    var mcHash = {};
    var lastMaskIndex;
    var children = dom.children;
    children.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component$1) {
        item = item.shadowRoot;
      } // 遮罩单独保存后特殊排序


      if (item instanceof Xom$1 && item.isMask) {
        // 开头的mc忽略，后续的连续mc以第一次出现为准
        if (lastMaskIndex !== undefined) {
          mcHash[lastMaskIndex].push(item);
        } else if (i) {
          lastMaskIndex = i - 1;
          children[lastMaskIndex].__iIndex = lastMaskIndex;
          mcHash[lastMaskIndex] = [item];
          hasMc = true;
        }
      } else {
        lastMaskIndex = undefined;

        if (item instanceof Xom$1) {
          child.__zIndex = item.currentStyle[Z_INDEX$3];

          if (isRelativeOrAbsolute$1(item)) {
            // 临时变量为排序使用
            child.__aIndex = true;
            normal.push(child);
          } else {
            normal.push(child);
          }
        } else {
          child.__zIndex = 0;
          normal.push(child);
        }

        child.__iIndex = i;
      }
    });
    normal.sort(function (a, b) {
      if (a.__zIndex !== b.__zIndex) {
        return a.__zIndex - b.__zIndex;
      } // zIndex相等时abs优先flow


      if (a.__aIndex !== b.__aIndex) {
        if (a.__aIndex) {
          return 1;
        }

        return -1;
      } // 都相等看索引


      return a.__iIndex - b.__iIndex;
    }); // 将遮罩插入到对应顺序上

    if (hasMc) {
      for (var i = normal.length - 1; i >= 0; i--) {
        var idx = normal[i].__iIndex;

        if (mcHash.hasOwnProperty(idx)) {
          normal.splice.apply(normal, [i + 1, 0].concat(_toConsumableArray(mcHash[idx])));
        }
      }
    }

    return normal;
  } // flex布局阶段顺序，不是渲染也和struct结构无关，可以无视mask


  function genOrderChildren(flowChildren) {
    var normal = [];
    flowChildren.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component$1) {
        item = item.shadowRoot;
      }

      if (item instanceof Xom$1) {
        child.__order = item.currentStyle[ORDER$2];
      } else {
        child.__order = 0;
      }

      normal.push(child);
      child.__iIndex = i;
    });
    normal.sort(function (a, b) {
      if (a.__order !== b.__order) {
        return a.__order - b.__order;
      } // order相等时看节点索引


      return a.__iIndex - b.__iIndex;
    });
    return normal;
  }
  /**
   * lineClamp超出范围时ib作为最后一行最后一个无法挤下时进行回溯
   */


  function backtrack(bp, lineBoxManager, lineBox, total, endSpace, isUpright) {
    var ew,
        computedStyle = bp.computedStyle,
        root = bp.root,
        renderMode = root.renderMode;
    var list = lineBox.list; // 根据textBox里的内容，确定当前内容，索引，x和剩余宽度

    list.forEach(function (item) {
      total -= isUpright ? item.outerHeight : item.outerWidth;
    });
    var ctx;

    if (renderMode === CANVAS$5 || renderMode === WEBGL$5) {
      ctx = renderMode === WEBGL$5 ? inject.getFontCanvas().ctx : root.ctx;
    } // 临时测量ELLIPSIS的尺寸


    if (renderMode === CANVAS$5 || renderMode === WEBGL$5) {
      var font = css.setFontStyle(computedStyle);

      if (ctx.font !== font) {
        ctx.font = font;
      }

      ew = ctx.measureText(ELLIPSIS$1).width;
    } else {
      ew = inject.measureTextSync(ELLIPSIS$1, computedStyle[FONT_FAMILY$6], computedStyle[FONT_SIZE$a], computedStyle[FONT_WEIGHT$6]);
    }

    for (var i = list.length - 1; i >= 0; i--) {
      var item = list[i]; // 无论删除一个ib还是textBox，放得下的话都可以暂停循环，注意强制保留行首

      if (!i || total + item.outerWidth >= ew + 1e-10) {
        if (item instanceof TextBox) {
          var text = item.parent;

          text.__backtrack(bp, lineBoxManager, lineBox, item, total, endSpace, ew, computedStyle, ctx, renderMode, isUpright);
        } else {
          var ep = new Ellipsis(item.x + item.outerWidth + endSpace, item.y, ew, bp);
          lineBoxManager.addItem(ep, true);
        }

        break;
      } // 放不下删除
      else {
        if (item instanceof TextBox) {
          var _text = item.parent;

          var _i = _text.textBoxes.indexOf(item);

          if (_i > -1) {
            _text.textBoxes.splice(_i, 1);
          }
        } else {
          item.__layoutNone();
        }

        list.pop();
        total += isUpright ? item.outerHeight : item.outerWidth;
      }
    }
  }

  var Dom$1 = /*#__PURE__*/function (_Xom) {
    _inherits(Dom, _Xom);

    var _super = _createSuper(Dom);

    function Dom(tagName, props, children) {
      var _this;

      _classCallCheck(this, Dom);

      _this = _super.call(this, tagName, props);

      var _assertThisInitialize = _assertThisInitialized(_this),
          style = _assertThisInitialize.style;

      if (!style.display || !{
        flex: true,
        block: true,
        inline: true,
        'inline-block': true,
        inlineBlock: true,
        none: true
      }.hasOwnProperty(style.display)) {
        if (tag.INLINE.hasOwnProperty(_this.tagName)) {
          style.display = 'inline';
        } else {
          style.display = 'block';
        }
      }

      if (!style[FONT_WEIGHT$6] && tag.BOLD.hasOwnProperty(tagName)) {
        style.fontWeight = 700;
      }

      _this.__style = css.normalize(style, reset.DOM_ENTRY_SET); // currentStyle/currentProps不深度clone，继承一层即可，动画时也是extend这样只改一层引用不动原始静态style

      _this.__currentStyle = extend$2({}, _this.__style);
      _this.__children = children || [];
      _this.__flexLine = []; // flex布局多行模式时存储行

      _this.__ellipsis = null; // 虚拟节点，有的话渲染

      var config = _this.__config;
      config[NODE_CURRENT_STYLE$2] = _this.__currentStyle;
      config[NODE_STYLE$2] = _this.__style;
      return _this;
    }

    _createClass(Dom, [{
      key: "__structure",
      value: function __structure(i, lv, j) {
        var res = _get(_getPrototypeOf(Dom.prototype), "__structure", this).call(this, i++, lv, j);

        var arr = [res];
        var zIndexChildren = this.__zIndexChildren = this.__zIndexChildren || genZIndexChildren(this);
        zIndexChildren.forEach(function (child, j) {
          var temp = child.__structure(i, lv + 1, j);

          if (Array.isArray(temp)) {
            i += temp.length;
            arr = arr.concat(temp);
          } else {
            i++;
            arr.push(temp);
          }
        });
        var total = arr.length - 1;
        res[STRUCT_NUM] = zIndexChildren.length;
        res[STRUCT_TOTAL] = total;
        return arr;
      }
    }, {
      key: "__modifyStruct",
      value: function __modifyStruct(root) {
        var _root$__structs;

        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var __config = this.__config;
        var struct = __config[NODE_STRUCT$2];
        var total = struct[STRUCT_TOTAL] || 0; // 新生成了struct，引用也变了

        var nss = this.__structure(struct[STRUCT_INDEX$1], struct[STRUCT_LV$1], struct[STRUCT_CHILD_INDEX$1]);

        (_root$__structs = root.__structs).splice.apply(_root$__structs, [struct[STRUCT_INDEX$1] + offset, total + 1].concat(_toConsumableArray(nss)));

        var d = 0;

        if (this !== root) {
          struct = __config[NODE_STRUCT$2];
          d = (struct[STRUCT_TOTAL] || 0) - total;
          var ps = __config[NODE_DOM_PARENT$3].__config[NODE_STRUCT$2];
          ps[STRUCT_TOTAL] = ps[STRUCT_TOTAL] || 0;
          ps[STRUCT_TOTAL] += d;
        }

        return [struct, d];
      }
      /**
       * 因为zIndex/abs的变化造成的更新，只需重排这一段顺序即可
       * 即便包含component造成的dom变化也不影响，component作为子节点reflow会再执行，这里重排老的vd
       * @param structs
       * @private
       */

    }, {
      key: "__updateStruct",
      value: function __updateStruct(structs) {
        var _this$__config$NODE_S = this.__config[NODE_STRUCT$2],
            index = _this$__config$NODE_S[STRUCT_INDEX$1],
            _this$__config$NODE_S2 = _this$__config$NODE_S[STRUCT_TOTAL],
            total = _this$__config$NODE_S2 === void 0 ? 0 : _this$__config$NODE_S2;
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);
        var length = zIndexChildren.length;

        if (length === 1) {
          return;
        }

        zIndexChildren.forEach(function (child, i) {
          child.__config[NODE_STRUCT$2][STRUCT_CHILD_INDEX$1] = i;
        }); // 按直接子节点划分为相同数量的若干段进行排序

        var arr = [];
        var source = [];

        for (var i = index + 1; i <= index + total; i++) {
          var child = structs[i];
          var o = {
            child: child,
            list: structs.slice(child[STRUCT_INDEX$1], child[STRUCT_INDEX$1] + child[STRUCT_TOTAL] + 1)
          };
          arr.push(o);
          source.push(o);
          i += child[STRUCT_TOTAL] || 0;
        }

        arr.sort(function (a, b) {
          return a.child[STRUCT_CHILD_INDEX$1] - b.child[STRUCT_CHILD_INDEX$1];
        }); // 是否有变更，有才进行重新计算

        var needSort;

        for (var _i2 = 0, len = source.length; _i2 < len; _i2++) {
          if (source[_i2] !== arr[_i2]) {
            needSort = true;
            break;
          }
        }

        if (needSort) {
          var list = [];
          arr.forEach(function (item) {
            list = list.concat(item.list);
          });
          list.forEach(function (struct, i) {
            struct[STRUCT_INDEX$1] = index + i + 1;
          });
          structs.splice.apply(structs, [index + 1, total].concat(_toConsumableArray(list)));
        }
      }
      /**
       * 给定父宽度情况下，尝试行内放下后的剩余宽度，为负数即放不下，这里只会出现行内级即inline(Block)
       * 调用前提是非行开头的inline尝试计算是否放得下，开头无需且禁止判断，防止出现永远放不下一个字符卡死
       * 返回非负数就是放得下，这样一些尺寸为0的也算
       * @param free 剩余宽度
       * @param total 容器尺寸
       * @param isUpright 垂直排版
       * @returns {number|*}
       * @private
       */

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(free, total, isUpright) {
        this.__computeReflow();

        var flowChildren = this.flowChildren,
            _this$currentStyle = this.currentStyle,
            display = _this$currentStyle[DISPLAY$5],
            width = _this$currentStyle[WIDTH$5],
            height = _this$currentStyle[HEIGHT$6],
            marginLeft = _this$currentStyle[MARGIN_LEFT$4],
            marginRight = _this$currentStyle[MARGIN_RIGHT$4],
            marginTop = _this$currentStyle[MARGIN_TOP$4],
            marginBottom = _this$currentStyle[MARGIN_BOTTOM$4],
            paddingLeft = _this$currentStyle[PADDING_LEFT$5],
            paddingRight = _this$currentStyle[PADDING_RIGHT$4],
            paddingTop = _this$currentStyle[PADDING_TOP$5],
            paddingBottom = _this$currentStyle[PADDING_BOTTOM$5],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$5],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$4],
            borderTopWidth = _this$computedStyle[BORDER_TOP_WIDTH$5],
            borderBottomWidth = _this$computedStyle[BORDER_BOTTOM_WIDTH$5]; // inline没w/h，并且尝试孩子第一个能放下即可，如果是文字就是第一个字符

        if (display === 'inline') {
          if (flowChildren.length) {
            var first = flowChildren[0];

            if (first instanceof Component$1) {
              first = first.shadowRoot;
            }

            if (first instanceof Xom$1) {
              free = first.__tryLayInline(free, total, isUpright);
            } else {
              free -= first.firstCharWidth;
            }
          }
        } // inlineBlock尝试所有孩子在一行上
        else {
          if (width[1] !== AUTO$5) {
            free -= isUpright ? this.__calSize(height, total, true) : this.__calSize(width, total, true);
          } else {
            for (var i = 0; i < flowChildren.length; i++) {
              // 当放不下时直接返回，无需继续多余的尝试计算
              if (free < 0) {
                return free;
              }

              var item = flowChildren[i];

              if (item instanceof Component$1) {
                item = item.shadowRoot;
              }

              if (item instanceof Xom$1) {
                free = item.__tryLayInline(free, total, isUpright);
              } // text强制一行，否则非头就是放不下，需从头开始
              else {
                free -= item.textWidth;
              }
            }
          } // ib要减去末尾mpb


          if (isUpright) {
            free -= this.__calSize(marginBottom, total, true);
            free -= this.__calSize(paddingBottom, total, true);
            free -= borderBottomWidth;
          } else {
            free -= this.__calSize(marginRight, total, true);
            free -= this.__calSize(paddingRight, total, true);
            free -= borderRightWidth;
          }
        } // 还要减去开头的mpb


        if (isUpright) {
          free -= this.__calSize(marginTop, total, true);
          free -= this.__calSize(paddingTop, total, true);
          free -= borderTopWidth;
        } else {
          free -= this.__calSize(marginLeft, total, true);
          free -= this.__calSize(paddingLeft, total, true);
          free -= borderLeftWidth;
        }

        return free;
      } // 设置y偏移值，递归包括children，此举在justify-content/margin-auto等对齐用

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        _get(_getPrototypeOf(Dom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetX(diff, isLayout);
        } // 记得偏移LineBox


        if (isLayout && !this.__config[NODE_IS_INLINE$1] && this.lineBoxManager) {
          this.lineBoxManager.__offsetX(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetX(diff, isLayout, lv);
          }
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        _get(_getPrototypeOf(Dom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetY(diff, isLayout);
        }

        if (isLayout && !this.__config[NODE_IS_INLINE$1] && this.lineBoxManager) {
          this.lineBoxManager.__offsetY(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetY(diff, isLayout, lv);
          }
        });
      }
      /**
       * flex布局时，计算basis尺寸，如果有固定声明则以其为标准，content为内容最大尺寸，auto依赖w/h或降级content
       * basis要考虑相加直接item的mpb，非绝对值单位以container为基准，basis为内容时为max值
       * item的孩子为孙子节点需递归，不参与basis计算，只参与min/max，尺寸和mpb均只考虑绝对值
       * 自动计算时影响尺寸的只有换行的text，以及一组inline，均按其中最大尺寸的一个计算
       * auto自动计算递归进行，如果是普通row方向，按最大text的charWidth为准
       * 如果是column方向，则虚拟布局后看text的height
       * 在abs下时进入特殊状态，无论是row/column，都会按row方向尝试最大尺寸，直到舞台边缘或容器声明的w折行
       * 返回b，声明则按css值，否则是auto/content
       * 返回min为最小宽度，遇到字符/inline则单列排版后需要的最大宽度
       * 返回max为最大宽度，理想情况一排最大值，在abs时virtualMode状态参与计算，文本抵达边界才进行换行
       * 当为column方向时，特殊进行虚拟布局isVirtual，需要获取高度
       * @param isDirectionRow
       * @param isAbs
       * @param isColumn
       * @param data
       * @param isDirectChild
       * @private
       */

    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        var _this2 = this;

        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexDirection = currentStyle[FLEX_DIRECTION$3],
            flexBasis = currentStyle[FLEX_BASIS$2],
            width = currentStyle[WIDTH$5],
            height = currentStyle[HEIGHT$6];
        var lineHeight = computedStyle[LINE_HEIGHT$7],
            display = computedStyle[DISPLAY$5],
            lineClamp = computedStyle[LINE_CLAMP$2],
            writingMode = computedStyle[WRITING_MODE$2];
        var isUpright = writingMode.indexOf('vertical') === 0;
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content

        var isAuto = flexBasis[1] === AUTO$5;
        var isFixed = [PX$6, PERCENT$7, REM$6, VW$6, VH$6, VMAX$6, VMIN$6].indexOf(flexBasis[1]) > -1;
        var isContent = !isAuto && !isFixed;
        var fixedSize; // flex的item固定basis计算

        if (isFixed) {
          b = fixedSize = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } // 已声明主轴尺寸的，当basis是auto时为main值
        else if (isAuto && [PX$6, PERCENT$7, REM$6, VW$6, VH$6, VMAX$6, VMIN$6].indexOf(main[1]) > -1) {
          b = fixedSize = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 非固定尺寸的basis为auto时降级为content
        else if (isAuto) {
          isContent = true;
        }

        var countMin = 0,
            countMax = 0;
        lineClamp = lineClamp || 0; // row的flex时，child只需计算宽度的basis/min/max，递归下去也是如此，即便包含递归的flex

        if (isDirectionRow) {
          // flex的item还是flex时
          if (display === 'flex') {
            var isR = ['column', 'columnReverse'].indexOf(flexDirection) === -1;
            flowChildren = genOrderChildren(flowChildren);
            flowChildren.forEach(function (item) {
              if (item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1) {
                var _item$__calBasis = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h
                }, false),
                    _item$__calBasis2 = _slicedToArray(_item$__calBasis, 3),
                    min2 = _item$__calBasis2[1],
                    max2 = _item$__calBasis2[2];

                if (isR) {
                  min += min2;
                  max += max2;
                } else {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                }
              } // text除了flex还需要分辨垂直排版
              else {
                if (isUpright) {
                  var lineBoxManager = _this2.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);

                  item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    isUpright: isUpright
                  });

                  min += item.width;
                  max += item.width;
                }

                if (isR) {
                  min += item.charWidth;
                  max += item.textWidth;
                } else {
                  min = Math.max(min, item.charWidth);
                  max = Math.max(max, item.textWidth);
                }
              }
            });
          } // 特殊的flex水平布局但书写垂直，遇到后直接假布局获取宽度，因为水平尺寸视为无限但垂直不是，
          // 这里一定是第一个垂直排版不会递归下去，因为flex的child匿名block，水平的垂直书写inline匿名ib
          else if (isUpright) {
            var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);

            this.__layout({
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              isUpright: isUpright
            }, isAbs, false, true);

            min = max = b = this.width;
          } // flex的item是block/inline时，inline也会变成block统一对待，递归下去会有inline出现，但row的水平size为无穷不会换行可以忽略
          else {
            var _lineBoxManager = data.lineBoxManager;

            if (display !== 'inline') {
              _lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);
            }

            flowChildren.forEach(function (item) {
              if (item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1) {
                var _item$__calBasis3 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lineBoxManager: _lineBoxManager
                }, false),
                    _item$__calBasis4 = _slicedToArray(_item$__calBasis3, 3),
                    min2 = _item$__calBasis4[1],
                    max2 = _item$__calBasis4[2];

                var _display = item.computedStyle[DISPLAY$5]; // row看块级最大尺寸和连续行级最大尺寸的宽

                if (_display === 'block' || _display === 'flex') {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                  countMin = countMax = 0;
                } else {
                  countMin += min2;
                  countMax += max2;
                  min = Math.max(min, countMin);
                  max = Math.max(max, countMax);
                }
              } else {
                countMin += item.charWidth;
                countMax += item.textWidth;
                min = Math.max(min, countMin);
                max = Math.max(max, countMax);
              }
            });
          }

          if (fixedSize) {
            max = Math.max(fixedSize, max);
          } // row降级为内容时basis等同于max


          if (isContent) {
            b = max;
          }
        } // column的flex时，每个child做一次虚拟布局，获取到每个child的高度和宽度
        else {
          this.__layout({
            x: x,
            y: y,
            w: w,
            h: h,
            isUpright: isUpright
          }, isAbs, true, false);

          min = max = b = this.height; // column的child，max和b总相等
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        _get(_getPrototypeOf(Dom.prototype), "__layoutNone", this).call(this);

        var children = this.children;
        children.forEach(function (item) {
          if (item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1) {
            item.__layoutNone();
          }
        });
      }
      /**
       * block布局，本身固定尺寸优先，否则看内容从上往下从左往右flow流排布
       * 内部inline和inlineBlock组成LineBox，通过LineBoxManager来管理混排的现象
       * LineBoxManager只有block和inlineBlock内部生成，inline会复用最近父级的
       * 内部的block在垂直方向要考虑margin合并的问题，强制所有节点为bfc，精简逻辑
       * @param data
       * @param isAbs abs无尺寸时提前虚拟布局计算尺寸
       * @param isColumn flex列无尺寸时提前虚拟布局计算尺寸
       * @param isRow flex行布局时出现writingMode垂直排版计算尺寸
       * @private
       */

    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this3 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN$3],
            whiteSpace = computedStyle[WHITE_SPACE$3],
            lineClamp = computedStyle[LINE_CLAMP$2],
            lineHeight = computedStyle[LINE_HEIGHT$7],
            overflow = computedStyle[OVERFLOW$2];

        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            x = _this$__preLayout.x,
            y = _this$__preLayout.y,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0; // 虚线管理一个block内部的LineBox列表，使得inline的元素可以中途衔接处理折行
        // 内部维护inline结束的各种坐标来达到目的，遇到block时中断并处理换行坐标

        var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright); // 因精度问题，统计宽度均从0开始累加每行，最后取最大值，仅在abs布局时isVirtual生效

        var maxSize = 0;
        var countSize = 0;
        var lx = x; // 行首，考虑了mbp

        var ly = y; // 连续block（flex相同，下面都是）的上下margin合并值记录，合并时从列表中取

        var mergeMarginEndList = [],
            mergeMarginStartList = [];
        var length = flowChildren.length;
        var ignoreNextLine; // lineClamp超过后，后面的均忽略并置none，注意block内部行数统计是跨子block的

        var ignoreNextWrap; // whiteSpace单行超过后，后面的均忽略并置none，注意这也是跨block的会被隔断重计

        flowChildren.forEach(function (item, i) {
          var isXom = item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline = isXom && item.computedStyle[DISPLAY$5] === 'inline';
          var isInlineBlock = isXom && item.computedStyle[DISPLAY$5] === 'inlineBlock';

          var isRealInline = isInline && item.__isRealInline();

          var lastLineClampCount = lineClampCount; // 每次循环开始前，这次不是block的话，看之前遗留待合并margin，并重置

          if (!isXom || isInline || isInlineBlock) {
            if (mergeMarginEndList.length && mergeMarginStartList.length) {
              var diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList);

              if (diff) {
                if (isUpright) {
                  x += diff;
                } else {
                  y += diff;
                }
              }
            }

            mergeMarginStartList = [];
            mergeMarginEndList = [];
          }

          if (isXom) {
            // inline和inlineBlock的细节不同之处，ib除了w/h之外，更想像block一样占据一行
            // 比如2个inline前面占一半后面比一半多但还是会从一半开始然后第2行换行继续，但ib放不下则重开一行
            // inline和ib能互相嵌套，形成的LineBox中则是TextBox和节点混合
            if (isInlineBlock || isInline) {
              if (ignoreNextLine || ignoreNextWrap) {
                item.__layoutNone();

                return;
              } // x开头或者nowrap单行的非block，不用考虑是否放得下直接放


              if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  // ib内部新生成会内部判断，这里不管统一传入
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // inlineBlock的特殊之处，一旦w为auto且内部产生折行时，整个变成block独占一块区域，坐标计算和block一样，注意nowrap排除

                if (item.__isIbFull) {
                  lineClampCount++;
                }

                if (item.__isIbFull && whiteSpace !== 'nowrap') {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                } // 单行时inline在ellipsis会导致行数变化，否则判断坐标尺寸(恰好有点空剩余inline排不下)，注意前提是非abs，其虚拟计算尺寸无视限制


                if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                  ignoreNextWrap = true;
                } else if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // abs统计宽度，注意nowrap时累加


                if (isAbs) {
                  if (whiteSpace === 'nowrap') {
                    countSize += isUpright ? item.outerHeight : item.outerWidth;
                  } else {
                    countSize = isUpright ? item.outerHeight : item.outerWidth;

                    if (lineClampCount > lastLineClampCount) {
                      countSize = Math.max(countSize, isUpright ? h : w);
                    }
                  }

                  maxSize = Math.max(maxSize, countSize);
                }
              } else {
                // 非开头先尝试是否放得下，内部判断了inline/ib，ib要考虑是否有width
                var free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x, isUpright ? h : w, isUpright); // 放得下继续，奇怪的精度问题，加上阈值


                if (free >= -1e-10) {
                  lineClampCount = item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    // ib和非换行inline累加
                    if (isInlineBlock || lineClampCount === lastLineClampCount) {
                      countSize += isUpright ? item.outerHeight : item.outerWidth;
                      maxSize = Math.max(maxSize, countSize);
                    } // inline换行时一定超过边界至少撑满w
                    else {
                      maxSize = Math.max(maxSize, isUpright ? h : w);
                      countSize = isUpright ? y - ly : x - lx;
                      maxSize = Math.max(maxSize, countSize);
                    }
                  }
                } // 放不下处理之前的lineBox，并考虑重新开头或截断
                else {
                  lineClampCount++;

                  if (isUpright) {
                    x = lineBoxManager.endX;
                    y = ly;
                  } else {
                    x = lx;
                    y = lineBoxManager.endY;
                  }

                  lineBoxManager.setNewLine(); // 超过行数，整个block共用计数器

                  if (lineClamp && lineClampCount >= lineClamp) {
                    item.__layoutNone();

                    ignoreNextLine = true;
                    var list = lineBoxManager.list;
                    var lineBox = list[list.length - 1];
                    backtrack(_this3, lineBoxManager, lineBox, isUpright ? h : w, 0, isUpright);
                    return;
                  }

                  lineClampCount = item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                  if (item.__isIbFull) {
                    lineBoxManager.addItem(item, false);

                    if (isUpright) {
                      x += item.outerWidth;
                      y = ly;
                    } else {
                      x = lx;
                      y += item.outerHeight;
                    }

                    lineBoxManager.setNotEnd();
                    lineClampCount++;
                  } // inline和不折行的ib，其中ib需要手动存入当前lb中
                  else {
                    (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                    x = lineBoxManager.lastX;
                    y = lineBoxManager.lastY;
                  }

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                    maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                    countSize = isUpright ? item.outerHeight : item.outerWidth;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              }
            } // block/flex先处理之前可能遗留的最后一行LineBox，然后递归时不传lineBoxManager，其内部生成新的
            else {
              ignoreNextWrap = false; // block出现的话只隔断单行，不影响多行计数器
              // 非开头，说明之前的text/ib未换行，需要增加行数

              if (isUpright && y > ly || !isUpright && x > lx) {
                lineClampCount++;
              }

              if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }

              if (isUpright) {
                y = ly;
              } else {
                x = lx;
              }

              if (lineBoxManager.isEnd) {
                if (isUpright) {
                  x = lineBoxManager.endX;
                } else {
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNotEnd();
                lineBoxManager.setNewLine();
              }

              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 自身无内容


              var isNone = item.currentStyle[DISPLAY$5] === 'none';
              var isEmptyBlock;

              if (!isNone && item.flowChildren && item.flowChildren.length === 0) {
                var _item$computedStyle = item.computedStyle,
                    marginTop = _item$computedStyle[MARGIN_TOP$4],
                    marginRight = _item$computedStyle[MARGIN_RIGHT$4],
                    marginBottom = _item$computedStyle[MARGIN_BOTTOM$4],
                    marginLeft = _item$computedStyle[MARGIN_LEFT$4],
                    paddingTop = _item$computedStyle[PADDING_TOP$5],
                    paddingRight = _item$computedStyle[PADDING_RIGHT$4],
                    paddingBottom = _item$computedStyle[PADDING_BOTTOM$5],
                    paddingLeft = _item$computedStyle[PADDING_LEFT$5],
                    width = _item$computedStyle[WIDTH$5],
                    height = _item$computedStyle[HEIGHT$6],
                    borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH$5],
                    borderRightWidth = _item$computedStyle[BORDER_RIGHT_WIDTH$4],
                    borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH$5],
                    borderLeftWidth = _item$computedStyle[BORDER_LEFT_WIDTH$5]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

                if (isUpright && paddingLeft <= 0 && paddingRight <= 0 && width <= 0 && borderLeftWidth <= 0 && borderRightWidth <= 0) {
                  mergeMarginEndList.push(marginRight);
                  mergeMarginStartList.push(marginLeft);
                  isEmptyBlock = true;
                } else if (!isUpright && paddingTop <= 0 && paddingBottom <= 0 && height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                  mergeMarginEndList.push(marginBottom);
                  mergeMarginStartList.push(marginTop);
                  isEmptyBlock = true;
                }
              }

              if (isUpright) {
                x += item.outerWidth;
                lineBoxManager.__lastX = x;
              } else {
                y += item.outerHeight;
                lineBoxManager.__lastY = y;
              } // absolute/flex前置虚拟计算


              if (isAbs) {
                maxSize = Math.max(maxSize, isUpright ? item.outerHeight : item.outerWidth);
                countSize = 0;
              } // 空block要留下轮循环看，除非是最后一个，此处非空本轮处理掉看是否要合并


              if (!isNone && !isEmptyBlock) {
                var _item$computedStyle2 = item.computedStyle,
                    _marginTop = _item$computedStyle2[MARGIN_TOP$4],
                    _marginRight = _item$computedStyle2[MARGIN_RIGHT$4],
                    _marginBottom = _item$computedStyle2[MARGIN_BOTTOM$4],
                    _marginLeft = _item$computedStyle2[MARGIN_LEFT$4]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
                // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

                if (mergeMarginEndList.length) {
                  if (isUpright) {
                    mergeMarginStartList.push(_marginLeft);

                    var _diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList);

                    if (_diff) {
                      item.__offsetX(_diff, true);

                      x += _diff;
                    }
                  } else {
                    mergeMarginStartList.push(_marginTop);

                    var _diff2 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList);

                    if (_diff2) {
                      item.__offsetY(_diff2, true);

                      y += _diff2;
                    }
                  }
                } // 同时自己保存bottom，为后续block准备


                mergeMarginStartList = [];
                mergeMarginEndList = [isUpright ? _marginRight : _marginBottom];
              } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0
              else if (i === length - 1) {
                var _diff3 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList);

                if (_diff3) {
                  if (isUpright) {
                    x += _diff3;
                  } else {
                    y += _diff3;
                  }
                }
              }
            }
          } // 文字和inline类似
          else {
            if (ignoreNextLine || ignoreNextWrap) {
              item.__layoutNone();

              return;
            } // x开头，不用考虑是否放得下直接放


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              });
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // 和inline很像，只是没有ib

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              } // abs统计宽度，注意nowrap时累加


              if (isAbs) {
                if (whiteSpace === 'nowrap') {
                  countSize += isUpright ? item.height : item.width;
                } else {
                  countSize = isUpright ? item.height : item.width;

                  if (lineClampCount > lastLineClampCount) {
                    countSize = Math.max(countSize, isUpright ? h : w);
                  }
                }

                maxSize = Math.max(maxSize, countSize);
              }
            } else {
              // 非开头先尝试是否放得下
              var _free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x); // 放得下继续


              if (_free >= -1e-10) {
                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  if (lineClampCount === lastLineClampCount) {
                    countSize += isUpright ? item.height : item.width;
                    maxSize = Math.max(maxSize, countSize);
                  } // inline换行一定超过边界
                  else {
                    maxSize = Math.max(maxSize, isUpright ? h : w);
                    countSize = isUpright ? y - ly : x - lx;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 和inline/ib一样

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list = lineBoxManager.list;
                  var _lineBox = _list[_list.length - 1];
                  backtrack(_this3, lineBoxManager, _lineBox, isUpright ? h : w, 0, isUpright);
                  return;
                }

                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                  maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                  countSize = isUpright ? item.height : item.width;
                  maxSize = Math.max(maxSize, countSize);
                }
              }
            }
          }
        }); // 结束后如果是以LineBox结尾，则需要设置y到这里，否则流布局中block会设置
        // 当以block换行时，新行是true，否则是false即结尾

        if (lineBoxManager.isEnd) {
          if (isUpright) {
            x = lineBoxManager.endX;
          } else {
            y = lineBoxManager.endY;
          }
        }

        var tw = 0,
            th = 0; // 根据书写模式、嵌套等条件计算宽高，只有父子同向才会主轴撑满

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else if (isAbs) {
          tw = isUpright ? x - data.x : maxSize;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else if (isAbs) {
          th = isUpright ? maxSize : y - data.y;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th); // 除了水平abs的虚拟外，都需要垂直对齐，因为img这种占位元素会影响lineBox高度，水平abs虚拟只需宽度


        if (!isAbs) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread);
            }
            /**
             * parent以及parent的next无需处理，因为深度遍历后面还会进行，
             * 但自己的block需处理，因为对齐只处理了inline元素，忽略了block，
             * 同时由于block和inline区域可能不连续，每个增加的y不一样，
             * 需要按照每个不同区域来判断，区域是按索引次序依次增大的，
             * 只有在inline出现过后才开始生效，inline之前的block忽略
             */


            var count = 0,
                spreadList = lineBoxManager.spreadList;
            var isLastBlock = false,
                hasStart = false;
            flowChildren.forEach(function (item) {
              var isXom = item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1;
              var isBlock = isXom && ['block', 'flex'].indexOf(item.computedStyle[DISPLAY$5]) > -1;

              if (isBlock) {
                if (!hasStart) {
                  return;
                }

                isLastBlock = true;

                if (isUpright) {
                  item.__offsetX(spreadList[count], true);
                } else {
                  item.__offsetY(spreadList[count], true);
                }
              } else {
                hasStart = true;

                if (isLastBlock) {
                  count++;
                }

                isLastBlock = false;
              }
            });
          } // 非abs提前的虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐


          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component$1) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // 所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });

            this.__marginAuto(currentStyle, data, isUpright);
          }
        }
      } // 弹性布局时的计算位置

    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        var _this4 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __flexLine = this.__flexLine;
        var flexDirection = computedStyle[FLEX_DIRECTION$3],
            justifyContent = computedStyle[JUSTIFY_CONTENT$2],
            alignItems = computedStyle[ALIGN_ITEMS$2],
            lineClamp = computedStyle[LINE_CLAMP$2],
            flexWrap = computedStyle[FLEX_WRAP$2],
            alignContent = computedStyle[ALIGN_CONTENT$1],
            lineHeight = computedStyle[LINE_HEIGHT$7],
            textAlign = computedStyle[TEXT_ALIGN$3];

        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            x = _this$__preLayout2.x,
            y = _this$__preLayout2.y,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h,
            isParentVertical = _this$__preLayout2.isParentVertical,
            isUpright = _this$__preLayout2.isUpright;

        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 每次布局情况多行内容


        __flexLine.splice(0); // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0;
        var isDirectionRow = ['column', 'columnReverse'].indexOf(flexDirection) === -1; // 计算伸缩基数

        var growList = [];
        var shrinkList = [];
        var basisList = [];
        var maxList = [];
        var minList = [];
        var orderChildren = genOrderChildren(flowChildren);
        orderChildren.forEach(function (item) {
          if (item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1) {
            var _currentStyle = item.currentStyle,
                _computedStyle = item.computedStyle;

            var _item$__calBasis5 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
              x: x,
              y: y,
              w: w,
              h: h
            }, true),
                _item$__calBasis6 = _slicedToArray(_item$__calBasis5, 3),
                b = _item$__calBasis6[0],
                min = _item$__calBasis6[1],
                max = _item$__calBasis6[2];

            var flexGrow = _currentStyle[FLEX_GROW$2],
                flexShrink = _currentStyle[FLEX_SHRINK$2];
            _computedStyle[FLEX_BASIS$2] = b;
            growList.push(flexGrow);
            shrinkList.push(flexShrink); // 根据basis不同，计算方式不同

            basisList.push(b);
            maxList.push(max);
            minList.push(min);
          } // 文本
          else {
            growList.push(0);
            shrinkList.push(1); // 水平flex垂直文字和垂直flex水平文字都先假布局一次取结果，其它取文本最大最小宽度即可

            if (isDirectionRow && isUpright || !isDirectionRow && !isUpright) {
              var lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);

              item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);

              var n = isUpright ? item.width : item.height;
              basisList.push(n);
              maxList.push(n);
              minList.push(n);
            } // 水平flex水平文本和垂直flex垂直文本
            else {
              var cw = item.charWidth;
              var _tw = item.textWidth;
              basisList.push(_tw);
              maxList.push(_tw);
              minList.push(cw);
            }
          }
        });
        var containerSize = isDirectionRow ? w : h;
        var isMultiLine = ['wrap', 'wrapReverse'].indexOf(flexWrap) > -1;
        /**
         * 判断是否需要分行，根据假设主尺寸来统计尺寸和计算，假设主尺寸是clamp(min_main_size, flex_base_size, max_main_size)
         * 当多行时，由于每行一定有最小限制，所以每行一般情况都不是shrink状态，
         * 但也有极端情况，比如一行只能放下1个元素时，且此元素比容器小，会是shrink
         */

        var line = [],
            sum = 0,
            hypotheticalList = [];
        basisList.forEach(function (item, i) {
          var min = minList[i],
              max = maxList[i];
          var hypothetical;

          if (item < min) {
            hypothetical = min;
          } else if (item > max) {
            hypothetical = max;
          } else {
            hypothetical = item;
          }

          hypotheticalList.push(hypothetical);

          if (isMultiLine) {
            // 超过尺寸时，要防止sum为0即1个也会超过尺寸
            if (sum + hypothetical > containerSize) {
              if (sum) {
                __flexLine.push(line);

                line = [orderChildren[i]];
                sum = hypothetical;
              } else {
                line.push(orderChildren[i]);

                __flexLine.push(line);

                line = [];
                sum = 0;
              }
            } else {
              line.push(orderChildren[i]);
              sum += hypothetical;
            }
          } else {
            line.push(orderChildren[i]);
          }
        });

        if (line.length) {
          __flexLine.push(line);
        }

        var offset = 0,
            clone = {
          x: x,
          y: y,
          w: w,
          h: h
        };
        var maxCrossList = [];

        __flexLine.forEach(function (item) {
          var length = item.length;
          var end = offset + length;

          var _this4$__layoutFlexLi = _this4.__layoutFlexLine(clone, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren.slice(offset, end), item, textAlign, growList.slice(offset, end), shrinkList.slice(offset, end), basisList.slice(offset, end), hypotheticalList.slice(offset, end), minList.slice(offset, end)),
              _this4$__layoutFlexLi2 = _slicedToArray(_this4$__layoutFlexLi, 3),
              x1 = _this4$__layoutFlexLi2[0],
              y1 = _this4$__layoutFlexLi2[1],
              maxCross = _this4$__layoutFlexLi2[2]; // 下一行/列更新坐标


          if (isDirectionRow) {
            clone.y = y1;
          } else {
            clone.x = x1;
          }

          x = Math.max(x, x1);
          y = Math.max(y, y1);
          maxCrossList.push(maxCross);
          offset += length;
        }); // abs预布局只计算宽度无需对齐


        if (isAbs) {
          var max = 0;

          __flexLine.forEach(function (line) {
            var count = 0;
            line.forEach(function (item) {
              if (isDirectionRow) {
                count += isUpright ? item.outerHeight : item.outerWidth;
              } else {
                count = Math.max(count, isUpright ? item.outerHeight : item.outerWidth);
              } // 文字发生换行无论row/column一定放不下需占满容器尺寸


              if (item instanceof Text) {
                if (isUpright) {
                  if (item.textWidth > h) {
                    max = Math.max(max, h);
                  }
                } else {
                  if (item.textWidth > w) {
                    max = Math.max(max, w);
                  }
                }
              }
            });
            max = Math.max(max, count);
          });

          if (isUpright) {
            this.__ioSize(undefined, max);
          } else {
            this.__ioSize(max, undefined);
          }

          return;
        } // 同block计算


        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th);

        if (isColumn || isRow) {
          return;
        } // flexDirection当有reverse时交换每line的主轴序


        if (flexDirection === 'rowReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = tw - item.outerWidth - (item.x - data.x) * 2;

              if (diff) {
                item.__offsetX(diff, true);
              }
            });
          });
        } else if (flexDirection === 'columnReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = th - item.outerHeight - (item.y - data.y) * 2;

              if (diff) {
                item.__offsetY(diff, true);
              }
            });
          });
        } // wrap-reverse且多轴线时交换轴线序，需要2行及以上才行


        var length = __flexLine.length;

        if (flexWrap === 'wrapReverse' && length > 1) {
          var crossSum = 0,
              crossSumList = [];
          maxCrossList.forEach(function (item) {
            crossSumList.push(crossSum);
            crossSum += item;
          });
          var count = 0;

          var _loop = function _loop(i) {
            var line = __flexLine[i];
            var source = crossSumList[i];
            var diff = count - source;

            if (diff) {
              line.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true);
                } else {
                  item.__offsetX(diff, true);
                }
              });
            }

            count += maxCrossList[i];
          };

          for (var i = length - 1; i >= 0; i--) {
            _loop(i);
          }

          __flexLine.reverse();
        } // 侧轴对齐分flexLine做，要考虑整体的alignContent的stretch和每行的alignItems的stretch
        // 先做整体的，得出交叉轴空白再均分给每一行做单行的，整体的只有1行忽略


        var per;

        if (length > 1 && (fixedHeight && isDirectionRow || !isDirectionRow)) {
          var diff = isDirectionRow ? th - (y - data.y) : tw - (x - data.x); // 有空余时才进行对齐

          if (diff > 0) {
            if (alignContent === 'center') {
              var _per = diff * 0.5;

              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(_per, true);
                } else {
                  item.__offsetX(_per, true);
                }
              });
            } else if (alignContent === 'flexStart') ; else if (alignContent === 'flexEnd') {
              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true);
                } else {
                  item.__offsetX(diff, true);
                }
              });
            } else if (alignContent === 'spaceBetween') {
              var between = diff / (length - 1); // 除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(between, true);
                    } else {
                      item.__offsetX(between, true);
                    }
                  });
                }
              });
            } else if (alignContent === 'spaceAround') {
              var around = diff / (length + 1);

              __flexLine.forEach(function (item, i) {
                item.forEach(function (item) {
                  if (isDirectionRow) {
                    item.__offsetY(around * (i + 1), true);
                  } else {
                    item.__offsetX(around * (i + 1), true);
                  }
                });
              });
            } // 默认stretch
            else {
              per = diff / length; // 除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(per * i, true);
                    } else {
                      item.__offsetX(per * i, true);
                    }
                  });
                }
              });
            }
          }
        } // 每行再进行cross对齐，在alignContent为stretch时计算每行的高度


        if (!isColumn && !isRow) {
          if (length > 1) {
            __flexLine.forEach(function (item, i) {
              var maxCross = maxCrossList[i];

              if (per) {
                maxCross += per;
              }

              _this4.__crossAlign(item, alignItems, isDirectionRow, maxCross);
            });
          } else if (length) {
            var maxCross = maxCrossList[0];

            if (isDirectionRow) {
              if (fixedHeight) {
                maxCross = h;
              }
            } else {
              maxCross = w;
            }

            this.__crossAlign(__flexLine[0], alignItems, isDirectionRow, maxCross);
          }

          this.__marginAuto(currentStyle, data, isUpright);
        }
      }
      /**
       * 计算获取子元素的b/min/max完毕后，尝试进行flex每行布局
       * https://www.w3.org/TR/css-flexbox-1/#layout-algorithm
       * 假想主尺寸，其为clamp(min_main_size, flex_base_size, max_main_size)
       * 随后按算法一步步来 https://zhuanlan.zhihu.com/p/354567655
       * 规范没提到mpb，item的要计算，孙子的只考虑绝对值
       * 先收集basis和假设主尺寸
       */

    }, {
      key: "__layoutFlexLine",
      value: function __layoutFlexLine(data, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren, flexLine, textAlign, growList, shrinkList, basisList, hypotheticalList, minList) {
        var _this5 = this;

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h;
        var hypotheticalSum = 0;
        hypotheticalList.forEach(function (item) {
          hypotheticalSum += item;
        }); // 根据假设尺寸确定使用grow还是shrink，冻结非弹性项并设置target尺寸，确定剩余未冻结数量

        var isOverflow = hypotheticalSum >= containerSize;
        var targetMainList = [];
        basisList.forEach(function (item, i) {
          if (isOverflow) {
            if (!shrinkList[i] || basisList[i] < hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          } else {
            if (!growList[i] || basisList[i] > hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          }
        }); // 初始可用空间，冻结使用确定的target尺寸，未冻结使用假想

        var free = 0;
        basisList.forEach(function (item, i) {
          if (targetMainList[i] !== undefined) {
            free += targetMainList[i];
          } else {
            free += item;
          }
        });
        var total = Infinity;

        if (isDirectionRow) {
          total = w;
        } else if (fixedHeight) {
          total = h;
        } else {
          total = free;
        }

        free = Math.abs(total - free); // 循环，文档算法不够简练，其合并了grow和shrink，实际拆开写更简单

        var factorSum = 0;

        if (isOverflow) {
          (function () {
            // 计算真正的因子占比，同时得出缩小尺寸数值
            // 还需判断每个item收缩不能<min值，小于的话将无法缩小的这部分按比例分配到其它几项上
            // 于是写成一个循环，每轮先处理一遍，如果产生收缩超限的情况，将超限的设为最小值并剔除
            // 剩下的重新分配因子占比继续从头循环重来一遍
            var factorList = shrinkList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                var n = item * basisList[i];
                factorSum += n;
                return n;
              }
            });

            while (true) {
              if (factorSum < 1) {
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要收缩的尺寸

                  var n = basisList[i] - s; // 实际尺寸
                  // 比min还小设置为min，同时设0剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    free -= basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸
                  } // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                  }
                }
              });

              if (!needReset) {
                break;
              }

              factorSum = factorSum2;
            }
          })();
        } else {
          (function () {
            var factorList = growList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                factorSum += item;
                return item;
              }
            });

            while (true) {
              if (factorSum < 1) {
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要扩展的尺寸

                  var n = basisList[i] + s; // 实际尺寸
                  // 比min还小设置为min，同时设0剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    free -= basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸
                  } // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                  }
                }
              });

              if (!needReset) {
                break;
              }

              factorSum = factorSum2;
            }
          })();
        }

        var maxCross = 0;
        var lbmList = [];
        var marginAutoCount = 0;
        orderChildren.forEach(function (item, i) {
          var main = targetMainList[i];

          if (item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1) {
            if (isDirectionRow) {
              item.__layout({
                x: x,
                y: y,
                w: main,
                h: h,
                w3: main,
                // w3假设固定宽度，忽略原始style中的设置
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
            } else {
              var _item$currentStyle = item.currentStyle,
                  alignSelf = _item$currentStyle[ALIGN_SELF$2],
                  width = _item$currentStyle[WIDTH$5]; // column的child真布局时，如果是stretch宽度，则可以直接生成animateRecord，否则自适应调整后才进行

              if (!isAbs && !isColumn && !isRow) {
                var needGenAr;

                if (width[1] !== AUTO$5 || alignSelf === 'stretch') {
                  needGenAr = true;
                } else if (alignSelf === 'auto' && alignItems === 'stretch') {
                  needGenAr = true;
                }

                if (needGenAr) {
                  item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                } else {
                  item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, true, isColumn, isRow);

                  item.__layout({
                    x: x,
                    y: y,
                    w: w,
                    w3: item.outerWidth,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                }
              } else {
                item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: main,
                  h3: main,
                  // 同w2
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
              }
            } // 记录主轴是否有margin为auto的情况


            if (!isAbs && !isColumn && !isRow) {
              var currentStyle = item.currentStyle;

              if (isDirectionRow) {
                if (currentStyle[MARGIN_LEFT$4][1] === AUTO$5) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_RIGHT$4][1] === AUTO$5) {
                  marginAutoCount++;
                }
              } else {
                if (currentStyle[MARGIN_TOP$4][1] === AUTO$5) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_BOTTOM$4][1] === AUTO$5) {
                  marginAutoCount++;
                }
              }
            }
          } // 文字
          else {
            var lineBoxManager = _this5.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);
            lbmList.push(lineBoxManager);

            item.__layout({
              x: x,
              y: y,
              w: isDirectionRow ? main : w,
              h: isDirectionRow ? h : main,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount,
              isUpright: isUpright
            });
          }

          if (isDirectionRow) {
            x += item.outerWidth;
            maxCross = Math.max(maxCross, item.outerHeight);
          } else {
            y += item.outerHeight;
            maxCross = Math.max(maxCross, item.outerWidth);
          }
        }); // 计算主轴剩余时要用真实剩余空间而不能用伸缩剩余空间

        var diff = isDirectionRow ? w - x + data.x : h - y + data.y; // 主轴对齐方式，需要考虑margin，如果有auto则优先于justifyContent

        if (!isAbs && !isColumn && !isRow && diff > 0) {
          var len = orderChildren.length;

          if (marginAutoCount) {
            // 类似于space-between，空白均分于auto，两边都有就是2份，只有1边是1份
            var count = 0,
                per = diff / marginAutoCount;

            for (var i = 0; i < len; i++) {
              var child = orderChildren[i];
              var currentStyle = child.currentStyle;

              if (isDirectionRow) {
                if (currentStyle[MARGIN_LEFT$4][1] === AUTO$5) {
                  count += per;

                  child.__offsetX(count, true);
                } else if (count) {
                  child.__offsetX(count, true);
                }

                if (currentStyle[MARGIN_RIGHT$4][1] === AUTO$5) {
                  count += per;
                }
              } else {
                if (currentStyle[MARGIN_TOP$4][1] === AUTO$5) {
                  count += per;

                  child.__offsetY(count, true);
                } else if (count) {
                  child.__offsetY(count, true);
                }

                if (currentStyle[MARGIN_BOTTOM$4][1] === AUTO$5) {
                  count += per;
                }
              }
            }
          } else {
            if (justifyContent === 'flexEnd') {
              for (var _i3 = 0; _i3 < len; _i3++) {
                var _child = orderChildren[_i3];
                isDirectionRow ? _child.__offsetX(diff, true) : _child.__offsetY(diff, true);
              }
            } else if (justifyContent === 'center') {
              var center = diff * 0.5;

              for (var _i4 = 0; _i4 < len; _i4++) {
                var _child2 = orderChildren[_i4];
                isDirectionRow ? _child2.__offsetX(center, true) : _child2.__offsetY(center, true);
              }
            } else if (justifyContent === 'spaceBetween') {
              var between = diff / (len - 1);

              for (var _i5 = 1; _i5 < len; _i5++) {
                var _child3 = orderChildren[_i5];
                isDirectionRow ? _child3.__offsetX(between * _i5, true) : _child3.__offsetY(between * _i5, true);
              }
            } else if (justifyContent === 'spaceAround') {
              var around = diff * 0.5 / len;

              for (var _i6 = 0; _i6 < len; _i6++) {
                var _child4 = orderChildren[_i6];
                isDirectionRow ? _child4.__offsetX(around * (_i6 * 2 + 1), true) : _child4.__offsetY(around * (_i6 * 2 + 1), true);
              }
            } else if (justifyContent === 'spaceEvenly') {
              var _around = diff / (len + 1);

              for (var _i7 = 0; _i7 < len; _i7++) {
                var _child5 = orderChildren[_i7];
                isDirectionRow ? _child5.__offsetX(_around * (_i7 + 1), true) : _child5.__offsetY(_around * (_i7 + 1), true);
              }
            }
          }
        }

        if (isDirectionRow) {
          y += maxCross;
        } else {
          x += maxCross;
        } // flex的直接text对齐比较特殊


        if (!isAbs && !isColumn && !isRow && ['center', 'right'].indexOf(textAlign) > -1) {
          lbmList.forEach(function (item) {
            item.horizonAlign(isUpright ? item.height : item.width, textAlign, isUpright);
          });
        }

        return [x, y, maxCross];
      } // 每个flexLine的侧轴对齐，单行时就是一行对齐

    }, {
      key: "__crossAlign",
      value: function __crossAlign(line, alignItems, isDirectionRow, maxCross) {
        var baseline = 0;
        line.forEach(function (item) {
          baseline = Math.max(baseline, item.firstBaseline);
        });
        line.forEach(function (item) {
          var alignSelf = item.currentStyle[ALIGN_SELF$2];

          if (isDirectionRow) {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var diff = maxCross - item.outerHeight;

              if (diff !== 0) {
                item.__offsetY(diff, true);
              }
            } else if (alignSelf === 'center') {
              var _diff4 = maxCross - item.outerHeight;

              if (_diff4 !== 0) {
                item.__offsetY(_diff4 * 0.5, true);
              }
            } else if (alignSelf === 'stretch') {
              var computedStyle = item.computedStyle,
                  height = item.currentStyle[HEIGHT$6];
              var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$5],
                  borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$5],
                  marginTop = computedStyle[MARGIN_TOP$4],
                  marginBottom = computedStyle[MARGIN_BOTTOM$4],
                  paddingTop = computedStyle[PADDING_TOP$5],
                  paddingBottom = computedStyle[PADDING_BOTTOM$5];

              if (height[1] === AUTO$5) {
                var old = item.height;
                var v = item.__height = computedStyle[HEIGHT$6] = maxCross - marginTop - marginBottom - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth;
                var d = v - old;
                item.__sy4 += d;
                item.__sy5 += d;
                item.__sy6 += d;
                item.__height += d;
                item.__clientHeight += d;
                item.__offsetHeight += d;
                item.__outerHeight += d;
              }
            } else if (alignSelf === 'baseline') {
              var _diff5 = baseline - item.firstBaseline;

              if (_diff5 !== 0) {
                item.__offsetY(_diff5, true);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff6 = maxCross - item.outerHeight;

                if (_diff6 !== 0) {
                  item.__offsetY(_diff6 * 0.5, true);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff7 = maxCross - item.outerHeight;

                if (_diff7 !== 0) {
                  item.__offsetY(_diff7, true);
                }
              } else if (alignItems === 'baseline') {
                var _diff8 = baseline - item.firstBaseline;

                if (_diff8 !== 0) {
                  item.__offsetY(_diff8, true);
                }
              } // 默认stretch
              else {
                var _computedStyle2 = item.computedStyle,
                    _item$currentStyle2 = item.currentStyle,
                    display = _item$currentStyle2[DISPLAY$5],
                    flexDirection = _item$currentStyle2[FLEX_DIRECTION$3],
                    _height = _item$currentStyle2[HEIGHT$6]; // row的孩子还是flex且column且不定高时，如果高度<侧轴拉伸高度则重新布局

                if (isDirectionRow && display === 'flex' && flexDirection === 'column' && _height[1] === AUTO$5 && item.outerHeight < maxCross) {
                  item.__layout(Object.assign(item.__layoutData, {
                    h3: maxCross
                  }));
                }

                var _borderTopWidth = _computedStyle2[BORDER_TOP_WIDTH$5],
                    _borderBottomWidth = _computedStyle2[BORDER_BOTTOM_WIDTH$5],
                    _marginTop2 = _computedStyle2[MARGIN_TOP$4],
                    _marginBottom2 = _computedStyle2[MARGIN_BOTTOM$4],
                    _paddingTop = _computedStyle2[PADDING_TOP$5],
                    _paddingBottom = _computedStyle2[PADDING_BOTTOM$5];

                if (_height[1] === AUTO$5) {
                  var _old = item.height;

                  var _v = maxCross - _marginTop2 - _marginBottom2 - _paddingTop - _paddingBottom - _borderTopWidth - _borderBottomWidth;

                  var _d = _v - _old;

                  item.__sy4 += _d;
                  item.__sy5 += _d;
                  item.__sy6 += _d;
                  item.__height += _d;
                  item.__clientHeight += _d;
                  item.__offsetHeight += _d;
                  item.__outerHeight += _d;
                }
              }
            }
          } // column
          else {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var _diff9 = maxCross - item.outerWidth;

              if (_diff9 !== 0) {
                item.__offsetX(_diff9, true);
              }
            } else if (alignSelf === 'center') {
              var _diff10 = maxCross - item.outerWidth;

              if (_diff10 !== 0) {
                item.__offsetX(_diff10 * 0.5, true);
              }
            } else if (alignSelf === 'stretch') {
              var _computedStyle3 = item.computedStyle,
                  width = item.currentStyle[WIDTH$5];
              var borderRightWidth = _computedStyle3[BORDER_RIGHT_WIDTH$4],
                  borderLeftWidth = _computedStyle3[BORDER_LEFT_WIDTH$5],
                  marginRight = _computedStyle3[MARGIN_RIGHT$4],
                  marginLeft = _computedStyle3[MARGIN_LEFT$4],
                  paddingRight = _computedStyle3[PADDING_RIGHT$4],
                  paddingLeft = _computedStyle3[PADDING_LEFT$5];

              if (width[1] === AUTO$5) {
                var _old2 = item.width;

                var _v2 = item.__width = _computedStyle3[WIDTH$5] = maxCross - marginLeft - marginRight - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth;

                var _d2 = _v2 - _old2;

                item.__sx4 += _d2;
                item.__sx5 += _d2;
                item.__sx6 += _d2;
                item.__width += _d2;
                item.__clientWidth += _d2;
                item.__offsetWidth += _d2;
                item.__outerWidth += _d2;
              }
            } else if (alignItems === 'baseline') {
              var _diff11 = baseline - item.firstBaseline;

              if (_diff11 !== 0) {
                item.__offsetX(_diff11, true);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff12 = maxCross - item.outerWidth;

                if (_diff12 !== 0) {
                  item.__offsetX(_diff12 * 0.5, true);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff13 = maxCross - item.outerWidth;

                if (_diff13 !== 0) {
                  item.__offsetX(_diff13, true);
                }
              } else if (alignItems === 'baseline') {
                var _diff14 = baseline - item.firstBaseline;

                if (_diff14 !== 0) {
                  item.__offsetX(_diff14, true);
                }
              } // 默认stretch
              else {
                var _computedStyle4 = item.computedStyle,
                    _width = item.currentStyle[WIDTH$5];
                var _borderRightWidth = _computedStyle4[BORDER_RIGHT_WIDTH$4],
                    _borderLeftWidth = _computedStyle4[BORDER_LEFT_WIDTH$5],
                    _marginRight2 = _computedStyle4[MARGIN_RIGHT$4],
                    _marginLeft2 = _computedStyle4[MARGIN_LEFT$4],
                    _paddingRight = _computedStyle4[PADDING_RIGHT$4],
                    _paddingLeft = _computedStyle4[PADDING_LEFT$5];

                if (_width[1] === AUTO$5) {
                  var _old3 = item.width;

                  var _v3 = item.__width = _computedStyle4[WIDTH$5] = maxCross - _marginLeft2 - _marginRight2 - _paddingLeft - _paddingRight - _borderRightWidth - _borderLeftWidth;

                  var _d3 = _v3 - _old3;

                  item.__sx4 += _d3;
                  item.__sx5 += _d3;
                  item.__sx6 += _d3;
                  item.__width += _d3;
                  item.__clientWidth += _d3;
                  item.__offsetWidth += _d3;
                  item.__outerWidth += _d3;
                }
              }
            }
          }
        });
      }
      /**
       * inline比较特殊，先简单顶部对齐，后续还需根据vertical和lineHeight计算y偏移
       * inlineBlock复用逻辑，可以设置w/h，在混排时表现不同，inlineBlock换行限制在规定的矩形内，
       * 且ib会在没设置width且换行的时候撑满上一行，即便内部尺寸没抵达边界
       * 而inline换行则会从父容器start处开始，且首尾可能占用矩形不同
       * 嵌套inline情况十分复杂，尾部mpb空白可能产生叠加情况，因此endSpace表示自身，
       * 然后根据是否在最后一个元素进行叠加父元素的，多层嵌套则多层尾部叠加，均以最后一个元素为依据判断
       * Text获取这个叠加的endSpace值即可，无需感知是否最后一个，外层（此处）进行逻辑封装
       * @param data
       * @param isAbs
       * @param isColumn
       * @param isRow
       * @param isInline
       * @private
       */

    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isColumn, isRow, isInline) {
        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN$3],
            whiteSpace = computedStyle[WHITE_SPACE$3],
            lineClamp = computedStyle[LINE_CLAMP$2],
            lineHeight = computedStyle[LINE_HEIGHT$7],
            marginTop = computedStyle[MARGIN_TOP$4],
            marginBottom = computedStyle[MARGIN_BOTTOM$4],
            marginLeft = computedStyle[MARGIN_LEFT$4],
            marginRight = computedStyle[MARGIN_RIGHT$4],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$5],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$5],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            paddingTop = computedStyle[PADDING_TOP$5],
            paddingBottom = computedStyle[PADDING_BOTTOM$5],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            paddingRight = computedStyle[PADDING_RIGHT$4];
        var lineClampCount = data.lineClampCount || 0;

        var _this$__preLayout3 = this.__preLayout(data, isInline),
            fixedWidth = _this$__preLayout3.fixedWidth,
            fixedHeight = _this$__preLayout3.fixedHeight,
            x = _this$__preLayout3.x,
            y = _this$__preLayout3.y,
            w = _this$__preLayout3.w,
            h = _this$__preLayout3.h,
            lx = _this$__preLayout3.lx,
            ly = _this$__preLayout3.ly,
            lineBoxManager = _this$__preLayout3.lineBoxManager,
            endSpace = _this$__preLayout3.endSpace,
            selfEndSpace = _this$__preLayout3.selfEndSpace,
            isUpright = _this$__preLayout3.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return lineClampCount;
        }

        var width = currentStyle[WIDTH$5];

        if (isInline && !this.__isRealInline()) {
          isInline = false;
        } // inline-block假布局提前结束


        if (!isInline) {
          if (isColumn && fixedHeight) {
            this.__ioSize(undefined, h);

            return lineClampCount;
          }

          if (isRow && fixedWidth) {
            this.__ioSize(w, undefined);

            return lineClampCount;
          }
        } // 只有inline的孩子需要考虑换行后从行首开始，而ib不需要，因此重置行首标识lx为x，末尾空白为0
        // 而inline的LineBoxManager复用最近非inline父dom的，ib需要重新生成，末尾空白叠加


        if (isInline) {
          this.__config[NODE_IS_INLINE$1] = true;
          this.__lineBoxManager = lineBoxManager;
          var baseline = isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle); // 特殊inline调用，有内容的话（如左右mbp），默认生成一个lineBox，即便是空，也要形成占位，只有开头时需要

          if (isUpright && (marginTop || marginBottom || paddingTop || paddingBottom || borderTopWidth || borderBottomWidth) || !isUpright && (marginLeft || marginRight || paddingLeft || paddingRight || borderLeftWidth || borderRightWidth)) {
            if (lineBoxManager.isNewLine) {
              lineBoxManager.genLineBoxByInlineIfNewLine(x, y, lineHeight, baseline);
            } else {
              lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
            }
          } else {
            lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
          }

          lineClamp = data.lineClamp || 0;
        } else {
          lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline$1(computedStyle) : getBaseline$1(computedStyle), isUpright);
          lx = x;
          ly = y;
          endSpace = selfEndSpace = lineClampCount = 0;
        } // 存LineBox里的内容列表专用，布局过程中由lineBoxManager存入，递归情况每个inline节点都保存contentBox


        if (isInline) {
          this.contentBoxList.splice(0);
          lineBoxManager.pushContentBoxList(this);
        } // ib的bp是自己，inline是最近的非inline


        var bp = this;

        while (bp.computedStyle[DISPLAY$5] === 'inline') {
          bp = bp.domParent;
        }

        var overflow = bp.computedStyle[OVERFLOW$2];
        var isIbFull = false; // ib时不限定w情况下发生折行则撑满行，即便内容没有撑满边界

        var length = flowChildren.length;
        var ignoreNextLine = false; // lineClamp超过后，后面的均忽略并置none，注意ib内部自己统计类似block

        var ignoreNextWrap = false; // whiteSpace单行超过后，后面的均忽略并置none，注意和block不一样不隔断

        var hasAddEndSpace; // 最后一行生效，只加1次防重复

        flowChildren.forEach(function (item, i) {
          // 和block不太一样可以提前判断，因为不可能包含block隔断区域了
          if (ignoreNextLine || ignoreNextWrap) {
            item.__layoutNone();

            return;
          }

          var isXom = item instanceof Xom$1 || item instanceof Component$1 && item.shadowRoot instanceof Xom$1;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline2 = isXom && item.computedStyle[DISPLAY$5] === 'inline';
          var isInlineBlock2 = isXom && item.computedStyle[DISPLAY$5] === 'inlineBlock';

          var isRealInline = isInline2 && item.__isRealInline(); // 最后一个元素会产生最后一行，叠加父元素的尾部mpb，注意只执行一次防止重复叠加


          var isEnd = isInline && !hasAddEndSpace && (whiteSpace === 'nowrap' || !isXom && i === length - 1 || lineClamp && i === length - 1 || lineClampCount === lineClamp - 1);

          if (isEnd) {
            hasAddEndSpace = true;
            endSpace += selfEndSpace;
          }

          var lastLineClampCount = lineClampCount;

          if (isXom) {
            if (!isInline2 && !isInlineBlock2) {
              item.currentStyle[DISPLAY$5] = item.computedStyle[DISPLAY$5] = 'inlineBlock';
              isInlineBlock2 = true;
              inject.warn('Inline can not contain block/flex');
            } // x开头或者nowrap单行，不用考虑是否放得下直接放，因为有beginSpace所以要多判断i为0


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 同block布局

              if (item.__isIbFull) {
                lineClampCount++;
              }

              if (item.__isIbFull && whiteSpace !== 'nowrap') {
                if (isUpright && h[1] === AUTO$5) {
                  isIbFull = true;
                } else if (!isUpright && w[1] === AUTO$5) {
                  isIbFull = true;
                }

                lineBoxManager.addItem(item, true);

                if (isUpright) {
                  x += item.outerWidth;
                  y = ly;
                } else {
                  x = lx;
                  y += item.outerHeight;
                }

                lineBoxManager.setNotEnd();
              } // inline和不折行的ib，其中ib需要手动存入当前lb中，以计算宽度
              else {
                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 不换行继续排，换行非开头先尝试是否放得下，结尾要考虑mpb因此减去endSpace
              var free = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace, isUpright ? h : w, isUpright); // 放得下继续


              if (free >= -1e-10) {
                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var list = lineBoxManager.list;
                  var lineBox = list[list.length - 1];
                  backtrack(bp, lineBoxManager, lineBox, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                if (item.__isIbFull) {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                  lineClampCount++;
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          } // inline里的其它只有文本，可能开始紧跟着之前的x，也可能换行后从lx行头开始
          // 紧跟着x可能出现在前面有节点换行后第2行，此时不一定放得下，因此不能作为判断依据，开头仅有lx
          else {
            var n = lineBoxManager.size; // i为0时强制不换行

            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layout({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // ib情况发生折行，且非定宽

              if (!isInline && lineBoxManager.size - n > 1 && width[1] === AUTO$5) {
                isIbFull = true;
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 非开头先尝试是否放得下，如果放得下再看是否end，加end且只有1个字时放不下要换行，否则可以放，换行由text内部做
              var _free2 = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace); // 放得下继续


              if (_free2 >= -1e-10) {
                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // 这里ib放得下一定是要么没换行要么固定宽度，所以无需判断isIbFull

              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list2 = lineBoxManager.list;
                  var _lineBox2 = _list2[_list2.length - 1];
                  backtrack(bp, lineBoxManager, _lineBox2, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layout({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY; // ib情况发生折行

                if (!isInline && lineBoxManager.size - n > 1 && width[1] === AUTO$5) {
                  isIbFull = true;
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          }
        }); // 同block结尾，不过这里一定是lineBox结束，无需判断

        if (isUpright) {
          x = lineBoxManager.endX;
        } else {
          y = lineBoxManager.endY;
        } // 标识ib情况同block一样占满行


        this.__isIbFull = isIbFull; // 元素的width在固定情况或者ibFull情况已被计算出来，否则为最大延展尺寸，inline没有固定尺寸概念

        var tw, th;

        if (isInline) {
          // inline最后的x要算上右侧mpb，为next行元素提供x坐标基准，同时其尺寸计算比较特殊
          if (selfEndSpace) {
            if (isUpright) {
              lineBoxManager.addY(selfEndSpace);
            } else {
              lineBoxManager.addX(selfEndSpace);
            }
          } // 如果没有内容，空白还要加上开头即左侧mpb


          if (!flowChildren.length) {
            var _marginTop3 = computedStyle[MARGIN_TOP$4],
                _marginLeft3 = computedStyle[MARGIN_LEFT$4],
                _paddingTop2 = computedStyle[PADDING_TOP$5],
                _paddingLeft2 = computedStyle[PADDING_LEFT$5],
                _borderTopWidth2 = computedStyle[BORDER_TOP_WIDTH$5],
                _borderLeftWidth2 = computedStyle[BORDER_LEFT_WIDTH$5];

            if (isUpright) {
              lineBoxManager.addY(_marginTop3 + _paddingTop2 + _borderTopWidth2);
            } else {
              lineBoxManager.addX(_marginLeft3 + _paddingLeft2 + _borderLeftWidth2);
            }
          } // 结束出栈contentBox，递归情况结束子inline获取contentBox，父inline继续


          lineBoxManager.popContentBoxList(); // abs非固定w时预计算，本来是最近非inline父层统一计算，但在abs时不算，这里无视textAlign默认left

          if (isAbs) {
            this.__inlineSize(0, 'left', isUpright);
          }
        } else {
          // ib在满时很特殊，取最大值，可能w本身很小不足排下1个字符，此时要用max
          var max = lineBoxManager.max - (isUpright ? data.y : data.x);

          if (isUpright) {
            tw = fixedWidth ? w : x - data.x;
            th = fixedHeight ? h : isIbFull ? Math.max(h, max) : max;
          } else {
            tw = fixedWidth ? w : isIbFull ? Math.max(w, max) : max;
            th = fixedHeight ? h : y - data.y;
          }

          this.__ioSize(tw, th);
        } // 非abs提前虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐，inline会被父级调用这里只看ib


        if (!isAbs && !isInline) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread);
            }
          }

          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component$1) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // block的所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });
          }
        } // inlineBlock新开上下文，但父级block遇到要处理换行


        return lineClampCount;
      }
      /**
       * inline的尺寸计算非常特殊，并非一个矩形区域，而是由字体行高结合节点下多个LineBox中的内容决定，
       * 且这个尺寸又并非真实LineBox中的内容直接合并计算而来，比如包含了个更大尺寸的ib却不会计入
       * 具体方法为遍历持有的LineBox下的内容，x取两侧极值，同时首尾要考虑mpb，y值取上下极值，同样首尾考虑mpb
       * 首尾行LineBox可能不是不是占满一行，比如前后都有同行inline的情况，非首尾行则肯定占满
       * 绘制内容（如背景色）的区域也很特殊，每行LineBox根据lineHeight对齐baseline得来，并非LineBox全部
       * 当LineBox只有直属Text时如果font没有lineGap则等价于全部，如有则需减去
       * 另外其client/offset/outer的w/h尺寸计算也很特殊，皆因首尾x方向的mpb导致
       * @private
       */

    }, {
      key: "__inlineSize",
      value: function __inlineSize(size, textAlign, isUpright) {
        var contentBoxList = this.contentBoxList,
            computedStyle = this.computedStyle,
            __ox = this.__ox,
            __oy = this.__oy;
        var display = computedStyle[DISPLAY$5],
            marginTop = computedStyle[MARGIN_TOP$4],
            marginRight = computedStyle[MARGIN_RIGHT$4],
            marginBottom = computedStyle[MARGIN_BOTTOM$4],
            marginLeft = computedStyle[MARGIN_LEFT$4],
            paddingTop = computedStyle[PADDING_TOP$5],
            paddingRight = computedStyle[PADDING_RIGHT$4],
            paddingBottom = computedStyle[PADDING_BOTTOM$5],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$5],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$5],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            lineHeight = computedStyle[LINE_HEIGHT$7]; // 可能因为Ellipsis回溯变成none

        if (display === 'none') {
          return;
        } // x/clientX/offsetX/outerX


        var maxX, maxY, minX, minY, maxCX, maxCY, minCX, minCY, maxFX, maxFY, minFX, minFY, maxOX, maxOY, minOX, minOY;
        var length = contentBoxList.length;

        if (length) {
          // 遍历contentBox，里面存的是LineBox内容，根据父LineBox引用判断是否换行
          contentBoxList.forEach(function (item, i) {
            // 非第一个除了minY不用看其它都要，minX是换行导致，而maxX在最后一个要考虑右侧mpb，中间的无需考虑嵌套inline的mpb
            if (i) {
              minX = Math.min(minX, item.x);
              minCX = Math.min(minCX, item.x);
              minFX = Math.min(minFX, item.x);
              minOX = Math.min(minOX, item.x);

              if (i === length - 1) {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
                maxY = maxCY = maxFY = maxOY = Math.max(maxY, item.y + item.outerHeight);
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              } else {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
              }
            } // 第一个初始化
            else {
              minX = item.x;
              minY = item.y;
              minCX = minX - paddingLeft;
              minCY = minY - paddingTop;
              minFX = minCX - borderLeftWidth;
              minFY = minCY - borderTopWidth;
              minOX = minFX - marginLeft;
              minOY = minFY - marginTop;
              maxX = maxCX = maxFX = maxOX = item.x + item.outerWidth;
              maxY = maxCY = maxFY = maxOY = item.y + item.outerHeight;

              if (i === length - 1) {
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              }
            }
          });
          this.__x = minOX;
          this.__y = minOY;
          this.__width = computedStyle[WIDTH$5] = maxX - minX; // 防止比自己最小高度lineHeight还小，比如内容是个小字体

          this.__height = computedStyle[HEIGHT$6] = Math.max(lineHeight, maxY - minY);
          this.__clientWidth = maxCX - minCX;
          this.__clientHeight = maxCY - minCY;
          this.__offsetWidth = maxFX - minFX;
          this.__offsetHeight = maxFY - minFY;
          this.__outerWidth = maxOX - minOX;
          this.__outerHeight = maxOY - minOY;
          this.__sx = minOX + __ox;
          this.__sy = minOY + __oy;
          this.__sx1 = minFX + __ox;
          this.__sy1 = minFY + __oy;
          this.__sx2 = minCX + __ox;
          this.__sy2 = minCY + __oy;
          this.__sx3 = minX + __ox;
          this.__sy3 = minY + __oy;
          this.__sx4 = maxX + __ox;
          this.__sy4 = maxY + __oy;
          this.__sx5 = maxCX + __ox;
          this.__sy5 = maxCY + __oy;
          this.__sx6 = maxFX + __ox;
          this.__sy6 = maxFY + __oy; // inline的text整体设置相同

          if (['center', 'right'].indexOf(textAlign) > -1) {
            this.children.forEach(function (item) {
              if (item instanceof Text) {
                item.__inlineSize(isUpright);
              }
            });
          }
        } // 如果没有内容，宽度为0高度为lineHeight，对齐也特殊处理，lineBoxManager不会处理
        else {
          var tw = 0,
              th = 0;

          if (['center', 'right'].indexOf(textAlign) > -1) {
            var diff = size;

            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (diff > 0) {
              if (isUpright) {
                this.__offsetY(diff, true);
              } else {
                this.__offsetX(diff, true);
              }
            }
          }

          if (isUpright) {
            tw = lineHeight;

            this.__ioSize(tw, 0);

            this.__sx -= marginLeft + paddingLeft + borderLeftWidth;
          } else {
            th = lineHeight;

            this.__ioSize(0, th);

            this.__sy -= marginTop + paddingTop + borderTopWidth;
          }

          this.__sx1 = this.__sx + marginLeft;
          this.__sy1 = this.__sy + marginTop;
          this.__sx2 = this.__sx1 + borderLeftWidth;
          this.__sy2 = this.__sy1 + borderTopWidth;
          this.__sx4 = this.__sx3 = this.__sx2 + paddingLeft;
          this.__sy4 = this.__sy3 = this.__sy2 + paddingTop;
          this.__sx5 = this.__sx4 + tw + paddingRight;
          this.__sy5 = this.__sy4 + th + paddingBottom;
          this.__sx6 = this.__sx5 + borderRightWidth;
          this.__sy6 = this.__sy5 + borderBottomWidth;
          this.__clientWidth = this.__sx5 - this.__sx2;
          this.__clientHeight = this.__sy5 - this.__sy2;
          this.__offsetWidth = this.__sx6 - this.__sx1;
          this.__offsetHeight = this.__sy6 - this.__sy1;
          this.__outerWidth = this.__offsetWidth + marginLeft + marginRight;
          this.__outerHeight = this.__offsetHeight + marginTop + marginBottom;
        }
      }
      /**
       * 只针对绝对定位children布局
       * @param container
       * @param data
       * @param target 可选，只针对某个abs的child特定布局，在局部更新时用
       * @private
       */

    }, {
      key: "__layoutAbs",
      value: function __layoutAbs(container, data, target) {
        var _this6 = this;

        var x = container.sx,
            y = container.sy,
            clientWidth = container.clientWidth,
            clientHeight = container.clientHeight,
            computedStyle = container.computedStyle;
        var isDestroyed = this.isDestroyed,
            children = this.children,
            absChildren = this.absChildren;
        var display = computedStyle[DISPLAY$5],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$5],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            marginTop = computedStyle[MARGIN_TOP$4],
            marginLeft = computedStyle[MARGIN_LEFT$4],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            paddingTop = computedStyle[PADDING_TOP$5];

        if (isDestroyed || display === 'none') {
          this.__layoutNone();

          return;
        }

        x += marginLeft + borderLeftWidth;
        y += marginTop + borderTopWidth; // 对absolute的元素进行相对容器布局

        absChildren.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component$1) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          var currentStyle = item.currentStyle,
              computedStyle = item.computedStyle;

          if (item.isDestroyed || currentStyle[DISPLAY$5] === 'none') {
            item.__layoutNone();

            return;
          } // 先根据容器宽度计算margin/padding，匿名块对象特殊处理，此时没有computedStyle


          item.__computeReflow();

          item.__mp(currentStyle, computedStyle, clientWidth);

          var left = currentStyle[LEFT$1],
              top = currentStyle[TOP$3],
              right = currentStyle[RIGHT$1],
              bottom = currentStyle[BOTTOM$3],
              width = currentStyle[WIDTH$5],
              height = currentStyle[HEIGHT$6];
          var x2, y2, w2, h2;
          var onlyRight;
          var onlyBottom;
          var fixedTop;
          var fixedRight;
          var fixedBottom;
          var fixedLeft; // 判断何种方式的定位，比如左+宽度，左+右之类

          if (left[1] !== AUTO$5) {
            fixedLeft = true;
            computedStyle[LEFT$1] = _this6.__calSize(left, clientWidth, true);
          } else {
            computedStyle[LEFT$1] = 'auto';
          }

          if (right[1] !== AUTO$5) {
            fixedRight = true;
            computedStyle[RIGHT$1] = _this6.__calSize(right, clientWidth, true);
          } else {
            computedStyle[RIGHT$1] = 'auto';
          }

          if (top[1] !== AUTO$5) {
            fixedTop = true;
            computedStyle[TOP$3] = _this6.__calSize(top, clientHeight, true);
          } else {
            computedStyle[TOP$3] = 'auto';
          }

          if (bottom[1] !== AUTO$5) {
            fixedBottom = true;
            computedStyle[BOTTOM$3] = _this6.__calSize(bottom, clientHeight, true);
          } else {
            computedStyle[BOTTOM$3] = 'auto';
          } // 优先级最高left+right，其次left+width，再次right+width，再次仅申明单个，最次全部auto


          if (fixedLeft && fixedRight) {
            x2 = x + computedStyle[LEFT$1];
            w2 = clientWidth - computedStyle[RIGHT$1] - computedStyle[LEFT$1];
          } else if (fixedLeft) {
            x2 = x + computedStyle[LEFT$1];

            if (width[1] !== AUTO$5) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } else if (fixedRight) {
            if (width[1] !== AUTO$5) {
              w2 = _this6.__calSize(width, clientWidth, true);
            } else {
              onlyRight = true;
            }

            x2 = x + clientWidth - computedStyle[RIGHT$1] - (w2 || 0); // 右对齐有尺寸时还需减去margin/border/padding的

            x2 -= computedStyle[MARGIN_LEFT$4];
            x2 -= computedStyle[MARGIN_RIGHT$4];
            x2 -= computedStyle[PADDING_LEFT$5];
            x2 -= computedStyle[PADDING_RIGHT$4];
            x2 -= computedStyle[BORDER_LEFT_WIDTH$5];
            x2 -= computedStyle[BORDER_RIGHT_WIDTH$4];
          } else {
            x2 = x + paddingLeft;

            if (width[1] !== AUTO$5) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } // top/bottom/height优先级同上


          if (fixedTop && fixedBottom) {
            y2 = y + computedStyle[TOP$3];
            h2 = clientHeight - computedStyle[TOP$3] - computedStyle[BOTTOM$3];
          } else if (fixedTop) {
            y2 = y + computedStyle[TOP$3];

            if (height[1] !== AUTO$5) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } else if (fixedBottom) {
            if (height[1] !== AUTO$5) {
              h2 = _this6.__calSize(height, clientHeight, true);
            } else {
              onlyBottom = true;
            }

            y2 = y + clientHeight - computedStyle[BOTTOM$3] - (h2 || 0); // 底对齐有尺寸时y值还需减去margin/border/padding的

            y2 -= computedStyle[MARGIN_TOP$4];
            y2 -= computedStyle[MARGIN_BOTTOM$4];
            y2 -= computedStyle[PADDING_TOP$5];
            y2 -= computedStyle[PADDING_BOTTOM$5];
            y2 -= computedStyle[BORDER_TOP_WIDTH$5];
            y2 -= computedStyle[BORDER_BOTTOM_WIDTH$5];
          } // 未声明y的找到之前的流布局child，紧随其下
          else {
            y2 = y + paddingTop;
            var prev = item.prev;

            while (prev) {
              // 以前面的flow的最近的prev末尾为准
              if (prev instanceof Text || prev.computedStyle[POSITION$4] !== 'absolute') {
                y2 = prev.y + prev.outerHeight;
                break;
              }

              prev = prev.prev;
            }

            if (height[1] !== AUTO$5) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } // onlyRight时做的布局其实是以那个点位为left/top布局然后offset，limit要特殊计算，从本点向左侧为边界


          var widthLimit = onlyRight ? x2 - x : clientWidth + x - x2; // onlyBottom相同，正常情况是左上到右下的尺寸限制

          var heightLimit = onlyBottom ? y2 - y : clientHeight + y - y2; // 未直接或间接定义尺寸，取特殊孩子宽度的最大值，同时不能超限

          if (w2 === undefined) {
            item.__layout({
              x: x2,
              y: y2,
              w: widthLimit,
              h: heightLimit,
              isUpright: data.isUpright // 父亲的

            }, true, false);

            widthLimit = item.outerWidth;
          }

          item.__layout({
            x: x2,
            y: y2,
            w: widthLimit,
            h: heightLimit,
            w2: w2,
            // left+right这种等于有宽度，但不能修改style，继续传入到__preLayout中特殊对待
            h2: h2,
            isUpright: data.isUpright
          }, false, false);

          if (onlyRight) {
            item.__offsetX(-item.outerWidth, true);
          }

          if (onlyBottom) {
            item.__offsetY(-item.outerHeight, true);
          }
        }); // 递归进行，遇到absolute/relative/component的设置新容器

        children.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component$1) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          if (item instanceof Dom) {
            item.__layoutAbs(isRelativeOrAbsolute$1(item) ? item : container, data);
          } else if (item instanceof Component$1) {
            var sr = item.shadowRoot;

            if (sr instanceof Dom) {
              sr.__layoutAbs(sr, data);
            }
          }
        }); // 根节点自己特殊执行，不在layout统一

        this.__execAr();
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Dom.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        var ep = this.__ellipsis;

        if (ep) {
          ep.render(renderMode, lv, res.ctx, cache, dx, dy);
        }

        if (renderMode === SVG$4) {
          this.virtualDom.type = 'dom';
        }

        return res;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        this.children.forEach(function (child) {
          // 有可能为空，因为diff过程中相同的cp被移到新的vd中，老的防止destroy设null
          if (child) {
            child.__destroy();
          }
        });

        if (this.__ellipsis) {
          this.__ellipsis.__destroy();
        }

        _get(_getPrototypeOf(Dom.prototype), "__destroy", this).call(this);
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        if (force) {
          return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, force);
        }

        var isDestroyed = this.isDestroyed,
            computedStyle = this.computedStyle,
            isMask = this.isMask;

        if (isDestroyed || computedStyle[DISPLAY$5] === 'none' || e.__stopPropagation || isMask) {
          return;
        } // 检查perspective嵌套状态，自身有perspective则设置10位，自身有transform的p矩阵则设置01位
        // if(computedStyle[PERSPECTIVE]) {
        //   perspectiveNest++;
        // }
        // if(tf.isPerspectiveMatrix(computedStyle[TRANSFORM])) {
        //   perspectiveTfNest++;
        // }
        // overflow:hidden时还需要判断是否超出范围外，如果是则无效


        if (computedStyle[OVERFLOW$2] === 'hidden' && !this.willResponseEvent(e, true)) {
          return;
        } // 找到对应的callback


        var type = e.event.type;
        var listener = this.listener,
            zIndexChildren = this.zIndexChildren;
        var cb;

        if (listener.hasOwnProperty(type)) {
          cb = listener[type];
        } // child触发则parent一定触发


        for (var i = zIndexChildren.length - 1; i >= 0; i--) {
          var child = zIndexChildren[i];

          if (child instanceof Xom$1 || child instanceof Component$1 && child.shadowRoot instanceof Xom$1) {
            if (child.__emitEvent(e)) {
              // 孩子阻止冒泡
              if (e.__stopPropagation) {
                return;
              }

              if (isFunction$6(cb) && !e.__stopImmediatePropagation) {
                cb.call(this, e);
              }

              return true;
            }
          }
        } // child不触发再看自己


        return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e);
      } // 深度遍历执行所有子节点，包含自己，如果cb返回true，提前跳出不继续深度遍历

    }, {
      key: "__deepScan",
      value: function __deepScan(cb, options) {
        if (_get(_getPrototypeOf(Dom.prototype), "__deepScan", this).call(this, cb, options)) {
          return;
        }

        this.children.forEach(function (node) {
          node.__deepScan(cb, options);
        });
      }
    }, {
      key: "appendChild",
      value: function appendChild(json, cb) {
        var self = this;

        if (!isNil$7(json) && !self.isDestroyed) {
          var root = self.root,
              host = self.host;

          if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
            if (json.vd) {
              root.delRefreshTask(json.vd.__task);
              json.vd.remove();
            }

            var vd;

            if ($$type.TYPE_CP === json.$$type) {
              vd = builder.initCp2(json, root, host, self);
            } else {
              vd = builder.initDom(json, root, host, self);
            }

            root.addRefreshTask(vd.__task = {
              __before: function __before() {
                vd.__task = null; // 清除在before，防止after的回调增加新的task误删

                self.__json.children.push(json);

                var len = self.children.length;

                if (len) {
                  var last = self.children[len - 1];
                  last.__next = vd;
                  vd.__prev = last;
                }

                self.children.push(vd);
                self.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

                var res = {};
                res[UPDATE_NODE$3] = vd;
                res[UPDATE_FOCUS$2] = o$3.REFLOW;
                res[UPDATE_ADD_DOM] = true;
                res[UPDATE_CONFIG$3] = vd.__config;

                root.__addUpdate(vd, vd.__config, root, root.__config, res);
              },
              __after: function __after(diff) {
                if (isFunction$6(cb)) {
                  cb.call(vd, diff);
                }
              }
            });
          } else {
            throw new Error('Invalid parameter in appendChild.');
          }
        }
      }
    }, {
      key: "prependChild",
      value: function prependChild(json, cb) {
        var self = this;

        if (!isNil$7(json) && !self.isDestroyed) {
          var root = self.root,
              host = self.host;

          if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
            if (json.vd) {
              root.delRefreshTask(json.vd.__task);
              json.vd.remove();
            }

            var vd;

            if ($$type.TYPE_CP === json.$$type) {
              vd = builder.initCp2(json, root, host, self);
            } else {
              vd = builder.initDom(json, root, host, self);
            }

            root.addRefreshTask(vd.__task = {
              __before: function __before() {
                vd.__task = null;

                self.__json.children.unshift(json);

                var len = self.children.length;

                if (len) {
                  var first = self.children[0];
                  first.__prev = vd;
                  vd.__next = first;
                }

                self.children.unshift(vd);
                self.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

                var res = {};
                res[UPDATE_NODE$3] = vd;
                res[UPDATE_FOCUS$2] = o$3.REFLOW;
                res[UPDATE_ADD_DOM] = true;
                res[UPDATE_CONFIG$3] = vd.__config;

                root.__addUpdate(vd, vd.__config, root, root.__config, res);
              },
              __after: function __after(diff) {
                if (isFunction$6(cb)) {
                  cb.call(vd, diff);
                }
              }
            });
          } else {
            throw new Error('Invalid parameter in prependChild.');
          }
        }
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(json, cb) {
        var self = this;

        if (!isNil$7(json) && !self.isDestroyed && self.domParent) {
          var root = self.root,
              domParent = self.domParent;
          var host = domParent.hostRoot;

          if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
            if (json.vd) {
              root.delRefreshTask(json.vd.__task);
              json.vd.remove();
            }

            var vd;

            if ($$type.TYPE_CP === json.$$type) {
              vd = builder.initCp2(json, root, host, domParent);
            } else {
              vd = builder.initDom(json, root, host, domParent);
            }

            root.addRefreshTask(vd.__task = {
              __before: function __before() {
                vd.__task = null;
                var i = 0,
                    has,
                    __json = domParent.__json,
                    children = __json.children,
                    len = children.length;
                var pJson = self.isShadowRoot ? self.hostRoot.__json : self.__json;

                for (; i < len; i++) {
                  if (children[i] === pJson) {
                    has = true;
                    break;
                  }
                }

                if (!has) {
                  throw new Error('InsertBefore exception.');
                } // 插入注意开头位置处理


                if (i) {
                  children.splice(i, 0, json);
                  vd.__next = self;
                  vd.__prev = self.__prev;
                  self.__prev = vd;
                  domParent.children.splice(i, 0, vd);
                } else {
                  if (len) {
                    var first = domParent.children[0];
                    first.__prev = vd;
                    vd.__next = first;
                  }

                  children.unshift(json);
                  domParent.children.unshift(vd);
                }

                domParent.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

                var res = {};
                res[UPDATE_NODE$3] = vd;
                res[UPDATE_FOCUS$2] = o$3.REFLOW;
                res[UPDATE_ADD_DOM] = true;
                res[UPDATE_CONFIG$3] = vd.__config;

                root.__addUpdate(vd, vd.__config, root, root.__config, res);
              },
              __after: function __after(diff) {
                if (isFunction$6(cb)) {
                  cb.call(vd, diff);
                }
              }
            });
          } else {
            throw new Error('Invalid parameter in insertBefore.');
          }
        }
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(json, cb) {
        var self = this;

        if (!isNil$7(json) && !self.isDestroyed && self.domParent) {
          var root = self.root,
              domParent = self.domParent;
          var host = domParent.hostRoot;

          if ([$$type.TYPE_VD, $$type.TYPE_GM, $$type.TYPE_CP].indexOf(json.$$type) > -1) {
            if (json.vd) {
              root.delRefreshTask(json.vd.__task);
              json.vd.remove();
            }

            var vd;

            if ($$type.TYPE_CP === json.$$type) {
              vd = builder.initCp2(json, root, host, domParent);
            } else {
              vd = builder.initDom(json, root, host, domParent);
            }

            root.addRefreshTask(vd.__task = {
              __before: function __before() {
                vd.__task = null;
                var i = 0,
                    has,
                    __json = domParent.__json,
                    children = __json.children,
                    len = children.length;
                var pJson = self.isShadowRoot ? self.hostRoot.__json : self.__json;

                for (; i < len; i++) {
                  if (children[i] === pJson) {
                    has = true;
                    break;
                  }
                }

                if (!has) {
                  throw new Error('insertAfter exception.');
                } // 插入注意末尾位置处理


                if (i < len - 1) {
                  children.splice(i + 1, 0, json);
                  vd.__prev = self;
                  vd.__next = self.__next;
                  self.__next = vd;
                  domParent.children.splice(i + 1, 0, vd);
                } else {
                  if (len) {
                    var last = domParent.children[len - 1];
                    last.__next = vd;
                    vd.__prev = last;
                  }

                  children.push(json);
                  domParent.children.push(vd);
                }

                domParent.__zIndexChildren = null; // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题

                var res = {};
                res[UPDATE_NODE$3] = vd;
                res[UPDATE_FOCUS$2] = o$3.REFLOW;
                res[UPDATE_ADD_DOM] = true;
                res[UPDATE_CONFIG$3] = vd.__config;

                root.__addUpdate(vd, vd.__config, root, root.__config, res);
              },
              __after: function __after(diff) {
                if (isFunction$6(cb)) {
                  cb.call(vd, diff);
                }
              }
            });
          } else {
            throw new Error('Invalid parameter in insertAfter.');
          }
        }
      }
    }, {
      key: "removeChild",
      value: function removeChild(target, cb) {
        if (target.parent === this && (target instanceof Xom$1 || target instanceof Component$1)) {
          if (this.isDestroyed) {
            inject.warn('Remove parent is destroyed.');

            if (isFunction$6(cb)) {
              cb();
            }

            return;
          }

          target.remove(cb);
        } else {
          throw new Error('Invalid parameter in removeChild.');
        }
      }
    }, {
      key: "children",
      get: function get() {
        return this.__children;
      }
    }, {
      key: "flowChildren",
      get: function get() {
        return this.children.filter(function (item) {
          if (item instanceof Component$1) {
            item = item.shadowRoot;
          }

          return item instanceof Text || item.currentStyle[POSITION$4] !== 'absolute';
        });
      }
    }, {
      key: "absChildren",
      get: function get() {
        return this.children.filter(function (item) {
          if (item instanceof Component$1) {
            item = item.shadowRoot;
          }

          return item instanceof Xom$1 && item.currentStyle[POSITION$4] === 'absolute';
        });
      }
    }, {
      key: "zIndexChildren",
      get: function get() {
        return this.__zIndexChildren;
      }
    }, {
      key: "lineBoxManager",
      get: function get() {
        return this.__lineBoxManager;
      }
    }, {
      key: "baseline",
      get: function get() {
        var _this$computedStyle2 = this.computedStyle,
            marginTop = _this$computedStyle2[MARGIN_TOP$4],
            borderTopWidth = _this$computedStyle2[BORDER_TOP_WIDTH$5],
            paddingTop = _this$computedStyle2[PADDING_TOP$5],
            writingMode = _this$computedStyle2[WRITING_MODE$2];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === 0) {
          return this.offsetHeight;
        }

        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.baseline;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return this.offsetHeight;
        }

        var _this$computedStyle3 = this.computedStyle,
            marginTop = _this$computedStyle3[MARGIN_TOP$4],
            borderTopWidth = _this$computedStyle3[BORDER_TOP_WIDTH$5],
            paddingTop = _this$computedStyle3[PADDING_TOP$5];
        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.firstBaseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return 0;
        }

        var _this$computedStyle4 = this.computedStyle,
            marginLeft = _this$computedStyle4[MARGIN_LEFT$4],
            borderLeftWidth = _this$computedStyle4[BORDER_LEFT_WIDTH$5],
            paddingLeft = _this$computedStyle4[PADDING_LEFT$5],
            writingMode = _this$computedStyle4[WRITING_MODE$2];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === -1) {
          return 0;
        }

        return marginLeft + borderLeftWidth + paddingLeft + this.lineBoxManager.verticalBaseline;
      }
    }]);

    return Dom;
  }(Xom$1);

  var _enums$STYLE_KEY$h = enums.STYLE_KEY,
      WIDTH$6 = _enums$STYLE_KEY$h.WIDTH,
      HEIGHT$7 = _enums$STYLE_KEY$h.HEIGHT,
      DISPLAY$6 = _enums$STYLE_KEY$h.DISPLAY,
      BORDER_TOP_WIDTH$6 = _enums$STYLE_KEY$h.BORDER_TOP_WIDTH,
      BORDER_RIGHT_WIDTH$5 = _enums$STYLE_KEY$h.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$6 = _enums$STYLE_KEY$h.BORDER_LEFT_WIDTH,
      BORDER_BOTTOM_WIDTH$6 = _enums$STYLE_KEY$h.BORDER_BOTTOM_WIDTH,
      BORDER_TOP_LEFT_RADIUS$2 = _enums$STYLE_KEY$h.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$2 = _enums$STYLE_KEY$h.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$2 = _enums$STYLE_KEY$h.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$2 = _enums$STYLE_KEY$h.BORDER_BOTTOM_LEFT_RADIUS,
      VISIBILITY$3 = _enums$STYLE_KEY$h.VISIBILITY,
      BACKGROUND_IMAGE$2 = _enums$STYLE_KEY$h.BACKGROUND_IMAGE,
      BACKGROUND_COLOR$2 = _enums$STYLE_KEY$h.BACKGROUND_COLOR,
      BOX_SHADOW$3 = _enums$STYLE_KEY$h.BOX_SHADOW,
      MIX_BLEND_MODE$1 = _enums$STYLE_KEY$h.MIX_BLEND_MODE,
      MARGIN_RIGHT$5 = _enums$STYLE_KEY$h.MARGIN_RIGHT,
      MARGIN_LEFT$5 = _enums$STYLE_KEY$h.MARGIN_LEFT,
      PADDING_RIGHT$5 = _enums$STYLE_KEY$h.PADDING_RIGHT,
      PADDING_LEFT$6 = _enums$STYLE_KEY$h.PADDING_LEFT,
      FONT_SIZE$b = _enums$STYLE_KEY$h.FONT_SIZE,
      FLEX_BASIS$3 = _enums$STYLE_KEY$h.FLEX_BASIS,
      _enums$UPDATE_KEY$4 = enums.UPDATE_KEY,
      UPDATE_NODE$4 = _enums$UPDATE_KEY$4.UPDATE_NODE,
      UPDATE_FOCUS$3 = _enums$UPDATE_KEY$4.UPDATE_FOCUS,
      UPDATE_CONFIG$4 = _enums$UPDATE_KEY$4.UPDATE_CONFIG,
      _enums$NODE_KEY$5 = enums.NODE_KEY,
      NODE_CACHE$2 = _enums$NODE_KEY$5.NODE_CACHE,
      NODE_DEFS_CACHE$3 = _enums$NODE_KEY$5.NODE_DEFS_CACHE,
      NODE_IS_MASK$1 = _enums$NODE_KEY$5.NODE_IS_MASK;
  var AUTO$6 = o.AUTO,
      PX$7 = o.PX,
      PERCENT$8 = o.PERCENT,
      REM$7 = o.REM,
      VW$7 = o.VW,
      VH$7 = o.VH,
      VMAX$7 = o.VMAX,
      VMIN$7 = o.VMIN,
      RGBA$3 = o.RGBA;
  var canvasPolygon$5 = painter.canvasPolygon,
      svgPolygon$5 = painter.svgPolygon;
  var isFunction$7 = util.isFunction;

  var Img$1 = /*#__PURE__*/function (_Dom) {
    _inherits(Img, _Dom);

    var _super = _createSuper(Img);

    function Img(tagName, props) {
      var _this;

      _classCallCheck(this, Img);

      _this = _super.call(this, tagName, props);
      var src = _this.props.src;
      var loadImg = _this.__loadImg = {
        src: src
      }; // 空url用错误图代替

      if (!src) {
        loadImg.error = true;
      } else {
        var ca = inject.IMG[src];

        if (ca && ca.state === inject.LOADED) {
          loadImg.source = ca.source;
          loadImg.width = ca.width;
          loadImg.height = ca.height;
        }
      }

      var config = _this.__config;

      if (config[NODE_IS_MASK$1]) {
        var _assertThisInitialize = _assertThisInitialized(_this),
            style = _assertThisInitialize.style,
            currentStyle = _assertThisInitialize.currentStyle;

        style[BACKGROUND_IMAGE$2] = currentStyle[BACKGROUND_IMAGE$2] = [null];
        style[BACKGROUND_COLOR$2] = currentStyle[BACKGROUND_COLOR$2] = [[0, 0, 0, 0], RGBA$3];
        style[BORDER_TOP_WIDTH$6] = currentStyle[BORDER_TOP_WIDTH$6] = [0, PX$7];
        style[BORDER_RIGHT_WIDTH$5] = currentStyle[BORDER_RIGHT_WIDTH$5] = [0, PX$7];
        style[BORDER_LEFT_WIDTH$6] = currentStyle[BORDER_LEFT_WIDTH$6] = [0, PX$7];
        style[BORDER_BOTTOM_WIDTH$6] = currentStyle[BORDER_BOTTOM_WIDTH$6] = [0, PX$7];
        style[BOX_SHADOW$3] = currentStyle[BOX_SHADOW$3] = null;
        style[MIX_BLEND_MODE$1] = currentStyle[MIX_BLEND_MODE$1] = 'normal';
      }

      return _this;
    }
    /**
     * 覆盖xom的方法，在__layout()3个分支中会首先被调用
     * 当样式中固定宽高时，图片按样式尺寸，加载后重新绘制即可
     * 只固定宽高一个时，加载完要计算缩放比，重新布局绘制
     * 都没有固定，按照图片尺寸，重新布局绘制
     * 这里计算非固定的情况，将其改为固定供布局渲染使用，未加载完成为0
     * @param data
     * @param isInline
     * @returns {{fixedWidth: boolean, w: *, x: *, h: *, y: *, fixedHeight: boolean}}
     * @private
     */


    _createClass(Img, [{
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var res = _get(_getPrototypeOf(Img.prototype), "__preLayout", this).call(this, data, false);

        var loadImg = this.__loadImg; // 可能已提前加载好了，或有缓存，为减少刷新直接使用

        if (!loadImg.error) {
          var src = loadImg.src;
          var cache = inject.IMG[src];

          if (cache && cache.state === inject.LOADED) {
            loadImg.source = cache.source;
            loadImg.width = cache.width;
            loadImg.height = cache.height;
          }

          loadImg.cache = false;
        }

        if (res.fixedWidth && res.fixedHeight) {
          return res;
        }

        if (loadImg.error && !this.props.placeholder) {
          if (res.fixedWidth) {
            res.h = res.w;
          } else if (res.fixedHeight) {
            res.w = res.h;
          } else {
            res.w = res.h = 32;
          }
        } else if (loadImg.source) {
          if (res.fixedWidth) {
            res.h = res.w * loadImg.height / loadImg.width;
          } else if (res.fixedHeight) {
            res.w = res.h * loadImg.width / loadImg.height;
          } else {
            res.w = loadImg.width;
            res.h = loadImg.height;
          }
        } else {
          res.w = res.h = 0;
        }

        res.fixedWidth = true;
        res.fixedHeight = true;
        return res;
      }
    }, {
      key: "__addGeom",
      value: function __addGeom(tagName, props) {
        props = util.hash2arr(props);
        this.virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.root.delRefreshTask(this.__task);

        _get(_getPrototypeOf(Img.prototype), "__destroy", this).call(this);

        this.__task = null;
      } // img根据加载情况更新__hasContent

    }, {
      key: "__calContent",
      value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
        var res = _get(_getPrototypeOf(Img.prototype), "__calContent", this).call(this, renderMode, lv, currentStyle, computedStyle);

        if (!res) {
          var loadImg = this.__loadImg;

          if (computedStyle[VISIBILITY$3] !== 'hidden' && (computedStyle[WIDTH$6] || computedStyle[HEIGHT$7]) && loadImg.source) {
            res = true;
          }
        }

        return res;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache) {
        var dx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var dy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

        var res = _get(_getPrototypeOf(Img.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (renderMode === mode.WEBGL) {
          dx = res.dx;
          dy = res.dy;
        }

        var offscreenBlend = res.offscreenBlend,
            offscreenMask = res.offscreenMask,
            offscreenFilter = res.offscreenFilter,
            offscreenOverflow = res.offscreenOverflow;
        var width = this.width,
            height = this.height,
            isDestroyed = this.isDestroyed,
            placeholder = this.props.placeholder,
            computedStyle = this.computedStyle,
            _this$computedStyle = this.computedStyle,
            display = _this$computedStyle[DISPLAY$6],
            borderTopLeftRadius = _this$computedStyle[BORDER_TOP_LEFT_RADIUS$2],
            borderTopRightRadius = _this$computedStyle[BORDER_TOP_RIGHT_RADIUS$2],
            borderBottomRightRadius = _this$computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$2],
            borderBottomLeftRadius = _this$computedStyle[BORDER_BOTTOM_LEFT_RADIUS$2],
            visibility = _this$computedStyle[VISIBILITY$3],
            virtualDom = this.virtualDom,
            __config = this.__config,
            loadImg = this.__loadImg,
            root = this.root;

        if (offscreenBlend) {
          ctx = offscreenBlend.target.ctx;
        }

        if (offscreenMask) {
          ctx = offscreenMask.target.ctx;
        }

        if (offscreenFilter) {
          ctx = offscreenFilter.target.ctx;
        }

        if (offscreenOverflow) {
          ctx = offscreenOverflow.target.ctx;
        } // 没source且不error时加载图片


        if (!loadImg.source && !loadImg.error && !loadImg.loading) {
          this.__loadAndRefresh(loadImg, root, ctx, placeholder, computedStyle, width, height);
        }

        if (isDestroyed || display === 'none' || visibility === 'hidden') {
          return res;
        }

        var __cache = __config[NODE_CACHE$2];

        if (cache && __cache && __cache.enabled) {
          ctx = __cache.ctx;
        }

        var originX, originY;
        originX = res.x3 + dx;
        originY = res.y3 + dy; // 根据配置以及占位图显示error

        var source = loadImg.source;

        if (loadImg.error && !placeholder && Img.showError) {
          var strokeWidth = Math.min(width, height) * 0.02;
          var stroke = '#CCC';
          var fill = '#DDD';
          var cx = originX + width * 0.7;
          var cy = originY + height * 0.3;
          var r = strokeWidth * 5;
          var pts = [[originX + width * 0.15, originY + height * 0.7], [originX + width * 0.3, originY + height * 0.4], [originX + width * 0.5, originY + height * 0.6], [originX + width * 0.6, originY + height * 0.5], [originX + width * 0.9, originY + height * 0.8], [originX + width * 0.15, originY + height * 0.8]];

          if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = strokeWidth;
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + width, originY);
            ctx.lineTo(originX + width, originY + height);
            ctx.lineTo(originX, originY + height);
            ctx.lineTo(originX, originY);
            ctx.stroke();
            ctx.closePath();
            ctx.beginPath();
            var points = geom.ellipsePoints(cx, cy, r, r);
            painter.canvasPolygon(ctx, points, 0, 0);
            ctx.fill();
            ctx.closePath();
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);

            for (var i = 1, len = pts.length; i < len; i++) {
              var point = pts[i];
              ctx.lineTo(point[0], point[1]);
            }

            ctx.lineTo(pts[0][0], pts[0][1]);
            ctx.fill();
            ctx.closePath();
          } else if (renderMode === mode.SVG) {
            this.__addGeom('rect', [['x', originX], ['y', originY], ['width', width], ['height', height], ['stroke', stroke], ['stroke-width', strokeWidth], ['fill', 'rgba(0,0,0,0)']]);

            this.__addGeom('circle', [['cx', cx], ['cy', cy], ['r', r], ['fill', fill]]);

            var s = '';

            for (var _i = 0, _len = pts.length; _i < _len; _i++) {
              var _point = pts[_i];

              if (_i) {
                s += ' ';
              }

              s += _point[0] + ',' + _point[1];
            }

            this.__addGeom('polygon', [['points', s], ['fill', fill]]);
          }
        } else if (source) {
          // 圆角需要生成一个mask
          var list = border.calRadius(originX, originY, width, height, borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius);

          if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
            // 有border-radius需模拟遮罩裁剪
            if (list) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$5(ctx, list, dx, dy);
              ctx.clip();
              ctx.closePath();
              ctx.drawImage(source, originX, originY, width, height);
              ctx.restore();
            } else {
              ctx.drawImage(source, originX, originY, width, height);
            }
          } else if (renderMode === mode.SVG) {
            // img没有变化无需diff，直接用上次的vd
            if (loadImg.cache) {
              loadImg.cache.cache = true;
              virtualDom.children = [loadImg.cache]; // 但是还是要校验是否有borderRadius变化，引发img的圆角遮罩

              if (!virtualDom.cache && list) {
                var d = svgPolygon$5(list);
                var v = {
                  tagName: 'clipPath',
                  props: [],
                  children: [{
                    type: 'item',
                    tagName: 'path',
                    props: [['d', d], ['fill', '#FFF']]
                  }]
                };
                var id = ctx.add(v);

                __config[NODE_DEFS_CACHE$3].push(v);

                virtualDom.conClip = 'url(#' + id + ')';
              }

              return;
            } // 缩放图片，无需考虑原先矩阵，xom里对父层<g>已经变换过了


            var matrix;

            if (width !== loadImg.width || height !== loadImg.height) {
              matrix = image.matrixResize(loadImg.width, loadImg.height, width, height, originX, originY, width, height);
            }

            var props = [['xlink:href', loadImg.error ? placeholder : loadImg.src], ['x', originX], ['y', originY], ['width', loadImg.width], ['height', loadImg.height]];

            if (list) {
              var _d = svgPolygon$5(list);

              var _v = {
                tagName: 'clipPath',
                props: [],
                children: [{
                  type: 'item',
                  tagName: 'path',
                  props: [['d', _d], ['fill', '#FFF']]
                }]
              };

              var _id = ctx.add(_v);

              __config[NODE_DEFS_CACHE$3].push(_v);

              virtualDom.conClip = 'url(#' + _id + ')';
              delete virtualDom.cache;
            }

            if (matrix && !mx.isE(matrix)) {
              props.push(['transform', 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')']);
            }

            var vd = {
              type: 'img',
              tagName: 'image',
              props: props
            };
            virtualDom.children = [vd];
            loadImg.cache = vd;
          }
        }

        return res;
      } // img没加载时，清空，这样Xom就认为没内容不生成cache，防止img先绘制cache再绘制主屏，重复

    }, {
      key: "__releaseWhenEmpty",
      value: function __releaseWhenEmpty(__cache) {
        if (!this.__loadImg.error && !this.__loadImg.source) {
          return _get(_getPrototypeOf(Img.prototype), "__releaseWhenEmpty", this).call(this, __cache);
        }
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      } // overwrite

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$6],
            height = _this$currentStyle[HEIGHT$7],
            marginLeft = _this$currentStyle[MARGIN_LEFT$5],
            marginRight = _this$currentStyle[MARGIN_RIGHT$5],
            paddingLeft = _this$currentStyle[PADDING_LEFT$6],
            paddingRight = _this$currentStyle[PADDING_RIGHT$5],
            _this$computedStyle2 = this.computedStyle,
            borderLeftWidth = _this$computedStyle2[BORDER_LEFT_WIDTH$6],
            borderRightWidth = _this$computedStyle2[BORDER_RIGHT_WIDTH$5];

        if (width[1] !== AUTO$6) {
          w -= this.__calSize(width, total, true);
        } else {
          var loadImg = this.__loadImg; // 加载成功计算缩放后的宽度

          if (loadImg.source) {
            if (height[1] === PX$7) {
              w -= loadImg.width * height[0] / loadImg.height;
            } else if (height[1] === PERCENT$8) {
              w -= loadImg.width * height[0] * total * 0.01 / loadImg.height;
            } else if (height[1] === REM$7) {
              w -= loadImg.width * height[0] * this.root.computedStyle[FONT_SIZE$b] / loadImg.height;
            } else if (height[1] === VW$7) {
              w -= loadImg.width * height[0] * this.root.width * 0.01 / loadImg.height;
            } else if (height[1] === VH$7) {
              w -= loadImg.width * height[0] * this.root.height * 0.01 / loadImg.height;
            } else if (height[1] === VMAX$7) {
              w -= height[0] * Math.max(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else if (height[1] === VMIN$7) {
              w -= height[0] * Math.min(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else {
              w -= loadImg.width;
            }
          }
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __loadImg = this.__loadImg;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS$3],
            width = currentStyle[WIDTH$6],
            height = currentStyle[HEIGHT$7];
        var main = isDirectionRow ? width : height;
        var cross = isDirectionRow ? height : width; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$7, PERCENT$8, REM$7, VW$7, VH$7, VMAX$7, VMIN$7].indexOf(flexBasis[1]) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$7, PERCENT$8, REM$7, VW$7, VH$7, VMAX$7, VMIN$7].indexOf(main[1]) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // auto和content固定尺寸比例计算
        else if (__loadImg.source || __loadImg.error) {
          var res = this.__preLayout(data);

          if (cross[1] !== AUTO$6) {
            cross = this.__calSize(cross, isDirectionRow ? h : w, true);
            var ratio = res.w / res.h;
            b = max = min = isDirectionRow ? cross * ratio : cross / ratio;
          } else {
            b = max = min = isDirectionRow ? res.w : res.h;
          }
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__loadAndRefresh",
      value: function __loadAndRefresh(loadImg, root, ctx, placeholder, computedStyle, width, height, cb) {
        var self = this; // 先清空之前可能的

        if (loadImg.source || loadImg.error) {
          root.delRefreshTask(self.__task);
          root.addRefreshTask(self.__task = {
            __before: function __before() {
              self.__task = null; // 清除在before，防止after的回调增加新的task误删

              if (self.isDestroyed) {
                return;
              } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


              var res = {};
              res[UPDATE_NODE$4] = self;
              res[UPDATE_FOCUS$3] = o$3.REFLOW; // 没有样式变化但内容尺寸发生了变化强制执行

              res[UPDATE_CONFIG$4] = self.__config;

              root.__addUpdate(self, self.__config, root, root.__config, res);
            }
          });
          loadImg.source = null;
        }

        loadImg.loading = true; // 再测量，可能瞬间完成替换掉上面的

        inject.measureImg(loadImg.src, function (data) {
          // 还需判断url，防止重复加载时老的替换新的，失败走error绘制
          if (data.url === loadImg.src && !self.isDestroyed) {
            var reload = function reload() {
              var _self$currentStyle = self.currentStyle,
                  width = _self$currentStyle[WIDTH$6],
                  height = _self$currentStyle[HEIGHT$7];
              root.delRefreshTask(self.__task);

              if (width[1] !== AUTO$6 && height[1] !== AUTO$6) {
                root.addRefreshTask(self.__task = {
                  __before: function __before() {
                    self.__task = null;

                    if (self.isDestroyed) {
                      return;
                    } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


                    var res = {};
                    res[UPDATE_NODE$4] = self;
                    res[UPDATE_FOCUS$3] = o$3.REPAINT;
                    res[UPDATE_CONFIG$4] = self.__config;

                    root.__addUpdate(self, self.__config, root, root.__config, res);
                  },
                  __after: function __after() {
                    if (isFunction$7(cb)) {
                      cb.call(self);
                    }
                  }
                });
              } else {
                root.addRefreshTask(self.__task = {
                  __before: function __before() {
                    self.__task = null;

                    if (self.isDestroyed) {
                      return;
                    } // 刷新前统一赋值，由刷新逻辑计算最终值避免优先级覆盖问题


                    var res = {};
                    res[UPDATE_NODE$4] = self;
                    res[UPDATE_FOCUS$3] = o$3.REFLOW; // 没有样式变化但内容尺寸发生了变化强制执行

                    res[UPDATE_CONFIG$4] = self.__config;

                    root.__addUpdate(self, self.__config, root, root.__config, res);
                  },
                  __after: function __after() {
                    if (isFunction$7(cb)) {
                      cb.call(self);
                    }
                  }
                });
              }
            };

            loadImg.cache && (loadImg.cache.cache = false);
            loadImg.loading = false;

            if (data.success) {
              loadImg.source = data.source;
              loadImg.width = data.width;
              loadImg.height = data.height;
            } else if (placeholder) {
              inject.measureImg(placeholder, function (data) {
                if (data.success) {
                  loadImg.error = true;
                  loadImg.source = data.source;
                  loadImg.width = data.width;
                  loadImg.height = data.height;
                  reload();
                }
              }, {
                ctx: ctx,
                root: root,
                width: width,
                height: height
              });
              return;
            } else {
              loadImg.error = true;
            } // 可见状态进行刷新操作，visibility某些情况需要刷新，可能宽高未定义要重新布局


            if (computedStyle[DISPLAY$6] !== 'none') {
              reload();
            }
          }
        }, {
          ctx: ctx,
          root: root,
          width: width,
          height: height
        });
      }
    }, {
      key: "updateSrc",
      value: function updateSrc(v, cb) {
        var self = this;
        var loadImg = self.__loadImg;
        var root = this.root; // 相等或空且当前error直接返回

        if (v === loadImg.src || !v && loadImg.error) {
          if (isFunction$7(cb)) {
            cb(-1);
          }
        } else if (v) {
          loadImg.src = v;

          self.__loadAndRefresh(loadImg, root, root.ctx, self.props.placeholder, self.computedStyle, self.width, self.height, cb);
        } else {
          loadImg.src = v;
          loadImg.source = null;
          loadImg.error = true;
          root.delRefreshTask(self.__task);
          root.addRefreshTask(self.__task = {
            __before: function __before() {
              self.__task = null;

              if (self.isDestroyed) {
                return;
              }

              var res = {};
              res[UPDATE_NODE$4] = self;
              res[UPDATE_FOCUS$3] = o$3.REFLOW;
              res[UPDATE_CONFIG$4] = self.__config;

              root.__addUpdate(self, self.__config, root, self.__config, res);
            },
            __after: function __after(diff) {
              if (isFunction$7(cb)) {
                cb(diff);
              }
            }
          });
        }
      }
    }, {
      key: "appendChild",
      value: function appendChild() {
        inject.error('Img can not appendChild.');
      }
    }, {
      key: "src",
      get: function get() {
        return this.__loadImg.src;
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return true;
      }
    }]);

    return Img;
  }(Dom$1);

  _defineProperty(Img$1, "showError", true);

  var Defs = /*#__PURE__*/function () {
    function Defs(uuid) {
      _classCallCheck(this, Defs);

      this.id = uuid;
      this.count = 0;
      this.list = [];
      this.cacheHash = {}; // 每次svg渲染前重置，存储前次渲染不变的缓存id
    }

    _createClass(Defs, [{
      key: "add",
      value: function add(data) {
        var uuid = this.count;
        var hash = this.cacheHash;

        while (hash.hasOwnProperty(uuid)) {
          uuid++;
        }

        this.count = uuid + 1;
        data.id = uuid;
        data.uuid = 'karas-defs-' + this.id + '-' + uuid;
        data.index = this.list.length;
        this.list.push(data);
        return data.uuid;
      }
    }, {
      key: "addCache",
      value: function addCache(data) {
        data.index = this.list.length;
        this.list.push(data);
        this.cacheHash[data.id] = true;
        return data.uuid;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.list = [];
        this.count = 0;
        this.cacheHash = {};
      }
    }, {
      key: "removeCache",
      value: function removeCache(data) {
        var list = this.list;
        var i = data.index; // 一般情况index即位置，但每次渲染过程中，可能会删掉一些，此时位置会往前，但index不变，因此遍历

        for (; i >= 0; i--) {
          if (list[i] === data) {
            list.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "value",
      get: function get() {
        return this.list;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(uuid) {
        return new Defs(uuid);
      }
    }]);

    return Defs;
  }();

  var _enums$STYLE_KEY$i = enums.STYLE_KEY,
      MARGIN_RIGHT$6 = _enums$STYLE_KEY$i.MARGIN_RIGHT,
      MARGIN_LEFT$6 = _enums$STYLE_KEY$i.MARGIN_LEFT,
      PADDING_RIGHT$6 = _enums$STYLE_KEY$i.PADDING_RIGHT,
      PADDING_LEFT$7 = _enums$STYLE_KEY$i.PADDING_LEFT,
      WIDTH$7 = _enums$STYLE_KEY$i.WIDTH,
      HEIGHT$8 = _enums$STYLE_KEY$i.HEIGHT,
      BORDER_RIGHT_WIDTH$6 = _enums$STYLE_KEY$i.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$7 = _enums$STYLE_KEY$i.BORDER_LEFT_WIDTH,
      FILL$1 = _enums$STYLE_KEY$i.FILL,
      STROKE$1 = _enums$STYLE_KEY$i.STROKE,
      STROKE_MITERLIMIT = _enums$STYLE_KEY$i.STROKE_MITERLIMIT,
      STROKE_WIDTH$1 = _enums$STYLE_KEY$i.STROKE_WIDTH,
      STROKE_LINECAP = _enums$STYLE_KEY$i.STROKE_LINECAP,
      STROKE_LINEJOIN = _enums$STYLE_KEY$i.STROKE_LINEJOIN,
      STROKE_DASHARRAY$1 = _enums$STYLE_KEY$i.STROKE_DASHARRAY,
      STROKE_DASHARRAY_STR = _enums$STYLE_KEY$i.STROKE_DASHARRAY_STR,
      FILL_RULE = _enums$STYLE_KEY$i.FILL_RULE,
      VISIBILITY$4 = _enums$STYLE_KEY$i.VISIBILITY,
      FLEX_BASIS$4 = _enums$STYLE_KEY$i.FLEX_BASIS,
      _enums$NODE_KEY$6 = enums.NODE_KEY,
      NODE_CACHE_PROPS = _enums$NODE_KEY$6.NODE_CACHE_PROPS,
      NODE_CURRENT_PROPS = _enums$NODE_KEY$6.NODE_CURRENT_PROPS,
      NODE_CURRENT_STYLE$3 = _enums$NODE_KEY$6.NODE_CURRENT_STYLE,
      NODE_STYLE$3 = _enums$NODE_KEY$6.NODE_STYLE,
      NODE_DEFS_CACHE$4 = _enums$NODE_KEY$6.NODE_DEFS_CACHE;
  var AUTO$7 = o.AUTO,
      PX$8 = o.PX,
      PERCENT$9 = o.PERCENT,
      REM$8 = o.REM,
      VW$8 = o.VW,
      VH$8 = o.VH,
      VMAX$8 = o.VMAX,
      VMIN$8 = o.VMIN,
      RGBA$4 = o.RGBA,
      GRADIENT$3 = o.GRADIENT;
  var int2rgba$4 = util.int2rgba,
      isNil$8 = util.isNil,
      joinArr$3 = util.joinArr;
  var canvasPolygon$6 = painter.canvasPolygon,
      svgPolygon$6 = painter.svgPolygon;
  var REGISTER$1 = {};

  var Geom$1 = /*#__PURE__*/function (_Xom) {
    _inherits(Geom, _Xom);

    var _super = _createSuper(Geom);

    function Geom(tagName, props) {
      var _this;

      _classCallCheck(this, Geom);

      _this = _super.call(this, tagName, props);
      _this.__isMulti = !!_this.props.multi;
      _this.__style = css.normalize(_this.style, reset.DOM_ENTRY_SET.concat(reset.GEOM_ENTRY_SET));
      _this.__currentStyle = util.extend({}, _this.__style);
      _this.__currentProps = util.clone(_this.props);
      var config = _this.__config;
      config[NODE_CACHE_PROPS] = _this.__cacheProps = {};
      config[NODE_CURRENT_PROPS] = _this.__currentProps;
      config[NODE_CURRENT_STYLE$3] = _this.__currentStyle;
      config[NODE_STYLE$3] = _this.__style;
      return _this;
    }

    _createClass(Geom, [{
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        this.__computeReflow(); // 无children，直接以style的width为宽度，不定义则为0


        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$7],
            marginLeft = _this$currentStyle[MARGIN_LEFT$6],
            marginRight = _this$currentStyle[MARGIN_RIGHT$6],
            paddingLeft = _this$currentStyle[PADDING_LEFT$7],
            paddingRight = _this$currentStyle[PADDING_RIGHT$6],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$7],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$6];

        if (width[1] !== AUTO$7) {
          w -= this.__calSize(width, total, true);
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS$4],
            width = currentStyle[WIDTH$7],
            height = currentStyle[HEIGHT$8];
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$8, PERCENT$9, REM$8, VW$8, VH$8, VMAX$8, VMIN$8].indexOf(flexBasis[1]) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$8, PERCENT$9, REM$8, VW$8, VH$8, VMAX$8, VMIN$8].indexOf(main[1]) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright;

        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        }

        this.__ioSize(tw, th);

        if (isAbs || isColumn || isRow) {
          return;
        }

        this.__marginAuto(this.currentStyle, data);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        // 无children所以等同于block
        this.__layoutBlock(data, isAbs, isColumn, isRow);
      }
    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isInline) {
        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            x = _this$__preLayout2.x,
            y = _this$__preLayout2.y,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h;

        var tw = fixedWidth ? w : 0;
        var th = fixedHeight ? h : 0;

        this.__ioSize(tw, th);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "__calCache",
      value: function __calCache(renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6) {
        var _this2 = this;

        var res = _get(_getPrototypeOf(Geom.prototype), "__calCache", this).call(this, renderMode, ctx, parent, __cacheStyle, currentStyle, computedStyle, clientWidth, clientHeight, offsetWidth, offsetHeight, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth, paddingTop, paddingRight, paddingBottom, paddingLeft, x1, x2, x3, x4, x5, x6, y1, y2, y3, y4, y5, y6);

        if (isNil$8(__cacheStyle[STROKE_WIDTH$1])) {
          __cacheStyle[STROKE_WIDTH$1] = true;
          var strokeWidth = currentStyle[STROKE_WIDTH$1] || [];
          var w = this.width;
          computedStyle[STROKE_WIDTH$1] = strokeWidth.map(function (item) {
            return _this2.__calSize(item, w, true);
          });
        }

        if (isNil$8(__cacheStyle[STROKE_DASHARRAY$1])) {
          __cacheStyle[STROKE_DASHARRAY$1] = true;
          computedStyle[STROKE_DASHARRAY$1] = currentStyle[STROKE_DASHARRAY$1] || [];
          __cacheStyle[STROKE_DASHARRAY_STR] = computedStyle[STROKE_DASHARRAY$1].map(function (item) {
            return joinArr$3(item, ',');
          });
        } // 直接赋值的


        [STROKE_LINECAP, STROKE_LINEJOIN, STROKE_MITERLIMIT, FILL_RULE].forEach(function (k) {
          computedStyle[k] = currentStyle[k];
        }); // stroke/fll移至render里处理，因为cache涉及渐变坐标偏移

        [FILL$1, STROKE$1].forEach(function (k) {
          if (isNil$8(__cacheStyle[k])) {
            var v = currentStyle[k];
            var cs = computedStyle[k] = [];

            var _res = __cacheStyle[k] = [];

            if (Array.isArray(v)) {
              v.forEach(function (item) {
                if (item && item[1] === GRADIENT$3) {
                  // let t = this.__gradient(renderMode, ctx, x3, y3, x4, y4, item[0], 0, 0);
                  cs.push(item[0]);

                  _res.push(true);
                } else if (item && item[1] === RGBA$4 && item[0][3] > 0) {
                  cs.push(item[0]);

                  _res.push(int2rgba$4(item[0]));
                } else {
                  cs.push('none');

                  _res.push('none');
                }
              });
            }
          }
        });
        return res;
      }
    }, {
      key: "__calContent",
      value: function __calContent(renderMode, lv, currentStyle, computedStyle) {
        // Geom强制有内容
        return computedStyle[VISIBILITY$4] !== 'hidden';
      }
    }, {
      key: "__preSet",
      value: function __preSet(renderMode, res) {
        var _this3 = this;

        var width = this.width,
            height = this.height,
            __cacheStyle = this.__cacheStyle,
            computedStyle = this.computedStyle;
        var cx = res.sx3 + width * 0.5;
        var cy = res.sy3 + height * 0.5;
        var strokeDasharrayStr = __cacheStyle[STROKE_DASHARRAY_STR];
        var fill = computedStyle[FILL$1],
            stroke = computedStyle[STROKE$1],
            strokeWidth = computedStyle[STROKE_WIDTH$1],
            strokeLinecap = computedStyle[STROKE_LINECAP],
            strokeLinejoin = computedStyle[STROKE_LINEJOIN],
            strokeMiterlimit = computedStyle[STROKE_MITERLIMIT],
            strokeDasharray = computedStyle[STROKE_DASHARRAY$1],
            fillRule = computedStyle[FILL_RULE];
        stroke = stroke.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.x3, res.y3, res.x4, res.y4, item, res.dx, res.dy);
          }

          return int2rgba$4(item);
        });
        fill = fill.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.x3, res.y3, res.x4, res.y4, item, res.dx, res.dy);
          }

          return int2rgba$4(item);
        });
        return {
          cx: cx,
          cy: cy,
          stroke: stroke,
          strokeWidth: strokeWidth,
          strokeDasharray: strokeDasharray,
          strokeDasharrayStr: strokeDasharrayStr,
          strokeLinecap: strokeLinecap,
          strokeLinejoin: strokeLinejoin,
          strokeMiterlimit: strokeMiterlimit,
          fill: fill,
          fillRule: fillRule
        };
      }
    }, {
      key: "__preSetCanvas",
      value: function __preSetCanvas(renderMode, ctx, res) {
        var stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            strokeDasharray = res.strokeDasharray,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            fill = res.fill;

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          if (fill) {
            if (fill.k === 'linear') {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'radial' && !Array.isArray(fill.v)) {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'conic') ; else if (!fill.k && ctx.fillStyle !== fill) {
              ctx.fillStyle = fill;
            }
          }

          if (stroke) {
            if (stroke.k === 'linear') {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'radial' && !Array.isArray(stroke.v)) {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'conic') ; else if (!stroke.k && ctx.strokeStyle !== stroke) {
              ctx.strokeStyle = stroke;
            }
          }

          if (strokeWidth !== undefined && ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          if (strokeLinecap !== undefined && ctx.lineCap !== strokeLinecap) {
            ctx.lineCap = strokeLinecap;
          }

          if (strokeLinejoin !== undefined && ctx.lineJoin !== strokeLinejoin) {
            ctx.lineJoin = strokeLinejoin;
          }

          if (strokeMiterlimit !== undefined && ctx.miterLimit !== strokeMiterlimit) {
            ctx.miterLimit = strokeMiterlimit;
          } // 小程序没这个方法


          if (util.isFunction(ctx.getLineDash)) {
            if (strokeDasharray && !util.equalArr(ctx.getLineDash(), strokeDasharray)) {
              ctx.setLineDash(strokeDasharray);
            }
          } else if (strokeDasharray) {
            ctx.setLineDash(strokeDasharray);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Geom.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (renderMode === mode.SVG) {
          this.virtualDom.type = 'geom';
        } // 无论canvas/svg，break可提前跳出省略计算


        if (res["break"]) {
          return res;
        } // data在无cache时没有提前设置


        var preData = this.__preSet(renderMode, res);

        return Object.assign(res, preData);
      }
    }, {
      key: "__renderPolygon",
      value: function __renderPolygon(renderMode, ctx, res) {
        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var list = this.__cacheProps.list,
            isMulti = this.isMulti,
            bbox = this.bbox; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy,
            bbox: bbox
          };

          this.__renderOnePolygon(renderMode, ctx, isMulti, list, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o);
            }
          }

          for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
            var stroke = strokes[_i];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i],
                strokeDasharray: strokeDasharrays[_i],
                strokeDasharrayStr: strokeDasharrayStrs[_i],
                strokeLinecap: strokeLinecaps[_i],
                strokeLinejoin: strokeLinejoins[_i],
                strokeMiterlimit: strokeMiterlimits[_i],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o2);
            }
          }
        }
      }
    }, {
      key: "__renderOnePolygon",
      value: function __renderOnePolygon(renderMode, ctx, isMulti, list, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill && fill.k === 'conic';
        var isStrokeCE = stroke && stroke.k === 'conic'; // 椭圆是array

        var isFillRE = fill && fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth && strokeWidth > 0 && stroke && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth && strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth && strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke.v = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, true);
        }
      }
    }, {
      key: "__drawPolygon",
      value: function __drawPolygon(renderMode, ctx, isMulti, list, res, isFill, isStroke) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            fillRule = res.fillRule,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          this.__preSetCanvas(renderMode, ctx, res);

          ctx.beginPath();

          if (isMulti) {
            list.forEach(function (item) {
              return canvasPolygon$6(ctx, item, dx, dy);
            });
          } else {
            canvasPolygon$6(ctx, list, dx, dy);
          }

          if (isFill && fill && fill !== 'none') {
            ctx.fill(fillRule);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            ctx.stroke();
          }

          ctx.closePath();
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$6(item);
            });
          } else {
            d = svgPolygon$6(list);
          }

          var props = [['d', d]]; // 2个都没有常出现在多fill/stroke时，也有可能特殊单个故意这样写的

          if ((!fill || fill === 'none') && (!stroke || stroke === 'none')) {
            return;
          }

          if (isFill && fill && fill !== 'none') {
            props.push(['fill', fill.v || fill]);

            if (fillRule && fillRule !== 'nonzero') {
              props.push(['fill-rule', fillRule]);
            }
          } else {
            props.push(['fill', 'none']);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            props.push(['stroke', stroke.v || stroke]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          } else {
            props.push(['stroke-width', 0]);
          }

          this.addGeom('path', props);
        }
      }
    }, {
      key: "__inversePtList",
      value: function __inversePtList(list, isMulti, t) {
        if (isMulti) {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            return item.map(function (item) {
              if (!item || !item.length) {
                return null;
              }

              var arr = [];

              for (var i = 0, len = item.length; i < len; i += 2) {
                var p = mx.calPoint([item[i], item[i + 1]], t);
                arr.push(p[0]);
                arr.push(p[1]);
              }

              return arr;
            });
          });
        } else {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            var arr = [];

            for (var i = 0, len = item.length; i < len; i += 2) {
              var p = mx.calPoint([item[i], item[i + 1]], t);
              arr.push(p[0]);
              arr.push(p[1]);
            }

            return arr;
          });
        }
      }
    }, {
      key: "__radialEllipse",
      value: function __radialEllipse(renderMode, ctx, list, isMulti, res, method) {
        var strokeWidth = res.strokeWidth,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        var _res$method$v = _slicedToArray(res[method].v, 4),
            color = _res$method$v[0],
            matrix = _res$method$v[1],
            cx = _res$method$v[2],
            cy = _res$method$v[3]; // 椭圆渐变的转换，顶点逆矩阵变换


        var tfo = [cx, cy];
        matrix = transform$1.calMatrixByOrigin(matrix, tfo);
        var t = mx.inverse(matrix);
        list = this.__inversePtList(list, isMulti, t); // 用正向matrix渲染

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          if (matrix) {
            ctx.save();
            var me = this.matrixEvent;
            matrix = mx.multiply(me, matrix);
            ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
          }

          ctx.beginPath();

          if (ctx[method + 'Style'] !== color) {
            ctx[method + 'Style'] = color;
          }

          if (isMulti) {
            list.forEach(function (item) {
              return painter.canvasPolygon(ctx, item, dx, dy);
            });
          } else {
            canvasPolygon$6(ctx, list, dx, dy);
          }

          ctx[method]();
          ctx.closePath();

          if (matrix) {
            ctx.restore();
          }
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$6(item);
            });
          } else {
            d = svgPolygon$6(list);
          }

          var props = [['d', d]];

          if (method === 'fill') {
            props.push(['fill', color]);
            props.push(['strokeWidth', 0]);
          } else if (method === 'stroke') {
            props.push(['fill', 'none']);
            props.push(['stroke', color]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          }

          props.push(['transform', "matrix(".concat(joinArr$3(mx.m2m6(matrix), ','), ")")]);
          this.addGeom('path', props);
        }
      }
    }, {
      key: "__conicGradient",
      value: function __conicGradient(renderMode, ctx, list, isMulti, res) {
        var _this4 = this;

        var fill = res.fill,
            bbox = res.bbox,
            _res$dx = res.dx,
            dx = _res$dx === void 0 ? 0 : _res$dx,
            _res$dy = res.dy,
            dy = _res$dy === void 0 ? 0 : _res$dy;
        var color = fill.v;

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          var _bbox = _slicedToArray(bbox, 4),
              x1 = _bbox[0],
              y1 = _bbox[1],
              x2 = _bbox[2],
              y2 = _bbox[3];

          var w = x2 - x1,
              h = y2 - y1;
          var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
          var imgData = offscreen.ctx.getImageData(0, 0, w, h);
          gradient.getConicGradientImage(w * 0.5, h * 0.5, w, h, fill.v.stop, imgData.data);
          offscreen.ctx.putImageData(imgData, 0, 0);

          if (isMulti) {
            list.forEach(function (item) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$6(ctx, item, dx, dy);
              ctx.clip();
              ctx.closePath();
              ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
              ctx.restore();
            });
          } else {
            ctx.save();
            ctx.beginPath();
            canvasPolygon$6(ctx, list, dx, dy);
            ctx.clip();
            ctx.closePath();
            ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
            ctx.restore();
          }

          offscreen.ctx.clearRect(0, 0, w, h);
        } else if (renderMode === mode.SVG) {
          if (isMulti) {
            list.forEach(function (item) {
              var v = {
                tagName: 'clipPath',
                children: [{
                  tagName: 'path',
                  props: [['d', svgPolygon$6(item)]]
                }]
              };
              var clip = ctx.add(v);

              _this4.__config[NODE_DEFS_CACHE$4].push(v);

              color.forEach(function (item) {
                _this4.virtualDom.bb.push({
                  type: 'item',
                  tagName: 'path',
                  props: [['d', svgPolygon$6(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
                });
              });
            });
          } else {
            var v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$6(list)]]
              }]
            };
            var clip = ctx.add(v);

            this.__config[NODE_DEFS_CACHE$4].push(v);

            color.forEach(function (item) {
              _this4.virtualDom.bb.push({
                type: 'item',
                tagName: 'path',
                props: [['d', svgPolygon$6(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
              });
            });
          }
        }
      }
    }, {
      key: "__propsStrokeStyle",
      value: function __propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (strokeDasharrayStr) {
          props.push(['stroke-dasharray', strokeDasharrayStr]);
        }

        if (strokeLinecap && strokeLinecap !== 'butt') {
          props.push(['stroke-linecap', strokeLinecap]);
        }

        if (strokeLinejoin && strokeLinejoin !== 'miter') {
          props.push(['stroke-linejoin', strokeLinejoin]);
        }

        if (strokeMiterlimit && strokeMiterlimit !== 4) {
          props.push(['stroke-miterlimit', strokeMiterlimit]);
        }
      } // geom的cache无内容也不清除，因为子类不清楚内容，除非看不见

    }, {
      key: "__releaseWhenEmpty",
      value: function __releaseWhenEmpty(cache, computedStyle) {
        return computedStyle[VISIBILITY$4] === 'hidden';
      } // offset/resize时要多一步清空props上记录的缓存

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeX", this).call(this, diff, lv);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeY", this).call(this, diff, lv);

        this.__config[NODE_CACHE_PROPS] = this.__cacheProps = {};
      }
    }, {
      key: "addGeom",
      value: function addGeom(tagName, props) {
        props = util.hash2arr(props);
        this.virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      }
    }, {
      key: "getProps",
      value: function getProps(k) {
        var v = this.currentProps[k];

        if (!isNil$8(v)) {
          return v;
        }

        return this['__' + k];
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      }
    }, {
      key: "isMulti",
      get: function get() {
        return this.__isMulti;
      }
    }, {
      key: "currentProps",
      get: function get() {
        return this.__currentProps;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER$1;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (!name || !util.isString(name) || name.charAt(0) !== '$') {
          throw new Error('Invalid param');
        }

        if (!REGISTER$1.hasOwnProperty(name)) {
          throw new Error("Geom has not register: ".concat(name));
        }

        return REGISTER$1[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || name.charAt(0) !== '$' || !obj.prototype || !(obj.prototype instanceof Geom)) {
          throw new Error('Invalid param');
        }

        if (Geom.hasRegister(name)) {
          throw new Error("Geom has already register: ".concat(name));
        }

        REGISTER$1[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER$1.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Geom.hasRegister(name)) {
          delete REGISTER$1[name];
        }
      }
    }]);

    return Geom;
  }(Xom$1);

  var _enums$NODE_KEY$7 = enums.NODE_KEY,
      NODE_STYLE$4 = _enums$NODE_KEY$7.NODE_STYLE,
      NODE_CURRENT_STYLE$4 = _enums$NODE_KEY$7.NODE_CURRENT_STYLE,
      NODE_COMPUTED_STYLE$2 = _enums$NODE_KEY$7.NODE_COMPUTED_STYLE,
      NODE_DOM_PARENT$4 = _enums$NODE_KEY$7.NODE_DOM_PARENT,
      NODE_MATRIX$2 = _enums$NODE_KEY$7.NODE_MATRIX,
      NODE_MATRIX_EVENT$3 = _enums$NODE_KEY$7.NODE_MATRIX_EVENT,
      NODE_STRUCT$3 = _enums$NODE_KEY$7.NODE_STRUCT;
  var TYPE_VD$3 = $$type.TYPE_VD,
      TYPE_GM$3 = $$type.TYPE_GM,
      TYPE_CP$3 = $$type.TYPE_CP;
  var updateList = [];
  var removeList = [];
  var KEY_FLAG = {};
  /**
   * setState后刷新前先根遍历检查组件开始进行shouldComponentUpdate判断
   */

  function check(vd) {
    if (vd instanceof Dom$1) {
      vd.children.forEach(function (child) {
        if (child instanceof Dom$1) {
          check(child);
        } // 当组件有setState更新时，从叶子到根链路会标识__hasCpUpdate，以便节约遍历成本忽略那些没变化的链路
        else if (child instanceof Component$1 && child.__hasCpUpdate) {
          child.__hasCpUpdate = false;
          checkCp(child, child.props);
        }
      });
    } // 高阶组件会进入此分支，被父组件调用
    else if (vd instanceof Component$1 && vd.__hasCpUpdate) {
      vd.__hasCpUpdate = false;
      checkCp(vd, vd.props);
    }
  }
  /**
   * 检查cp是否有state变更，注意递归检查时需要看shadow不能看shadowRoot，
   * 否则高阶组件会被跳过，其更新无法触发update生命周期
   * @param cp
   * @param nextProps
   * @param forceCheckUpdate，被render()后的json的二级组件，发现props有变更强制检查更新，否则可以跳过
   */


  function checkCp(cp, nextProps, forceCheckUpdate) {
    if (cp.__nextState || forceCheckUpdate) {
      var shouldUpdate;

      if (util.isFunction(cp.shouldComponentUpdate)) {
        shouldUpdate = cp.shouldComponentUpdate(nextProps, cp.__nextState || cp.state);
      } else {
        // 没有默认更新
        shouldUpdate = true;
      }

      if (shouldUpdate) {
        updateCp(cp, nextProps, cp.__nextState || cp.state);
      } // 不更新则递归检查子tree的cp
      else {
        cp.props = nextProps;
        cp.state = cp.__nextState || cp.state;
        check(cp.shadow);
      }
    } else {
      check(cp.shadow);
    }
  }
  /**
   * 更新组件的props和state，清空__nextState
   * @param cp
   * @param props
   * @param state
   */


  function updateCp(cp, props, state) {
    cp.props = props;
    cp.state = state;
    cp.__nextState = null; // 同步在refresh前清除component的新state标识，这样frame动画在after回调中可以新设

    var oldS = cp.shadow;
    var oldSr = cp.shadowRoot;
    var oldJson = cp.__cd;
    var json = flattenJson(cp.render()); // 对比新老render()返回的内容，更新后重新生成sr

    diffSr(oldS, oldJson, json);

    cp.__init(json); // 为了局部dom布局需要知道老的css信息


    var sr = cp.shadowRoot;

    if (sr instanceof Xom$1) {
      ['__outerWidth', '__outerHeight', '__sx', '__sy', '__sx2', '__sx3', '__sx4', '__sx5', '__sx6', '__sy2', '__sy3', '__sy4', '__sy5', '__sy6'].forEach(function (k) {
        sr[k] = oldSr[k];
      });
      sr.__computedStyle = sr.__config[NODE_COMPUTED_STYLE$2] = oldSr.computedStyle;
    } else {
      var domParent = cp.domParent;
      [NODE_STYLE$4, NODE_CURRENT_STYLE$4, NODE_COMPUTED_STYLE$2, NODE_MATRIX$2, NODE_MATRIX_EVENT$3].forEach(function (k) {
        sr.__config[k] = domParent.__config[k];
      });
    }

    ['__x', '__y', '__width', '__height', '__sx1', // text和xom
    '__sy1', '__layoutData', '__parent', '__domParent'].forEach(function (k) {
      sr[k] = oldSr[k];
    });
    sr.__config[NODE_DOM_PARENT$4] = oldSr.domParent;
    sr.__config[NODE_STRUCT$3] = oldSr.__config[NODE_STRUCT$3];
    updateList.push(cp); // 老的需回收，diff会生成新的dom，唯一列外是cp直接返回一个没变化的cp

    if (!util.isObject(json) || !json.__placeholder) {
      removeList.push(oldS);
    } // 子组件使用老的json时标识，更新后删除，render()返回空会没json对象


    if (json && json.__placeholder) {
      delete json.__placeholder;
    }

    if (json && json.__inheritAnimate) {
      delete json.__inheritAnimate;
    }

    if (json && json.__animateRecords) {
      delete json.__animateRecords;
    } // 高阶组件时需判断，子组件更新后生成新的sr，父组件的sr/host需要同时更新引用


    var host = cp.host;

    while (host) {
      if (host.shadow === cp) {
        host.__shadowRoot = sr;
        sr.__hostRoot = host;
        cp = host;
        host = host.host;
      } else {
        break;
      }
    }
  }
  /**
   * 非一级组件sr进行对比，key相同的无需重新生成且继承动画
   * @param vd
   * @param oj oldJson
   * @param nj
   */


  function diffSr(vd, oj, nj) {
    // 先遍历检查key相同的，将没有变化的key暂存下来，深度优先，这样叶子节点出现在前面，当key的叶子也有key时，确保叶子先对比
    var ojk = getKeyHash(oj, {}, vd);
    var njk = getKeyHash(nj, {});
    var keyList = [];
    var cpList = []; // 先对比key对应的节点，如果新老有一方对不上则落空

    Object.keys(ojk).forEach(function (k) {
      var o = ojk[k];
      var n = njk[k];

      if (!n) {
        o.json.key = KEY_FLAG;
      }
    });
    Object.keys(njk).forEach(function (k) {
      var o = ojk[k];
      var n = njk[k]; // 有可能老的没有这个key，新key落空

      if (!o) {
        n.json.key = KEY_FLAG;
        return;
      }

      var oj = o.json;
      var nj = n.json;
      var vd = o.vd; // 相同class的组件进行对比替换

      if (oj.$$type === TYPE_CP$3 && nj.$$type === TYPE_CP$3) {
        if (oj.klass === nj.klass) {
          // 对比props和children看是否全等，是则直接替换新json类型为占位符，引用老vd，否则强制更新
          diffCp(oj, nj, vd); // 标识对比过了

          oj.key = nj.key = KEY_FLAG; // 老的sr里需删除这个vd，因为老sr会回收

          cpList.push(vd);
        }
      } // 相同类型的vd进行对比继承动画
      else if (oj.$$type === nj.$$type && oj.tagName === nj.tagName) {
        // 需判断矢量标签mutil是否相等
        if (nj.$$type !== TYPE_GM$3 || oj.props.multi === nj.props.multi) {
          nj.__inheritAnimate = vd;
        }

        oj.key = nj.key = KEY_FLAG; // key相同的dom暂存下来

        if (nj.$$type === TYPE_VD$3) {
          keyList.push({
            vd: vd,
            oj: oj,
            nj: nj
          });
        }
      }
    }); // key相同的dom对比children，下面非key逻辑就不做了

    keyList.forEach(function (item) {
      diffChildren(item.vd, item.oj, item.nj);
    }); // 整体tree进行对比

    diffChild(vd, oj, nj); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收，这里处理key的

    cpList.forEach(function (vd) {
      removeCpFromOldTree(vd);
    });
  }
  /**
   * 递归检查dom的children，相同的无需重新生成，用PL类型占位符代替直接返回老vd
   * @param vd
   * @param oj
   * @param nj
   */


  function diffChild(vd, oj, nj) {
    if (util.isObject(nj)) {
      if (nj.$$type === TYPE_CP$3) {
        // key对比过了忽略
        if (nj.key === KEY_FLAG) {
          return;
        } // 相同class的组件处理


        if (oj && oj.$$type === nj.$$type && oj.klass === nj.klass) {
          diffCp(oj, nj, vd); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收

          removeCpFromOldTree(vd);
        }
      } else if (nj.$$type === TYPE_GM$3 && oj && oj.$$type === TYPE_GM$3) {
        // $geom的multi必须一致
        if (oj.tagName === nj.tagName && oj.props.multi === nj.props.multi) {
          nj.__inheritAnimate = vd;
        }
      } // dom类型递归children
      else if (nj.$$type === TYPE_VD$3 && oj && oj.$$type === TYPE_VD$3) {
        if (oj.tagName === nj.tagName) {
          nj.__inheritAnimate = vd;
        }

        diffChildren(vd, oj, nj);
      }
    }
  }
  /**
   * dom类型的vd对比children
   * @param vd
   * @param oj
   * @param nj
   */


  function diffChildren(vd, oj, nj) {
    var oc = oj.children;
    var nc = nj.children;
    var ol = oc.length;
    var nl = nc.length;
    var children = vd.children;

    for (var i = 0, of = 0, nf = 0, len = Math.min(ol, nl); i < len; i++) {
      var o = oc[i + of];
      var n = nc[i + nf]; // 新老都是key直接跳过

      if (o.key === KEY_FLAG && n.key === KEY_FLAG) ; // 其中一个是key对比过了调整索引和长度
      else if (o.key === KEY_FLAG) {
        of++;
        i--;
        ol--;
        len = Math.min(ol, nl);
      } else if (n.key === KEY_FLAG) {
        nf++;
        i--;
        nl--;
        len = Math.min(ol, nl);
      } else {
        diffChild(children[i + of], o, n);
      }
    } // 长度不同增减的无需关注，新json创建cp有didMount，老vd会调用cp的destroy

  }
  /**
   * 根据json对比看cp如何更新，被render()后的json的二级组件对比才会出现
   * @param oj
   * @param nj
   * @param vd
   */


  function diffCp(oj, nj, vd) {
    // props全等，直接替换新json类型为占位符，引用老vd内容，无需重新创建，暂时存在json的placeholder上
    // 否则需要强制触发组件更新，包含setState内容
    nj.__placeholder = vd;
    var sr = vd.shadowRoot; // 对比需忽略on开头的事件，直接改老的引用到新的上，这样只变了on的话无需更新

    var exist = {};
    Object.keys(oj.props).forEach(function (k) {
      var v = oj.props[k];
      exist[k] = v;
    });
    Object.keys(nj.props).forEach(function (k) {
      var v = nj.props[k];

      if (/^on[a-zA-Z]/.test(k)) {
        oj.props[k] = v;
        var ex = exist[k];

        if (ex) {
          delete exist[k];

          if (ex !== v) {
            k = k.slice(2).toLowerCase();
            sr.listener[k] = v;
          }
        } else {
          k = k.slice(2).toLowerCase();
          sr.listener[k] = v;
        }
      } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
        oj.props[k] = v;
        var _ex = exist[k];

        if (_ex) {
          delete exist[k];

          if (_ex !== v) {
            k = k.slice(2).toLowerCase();
            vd.off(k, exist[k]);
            vd.on(k, v);
          }

          delete exist[k];
        } else {
          k = k.slice(2).toLowerCase();
          vd.on(k, v);
        }
      }
    }); // 新的少的事件取消

    Object.keys(exist).forEach(function (k) {
      var v = exist[k];

      if (/^on[a-zA-Z]/.test(k)) {
        nj.props[k] = v;
        k = k.slice(2).toLowerCase();
        delete sr.listener[k];
      } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
        nj.props[k] = v;
        k = k.slice(2).toLowerCase();
        vd.off(k, v);
      }
    });
    checkCp(vd, nj.props, !util.equal(oj.props, nj.props));
  }
  /**
   * 深度优先遍历json，将有key的记录在hash中，如果传入根vd，同步递归保存对应位置的vd
   * @param json
   * @param hash
   * @param vd
   * @returns {*}
   */


  function getKeyHash(json, hash, vd) {
    if (Array.isArray(json)) {
      json.forEach(function (item, i) {
        return getKeyHash(item, hash, vd && vd[i]);
      });
    } else if (util.isObject(json)) {
      if (json.$$type === TYPE_VD$3 || json.$$type === TYPE_GM$3 || json.$$type === TYPE_CP$3) {
        // 深度优先
        if (json.$$type === TYPE_VD$3) {
          getKeyHash(json.children, hash, vd && vd.children);
        }

        var key = json.props.key;

        if (!util.isNil(key) && key !== '') {
          // 重复key错误警告
          if (hash.hasOwnProperty(key)) {
            inject.warn('Component ' + vd.tagName + ' has duplicate key: ' + key);
          }

          hash[key] = {
            json: json,
            vd: vd
          };
        }
      }
    }

    return hash;
  }
  /**
   * 非一级组件diff发生更新时，其需要从sr的tree中移除，因为sr会销毁
   */


  function removeCpFromOldTree(vd) {
    // root下的一级组件不会发生回收情况，忽略
    if (!vd.host) {
      return;
    }

    var parent = vd.parent;

    if (parent) {
      var i = parent.children.indexOf(vd);

      if (i > -1) {
        parent.children[i] = null;
      } else {
        throw new Error('Can not find child: ' + vd.tagName);
      }
    }
  }
  /**
   * 执行componentDidUpdate/destroy
   */


  function did() {
    updateList.forEach(function (item) {
      if (util.isFunction(item.componentDidUpdate)) {
        item.componentDidUpdate();
      }
    });
    updateList.splice(0);
    removeList.forEach(function (item) {
      item.__destroy();
    });
    removeList = [];
  }

  var updater = {
    updateList: updateList,
    check: check,
    did: did
  };

  var joinVd$1 = util.joinVd,
      joinDef$1 = util.joinDef;
  var contain$1 = o$3.contain,
      NONE$1 = o$3.NONE,
      TRANSFORM_ALL = o$3.TRANSFORM_ALL,
      OPACITY$4 = o$3.OPACITY,
      FILTER$5 = o$3.FILTER,
      MIX_BLEND_MODE$2 = o$3.MIX_BLEND_MODE;

  function diff$1(elem, ovd, nvd) {
    var cns = elem.childNodes;
    diffDefs(cns[0], ovd.defs, nvd.defs); // <REPAINT不会有lv属性，无需对比

    if (!nvd.hasOwnProperty('lv')) {
      diffBb(cns[1], ovd.bb, nvd.bb);
    }

    diffD2D(elem, ovd, nvd, true);
  }

  function diffDefs(elem, od, nd) {
    var ol = od.length;
    var nl = nd.length;
    var i = 0;
    var cns = elem.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffDef(cns[i], od[i], nd[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinDef$1(nd[i]));
      }
    }
  }

  function diffDef(elem, od, nd) {
    if (od.tagName !== nd.tagName) {
      insertAdjacentHTML(elem, 'beforebegin', joinDef$1(nd)); // elem.insertAdjacentHTML('beforebegin', joinDef(nd));

      elem.parentNode.removeChild(elem);
    } else {
      if (od.uuid !== nd.uuid) {
        elem.setAttribute('id', nd.uuid);
      }

      var op = {};

      for (var _i = 0, len = (od.props || []).length; _i < len; _i++) {
        var prop = od.props[_i];

        var _prop = _slicedToArray(prop, 2),
            k = _prop[0],
            v = _prop[1];

        op[k] = v;
      }

      for (var _i2 = 0, _len = (nd.props || []).length; _i2 < _len; _i2++) {
        var _prop2 = nd.props[_i2];

        var _prop3 = _slicedToArray(_prop2, 2),
            _k = _prop3[0],
            _v = _prop3[1]; // 已有不等更新，没有添加


        if (op.hasOwnProperty(_k)) {
          if (op[_k] !== _v) {
            elem.setAttribute(_k, _v);
          }

          delete op[_k];
        } else {
          elem.setAttribute(_k, _v);
        }
      } // 多余的删除


      Object.keys(op).forEach(function (i) {
        elem.removeAttribute(i);
      });
      var cns = elem.childNodes;
      var ol = od.children.length;
      var nl = nd.children.length;
      var i = 0;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(elem, i, od.children[i], nd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(elem, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(elem, cns, i, joinVd$1(nd.children[i]));
        }
      }
    }
  }

  function diffChild$1(elem, ovd, nvd) {
    if (ovd.type === 'dom') {
      if (nvd.type === 'dom') {
        diffD2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffD2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'text') {
      if (nvd.type === 'text') {
        diffT2T(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'geom') {
      if (nvd.type === 'dom') {
        diffG2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffG2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'img') {
      if (nvd.type === 'img') {
        diffItemSelf(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } // 特殊情况，当有连续2个img，后面1个发生error时，其children内容不是type为img的图片，而是矢量图item，会进入此分支
    else if (ovd.type === 'item' && nvd.type === 'item') {
      diffItemSelf(elem, ovd, nvd);
    }
  }

  function diffX2X(elem, ovd, nvd) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        visibility = nvd.visibility,
        mask = nvd.mask,
        overflow = nvd.overflow,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode,
        conClip = nvd.conClip;

    if (ovd.transform !== transform) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (ovd.opacity !== opacity) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (ovd.visibility !== visibility) {
      elem.setAttribute('visibility', visibility);
    }

    if (ovd.mask !== mask) {
      if (mask) {
        elem.setAttribute('mask', mask);
      } else {
        elem.removeAttribute('mask');
      }
    }

    if (ovd.filter !== filter || ovd.mixBlendMode !== mixBlendMode) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('filter');
      }
    } // if(ovd.filter !== filter) {
    //   if(filter) {
    //     elem.setAttribute('filter', filter);
    //   }
    //   else {
    //     elem.removeAttribute('filter');
    //   }
    // }


    if (ovd.overflow !== overflow) {
      if (overflow) {
        elem.setAttribute('clipPath', overflow);
      } else {
        elem.removeAttribute('overflow');
      }
    }

    if (ovd.conClip !== conClip) {
      if (conClip) {
        elem.childNodes[1].setAttribute('clip-path', conClip);
      } else {
        elem.childNodes[1].removeAttribute('clip-path');
      }
    }
  }

  function diffByLessLv(elem, ovd, nvd, lv) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        mask = nvd.mask,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode;

    if (mask) {
      elem.setAttribute('mask', mask);
    } else {
      elem.removeAttribute('mask');
    }

    if (lv === NONE$1) {
      return;
    }

    if (contain$1(lv, TRANSFORM_ALL)) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (contain$1(lv, OPACITY$4)) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (contain$1(lv, FILTER$5) || contain$1(lv, MIX_BLEND_MODE$2)) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('style');
      }
    }
  }

  function diffD2D(elem, ovd, nvd, root) {
    // cache表明children无变化缓存，一定是REPAINT以下的，只需看自身的lv以及mask
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);

      if (!root) {
        diffBb(elem.firstChild, ovd.bb, nvd.bb);
      }
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffChild$1(cns[i], ovd.children[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd$1(nvd.children[i]));
      }
    }
  }

  function diffD2G(elem, ovd, nvd) {
    diffX2X(elem, ovd, nvd);
    diffBb(elem.firstChild, ovd.bb, nvd.bb);
    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      replaceWith(cns[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd$1(nvd.children[i]));
      }
    }
  }

  function diffT2T(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, ovd.children[i], nvd.children[i], true);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd$1(nvd.children[i]));
      }
    }
  }

  function diffG2D(elem, ovd, nvd) {
    diffD2G(elem, ovd, nvd);
  }

  function diffG2G(elem, ovd, nvd) {
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);
      diffBb(elem.firstChild, ovd.bb, nvd.bb);
      var ol = ovd.children.length;
      var nl = nvd.children.length;
      var i = 0;
      var lastChild = elem.lastChild;
      var cns = lastChild.childNodes;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(lastChild, i, ovd.children[i], nvd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(lastChild, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(lastChild, cns, i, joinVd$1(nvd.children[i]));
        }
      }
    }
  }

  function diffBb(elem, obb, nbb) {
    var ol = obb.length;
    var nl = nbb.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, obb[i], nbb[i]);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd$1(nbb[i]));
      }
    }
  }

  function diffItem(elem, i, ovd, nvd, isText) {
    var cns = elem.childNodes;

    if (ovd.tagName !== nvd.tagName) {
      replaceWith(cns[i], nvd);
    } else {
      diffItemSelf(cns[i], ovd, nvd);

      if (isText && ovd.content !== nvd.content) {
        cns[i].innerHTML = nvd.content;
      }
    }
  }

  function diffItemSelf(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var op = {};

    for (var i = 0, len = (ovd.props || []).length; i < len; i++) {
      var prop = ovd.props[i];

      var _prop4 = _slicedToArray(prop, 2),
          k = _prop4[0],
          v = _prop4[1];

      op[k] = v;
    }

    for (var _i3 = 0, _len2 = (nvd.props || []).length; _i3 < _len2; _i3++) {
      var _prop5 = nvd.props[_i3];

      var _prop6 = _slicedToArray(_prop5, 2),
          _k2 = _prop6[0],
          _v2 = _prop6[1]; // 已有不等更新，没有添加


      if (op.hasOwnProperty(_k2)) {
        if (op[_k2] !== _v2) {
          elem.setAttribute(_k2, _v2);
        }

        delete op[_k2];
      } else {
        elem.setAttribute(_k2, _v2);
      }
    } // 多余的删除


    Object.keys(op).forEach(function (i) {
      elem.removeAttribute(i);
    });
  }

  function replaceWith(elem, vd) {
    var res;

    if (Array.isArray(vd)) {
      res = '';
      vd.forEach(function (item) {
        res += joinVd$1(item);
      });
    } else {
      res = joinVd$1(vd);
    }

    insertAdjacentHTML(elem, 'beforebegin', res); // elem.insertAdjacentHTML('beforebegin', res);

    elem.parentNode.removeChild(elem);
  }

  function insertAt(elem, cns, index, html) {
    if (index >= cns.length) {
      insertAdjacentHTML(elem, 'beforeend', html); // elem.insertAdjacentHTML('beforeend', html);
    } else {
      insertAdjacentHTML(cns[index], 'beforebegin', html); // cns[index].insertAdjacentHTML('beforebegin', html);
    }
  }

  function removeAt(elem, cns, index) {
    if (cns[index]) {
      elem.removeChild(cns[index]);
    }
  }

  var svg;

  function insertAdjacentHTML(elem, where, content) {
    if (elem.insertAdjacentHTML) {
      elem.insertAdjacentHTML(where, content);
    } else {
      switch (where) {
        case 'beforeend':
          elem.innerHTML += content;
          break;

        case 'beforebegin':
          svg = svg || document.createElement('svg');
          svg.innerHTML = content;
          elem.parentNode.insertBefore(svg.childNodes[0], elem);
          break;
      }
    }
  }

  var isFunction$8 = util.isFunction;

  var Controller = /*#__PURE__*/function () {
    function Controller() {
      _classCallCheck(this, Controller);

      this.__records = []; // 默认记录和自动记录

      this.__records2 = []; // 非自动播放的动画记录

      this.__list = []; // 默认初始化播放列表，自动播放也存这里

      this.__list2 = []; // json中autoPlay为false的初始化存入这里

      this.__onList = []; // list中已存在的侦听事件，list2初始化时也需要增加上

      this.__lastTime = {}; // 每个类型的上次触发时间，防止重复emit
    }

    _createClass(Controller, [{
      key: "add",
      value: function add(v) {
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

        if (list.indexOf(v) === -1) {
          list.push(v);
        }
      }
    }, {
      key: "remove",
      value: function remove(v) {
        var i = this.list.indexOf(v);

        if (i > -1) {
          this.list.splice(i, 1);
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__records = [];
        this.__records2 = [];
        this.__list = [];
        this.__list2 = [];
      }
    }, {
      key: "__action",
      value: function __action(k, args) {
        this.list.forEach(function (item) {
          item[k].apply(item, args);
        });
      }
    }, {
      key: "init",
      value: function init() {
        var _this = this;

        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__records;
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

        // 检查尚未初始化的record，并初始化，后面才能调用各种控制方法
        if (records.length) {
          // 清除防止重复调用，并且新的json还会进入整体逻辑
          records.splice(0).forEach(function (item) {
            var target = item.target,
                animate = item.animate;

            if (target.isDestroyed) {
              return;
            }

            if (Array.isArray(animate)) {
              animate.forEach(function (animate) {
                var value = animate.value,
                    options = animate.options;
                options.autoPlay = false;
                var o = target.animate(value, options);

                _this.add(o, list);
              });
            } else {
              var value = animate.value,
                  options = animate.options;
              options.autoPlay = false;
              var o = target.animate(value, options);

              _this.add(o, list);
            }
          });
        } // 非自动播放后初始化需检测事件，给非自动播放添加上，并清空本次


        if (records === this.__records2) {
          var onList = this.__onList;
          var list2 = this.list2;

          if (list2.length && onList.length) {
            list2.forEach(function (item) {
              onList.forEach(function (arr) {
                item.off(arr[0], arr[1]);
                item.on(arr[0], arr[1]);
              });
            });
          }
        }
      }
    }, {
      key: "__playAuto",
      value: function __playAuto() {
        this.init();

        this.__action('play');
      }
    }, {
      key: "play",
      value: function play(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('play', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "pause",
      value: function pause() {
        this.__action('pause');
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var once = true;

        this.__action('resume', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "__mergeAuto",
      value: function __mergeAuto() {
        this.init();
        this.init(this.__records2);

        if (this.__list2.length) {
          this.__list = this.__list.concat(this.__list2);
          this.__list2 = [];
        }
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('cancel', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('finish', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$8(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndStop', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$8(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndPlay', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$8(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$8(handle)) {
          return;
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.__on(id[i], handle);
          }

          this.__onList.push([id, handle]);
        } else {
          this.__on(id, handle);

          this.__onList.push([id, handle]);
        }
      }
    }, {
      key: "__on",
      value: function __on(id, handle) {
        var _this2 = this;

        this.list.forEach(function (item) {
          var cb = function cb() {
            var time = item.timestamp;

            if (time !== _this2.__lastTime[id]) {
              _this2.__lastTime[id] = time;
              handle();
            }
          };

          cb.__karasEventCb = handle;
          item.on(id, cb);
        });
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.off(id[i], handle);
          }
        } else {
          this.list.forEach(function (item) {
            item.off(id, handle);
          });
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "list2",
      get: function get() {
        return this.__list2;
      }
    }, {
      key: "__set",
      value: function __set(key, value) {
        this.list.forEach(function (item) {
          item[key] = value;
        });
      }
    }, {
      key: "playbackRate",
      set: function set(v) {
        this.__set('playbackRate', v);
      }
    }, {
      key: "iterations",
      set: function set(v) {
        this.__set('iterations', v);
      }
    }, {
      key: "playCount",
      set: function set(v) {
        this.__set('playCount', v);
      }
    }, {
      key: "fps",
      set: function set(v) {
        this.__set('fps', v);
      }
    }, {
      key: "currentTime",
      set: function set(v) {
        this.__set('currentTime', v);
      }
    }, {
      key: "spfLimit",
      set: function set(v) {
        this.__set('spfLimit', v);
      }
    }, {
      key: "delay",
      set: function set(v) {
        this.__set('delay', v);
      }
    }, {
      key: "endDelay",
      set: function set(v) {
        this.__set('endDelay', v);
      }
    }, {
      key: "fill",
      set: function set(v) {
        this.__set('fill', v);
      }
    }, {
      key: "direction",
      set: function set(v) {
        this.__set('direction', v);
      }
    }]);

    return Controller;
  }();

  var canvasPolygon$7 = painter.canvasPolygon; // 无cache时应用离屏时的优先级，从小到大，OFFSCREEN_MASK2是个特殊的

  var OFFSCREEN_OVERFLOW = 0;
  var OFFSCREEN_FILTER = 1;
  var OFFSCREEN_MASK = 2;
  var OFFSCREEN_BLEND = 3;
  var OFFSCREEN_MASK2 = 4;

  function applyOffscreen(ctx, list, width, height) {
    list.sort(function (a, b) {
      if (a[1] === b[1]) {
        if (a[0] === b[0]) {
          return a[2] - b[2];
        }

        return b[0] - a[0];
      }

      return b[1] - a[1];
    });
    list.forEach(function (item) {
      var _item = _slicedToArray(item, 4),
          type = _item[2],
          offscreen = _item[3];

      if (type === OFFSCREEN_OVERFLOW) {
        var matrix = offscreen.matrix,
            target = offscreen.target,
            origin = offscreen.ctx,
            x = offscreen.x,
            y = offscreen.y,
            offsetWidth = offscreen.offsetWidth,
            offsetHeight = offscreen.offsetHeight,
            _list = offscreen.list;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.globalAlpha = 1;
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        ctx.fillStyle = '#FFF';
        ctx.beginPath();

        if (_list) {
          canvasPolygon$7(ctx, _list);
        } else {
          ctx.rect(x, y, offsetWidth, offsetHeight);
        }

        ctx.fill();
        ctx.closePath();
        ctx.globalCompositeOperation = 'source-over';
        target.draw();
        ctx = origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        ctx.draw && ctx.draw(true);
        target.ctx.setTransform(1, 0, 0, 1, 0, 0);
        target.ctx.clearRect(0, 0, width, height);
        target.draw();
        inject.releaseCacheCanvas(target.canvas);
      } else if (type === OFFSCREEN_FILTER) {
        var _target = offscreen.target,
            _origin = offscreen.ctx,
            filter = offscreen.filter; // 申请一个新的离屏，应用blur并绘制，如没有则降级，默认ctx.filter为'none'

        if (ctx.filter) {
          var apply = inject.getCacheCanvas(width, height, null, 'filter2');
          apply.ctx.filter = painter.canvasFilter(filter);

          if (width && height) {
            apply.ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          apply.ctx.filter = 'none';
          apply.draw();
          _target.ctx.globalAlpha = 1;

          _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target.ctx.clearRect(0, 0, width, height);

          if (width && height) {
            _target.ctx.drawImage(apply.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          _target.draw();

          apply.ctx.setTransform(1, 0, 0, 1, 0, 0);
          apply.ctx.clearRect(0, 0, width, height);
          apply.draw();
          inject.releaseCacheCanvas(apply.canvas);
        } // 绘制回主画布，如果不支持则等同无filter原样绘制


        ctx = _origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        ctx.draw && ctx.draw(true);

        _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target.ctx.globalAlpha = 1;

        _target.ctx.clearRect(0, 0, width, height);

        _target.draw();

        inject.releaseCacheCanvas(_target.canvas);
      } else if (type === OFFSCREEN_MASK) {
        var mask = offscreen.mask,
            isClip = offscreen.isClip;

        if (isClip) {
          offscreen.target.draw();
          ctx = mask.ctx;
          ctx.globalCompositeOperation = 'source-out';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(offscreen.target.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          mask.draw();
          ctx.globalCompositeOperation = 'source-over';
          offscreen.target.ctx.setTransform(1, 0, 0, 1, 0, 0);
          offscreen.target.ctx.clearRect(0, 0, width, height);
          offscreen.target.draw();
          inject.releaseCacheCanvas(offscreen.target.canvas);
          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.draw && ctx.draw(true);
          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          mask.draw();
          inject.releaseCacheCanvas(mask.canvas);
        } else {
          mask.draw();
          var _target2 = offscreen.target;
          ctx = _target2.ctx;
          ctx.globalCompositeOperation = 'destination-in';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.globalCompositeOperation = 'source-over';

          _target2.draw();

          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          mask.draw();
          inject.releaseCacheCanvas(mask.canvas);
          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(_target2.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.draw && ctx.draw(true);

          _target2.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target2.ctx.clearRect(0, 0, width, height);

          _target2.draw();

          inject.releaseCacheCanvas(_target2.canvas);
        }
      } else if (type === OFFSCREEN_BLEND) {
        var _target3 = offscreen.target;
        ctx = offscreen.ctx;
        ctx.globalCompositeOperation = offscreen.mixBlendMode;

        _target3.draw();

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target3.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.draw && ctx.draw(true);
        _target3.ctx.globalAlpha = 1;

        _target3.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target3.ctx.clearRect(0, 0, width, height);

        _target3.draw();

        inject.releaseCacheCanvas(_target3.canvas);
      } // 特殊的mask节点汇总结束，还原ctx
      else if (type === OFFSCREEN_MASK2) {
        ctx = offscreen.ctx;
      }
    });
    return ctx;
  }

  var offscreen = {
    OFFSCREEN_OVERFLOW: OFFSCREEN_OVERFLOW,
    OFFSCREEN_FILTER: OFFSCREEN_FILTER,
    OFFSCREEN_MASK: OFFSCREEN_MASK,
    OFFSCREEN_BLEND: OFFSCREEN_BLEND,
    OFFSCREEN_MASK2: OFFSCREEN_MASK2,
    applyOffscreen: applyOffscreen
  };

  var MockPage = /*#__PURE__*/_createClass(function MockPage(texture, width, height) {
    _classCallCheck(this, MockPage);

    this.uuid = Page.genUuid();
    this.time = inject.now();
    this.texture = texture;
    this.width = width;
    this.height = height;
  });

  /**
   * 一个fbo离屏纹理，mock成cache，当webgl需要局部根节点汇总时生成，即cacheTotal，
   * 基于此纹理进行filter、mask等后处理渲染
   */

  var MockCache = /*#__PURE__*/function () {
    function MockCache(gl, texture, sx1, sy1, width, height, bbox) {
      _classCallCheck(this, MockCache);

      this.gl = gl;
      this.x = 0;
      this.y = 0;
      this.sx1 = sx1;
      this.sy1 = sy1;
      this.width = width;
      this.height = height;
      this.bbox = bbox;
      this.available = true;
      this.__page = new MockPage(texture, width, height);
      this.reOffset();
    }

    _createClass(MockCache, [{
      key: "reOffset",
      value: function reOffset() {
        var bbox = this.bbox;
        this.dx = -bbox[0];
        this.dy = -bbox[1];
        this.dbx = this.sx1 - bbox[0];
        this.dby = this.sy1 - bbox[1];
      }
    }, {
      key: "release",
      value: function release() {
        this.available = false;
        this.gl.deleteTexture(this.page.texture);
      }
    }, {
      key: "page",
      get: function get() {
        return this.__page;
      }
    }]);

    return MockCache;
  }();

  var vertexBlur = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoordsBlur[3];uniform vec2 u_direction;void main(){gl_Position=a_position;}"; // eslint-disable-line

  var fragmentBlur = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoordsBlur[3];uniform sampler2D u_texture;void main(){gl_FragColor=vec4(0.0);}"; // eslint-disable-line

  var vertexMbm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentMultiply = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return((1.0-a2/a3)*c1*255.0+a2/a3*((1.0-a1)*c2*255.0+a1*c3*255.0))/255.0;}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=bottom*top;float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentScreen = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentOverlay = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(top.r,bottom.r),op(top.g,bottom.g),op(top.b,bottom.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDarken = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return min(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLighten = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return max(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorDodge = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==1.0){return a==0.0 ? a : 1.0;}return min(1.0,a/(1.0-b));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorBurn = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==0.0){return a==1.0 ? a : 0.0;}return 1.0-min(1.0,(1.0-a)/b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHardLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSoftLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5? a-(1.0-2.0*b)*a*(1.0-a): a+(2.0*b-1.0)*(a<=0.25?((16.0*a-12.0)*a+4.0)*a: sqrt(a)-a);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDifference = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return abs(a-b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentExclusion = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-2.0*a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHue = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(a);float l=getLuminosity(a);return setLuminosity(setSaturation(b,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSaturation = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(b);float l=getLuminosity(a);return setLuminosity(setSaturation(a,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColor = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(a);return setLuminosity(b,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLuminosity = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(b);return setLuminosity(a,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var NA = Cache.NA,
      LOCAL$1 = Cache.LOCAL,
      CHILD = Cache.CHILD,
      SELF = Cache.SELF,
      getCache = Cache.getCache;
  var OFFSCREEN_OVERFLOW$1 = offscreen.OFFSCREEN_OVERFLOW,
      OFFSCREEN_FILTER$1 = offscreen.OFFSCREEN_FILTER,
      OFFSCREEN_MASK$1 = offscreen.OFFSCREEN_MASK,
      OFFSCREEN_BLEND$1 = offscreen.OFFSCREEN_BLEND,
      OFFSCREEN_MASK2$1 = offscreen.OFFSCREEN_MASK2,
      applyOffscreen$1 = offscreen.applyOffscreen;
  var _enums$STYLE_KEY$j = enums.STYLE_KEY,
      DISPLAY$7 = _enums$STYLE_KEY$j.DISPLAY,
      OPACITY$5 = _enums$STYLE_KEY$j.OPACITY,
      VISIBILITY$5 = _enums$STYLE_KEY$j.VISIBILITY,
      FILTER$6 = _enums$STYLE_KEY$j.FILTER,
      OVERFLOW$3 = _enums$STYLE_KEY$j.OVERFLOW,
      MIX_BLEND_MODE$3 = _enums$STYLE_KEY$j.MIX_BLEND_MODE,
      FILL$2 = _enums$STYLE_KEY$j.FILL,
      TRANSFORM$4 = _enums$STYLE_KEY$j.TRANSFORM,
      TRANSFORM_ORIGIN$5 = _enums$STYLE_KEY$j.TRANSFORM_ORIGIN,
      PERSPECTIVE$4 = _enums$STYLE_KEY$j.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$4 = _enums$STYLE_KEY$j.PERSPECTIVE_ORIGIN,
      PADDING_LEFT$8 = _enums$STYLE_KEY$j.PADDING_LEFT,
      PADDING_RIGHT$7 = _enums$STYLE_KEY$j.PADDING_RIGHT,
      PADDING_TOP$6 = _enums$STYLE_KEY$j.PADDING_TOP,
      PADDING_BOTTOM$6 = _enums$STYLE_KEY$j.PADDING_BOTTOM,
      BORDER_TOP_WIDTH$7 = _enums$STYLE_KEY$j.BORDER_TOP_WIDTH,
      BORDER_RIGHT_WIDTH$7 = _enums$STYLE_KEY$j.BORDER_RIGHT_WIDTH,
      BORDER_BOTTOM_WIDTH$7 = _enums$STYLE_KEY$j.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$8 = _enums$STYLE_KEY$j.BORDER_LEFT_WIDTH,
      MATRIX$4 = _enums$STYLE_KEY$j.MATRIX,
      _enums$NODE_KEY$8 = enums.NODE_KEY,
      NODE_CACHE$3 = _enums$NODE_KEY$8.NODE_CACHE,
      NODE_CACHE_TOTAL$1 = _enums$NODE_KEY$8.NODE_CACHE_TOTAL,
      NODE_CACHE_OVERFLOW$1 = _enums$NODE_KEY$8.NODE_CACHE_OVERFLOW,
      NODE_CACHE_MASK$1 = _enums$NODE_KEY$8.NODE_CACHE_MASK,
      NODE_CACHE_FILTER$1 = _enums$NODE_KEY$8.NODE_CACHE_FILTER,
      NODE_MATRIX$3 = _enums$NODE_KEY$8.NODE_MATRIX,
      NODE_MATRIX_EVENT$4 = _enums$NODE_KEY$8.NODE_MATRIX_EVENT,
      NODE_OPACITY$2 = _enums$NODE_KEY$8.NODE_OPACITY,
      NODE_COMPUTED_STYLE$3 = _enums$NODE_KEY$8.NODE_COMPUTED_STYLE,
      NODE_CURRENT_STYLE$5 = _enums$NODE_KEY$8.NODE_CURRENT_STYLE,
      NODE_LIMIT_CACHE$2 = _enums$NODE_KEY$8.NODE_LIMIT_CACHE,
      NODE_REFRESH_LV$1 = _enums$NODE_KEY$8.NODE_REFRESH_LV,
      NODE_CACHE_STYLE$1 = _enums$NODE_KEY$8.NODE_CACHE_STYLE,
      NODE_DEFS_CACHE$5 = _enums$NODE_KEY$8.NODE_DEFS_CACHE,
      NODE_IS_MASK$2 = _enums$NODE_KEY$8.NODE_IS_MASK,
      NODE_DOM_PARENT$5 = _enums$NODE_KEY$8.NODE_DOM_PARENT,
      NODE_PERSPECTIVE_MATRIX$1 = _enums$NODE_KEY$8.NODE_PERSPECTIVE_MATRIX,
      NODE_VIRTUAL_DOM$3 = _enums$NODE_KEY$8.NODE_VIRTUAL_DOM,
      NODE_CACHE_AS_BITMAP$1 = _enums$NODE_KEY$8.NODE_CACHE_AS_BITMAP,
      NODE_STRUCT$4 = _enums$NODE_KEY$8.NODE_STRUCT,
      _enums$STRUCT_KEY$2 = enums.STRUCT_KEY,
      STRUCT_NODE$1 = _enums$STRUCT_KEY$2.STRUCT_NODE,
      STRUCT_INDEX$2 = _enums$STRUCT_KEY$2.STRUCT_INDEX,
      STRUCT_TOTAL$1 = _enums$STRUCT_KEY$2.STRUCT_TOTAL,
      STRUCT_HAS_MASK$1 = _enums$STRUCT_KEY$2.STRUCT_HAS_MASK,
      STRUCT_LV$2 = _enums$STRUCT_KEY$2.STRUCT_LV;
  var NONE$2 = o$3.NONE,
      TRANSFORM_ALL$1 = o$3.TRANSFORM_ALL,
      OP = o$3.OPACITY,
      FT = o$3.FILTER,
      REPAINT$2 = o$3.REPAINT,
      contain$2 = o$3.contain,
      MBM = o$3.MIX_BLEND_MODE,
      PPT = o$3.PERSPECTIVE;
  var isE$3 = mx.isE,
      inverse$1 = mx.inverse,
      multiply$2 = mx.multiply;
  var mbmName$2 = mbm.mbmName,
      isValidMbm$2 = mbm.isValidMbm;
  var assignMatrix$1 = util.assignMatrix,
      transformBbox$1 = util.transformBbox;
  /**
   * 生成一个节点及其子节点所包含的矩形范围盒，canvas和webgl的最大尺寸限制不一样，由外部传入
   * 如果某个子节点超限，则视为整个超限，超限返回空
   * @param node
   * @param __structs
   * @param index
   * @param total
   * @param parentIndexHash
   * @param opacityHash
   * @param MAX
   * @param includeLimitCache webgl时即便超限也要强制生成total，所以标识不能跳出
   * @returns {*}
   */

  function genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, MAX, includeLimitCache) {
    var sx1 = node.__sx1,
        sy1 = node.__sy1,
        __config = node.__config;
    var cache = __config[NODE_CACHE$3],
        _config$NODE_COMPUTE = __config[NODE_COMPUTED_STYLE$3],
        filter = _config$NODE_COMPUTE[FILTER$6],
        perspective = _config$NODE_COMPUTE[PERSPECTIVE$4],
        perspectiveOrigin = _config$NODE_COMPUTE[PERSPECTIVE_ORIGIN$4]; // 先将局部根节点的bbox算好，可能没内容是空

    var bboxTotal;

    if (cache && cache.available) {
      bboxTotal = cache.bbox;
    } else {
      bboxTotal = node.filterBbox;
    }

    bboxTotal = bboxTotal.slice(0); // 局部根节点如有perspective，则计算pm，这里不会出现嵌套，因为每个出现都会生成局部根节点

    var pm;

    if (perspective) {
      pm = transform$1.calPerspectiveMatrix(perspective, perspectiveOrigin);
    } // 广度遍历，不断一层层循环下去，用2个hash暂存每层的父matrix和opacity，blur只需记住顶层，因为子的如果有一定是cacheFilter


    var list = [index];
    var d = 0;
    filter.forEach(function (item) {
      var _item = _slicedToArray(item, 2),
          k = _item[0],
          v = _item[1];

      if (k === 'blur') {
        d = blur.outerSize(v);
      }
    });
    opacityHash[index] = 1; // opacity可以保存下来层级相乘结果供外部使用，但matrix不可以，因为这里按画布原点为坐标系计算，外部合并局部根节点以bbox左上角为原点

    var matrixHash = {};

    while (list.length) {
      var arr = list.splice(0);

      for (var i = 0, len = arr.length; i < len; i++) {
        var parentIndex = arr[i];

        var _total = __structs[parentIndex][STRUCT_TOTAL$1] || 0;

        for (var _i = parentIndex + 1, _len = parentIndex + _total + 1; _i < _len; _i++) {
          var _structs$_i = __structs[_i],
              node2 = _structs$_i[STRUCT_NODE$1],
              _total2 = _structs$_i[STRUCT_TOTAL$1]; // mask也不占bbox位置

          if (node2.isMask) {
            continue;
          }

          var __sx1 = node2.__sx1,
              __sy1 = node2.__sy1,
              _node2$__config = node2.__config,
              limitCache = _node2$__config[NODE_LIMIT_CACHE$2],
              __cache = _node2$__config[NODE_CACHE$3],
              __cacheTotal = _node2$__config[NODE_CACHE_TOTAL$1],
              __cacheFilter = _node2$__config[NODE_CACHE_FILTER$1],
              __cacheMask = _node2$__config[NODE_CACHE_MASK$1],
              __cacheOverflow = _node2$__config[NODE_CACHE_OVERFLOW$1],
              _node2$__config$NODE_ = _node2$__config[NODE_COMPUTED_STYLE$3],
              display = _node2$__config$NODE_[DISPLAY$7],
              visibility = _node2$__config$NODE_[VISIBILITY$5],
              transform = _node2$__config$NODE_[TRANSFORM$4],
              transformOrigin = _node2$__config$NODE_[TRANSFORM_ORIGIN$5],
              opacity = _node2$__config$NODE_[OPACITY$5]; // webgl不能跳过超限

          if (limitCache && !includeLimitCache) {
            return;
          } // display:none跳过整个节点树，visibility只跳过自身


          if (display === 'none') {
            _i += _total2 || 0;
            continue;
          }

          if (visibility === 'hidden') {
            continue;
          }

          parentIndexHash[_i] = parentIndex;
          opacityHash[_i] = opacityHash[parentIndex] * opacity;
          var bbox = void 0,
              dx = 0,
              dy = 0,
              hasTotal = void 0; // text不能用filter

          if (node2 instanceof Text) {
            bbox = node2.bbox;
          } else {
            var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal]);

            if (target) {
              bbox = target.bbox;
              dx = target.dbx;
              dy = target.dby;
              _i += _total2 || 0;
              hasTotal = true;
            } else if (__cache && __cache.available) {
              bbox = __cache.bbox;
              dx = __cache.dbx;
              dy = __cache.dby;
            } else {
              bbox = node2.filterBbox;
            }
          } // 可能Xom没有内容


          if (bbox) {
            bbox = bbox.slice(0); // 相对于根节点偏移

            bbox[0] -= sx1;
            bbox[1] -= sy1;
            bbox[2] -= sx1;
            bbox[3] -= sy1;
            var matrix = matrixHash[parentIndex]; // 父级matrix初始化E为null，自身不为E时才运算，可以加速

            if (transform && !isE$3(transform)) {
              var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

              tfo[0] += __sx1 - sx1 + dx;
              tfo[1] += __sy1 - sy1 + dy;
              var m = transform$1.calMatrixByOrigin(transform, tfo);

              if (matrix) {
                matrix = multiply$2(matrix, m);
              } else {
                matrix = m;
              }
            }

            if (matrix) {
              matrixHash[_i] = matrix;
            }

            if (pm) {
              matrix = multiply$2(pm, matrix);
            }

            bbox = transformBbox$1(bbox, matrix, d, d); // 有孩子才继续存入下层级广度运算

            if (_total2 && !hasTotal) {
              list.push(_i);
            }

            mergeBbox(bboxTotal, bbox, sx1, sy1);
          }
        }
      }
    }

    return [bboxTotal, pm];
  }

  function mergeBbox(bbox, t, sx1, sy1) {
    bbox[0] = Math.min(bbox[0], sx1 + t[0]);
    bbox[1] = Math.min(bbox[1], sy1 + t[1]);
    bbox[2] = Math.max(bbox[2], sx1 + t[2]);
    bbox[3] = Math.max(bbox[3], sy1 + t[3]);
  }
  /**
   * 生成局部根节点离屏缓存，超限时除外
   * cache是每个节点自身的缓存，且共享离屏canvas
   * cacheTotal是基础
   * cacheFilter基于total
   * cacheOverflow基于filter
   * cacheMask基于overflow
   * cacheBlend基于mask
   * @param renderMode
   * @param node
   * @param config
   * @param index
   * @param lv
   * @param total
   * @param __structs
   * @param hasMask
   * @param width
   * @param height
   * @returns {{enabled}|Cache|*}
   */


  function genTotal(renderMode, node, config, index, lv, total, __structs, hasMask, width, height) {
    var cacheTotal = config[NODE_CACHE_TOTAL$1],
        cacheFilter = config[NODE_CACHE_FILTER$1],
        cacheMask = config[NODE_CACHE_MASK$1],
        cacheOverflow = config[NODE_CACHE_OVERFLOW$1],
        currentStyle = config[NODE_CURRENT_STYLE$5],
        computedStyle = config[NODE_COMPUTED_STYLE$3];
    var needGen; // 先绘制形成基础的total，有可能已经存在无变化，就可省略

    if (!cacheTotal || !cacheTotal.available) {
      needGen = true; // total重新生成了，其它基于的也一定需要重新生成

      var bboxTotal, baseMatrix;
      var _sx = node.__sx1,
          _sy = node.__sy1; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

      var matrixList = [];
      var parentMatrix;
      var opacityList = [];
      var parentOpacity = 1;
      var lastConfig;
      var lastLv = lv; // 先遍历每个节点，以局部根节点左上角为原点，求得所占的总的bbox，即合并所有bbox

      for (var i = index, len = index + (total || 0) + 1; i < len; i++) {
        var _structs$i = __structs[i],
            _node = _structs$i[STRUCT_NODE$1],
            _lv = _structs$i[STRUCT_LV$2],
            _total3 = _structs$i[STRUCT_TOTAL$1],
            _hasMask = _structs$i[STRUCT_HAS_MASK$1]; // 排除Text

        if (_node instanceof Text) {
          var _bbox = _node.bbox; // 文字节点不能算filter

          if (!isE$3(parentMatrix)) {
            _bbox = transformBbox$1(_bbox, parentMatrix, 0, 0);
          }

          mergeBbox(bboxTotal, _bbox, 0, 0);
          continue;
        }

        var __config = _node.__config;
        var refreshLevel = __config[NODE_REFRESH_LV$1],
            __cacheTotal = __config[NODE_CACHE_TOTAL$1],
            __cacheFilter = __config[NODE_CACHE_FILTER$1],
            __cacheMask = __config[NODE_CACHE_MASK$1],
            __cacheOverflow = __config[NODE_CACHE_OVERFLOW$1],
            _computedStyle = __config[NODE_COMPUTED_STYLE$3],
            isMask = __config[NODE_IS_MASK$2]; // 跳过display:none元素和它的所有子节点和mask

        if (_computedStyle[DISPLAY$7] === 'none') {
          i += (_total3 || 0) + countMaskNum(__structs, i + (_total3 || 0) + 1, _hasMask || 0);
          continue;
        } // mask不占bbox，本身除外


        if (i !== index && isMask) {
          i += (_total3 || 0) + countMaskNum(__structs, i + (_total3 || 0) + 1, _hasMask || 0);
          continue;
        } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


        if (i === index) ; else if (_lv > lastLv) {
          parentMatrix = lastConfig[NODE_MATRIX_EVENT$4];

          if (isE$3(parentMatrix)) {
            parentMatrix = null;
          }

          matrixList.push(parentMatrix);
          parentOpacity = lastConfig[NODE_OPACITY$2];
          opacityList.push(parentOpacity);
        } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
        else if (_lv < lastLv) {
          var diff = lastLv - _lv;
          matrixList.splice(-diff);
          parentMatrix = matrixList[_lv - 1];
          opacityList.splice(-diff);
          parentOpacity = opacityList[_lv - 1];
        } // 不变是同级兄弟，无需特殊处理 else {}


        lastConfig = __config;
        lastLv = _lv;
        var _currentStyle = __config[NODE_CURRENT_STYLE$5],
            __cacheStyle = __config[NODE_CACHE_STYLE$1];
        var matrix = void 0,
            opacity = void 0;
        /**
         * lv<REPAINT，bbox基本不变（除非filter），无需重新生成，否则置空后重新计算获得
         * 同时计算matrix，并以局部根节点为原点，计算matrixEvent，临时保存下来
         * 如果后续向主画布渲染时局部根节点为E，则可省略真正计算子节点matrixEvent的过程
         */

        if (refreshLevel < REPAINT$2) {
          if (contain$2(refreshLevel, TRANSFORM_ALL$1)) {
            matrix = _node.__calMatrix(refreshLevel, __cacheStyle, _currentStyle, _computedStyle, __config);
            assignMatrix$1(__config[NODE_MATRIX$3], matrix);
          } else {
            matrix = __config[NODE_MATRIX$3];
          }

          if (contain$2(refreshLevel, OP)) {
            _computedStyle[OPACITY$5] = _currentStyle[OPACITY$5];
          }

          opacity = _computedStyle[OPACITY$5];

          if (contain$2(refreshLevel, FT)) {
            _node.__bbox = null;
            _node.__filterBbox = null;

            _node.__calFilter(_currentStyle, _computedStyle);
          }

          matrix = __config[NODE_MATRIX$3];

          if (contain$2(refreshLevel, MBM)) {
            _computedStyle[MIX_BLEND_MODE$3] = _currentStyle[MIX_BLEND_MODE$3];
          }
        }
        /**
         * >=REPAINT重新渲染，bbox重新生成，matrix重新生成，filter重新生成
         */
        else {
          _node.__bbox = null;
          _node.__filterBbox = null;

          if (i === index) {
            _node.__calFilter(_currentStyle, _computedStyle);
          }

          matrix = _node.__calMatrix(refreshLevel, __cacheStyle, _currentStyle, _computedStyle, __config);
          assignMatrix$1(__config[NODE_MATRIX$3], matrix);
          opacity = _computedStyle[OPACITY$5] = _currentStyle[OPACITY$5];
        } // opacity可临时赋值下面循环渲染用，matrixEvent可能需重新计算，因为局部根节点为E没考虑继承，这里仅计算bbox用


        if (i === index) {
          opacity = 1;
          baseMatrix = matrix;
          matrix = mx.identity();
        } else if (!isE$3(parentMatrix)) {
          matrix = multiply$2(parentMatrix, matrix);
        }

        assignMatrix$1(__config[NODE_MATRIX_EVENT$4], matrix);
        __config[NODE_OPACITY$2] = parentOpacity * opacity;
        var bbox = void 0; // 子元素有cacheTotal优先使用，一定是子元素，局部根节点available为false不会进

        var target = i > index && getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal]); // 局部根节点的total不需要考虑filter，子节点要

        if (target) {
          i += (_total3 || 0) + countMaskNum(__structs, i + (_total3 || 0) + 1, _hasMask || 0);
          bbox = target.bbox;
        } else {
          bbox = i === index ? _node.bbox : _node.filterBbox;
        } // 老的不变，新的会各自重新生成，根据matrixEvent合并bboxTotal


        bbox = transformBbox$1(bbox, matrix, 0, 0);

        if (i === index) {
          bboxTotal = bbox.slice(0);
        } else {
          mergeBbox(bboxTotal, bbox, 0, 0);
        }
      } // 生成cacheTotal，获取偏移dx/dy


      config[NODE_CACHE_TOTAL$1] = cacheTotal = Cache.getInstance(bboxTotal, _sx, _sy);

      if (!cacheTotal || !cacheTotal.enabled) {
        return;
      }

      cacheTotal.__available = true;
      var _cacheTotal = cacheTotal,
          dx = _cacheTotal.dx,
          dy = _cacheTotal.dy,
          dbx = _cacheTotal.dbx,
          dby = _cacheTotal.dby,
          tx = _cacheTotal.x,
          ty = _cacheTotal.y;
      var ctxTotal = cacheTotal.ctx;
      /**
       * 再次遍历每个节点，以局部根节点左上角为基准原点，将所有节点绘制上去
       * 每个子节点的opacity有父继承计算在上面循环已经做好了，直接获取
       * 但matrixEvent可能需要重算，因为原点不一定是根节点的原点，影响tfo
       * 另外每个节点的refreshLevel需要设置REPAINT
       * 这样cacheTotal取消时子节点需确保重新计算一次matrix/opacity/filter，保证下次和父元素继承正确
       */

      parentMatrix = null;
      var lastMatrix;
      lastLv = lv; // 和外面没cache的类似，mask生成hash记录

      var maskStartHash = {};
      var offscreenHash = {};

      for (var _i2 = index, _len2 = index + (total || 0) + 1; _i2 < _len2; _i2++) {
        var _structs$_i2 = __structs[_i2],
            _node2 = _structs$_i2[STRUCT_NODE$1],
            _lv2 = _structs$_i2[STRUCT_LV$2],
            _total4 = _structs$_i2[STRUCT_TOTAL$1],
            _hasMask2 = _structs$_i2[STRUCT_HAS_MASK$1]; // 排除Text

        if (_node2 instanceof Text) {
          _node2.render(renderMode, REPAINT$2, ctxTotal, CHILD, dx, dy);

          if (offscreenHash.hasOwnProperty(_i2)) {
            ctxTotal = applyOffscreen$1(ctxTotal, offscreenHash[_i2], width, height);
          }
        } else {
          var _config = _node2.__config;
          var _refreshLevel = _config[NODE_REFRESH_LV$1],
              _cacheTotal2 = _config[NODE_CACHE_TOTAL$1],
              _cacheFilter = _config[NODE_CACHE_FILTER$1],
              _cacheMask = _config[NODE_CACHE_MASK$1],
              _cacheOverflow = _config[NODE_CACHE_OVERFLOW$1],
              _computedStyle2 = _config[NODE_COMPUTED_STYLE$3];

          if (maskStartHash.hasOwnProperty(_i2)) {
            var _maskStartHash$_i = _slicedToArray(maskStartHash[_i2], 3),
                idx = _maskStartHash$_i[0],
                n = _maskStartHash$_i[1],
                offscreenMask = _maskStartHash$_i[2];

            var _target2 = inject.getCacheCanvas(width, height, null, 'mask2');

            offscreenMask.mask = _target2; // 应用mask用到

            offscreenMask.isClip = _node2.isClip; // 定位到最后一个mask元素上的末尾

            var j = _i2 + (_total4 || 0) + 1;

            while (--n) {
              var _total5 = __structs[j][STRUCT_TOTAL$1];
              j += (_total5 || 0) + 1;
            }

            j--;
            var list = offscreenHash[j] = offscreenHash[j] || [];
            list.push([idx, _lv2, OFFSCREEN_MASK$1, offscreenMask]);
            list.push([j, _lv2, OFFSCREEN_MASK2$1, {
              ctx: ctxTotal,
              // 保存等待OFFSCREEN_MASK2时还原
              target: _target2
            }]);
            ctxTotal = _target2.ctx;
          } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


          if (_i2 === index) ; else if (_lv2 > lastLv) {
            parentMatrix = lastMatrix;

            if (isE$3(parentMatrix)) {
              parentMatrix = null;
            }

            matrixList.push(parentMatrix);
          } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
          else if (_lv2 < lastLv) {
            var _diff = lastLv - _lv2;

            matrixList.splice(-_diff);
            parentMatrix = matrixList[_lv2 - 1];
          } // 不变是同级兄弟，无需特殊处理 else {}


          var transform = _computedStyle2[TRANSFORM$4],
              tfo = _computedStyle2[TRANSFORM_ORIGIN$5],
              display = _computedStyle2[DISPLAY$7]; // 特殊渲染的matrix，局部根节点为原点考虑，当需要计算时再计算

          var m = void 0;

          if (_i2 !== index && (!isE$3(parentMatrix) || !isE$3(transform))) {
            tfo = tfo.slice(0);
            tfo[0] += dbx + _node2.__sx1 - _sx + tx;
            tfo[1] += dby + _node2.__sy1 - _sy + ty;
            m = transform$1.calMatrixByOrigin(transform, tfo);

            if (!isE$3(parentMatrix)) {
              m = multiply$2(parentMatrix, m);
            }
          } else {
            m = null;
          }

          if (m) {
            ctxTotal.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
          } else {
            ctxTotal.setTransform(1, 0, 0, 1, 0, 0);
          }

          lastLv = _lv2;
          lastMatrix = m; // 子元素有cacheTotal优先使用，也一定是子元素，局部根节点不会进

          var _target = getCache([_cacheMask, _cacheFilter, _cacheOverflow, _cacheTotal2]);

          if (_i2 !== index && _target) {
            _i2 += (_total4 || 0) + countMaskNum(__structs, _i2 + (_total4 || 0) + 1, _hasMask2 || 0); // 跳过display:none元素和它的所有子节点

            if (display === 'none') {
              continue;
            }

            var mixBlendMode = _computedStyle2[MIX_BLEND_MODE$3];

            if (isValidMbm$2(mixBlendMode)) {
              ctxTotal.globalCompositeOperation = mbmName$2(mixBlendMode);
            } else {
              ctxTotal.globalCompositeOperation = 'source-over';
            }

            ctxTotal.globalAlpha = _config[NODE_OPACITY$2];
            Cache.drawCache(_target, cacheTotal);
            ctxTotal.globalCompositeOperation = 'source-over';
          } else {
            if (_refreshLevel >= REPAINT$2) {
              // 手动计算cacheStyle和根据border-box的坐标再渲染
              _node2.__calCache(renderMode, ctxTotal, _config[NODE_DOM_PARENT$5], _config[NODE_CACHE_STYLE$1], _config[NODE_CURRENT_STYLE$5], _computedStyle2, _node2.clientWidth, _node2.clientHeight, _node2.offsetWidth, _node2.offsetHeight, _computedStyle2[BORDER_TOP_WIDTH$7], _computedStyle2[BORDER_RIGHT_WIDTH$7], _computedStyle2[BORDER_BOTTOM_WIDTH$7], _computedStyle2[BORDER_LEFT_WIDTH$8], _computedStyle2[PADDING_TOP$6], _computedStyle2[PADDING_RIGHT$7], _computedStyle2[PADDING_BOTTOM$6], _computedStyle2[PADDING_LEFT$8], _node2.__sx1, _node2.__sx2, _node2.__sx3, _node2.__sx4, _node2.__sx5, _node2.__sx6, _node2.__sy1, _node2.__sy2, _node2.__sy3, _node2.__sy4, _node2.__sy5, _node2.__sy6);
            }

            var res = _node2.render(renderMode, _refreshLevel, ctxTotal, _i2 === index ? LOCAL$1 : CHILD, dx, dy);

            _config[NODE_REFRESH_LV$1] = REPAINT$2;

            var _ref = res || {},
                offscreenBlend = _ref.offscreenBlend,
                _offscreenMask = _ref.offscreenMask,
                offscreenFilter = _ref.offscreenFilter,
                offscreenOverflow = _ref.offscreenOverflow; // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


            if (offscreenBlend) {
              var _j = _i2 + (_total4 || 0) + countMaskNum(__structs, _i2 + (_total4 || 0) + 1, _hasMask2 || 0);

              var _list = offscreenHash[_j] = offscreenHash[_j] || [];

              _list.push([_i2, _lv2, OFFSCREEN_BLEND$1, offscreenBlend]);

              ctxTotal = offscreenBlend.target.ctx;
            } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
            // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


            if (_offscreenMask) {
              var _j2 = _i2 + (_total4 || 0);

              maskStartHash[_j2 + 1] = [_i2, _hasMask2, _offscreenMask];
              ctxTotal = _offscreenMask.target.ctx;
            } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


            if (offscreenFilter) {
              var _j3 = _i2 + (_total4 || 0) + countMaskNum(__structs, _i2 + (_total4 || 0) + 1, _hasMask2 || 0);

              var _list2 = offscreenHash[_j3] = offscreenHash[_j3] || [];

              _list2.push([_i2, _lv2, OFFSCREEN_FILTER$1, offscreenFilter]);

              ctxTotal = offscreenFilter.target.ctx;
            } // overflow:hidden的离屏，最后孩子进行截取


            if (offscreenOverflow) {
              var _j4 = _i2 + (_total4 || 0) + countMaskNum(__structs, _i2 + (_total4 || 0) + 1, _hasMask2 || 0);

              var _list3 = offscreenHash[_j4] = offscreenHash[_j4] || [];

              _list3.push([_i2, _lv2, OFFSCREEN_OVERFLOW$1, offscreenOverflow]);

              ctxTotal = offscreenOverflow.target.ctx;
            } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
            // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


            if (offscreenHash.hasOwnProperty(_i2)) {
              ctxTotal = applyOffscreen$1(ctxTotal, offscreenHash[_i2], width, height);
            } // render后判断可见状态，此时computedStyle才有值


            if (display === 'none') {
              _i2 += (_total4 || 0) + countMaskNum(__structs, _i2 + (_total4 || 0) + 1, _hasMask2 || 0);
            }
          }
        }
      } // 恢复，且局部根节点设置NONE


      assignMatrix$1(config[NODE_MATRIX_EVENT$4], baseMatrix);
      config[NODE_REFRESH_LV$1] = NONE$2;
    } // cacheTotal仍在说明<REPAINT，需计算各种新的参数
    else {
      var _refreshLevel2 = config[NODE_REFRESH_LV$1],
          _cacheStyle = config[NODE_CACHE_STYLE$1];

      if (contain$2(_refreshLevel2, TRANSFORM_ALL$1)) {
        var _matrix = node.__calMatrix(_refreshLevel2, _cacheStyle, currentStyle, computedStyle, config);

        assignMatrix$1(config[NODE_MATRIX$3], _matrix);
      }

      if (contain$2(_refreshLevel2, OP)) {
        config[NODE_OPACITY$2] = computedStyle[OPACITY$5] = currentStyle[OPACITY$5];
      }

      if (contain$2(_refreshLevel2, FT)) {
        node.__calFilter(currentStyle, computedStyle);
      }

      if (contain$2(_refreshLevel2, MBM)) {
        computedStyle[MIX_BLEND_MODE$3] = currentStyle[MIX_BLEND_MODE$3];
      }
    } // 其它基于total的cache，为了防止失败超限，必须有total结果


    if (cacheTotal && cacheTotal.available) {
      var overflow = computedStyle[OVERFLOW$3],
          filter = computedStyle[FILTER$6];
      var _target3 = cacheTotal;

      if (overflow === 'hidden') {
        if (!cacheOverflow || !cacheOverflow.available || needGen) {
          config[NODE_CACHE_OVERFLOW$1] = Cache.genOverflow(_target3, node);
          needGen = true;
        }

        _target3 = config[NODE_CACHE_OVERFLOW$1] || _target3;
      }

      if (filter && filter.length) {
        // 新生成单独的filter离屏，老的已经release()过了
        if (!cacheFilter || !cacheFilter.available || needGen) {
          config[NODE_CACHE_FILTER$1] = Cache.genFilter(_target3, filter);
          needGen = true;
        }

        _target3 = config[NODE_CACHE_FILTER$1] || _target3;
      }

      if (hasMask && (!cacheMask || !cacheMask.available || needGen)) {
        /**
         * 回调给Cache.genMask()使用，汇集所有mask到离屏mask2中
         * 当mask节点有cache时内部直接调用绘制了cache位图
         * 当mask没有缓存可用时进这里的普通渲染逻辑
         */
        config[NODE_CACHE_MASK$1] = Cache.genMask(_target3, node, function (item, cacheMask, inverse) {
          // 和外面没cache的类似，mask生成hash记录，这里mask节点一定是个普通无cache的独立节点
          var maskStartHash = {};
          var offscreenHash = {};
          var dx = cacheMask.dx,
              dy = cacheMask.dy,
              dbx = cacheMask.dbx,
              dby = cacheMask.dby,
              tx = cacheMask.x,
              ty = cacheMask.y,
              ctx = cacheMask.ctx;
          var _item$__config$NODE_S = item.__config[NODE_STRUCT$4],
              index = _item$__config$NODE_S[STRUCT_INDEX$2],
              total = _item$__config$NODE_S[STRUCT_TOTAL$1],
              lv = _item$__config$NODE_S[STRUCT_LV$2];
          var matrixList = [];
          var parentMatrix;
          var lastMatrix;
          var opacityList = [];
          var parentOpacity = 1;
          var lastOpacity;
          var lastLv = lv;

          for (var _i3 = index, _len3 = index + (total || 0) + 1; _i3 < _len3; _i3++) {
            var _structs$_i3 = __structs[_i3],
                _node3 = _structs$_i3[STRUCT_NODE$1],
                _lv3 = _structs$_i3[STRUCT_LV$2],
                _total6 = _structs$_i3[STRUCT_TOTAL$1],
                _hasMask3 = _structs$_i3[STRUCT_HAS_MASK$1]; // 排除Text

            if (_node3 instanceof Text) {
              _node3.render(renderMode, REPAINT$2, ctx, CHILD, dx, dy);

              if (offscreenHash.hasOwnProperty(_i3)) {
                ctx = applyOffscreen$1(ctx, offscreenHash[_i3], width, height);
              }
            } else {
              var _config2 = _node3.__config;
              var _refreshLevel3 = _config2[NODE_REFRESH_LV$1],
                  _cacheTotal3 = _config2[NODE_CACHE_TOTAL$1],
                  _cacheFilter2 = _config2[NODE_CACHE_FILTER$1],
                  _cacheMask2 = _config2[NODE_CACHE_MASK$1],
                  _cacheOverflow2 = _config2[NODE_CACHE_OVERFLOW$1],
                  _computedStyle3 = _config2[NODE_COMPUTED_STYLE$3];

              if (maskStartHash.hasOwnProperty(_i3)) {
                var _maskStartHash$_i2 = _slicedToArray(maskStartHash[_i3], 3),
                    _idx = _maskStartHash$_i2[0],
                    _n = _maskStartHash$_i2[1],
                    _offscreenMask2 = _maskStartHash$_i2[2];

                var _target5 = inject.getCacheCanvas(width, height, null, 'mask2');

                _offscreenMask2.mask = _target5; // 应用mask用到

                _offscreenMask2.isClip = _node3.isClip; // 定位到最后一个mask元素上的末尾

                var _j5 = _i3 + (_total6 || 0) + 1;

                while (--_n) {
                  var _total7 = __structs[_j5][STRUCT_TOTAL$1];
                  _j5 += (_total7 || 0) + 1;
                }

                _j5--;

                var _list4 = offscreenHash[_j5] = offscreenHash[_j5] || [];

                _list4.push([_idx, _lv3, OFFSCREEN_MASK$1, _offscreenMask2]);

                _list4.push([_j5, _lv3, OFFSCREEN_MASK2$1, {
                  ctx: ctx,
                  // 保存等待OFFSCREEN_MASK2时还原
                  target: _target5
                }]);

                ctx = _target5.ctx;
              } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


              if (_i3 === index) ; else if (_lv3 > lastLv) {
                parentMatrix = lastMatrix;

                if (isE$3(parentMatrix)) {
                  parentMatrix = null;
                }

                matrixList.push(parentMatrix);
                parentOpacity = lastOpacity;
                opacityList.push(parentOpacity);
              } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
              else if (_lv3 < lastLv) {
                var _diff2 = lastLv - _lv3;

                matrixList.splice(-_diff2);
                parentMatrix = matrixList[_lv3 - 1];
                opacityList.splice(-_diff2);
                parentOpacity = opacityList[_lv3 - 1];
              } // 不变是同级兄弟，无需特殊处理 else {}


              lastLv = _lv3; // 计算临时的matrix

              var _display = _computedStyle3[DISPLAY$7],
                  _transform = _computedStyle3[TRANSFORM$4],
                  _tfo = _computedStyle3[TRANSFORM_ORIGIN$5]; // 特殊渲染的matrix，局部根节点为原点考虑，本节点需inverse反向

              var _target4 = getCache([_cacheMask2, _cacheFilter2, _cacheOverflow2, _cacheTotal3]);

              if (_target4) {
                _i3 += (_total6 || 0) + countMaskNum(__structs, _i3 + (_total6 || 0) + 1, _hasMask3 || 0); // 跳过display:none元素和它的所有子节点

                if (_display === 'none') {
                  continue;
                }

                var _mixBlendMode = _computedStyle3[MIX_BLEND_MODE$3];

                if (isValidMbm$2(_mixBlendMode)) {
                  ctx.globalCompositeOperation = mbmName$2(_mixBlendMode);
                } else {
                  ctx.globalCompositeOperation = 'source-over';
                }

                ctx.globalAlpha = _config2[NODE_OPACITY$2];
                Cache.drawCache(_target4, cacheMask, _transform, mx.identity(), _tfo.slice(0), parentMatrix, inverse);
                ctx.globalCompositeOperation = 'source-over';
              } // 等于将外面bbox计算和渲染合一的过程，但不需要bbox本身的内容
              else {
                var _currentStyle2 = _config2[NODE_CURRENT_STYLE$5],
                    _cacheStyle2 = _config2[NODE_CACHE_STYLE$1];

                var _matrix2 = void 0,
                    _opacity = void 0;

                if (_refreshLevel3 < REPAINT$2) {
                  if (contain$2(_refreshLevel3, TRANSFORM_ALL$1)) {
                    _matrix2 = _node3.__calMatrix(_refreshLevel3, _cacheStyle2, _currentStyle2, _computedStyle3, _config2);
                    assignMatrix$1(_config2[NODE_MATRIX$3], _matrix2);
                  } else {
                    _matrix2 = _config2[NODE_MATRIX$3];
                  }

                  if (contain$2(_refreshLevel3, OP)) {
                    _computedStyle3[OPACITY$5] = _currentStyle2[OPACITY$5];
                  }

                  _opacity = _computedStyle3[OPACITY$5];

                  if (contain$2(_refreshLevel3, FT)) {
                    _node3.__bbox = null;
                    _node3.__filterBbox = null;

                    _node3.__calFilter(_currentStyle2, _computedStyle3);
                  }

                  _matrix2 = _config2[NODE_MATRIX$3];

                  if (contain$2(_refreshLevel3, MBM)) {
                    _computedStyle3[MIX_BLEND_MODE$3] = _currentStyle2[MIX_BLEND_MODE$3];
                  }
                } else {
                  _node3.__bbox = null;
                  _node3.__filterBbox = null;

                  if (_i3 === index) {
                    _node3.__calFilter(_currentStyle2, _computedStyle3);
                  }

                  _matrix2 = _node3.__calMatrix(_refreshLevel3, _cacheStyle2, _currentStyle2, _computedStyle3, _config2);
                  assignMatrix$1(_config2[NODE_MATRIX$3], _matrix2);
                  _opacity = _computedStyle3[OPACITY$5] = _currentStyle2[OPACITY$5];
                } // opacity可临时赋值下面循环渲染用，matrixEvent可能需重新计算，因为局部根节点为E没考虑继承，这里仅计算bbox用


                if (_i3 === index) {
                  _opacity = 1;
                  _matrix2 = mx.identity();
                } else if (parentMatrix) {
                  _matrix2 = multiply$2(parentMatrix, _matrix2);
                }

                assignMatrix$1(_config2[NODE_MATRIX_EVENT$4], _matrix2);
                lastOpacity = _config2[NODE_OPACITY$2] = parentOpacity * _opacity; // 特殊渲染的matrix，局部根节点为原点考虑，当需要计算时再计算

                var _m = void 0;

                if (_i3 !== index && (!isE$3(parentMatrix) || !isE$3(_transform))) {
                  _tfo = _tfo.slice(0);
                  _tfo[0] += dbx + _node3.__sx1 - sx1 + tx;
                  _tfo[1] += dby + _node3.__sy1 - sy1 + ty;
                  _m = transform$1.calMatrixByOrigin(_transform, _tfo);

                  if (!isE$3(parentMatrix)) {
                    _m = multiply$2(parentMatrix, _m);
                  }
                } else {
                  _m = null;
                }

                lastMatrix = _m;

                if (_m) {
                  // 很多情况mask和target相同matrix，可简化计算
                  if (util.equalArr(_m, inverse)) {
                    _m = mx.identity();
                  } else {
                    inverse = mx.inverse(inverse);
                    _m = mx.multiply(inverse, _m);
                  }
                }

                if (_m) {
                  ctx.setTransform(_m[0], _m[1], _m[4], _m[5], _m[12], _m[13]);
                } else {
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                }

                if (_refreshLevel3 >= REPAINT$2) {
                  // 手动计算cacheStyle和根据border-box的坐标再渲染
                  _node3.__calCache(renderMode, ctx, _config2[NODE_DOM_PARENT$5], _config2[NODE_CACHE_STYLE$1], _config2[NODE_CURRENT_STYLE$5], _computedStyle3, _node3.clientWidth, _node3.clientHeight, _node3.offsetWidth, _node3.offsetHeight, _computedStyle3[BORDER_TOP_WIDTH$7], _computedStyle3[BORDER_RIGHT_WIDTH$7], _computedStyle3[BORDER_BOTTOM_WIDTH$7], _computedStyle3[BORDER_LEFT_WIDTH$8], _computedStyle3[PADDING_TOP$6], _computedStyle3[PADDING_RIGHT$7], _computedStyle3[PADDING_BOTTOM$6], _computedStyle3[PADDING_LEFT$8], _node3.__sx1, _node3.__sx2, _node3.__sx3, _node3.__sx4, _node3.__sx5, _node3.__sx6, _node3.__sy1, _node3.__sy2, _node3.__sy3, _node3.__sy4, _node3.__sy5, _node3.__sy6);
                }

                var _res = _node3.render(renderMode, _refreshLevel3, ctx, CHILD, dx, dy);

                _config2[NODE_REFRESH_LV$1] = REPAINT$2;

                var _ref2 = _res || {},
                    _offscreenBlend = _ref2.offscreenBlend,
                    _offscreenMask3 = _ref2.offscreenMask,
                    _offscreenFilter = _ref2.offscreenFilter,
                    _offscreenOverflow = _ref2.offscreenOverflow; // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


                if (_offscreenBlend) {
                  var _j6 = _i3 + (_total6 || 0) + countMaskNum(__structs, _i3 + (_total6 || 0) + 1, _hasMask3 || 0);

                  var _list5 = offscreenHash[_j6] = offscreenHash[_j6] || [];

                  _list5.push([_i3, _lv3, OFFSCREEN_BLEND$1, _offscreenBlend]);

                  ctx = _offscreenBlend.target.ctx;
                } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
                // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


                if (_offscreenMask3) {
                  var _j7 = _i3 + (_total6 || 0);

                  maskStartHash[_j7 + 1] = [_i3, _hasMask3, _offscreenMask3];
                  ctx = _offscreenMask3.target.ctx;
                } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


                if (_offscreenFilter) {
                  var _j8 = _i3 + (_total6 || 0) + countMaskNum(__structs, _i3 + (_total6 || 0) + 1, _hasMask3 || 0);

                  var _list6 = offscreenHash[_j8] = offscreenHash[_j8] || [];

                  _list6.push([_i3, _lv3, OFFSCREEN_FILTER$1, _offscreenFilter]);

                  ctx = _offscreenFilter.target.ctx;
                } // overflow:hidden的离屏，最后孩子进行截取


                if (_offscreenOverflow) {
                  var _j9 = _i3 + (_total6 || 0) + countMaskNum(__structs, _i3 + (_total6 || 0) + 1, _hasMask3 || 0);

                  var _list7 = offscreenHash[_j9] = offscreenHash[_j9] || [];

                  _list7.push([_i3, _lv3, OFFSCREEN_OVERFLOW$1, _offscreenOverflow]);

                  ctx = _offscreenOverflow.target.ctx;
                } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
                // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


                if (offscreenHash.hasOwnProperty(_i3)) {
                  ctx = applyOffscreen$1(ctx, offscreenHash[_i3], width, height);
                } // render后判断可见状态，此时computedStyle才有值


                if (_display === 'none') {
                  _i3 += (_total6 || 0) + countMaskNum(__structs, _i3 + (_total6 || 0) + 1, _hasMask3 || 0);
                }
              }
            }
          }
        });
      }
    }
  }

  function resetMatrixCacheTotal(__structs, index, total, lv, matrixEvent) {
    var matrixList = [];
    var parentMatrix;
    var lastMatrix = matrixEvent;
    var lastLv = lv;

    for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i2 = __structs[i],
          node = _structs$i2[STRUCT_NODE$1],
          _lv4 = _structs$i2[STRUCT_LV$2],
          _total8 = _structs$i2[STRUCT_TOTAL$1],
          hasMask = _structs$i2[STRUCT_HAS_MASK$1]; // 排除Text

      if (node instanceof Text) {
        continue;
      }

      var __config = node.__config;
      var old = __config[NODE_MATRIX_EVENT$4],
          __cacheTotal = __config[NODE_CACHE_TOTAL$1],
          currentStyle = __config[NODE_CURRENT_STYLE$5],
          computedStyle = __config[NODE_COMPUTED_STYLE$3],
          cacheStyle = __config[NODE_CACHE_STYLE$1]; // 跳过display:none元素和它的所有子节点和mask

      if (computedStyle[DISPLAY$7] === 'none') {
        i += (_total8 || 0) + countMaskNum(__structs, i + (_total8 || 0) + 1, hasMask || 0);
        continue;
      } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树


      if (_lv4 > lastLv) {
        parentMatrix = lastMatrix;

        if (isE$3(parentMatrix)) {
          parentMatrix = null;
        }

        matrixList.push(parentMatrix);
      } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
      else if (_lv4 < lastLv) {
        var diff = lastLv - _lv4;
        matrixList.splice(-diff);
        parentMatrix = matrixList[_lv4 - 1];
      } // 不变是同级兄弟，无需特殊处理 else {}


      lastLv = _lv4;
      old = old.slice(0); // 计算真正的相对于root原点的matrix

      cacheStyle[MATRIX$4] = null;

      var matrix = node.__calMatrix(REPAINT$2, cacheStyle, currentStyle, computedStyle, __config);

      assignMatrix$1(__config[NODE_MATRIX$3], matrix);

      if (!isE$3(parentMatrix)) {
        matrix = multiply$2(parentMatrix, matrix);
      }

      assignMatrix$1(__config[NODE_MATRIX_EVENT$4], matrix);
      lastMatrix = matrix; // 深度遍历递归进行

      if (__cacheTotal && __cacheTotal.available) {
        var needReset = __cacheTotal.isNew;

        if (!needReset && !util.equalArr(old, matrix)) {
          needReset = true;
        }

        if (needReset) {
          resetMatrixCacheTotal(__structs, i, _total8 || 0, _lv4, matrix);
        }

        __cacheTotal.__isNew = false;
        i += (_total8 || 0) + countMaskNum(__structs, i + (_total8 || 0) + 1, hasMask || 0);
      }
    }
  }
  /**
   * canvas/webgl支持任意节点为mask，不像svg仅单节点
   * hasMask的num是指遮罩对象后面的兄弟节点数，需要换算成包含子节点的总数
   * @param __structs
   * @param start
   * @param hasMask
   */


  function countMaskNum(__structs, start, hasMask) {
    var count = 0;

    while (hasMask--) {
      var total = __structs[start][STRUCT_TOTAL$1];
      count += total || 0;
      start += total || 0; // total不算自身，所以还得+1

      count++;
      start++;
    }

    return count;
  } // webgl不太一样，使用fbo离屏绘制到一个纹理上进行汇总


  function genFrameBufferWithTexture(gl, texCache, width, height) {
    var n = texCache.lockOneChannel();
    var texture = webgl.createTexture(gl, null, n, width, height);
    var frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    if (check !== gl.FRAMEBUFFER_COMPLETE) {
      inject.error('Framebuffer object is incomplete: ' + check.toString());
    } // 离屏窗口0开始


    gl.viewport(0, 0, width, height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return [n, frameBuffer, texture];
  }
  /**
   * 局部根节点复合图层生成，汇总所有子节点到一颗局部树上的位图缓存，包含超限特殊情况
   * 即便只有自己一个也要返回，因为webgl生成total的原因是有类似filter/mask等必须离屏处理的东西
   * @param gl
   * @param texCache
   * @param node
   * @param __config
   * @param index
   * @param total
   * @param __structs
   * @param cache
   * @param limitCache
   * @param hasMbm
   * @param W
   * @param H
   * @returns {*}
   */


  function genTotalWebgl(gl, texCache, node, __config, index, total, __structs, cache, limitCache, hasMbm, W, H) {
    // 存每层父亲的matrix和opacity和index，bbox计算过程中生成，缓存给下面渲染过程用
    var parentIndexHash = {};
    var opacityHash = {};

    var _genBboxTotal = genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, gl.getParameter(gl.MAX_TEXTURE_SIZE), limitCache),
        _genBboxTotal2 = _slicedToArray(_genBboxTotal, 2),
        bboxTotal = _genBboxTotal2[0],
        parentPm = _genBboxTotal2[1]; // 可能局部根节点合成过程中发现整体超限


    var totalLimitCache;

    if (!bboxTotal) {
      totalLimitCache = true;
    } // 超限情况生成画布大小的特殊纹理


    if (limitCache || totalLimitCache) {
      bboxTotal = [0, 0, W, H];
    }

    var width = bboxTotal[2] - bboxTotal[0];
    var height = bboxTotal[3] - bboxTotal[1];

    var _genFrameBufferWithTe = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe2 = _slicedToArray(_genFrameBufferWithTe, 3),
        n = _genFrameBufferWithTe2[0],
        frameBuffer = _genFrameBufferWithTe2[1],
        texture = _genFrameBufferWithTe2[2]; // 以bboxTotal的左上角为原点生成离屏texture


    var sx1 = node.__sx1,
        sy1 = node.__sy1;
    var cx = width * 0.5,
        cy = height * 0.5;
    var dx = -bboxTotal[0],
        dy = -bboxTotal[1];
    var dbx = sx1 - bboxTotal[0],
        dby = sy1 - bboxTotal[1]; // 先绘制自己的cache，起点所以matrix视作E为空，opacity固定1

    if (cache && cache.available) {
      texCache.addTexAndDrawWhenLimit(gl, cache, 1, null, cx, cy, dx, dy, false);
    } // limitCache无cache需先绘制到统一的离屏画布上
    else if (limitCache) {
      var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');
      node.render(mode.WEBGL, 0, gl, NA, 0, 0);
      var j = texCache.lockOneChannel();

      var _texture = webgl.createTexture(gl, c.canvas, j);

      var _mockCache = new MockCache(gl, _texture, 0, 0, width, height, [0, 0, width, height]);

      texCache.addTexAndDrawWhenLimit(gl, _mockCache, 1, null, cx, cy, 0, 0, false);
      texCache.refresh(gl, cx, cy);
      c.ctx.setTransform(1, 0, 0, 1, 0, 0);
      c.ctx.globalAlpha = 1;
      c.ctx.clearRect(0, 0, width, height);

      _mockCache.release();

      texCache.releaseLockChannel(j);
    } // 因为cacheTotal不总是以左上角原点为开始，所以必须每个节点重算matrix，合并box时计算的无法用到


    var matrixHash = {}; // 先序遍历汇总到total

    for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i3 = __structs[i],
          _node4 = _structs$i3[STRUCT_NODE$1],
          _total9 = _structs$i3[STRUCT_TOTAL$1],
          hasMask = _structs$i3[STRUCT_HAS_MASK$1];
      var _config3 = _node4.__config;
      var parentIndex = parentIndexHash[i];
      var matrix = matrixHash[parentIndex]; // 父节点的在每个节点计算后保存，第一个为top的默认为E（空）

      var opacity = opacityHash[i]; // opacity在合并box时已经计算可以直接用
      // 先看text，visibility会在内部判断，display会被parent判断

      if (_node4 instanceof Text) {
        if (parentPm) {
          matrix = multiply$2(parentPm, matrix);
        }

        texCache.addTexAndDrawWhenLimit(gl, _config3[NODE_CACHE$3], opacity, matrix, cx, cy, dx, dy, false);
      } // 再看total缓存/cache，都没有的是无内容的Xom节点
      else {
        var __cache = _config3[NODE_CACHE$3],
            __cacheTotal = _config3[NODE_CACHE_TOTAL$1],
            __cacheFilter = _config3[NODE_CACHE_FILTER$1],
            __cacheMask = _config3[NODE_CACHE_MASK$1],
            __cacheOverflow = _config3[NODE_CACHE_OVERFLOW$1],
            isMask = _config3[NODE_IS_MASK$2],
            _config3$NODE_COMPUTE = _config3[NODE_COMPUTED_STYLE$3],
            display = _config3$NODE_COMPUTE[DISPLAY$7],
            visibility = _config3$NODE_COMPUTE[VISIBILITY$5],
            transform = _config3$NODE_COMPUTE[TRANSFORM$4],
            transformOrigin = _config3$NODE_COMPUTE[TRANSFORM_ORIGIN$5],
            mixBlendMode = _config3$NODE_COMPUTE[MIX_BLEND_MODE$3];

        if (display === 'none') {
          i += (_total9 || 0) + countMaskNum(__structs, i + (_total9 || 0) + 1, hasMask || 0);
          continue;
        } // mask和不可见不能被汇总到top上


        if ((visibility === 'hidden' || isMask) && !_node4.hookGlRender) {
          continue;
        }

        if (transform && !isE$3(transform)) {
          var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

          if (__cache && __cache.available) {
            tfo[0] += __cache.sx1;
            tfo[1] += __cache.sy1;
          } else {
            tfo[0] += _node4.__sx1;
            tfo[1] += _node4.__sy1;
          }

          var _dx = -sx1 + dbx;

          var _dy = -sy1 + dby;

          tfo[0] += _dx;
          tfo[1] += _dy;
          var m = transform$1.calMatrixByOrigin(transform, tfo);

          if (matrix) {
            matrix = multiply$2(matrix, m);
          } else {
            matrix = m;
          }
        }

        if (matrix) {
          matrixHash[i] = matrix;
        }

        if (parentPm) {
          matrix = multiply$2(parentPm, matrix);
        }

        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, __cache]);

        if (target) {
          // 局部的mbm和主画布一样，先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
          if (isValidMbm$2(mixBlendMode)) {
            texCache.refresh(gl, cx, cy);

            var _genFrameBufferWithTe3 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe4 = _slicedToArray(_genFrameBufferWithTe3, 3),
                n2 = _genFrameBufferWithTe4[0],
                frameBuffer2 = _genFrameBufferWithTe4[1],
                texture2 = _genFrameBufferWithTe4[2];

            texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy, false);
            texCache.refresh(gl, cx, cy); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前fbo作为绘制对象

            var _genMbmWebgl = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName$2(mixBlendMode), width, height);

            var _genMbmWebgl2 = _slicedToArray(_genMbmWebgl, 3);

            n = _genMbmWebgl2[0];
            frameBuffer = _genMbmWebgl2[1];
            texture = _genMbmWebgl2[2];
            gl.deleteFramebuffer(frameBuffer2);
            gl.deleteTexture(texture2);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy, false);
          }

          if (target !== __cache) {
            i += (_total9 || 0) + countMaskNum(__structs, i + (_total9 || 0) + 1, hasMask || 0);
          }
        } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


        if (_node4.hookGlRender) {
          _node4.hookGlRender(gl, opacity, matrix, cx, cy, dx, dy, false);
        }
      }
    }

    if (node.hookGlRender) {
      node.hookGlRender(gl, 1, null, cx, cy, dx, dy, false);
    } // 绘制到fbo的纹理对象上并删除fbo恢复


    texCache.refresh(gl, cx, cy);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.deleteFramebuffer(frameBuffer); // 生成的纹理对象本身已绑定一个纹理单元了，释放lock的同时可以给texCache的channel缓存，避免重复上传

    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bboxTotal);
    texCache.releaseLockChannel(n, mockCache.page);
    return [limitCache || totalLimitCache, mockCache];
  }

  function genFilterWebgl(gl, texCache, node, cache, filter, W, H) {
    var sx1 = cache.sx1,
        sy1 = cache.sy1,
        width = cache.width,
        height = cache.height,
        bbox = cache.bbox;
    var mockCache = cache;
    filter.forEach(function (item) {
      var _item2 = _slicedToArray(item, 2),
          k = _item2[0],
          v = _item2[1];

      if (k === 'blur' && v > 0) {
        var res = genBlurWebgl(gl, texCache, mockCache, v, width, height, sx1, sy1, bbox);

        if (res) {
          var _res2 = _slicedToArray(res, 4);

          mockCache = _res2[0];
          width = _res2[1];
          height = _res2[2];
          bbox = _res2[3];
        }
      } else if (k === 'dropShadow') {
        var _res3 = genDropShadowWebgl(gl, texCache, mockCache, v, width, height, sx1, sy1, bbox);

        if (_res3) {
          var _res4 = _slicedToArray(_res3, 4);

          mockCache = _res4[0];
          width = _res4[1];
          height = _res4[2];
          bbox = _res4[3];
        }
      } else if (k === 'hueRotate') {
        var rotation = geom.d2r(v % 360);
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);

        var _res5 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + cosR * 0.787 - sinR * 0.213, 0.715 - cosR * 0.715 - sinR * 0.715, 0.072 - cosR * 0.072 + sinR * 0.928, 0, 0, 0.213 - cosR * 0.213 + sinR * 0.143, 0.715 + cosR * 0.285 + sinR * 0.140, 0.072 - cosR * 0.072 - sinR * 0.283, 0, 0, 0.213 - cosR * 0.213 - sinR * 0.787, 0.715 - cosR * 0.715 + sinR * 0.715, 0.072 + cosR * 0.928 + sinR * 0.072, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res5) {
          var _res6 = _slicedToArray(_res5, 4);

          mockCache = _res6[0];
          width = _res6[1];
          height = _res6[2];
          bbox = _res6[3];
        }
      } else if (k === 'saturate' && v !== 100) {
        var amount = v * 0.01;

        var _res7 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + 0.787 * amount, 0.715 - 0.715 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 + 0.285 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 - 0.715 * amount, 0.072 + 0.928 * amount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res7) {
          var _res8 = _slicedToArray(_res7, 4);

          mockCache = _res8[0];
          width = _res8[1];
          height = _res8[2];
          bbox = _res8[3];
        }
      } else if (k === 'brightness' && v !== 100) {
        var b = v * 0.01;

        var _res9 = genColorMatrixWebgl(gl, texCache, mockCache, [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res9) {
          var _res10 = _slicedToArray(_res9, 4);

          mockCache = _res10[0];
          width = _res10[1];
          height = _res10[2];
          bbox = _res10[3];
        }
      } else if (k === 'grayscale' && v > 0) {
        v = Math.min(v, 100);
        var oneMinusAmount = 1 - v * 0.01;

        if (oneMinusAmount < 0) {
          oneMinusAmount = 0;
        } else if (oneMinusAmount > 1) {
          oneMinusAmount = 1;
        }

        var _res11 = genColorMatrixWebgl(gl, texCache, mockCache, [0.2126 + 0.7874 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 + 0.2848 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 + 0.9278 * oneMinusAmount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res11) {
          var _res12 = _slicedToArray(_res11, 4);

          mockCache = _res12[0];
          width = _res12[1];
          height = _res12[2];
          bbox = _res12[3];
        }
      } else if (k === 'contrast' && v !== 100) {
        var _amount = v * 0.01;

        var o = -0.5 * _amount + 0.5;

        var _res13 = genColorMatrixWebgl(gl, texCache, mockCache, [_amount, 0, 0, 0, o, 0, _amount, 0, 0, o, 0, 0, _amount, 0, o, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res13) {
          var _res14 = _slicedToArray(_res13, 4);

          mockCache = _res14[0];
          width = _res14[1];
          height = _res14[2];
          bbox = _res14[3];
        }
      } else if (k === 'sepia' && v > 0) {
        v = Math.min(v, 100);

        var _oneMinusAmount = 1 - v * 0.01;

        if (_oneMinusAmount < 0) {
          _oneMinusAmount = 0;
        } else if (_oneMinusAmount > 1) {
          _oneMinusAmount = 1;
        }

        var _res15 = genColorMatrixWebgl(gl, texCache, mockCache, [0.393 + 0.607 * _oneMinusAmount, 0.769 - 0.769 * _oneMinusAmount, 0.189 - 0.189 * _oneMinusAmount, 0, 0, 0.349 - 0.349 * _oneMinusAmount, 0.686 + 0.314 * _oneMinusAmount, 0.168 - 0.168 * _oneMinusAmount, 0, 0, 0.272 - 0.272 * _oneMinusAmount, 0.534 - 0.534 * _oneMinusAmount, 0.131 + 0.869 * _oneMinusAmount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res15) {
          var _res16 = _slicedToArray(_res15, 4);

          mockCache = _res16[0];
          width = _res16[1];
          height = _res16[2];
          bbox = _res16[3];
        }
      } else if (k === 'invert' && v > 0) {
        v = Math.min(v, 100);

        var _o = v * 0.01;

        var _amount2 = 1 - 2 * _o;

        var _res17 = genColorMatrixWebgl(gl, texCache, mockCache, [_amount2, 0, 0, 0, _o, 0, _amount2, 0, 0, _o, 0, 0, _amount2, 0, _o, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res17) {
          var _res18 = _slicedToArray(_res17, 4);

          mockCache = _res18[0];
          width = _res18[1];
          height = _res18[2];
          bbox = _res18[3];
        }
      }
    }); // 切换回主程序

    gl.useProgram(gl.program);
    gl.viewport(0, 0, W, H);
    return mockCache;
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核d扩大3倍性能慢
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * 先动态生成gl程序，默认3核源码示例已注释，根据sigma获得d（一定奇数），再计算权重
   * 然后将d尺寸和权重拼接成真正程序并编译成program，再开始绘制
   */


  function genBlurWebgl(gl, texCache, cache, sigma, width, height, sx1, sy1, bbox) {
    var d = blur.kernelSize(sigma);
    var max = Math.max(15, gl.getParameter(gl.MAX_VARYING_VECTORS));

    while (d > max) {
      d -= 2;
    }

    var spread = blur.outerSizeByD(d); // 防止超限，webgl最大纹理尺寸限制

    var limit = gl.getParameter(gl.MAX_TEXTURE_SIZE);

    if (width > limit || height > limit) {
      return;
    }

    var bboxNew = bbox.slice(0);
    bboxNew[0] -= spread;
    bboxNew[1] -= spread;
    bboxNew[2] += spread;
    bboxNew[3] += spread;
    var widthNew = width + spread * 2;
    var heightNew = height + spread * 2;
    var cx = widthNew * 0.5,
        cy = heightNew * 0.5;
    var weights = blur.gaussianWeight(sigma, d);
    var vert = '';
    var frag = '';
    var r = Math.floor(d * 0.5);

    for (var _i4 = 0; _i4 < r; _i4++) {
      var c = (r - _i4) * 0.01;
      vert += "v_texCoordsBlur[".concat(_i4, "] = a_texCoords + vec2(-").concat(c, ", -").concat(c, ") * u_direction;");
      frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i4, "]) * ").concat(weights[_i4], ";");
    }

    vert += "v_texCoordsBlur[".concat(r, "] = a_texCoords;");
    frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(r, "]) * ").concat(weights[r], ";");

    for (var _i5 = 0; _i5 < r; _i5++) {
      var _c = (_i5 + 1) * 0.01;

      vert += "v_texCoordsBlur[".concat(_i5 + r + 1, "] = a_texCoords + vec2(").concat(_c, ", ").concat(_c, ") * u_direction;");
      frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i5 + r + 1, "]) * ").concat(weights[_i5 + r + 1], ";");
    }

    vert = vertexBlur.replace('[3]', '[' + d + ']').replace(/}$/, vert + '}');
    frag = fragmentBlur.replace('[3]', '[' + d + ']').replace(/}$/, frag + '}');
    var program = webgl.initShaders(gl, vert, frag);
    gl.useProgram(program);

    var _genFrameBufferWithTe5 = genFrameBufferWithTexture(gl, texCache, widthNew, heightNew),
        _genFrameBufferWithTe6 = _slicedToArray(_genFrameBufferWithTe5, 3),
        i = _genFrameBufferWithTe6[0],
        frameBuffer = _genFrameBufferWithTe6[1],
        texture = _genFrameBufferWithTe6[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    texture = webgl.drawBlur(gl, program, frameBuffer, texture, cache.page.texture, i, j, width, height, spread, widthNew, heightNew, cx, cy); // 销毁这个临时program

    gl.deleteShader(program.vertexShader);
    gl.deleteShader(program.fragmentShader);
    gl.deleteProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    texCache.releaseLockChannel(j);
    var mockCache = new MockCache(gl, texture, sx1, sy1, widthNew, heightNew, bboxNew);
    texCache.releaseLockChannel(i, mockCache.page);
    return [mockCache, widthNew, heightNew, bboxNew];
  }

  function genColorMatrixWebgl(gl, texCache, cache, m, width, height, sx1, sy1, bbox) {
    // 生成最终纹理，尺寸为被遮罩节点大小
    var _genFrameBufferWithTe7 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe8 = _slicedToArray(_genFrameBufferWithTe7, 3),
        i = _genFrameBufferWithTe8[0],
        frameBuffer = _genFrameBufferWithTe8[1],
        texture = _genFrameBufferWithTe8[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    gl.useProgram(gl.programCm);
    webgl.drawCm(gl, gl.programCm, j, m);
    texCache.releaseLockChannel(j); // 切回

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox.slice(0));
    texCache.releaseLockChannel(i, mockCache.page);
    return [mockCache, width, height, bbox];
  }

  function genOverflowWebgl(gl, texCache, node, cache, W, H) {
    var bbox = cache.bbox;
    var __sx1 = node.__sx1,
        __sy1 = node.__sy1,
        clientWidth = node.clientWidth,
        clientHeight = node.clientHeight;
    var xe = __sx1 + clientWidth;
    var ye = __sy1 + clientHeight; // 没超过无需生成

    if (bbox[0] >= __sx1 && bbox[1] >= __sy1 && bbox[2] <= xe && ye) {
      return;
    }

    var bboxNew = [__sx1, __sy1, xe, ye]; // 生成最终纹理，尺寸为被遮罩节点大小

    var _genFrameBufferWithTe9 = genFrameBufferWithTexture(gl, texCache, clientWidth, clientHeight),
        _genFrameBufferWithTe10 = _slicedToArray(_genFrameBufferWithTe9, 3),
        i = _genFrameBufferWithTe10[0],
        frameBuffer = _genFrameBufferWithTe10[1],
        texture = _genFrameBufferWithTe10[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    } // 绘制，根据坐标裁剪使用原本纹理的一部分


    gl.useProgram(gl.programOverflow);
    webgl.drawOverflow(gl, j, bboxNew[0] - bbox[0], bboxNew[1] - bbox[1], clientWidth, clientHeight, cache.width, cache.height);
    texCache.releaseLockChannel(j); // 切回

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

    var overflowCache = new MockCache(gl, texture, cache.sx1, cache.sy1, clientWidth, clientHeight, bboxNew);
    texCache.releaseLockChannel(i, overflowCache.page);
    return overflowCache;
  }

  function genMaskWebgl(gl, texCache, node, __config, cache, W, H, lv, __structs) {
    var sx1 = cache.sx1,
        sy1 = cache.sy1,
        width = cache.width,
        height = cache.height,
        bbox = cache.bbox,
        dx = cache.dx,
        dy = cache.dy; // cache一定是mockCache，可能是total/filter/overflow一种

    var cx = width * 0.5,
        cy = height * 0.5; // 先求得被遮罩的matrix，用作inverse给mask计算

    var _config$NODE_COMPUTE2 = __config[NODE_COMPUTED_STYLE$3],
        transform = _config$NODE_COMPUTE2[TRANSFORM$4],
        transformOrigin = _config$NODE_COMPUTE2[TRANSFORM_ORIGIN$5];
    var inverse;

    if (isE$3(transform)) {
      inverse = mx.identity();
    } else {
      var tfo = transformOrigin.slice(0);
      tfo[0] += sx1 + dx;
      tfo[1] += sy1 + dy;
      inverse = transform$1.calMatrixByOrigin(transform, tfo);
    }

    inverse = mx.inverse(inverse); // 将所有mask绘入一个单独纹理中，尺寸和原点与被遮罩total相同，才能做到顶点坐标一致

    var _genFrameBufferWithTe11 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe12 = _slicedToArray(_genFrameBufferWithTe11, 3),
        i = _genFrameBufferWithTe12[0],
        frameBuffer = _genFrameBufferWithTe12[1],
        texture = _genFrameBufferWithTe12[2];

    var next = node.next;
    var isClip = next.isClip;
    var list = [];

    while (next && next.isMask && next.isClip === isClip) {
      list.push(next);
      next = next.next;
    }

    for (var _i6 = 0, len = list.length; _i6 < len; _i6++) {
      var item = list[_i6];
      var matrixList = [];
      var parentMatrix = void 0;
      var lastMatrix = void 0;
      var opacityList = [];
      var parentOpacity = 1;
      var lastOpacity = void 0;
      var lastLv = lv;
      var _item$__config$NODE_S2 = item.__config[NODE_STRUCT$4],
          index = _item$__config$NODE_S2[STRUCT_INDEX$2],
          total = _item$__config$NODE_S2[STRUCT_TOTAL$1]; // 可以忽略mbm，因为只有透明遮罩

      for (var _i7 = index, _len4 = index + (total || 0) + 1; _i7 < _len4; _i7++) {
        var _structs$_i4 = __structs[_i7],
            _node5 = _structs$_i4[STRUCT_NODE$1],
            _lv5 = _structs$_i4[STRUCT_LV$2],
            _total10 = _structs$_i4[STRUCT_TOTAL$1],
            hasMask = _structs$_i4[STRUCT_HAS_MASK$1];
        var _config4 = _node5.__config;
        var __cache = _config4[NODE_CACHE$3],
            computedStyle = _config4[NODE_COMPUTED_STYLE$3],
            limitCache = _config4[NODE_LIMIT_CACHE$2]; // 跳过display:none元素和它的所有子节点和mask

        if (computedStyle[DISPLAY$7] === 'none') {
          _i7 += (_total10 || 0) + countMaskNum(__structs, _i7 + (_total10 || 0) + 1, hasMask || 0);
          continue;
        }

        if (_node5 instanceof Text) {
          if (__cache && __cache.available) {
            // text用父级的matrixEvent，在之前texCache添加到末尾了
            texCache.addTexAndDrawWhenLimit(gl, __cache, parentOpacity, texCache.last[2], cx, cy, 0, 0, true);
          } else if (limitCache) {
            return;
          }
        } else {
          var _cache = _config4[NODE_CACHE$3],
              __cacheMask = _config4[NODE_CACHE_MASK$1],
              __cacheFilter = _config4[NODE_CACHE_FILTER$1],
              __cacheOverflow = _config4[NODE_CACHE_OVERFLOW$1],
              __cacheTotal = _config4[NODE_CACHE_TOTAL$1],
              _config4$NODE_COMPUTE = _config4[NODE_COMPUTED_STYLE$3],
              opacity = _config4$NODE_COMPUTE[OPACITY$5],
              _transform2 = _config4$NODE_COMPUTE[TRANSFORM$4],
              _transformOrigin = _config4$NODE_COMPUTE[TRANSFORM_ORIGIN$5]; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理

          if (_i7 === index) ; else if (_lv5 > lastLv) {
            parentMatrix = lastMatrix;

            if (isE$3(parentMatrix)) {
              parentMatrix = null;
            }

            matrixList.push(parentMatrix);
            parentOpacity = lastOpacity;
            opacityList.push(parentOpacity);
          } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
          else if (_lv5 < lastLv) {
            var diff = lastLv - _lv5;
            matrixList.splice(-diff);
            parentMatrix = matrixList[_lv5 - 1];
            opacityList.splice(-diff);
            parentOpacity = opacityList[_lv5 - 1];
          } // 不变是同级兄弟，无需特殊处理 else {}


          lastLv = _lv5;
          var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, _cache]); // total和自身cache的尝试，visibility不可见时没有cache

          if (target) {
            var m = void 0;

            if (isE$3(_transform2)) {
              m = mx.identity();
            } else {
              var _tfo3 = _transformOrigin.slice(0);

              _tfo3[0] += target.bbox[0] + dx;
              _tfo3[1] += target.bbox[1] + dy;
              m = transform$1.calMatrixByOrigin(_transform2, _tfo3);
            }

            m = mx.multiply(inverse, m);

            var _tfo2 = _transformOrigin.slice(0);

            _tfo2[0] += target.bbox[0] + dx;
            _tfo2[1] += target.bbox[1] + dy;
            lastMatrix = transform$1.calMatrixByOrigin(_transform2, _tfo2);

            if (!isE$3(parentMatrix)) {
              lastMatrix = multiply$2(parentMatrix, lastMatrix);
            }

            lastOpacity = parentOpacity * opacity;
            texCache.addTexAndDrawWhenLimit(gl, target, lastOpacity, m, cx, cy, dx, dy, true);

            if (target !== _cache) {
              _i7 += (_total10 || 0) + countMaskNum(__structs, _i7 + (_total10 || 0) + 1, hasMask || 0);
            }
          } else if (limitCache) {
            return;
          }
        }
      }
    }

    texCache.refresh(gl, cx, cy);
    gl.deleteFramebuffer(frameBuffer); // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况mask变更引发的可能不在

    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    } // 生成最终纹理，汇总total和maskCache


    var _genFrameBufferWithTe13 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe14 = _slicedToArray(_genFrameBufferWithTe13, 3),
        n = _genFrameBufferWithTe14[0],
        frameBuffer2 = _genFrameBufferWithTe14[1],
        texture2 = _genFrameBufferWithTe14[2];

    var program;

    if (isClip) {
      program = gl.programClip;
    } else {
      program = gl.programMask;
    }

    gl.useProgram(program);
    webgl.drawMask(gl, i, j, program);
    gl.deleteTexture(texture);
    texCache.releaseLockChannel(i);
    texCache.releaseLockChannel(j); // 切换回主程序

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.deleteFramebuffer(frameBuffer2); // 同total一样生成一个mockCache

    var maskCache = new MockCache(gl, texture2, sx1, sy1, width, height, bbox);
    texCache.releaseLockChannel(n, maskCache.page);
    return maskCache;
  }
  /**
   * webgl的dropShadow只生成阴影部分，模糊复用blur，然后进行拼合
   * @param gl
   * @param texCache
   * @param cache
   * @param v
   * @param width
   * @param height
   * @param sx1
   * @param sy1
   * @param bbox
   * @returns {*[]}
   */


  function genDropShadowWebgl(gl, texCache, cache, v, width, height, sx1, sy1, bbox) {
    // 先清空之前所有绘制遗留
    texCache.refresh(gl, width * 0.5, height * 0.5); // 先根据x/y/color生成单色阴影

    var _v = _slicedToArray(v, 5),
        x = _v[0],
        y = _v[1],
        blur = _v[2],
        color = _v[4];

    var _genFrameBufferWithTe15 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe16 = _slicedToArray(_genFrameBufferWithTe15, 3),
        i = _genFrameBufferWithTe16[0],
        frameBuffer = _genFrameBufferWithTe16[1],
        texture = _genFrameBufferWithTe16[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    gl.useProgram(gl.programDs);
    texture = webgl.drawDropShadow(gl, gl.programDs, frameBuffer, texture, cache.page.texture, i, j, width, height, color); // 部分清除

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    var bboxOld = bbox;
    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox.slice(0)); // 复用blur先生成模糊的阴影

    var res = genBlurWebgl(gl, texCache, mockCache, blur, width, height, sx1, sy1, bbox);
    texCache.releaseLockChannel(j); // 不管后续成功如何，都先释放阴影的lock

    gl.useProgram(gl.program);

    if (res) {
      gl.deleteTexture(texture); // 有模糊的阴影后删除之前无模糊的临时阴影

      var _res19 = _slicedToArray(res, 4);

      mockCache = _res19[0];
      width = _res19[1];
      height = _res19[2];
      bbox = _res19[3];

      // 根据dropShadow的x/y偏移重置模糊阴影的相关数据
      if (x || y) {
        bbox[0] += x;
        bbox[1] += y;
        bbox[2] += x;
        bbox[3] += y; // 把模糊阴影当做一张普通的图片

        mockCache.sx1 = bbox[0];
        mockCache.sy1 = bbox[1];
        mockCache.reOffset();
      }

      var bboxMerge = bboxOld.slice(0);
      mergeBbox(bboxMerge, bbox, 0, 0); // 合并原本cache和blur的纹理为最终对象，i是最初的cache，j是

      width = bboxMerge[2] - bboxMerge[0];
      height = bboxMerge[3] - bboxMerge[1];
      var cx = width * 0.5,
          cy = height * 0.5;
      var dx = -bboxMerge[0],
          dy = -bboxMerge[1];

      var _genFrameBufferWithTe17 = genFrameBufferWithTexture(gl, texCache, width, height),
          _genFrameBufferWithTe18 = _slicedToArray(_genFrameBufferWithTe17, 3),
          k = _genFrameBufferWithTe18[0],
          _frameBuffer = _genFrameBufferWithTe18[1],
          texture2 = _genFrameBufferWithTe18[2]; // 以merge的bbox的左上角为原点，每个cache要换算一下


      texCache.addTexAndDrawWhenLimit(gl, cache, 1, null, cx, cy, dx, dy, false);
      texCache.addTexAndDrawWhenLimit(gl, mockCache, 1, null, cx, cy, dx, dy, false);
      texCache.refresh(gl, cx, cy, false); // 回收

      texCache.releaseLockChannel(i);
      texCache.releaseLockChannel(k);
      gl.deleteFramebuffer(_frameBuffer); // 同total一样生成一个mockCache，数据和本身一样

      var mockCache2 = new MockCache(gl, texture2, sx1, sy1, width, height, bboxMerge);
      texCache.releaseLockChannel(k, mockCache.page);
      return [mockCache2, width, height, bboxMerge];
    }
  }
  /**
   * 生成blendMode混合fbo纹理结果，原本是所有元素向一个fbo记A进行绘制，当出现mbm时，进入到这里，
   * 先生成一个新的fbo记B，将A和待混合节点进行对应的mbm模式混合，结果绘制到B中，然后返回B来替换A，包括纹理单元
   * @param gl
   * @param texCache
   * @param i 之前已有的fbo和纹理单元
   * @param j 当前节点绘制的fbo和纹理单元
   * @param mbm
   * @param fbo 之前舞台绑定的fbo和纹理
   * @param tex
   * @param W
   * @param H
   * @returns {number|*}
   */


  function genMbmWebgl(gl, texCache, i, j, fbo, tex, mbm, W, H) {
    var frag;
    mbm = mbmName$2(mbm);

    if (mbm === 'multiply') {
      frag = fragmentMultiply;
    } else if (mbm === 'screen') {
      frag = fragmentScreen;
    } else if (mbm === 'overlay') {
      frag = fragmentOverlay;
    } else if (mbm === 'darken') {
      frag = fragmentDarken;
    } else if (mbm === 'lighten') {
      frag = fragmentLighten;
    } else if (mbm === 'color-dodge') {
      frag = fragmentColorDodge;
    } else if (mbm === 'color-burn') {
      frag = fragmentColorBurn;
    } else if (mbm === 'hard-light') {
      frag = fragmentHardLight;
    } else if (mbm === 'soft-light') {
      frag = fragmentSoftLight;
    } else if (mbm === 'difference') {
      frag = fragmentDifference;
    } else if (mbm === 'exclusion') {
      frag = fragmentExclusion;
    } else if (mbm === 'hue') {
      frag = fragmentHue;
    } else if (mbm === 'saturation') {
      frag = fragmentSaturation;
    } else if (mbm === 'color') {
      frag = fragmentColor;
    } else if (mbm === 'luminosity') {
      frag = fragmentLuminosity;
    }

    var program = webgl.initShaders(gl, vertexMbm, frag);
    gl.useProgram(program); // 生成新的fbo，将混合结果绘入

    var _genFrameBufferWithTe19 = genFrameBufferWithTexture(gl, texCache, W, H),
        _genFrameBufferWithTe20 = _slicedToArray(_genFrameBufferWithTe19, 3),
        n = _genFrameBufferWithTe20[0],
        frameBuffer = _genFrameBufferWithTe20[1],
        texture = _genFrameBufferWithTe20[2];

    webgl.drawMbm(gl, program, i, j, W, H); // 切换回主程序并销毁这个临时program

    gl.useProgram(gl.program);
    gl.deleteShader(program.vertexShader);
    gl.deleteShader(program.fragmentShader);
    gl.deleteProgram(program);
    gl.deleteFramebuffer(fbo);
    gl.deleteTexture(tex);
    texCache.releaseLockChannel(i);
    texCache.releaseLockChannel(j);
    return [n, frameBuffer, texture];
  }

  function renderSvg(renderMode, ctx, root, isFirst) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height; // mask节点很特殊，本身有matrix会影响，本身没改变但对象节点有改变也需要计算逆矩阵应用顶点

    var maskEffectHash = {};

    if (!isFirst) {
      // 先遍历一遍收集完全不变的defs，缓存起来id，随后再执行遍历渲染生成新的，避免掉重复的id
      for (var i = 0, len = __structs.length; i < len; i++) {
        var _structs$i4 = __structs[i],
            node = _structs$i4[STRUCT_NODE$1],
            total = _structs$i4[STRUCT_TOTAL$1],
            hasMask = _structs$i4[STRUCT_HAS_MASK$1];
        var _node$__config = node.__config,
            refreshLevel = _node$__config[NODE_REFRESH_LV$1],
            defsCache = _node$__config[NODE_DEFS_CACHE$5]; // 只要涉及到matrix和opacity就影响mask

        var hasEffectMask = hasMask && (refreshLevel >= REPAINT$2 || contain$2(refreshLevel, TRANSFORM_ALL$1 | OP));

        if (hasEffectMask) {
          var start = i + (total || 0) + 1;
          var end = start + hasMask; // mask索引遍历时处理，暂存遮罩对象的刷新lv

          maskEffectHash[end - 1] = refreshLevel;
        } // >=REPAINT重绘生成走render()跳过这里


        if (refreshLevel < REPAINT$2) {
          // 特殊的mask判断，遮罩对象影响这个mask了，除去filter、遮罩对象无TRANSFORM变化外都可缓存
          if (maskEffectHash.hasOwnProperty(i)) {
            var v = maskEffectHash[i];

            if (!contain$2(refreshLevel, TRANSFORM_ALL$1) && v < REPAINT$2 && !contain$2(v, TRANSFORM_ALL$1)) {
              defsCache.forEach(function (item) {
                ctx.addCache(item);
              });
            }
          } // 去除特殊的filter，普通节点或不影响的mask在<REPAINT下defs的其它都可缓存
          else {
            defsCache.forEach(function (item) {
              ctx.addCache(item);
            });
          }
        }
      }
    }

    var maskHash = {}; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var matrixList = [];
    var parentMatrix;
    var vdList = [];
    var parentVd;
    var lastLv = 0;
    var lastConfig;

    for (var _i8 = 0, _len5 = __structs.length; _i8 < _len5; _i8++) {
      var _structs$_i5 = __structs[_i8],
          _node6 = _structs$_i5[STRUCT_NODE$1],
          _total11 = _structs$_i5[STRUCT_TOTAL$1],
          _hasMask4 = _structs$_i5[STRUCT_HAS_MASK$1],
          lv = _structs$_i5[STRUCT_LV$2];
      var __config = _node6.__config;
      var __cacheTotal = __config[NODE_CACHE_TOTAL$1],
          _refreshLevel4 = __config[NODE_REFRESH_LV$1],
          _defsCache = __config[NODE_DEFS_CACHE$5],
          computedStyle = __config[NODE_COMPUTED_STYLE$3];
      var display = computedStyle[DISPLAY$7]; // 将随后的若干个mask节点范围存下来

      if (_hasMask4 && display !== 'none') {
        var _start = _i8 + (_total11 || 0) + 1;

        var _end = _start + _hasMask4; // svg限制了只能Geom单节点，不可能是Dom，所以end只有唯一


        maskHash[_end - 1] = {
          index: _i8,
          start: _start,
          end: _end,
          isClip: __structs[_start][STRUCT_NODE$1].isClip // 第一个节点是clip为准

        };
      } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点第一个特殊处理


      if (lv < lastLv) {
        var diff = lastLv - lv;
        matrixList.splice(-diff);
        parentMatrix = matrixList[lv - 1];
        vdList.splice(-diff);
        parentVd = vdList[lv - 1];
      } else if (lv > lastLv) {
        matrixList.push(lastConfig[NODE_MATRIX$3]);
        var vd = lastConfig[NODE_VIRTUAL_DOM$3];
        vdList.push(vd);
        parentVd = vd;
      }

      lastConfig = __config;
      var virtualDom = void 0; // svg小刷新等级时直接修改vd，这样Geom不再感知

      if (_refreshLevel4 < REPAINT$2 && !(_node6 instanceof Text)) {
        __config[NODE_REFRESH_LV$1] = NONE$2;
        virtualDom = __config[NODE_VIRTUAL_DOM$3]; // total可以跳过所有孩子节点省略循环

        if (__cacheTotal && __cacheTotal.available) {
          _i8 += _total11 || 0;
          virtualDom.cache = true;
        } else {
          __cacheTotal && (__cacheTotal.available = true);
          virtualDom = __config[NODE_VIRTUAL_DOM$3] = _node6.__virtualDom = util.extend({}, virtualDom); // dom要清除children缓存，geom和img无需

          if (_node6 instanceof Dom$1 && !(_node6 instanceof Img$1)) {
            virtualDom.children = [];
          } // 还得判断，和img加载混在一起时，触发刷新如果display:none，则还有cacheTotal


          if (display === 'none') {
            _i8 += _total11 || 0;

            if (_hasMask4) {
              _i8 += _hasMask4;
            }
          } else {
            delete virtualDom.cache;
          }
        }

        var currentStyle = __config[NODE_CURRENT_STYLE$5],
            _computedStyle4 = __config[NODE_COMPUTED_STYLE$3],
            __cacheStyle = __config[NODE_CACHE_STYLE$1];

        if (contain$2(_refreshLevel4, TRANSFORM_ALL$1)) {
          var matrix = _node6.__calMatrix(_refreshLevel4, __cacheStyle, currentStyle, _computedStyle4, __config); // 恶心的v8性能优化


          var m = __config[NODE_MATRIX$3];
          assignMatrix$1(m, matrix);

          if (!matrix || isE$3(matrix)) {
            delete virtualDom.transform;
          } else {
            virtualDom.transform = 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')';
          }

          if (parentMatrix && matrix) {
            matrix = multiply$2(parentMatrix, matrix);
          } // 恶心的v8性能优化


          m = __config[NODE_MATRIX_EVENT$4];
          assignMatrix$1(m, matrix);
        }

        if (contain$2(_refreshLevel4, OP)) {
          var opacity = _computedStyle4[OPACITY$5] = currentStyle[OPACITY$5];

          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        }

        if (contain$2(_refreshLevel4, FT)) {
          var filter = _node6.__calFilter(currentStyle, _computedStyle4);

          var s = painter.svgFilter(filter);

          if (s) {
            virtualDom.filter = s;
          } else {
            delete virtualDom.filter;
          }
        }

        if (contain$2(_refreshLevel4, MBM)) {
          var mixBlendMode = _computedStyle4[MIX_BLEND_MODE$3] = currentStyle[MIX_BLEND_MODE$3];

          if (isValidMbm$2(mixBlendMode)) {
            virtualDom.mixBlendMode = mbmName$2(mixBlendMode);
          } else {
            delete virtualDom.mixBlendMode;
          }
        }

        virtualDom.lv = _refreshLevel4;
      } else {
        // >=REPAINT会调用render，重新生成defsCache，text没有这个东西
        __config[NODE_DEFS_CACHE$5] && __config[NODE_DEFS_CACHE$5].splice(0);

        _node6.render(renderMode, _refreshLevel4, ctx, NA, 0, 0);

        virtualDom = __config[NODE_VIRTUAL_DOM$3]; // 渲染后更新取值

        display = computedStyle[DISPLAY$7];

        if (display === 'none') {
          _i8 += _total11 || 0;

          if (_hasMask4) {
            _i8 += _hasMask4;
          }
        }
      }
      /**
       * mask会在join时过滤掉，这里将假设正常渲染的vd的内容获取出来组成defs的mask内容
       * 另外最初遍历时记录了会影响的mask，在<REPAINT时比较，>=REPAINT始终重新设置
       * 本身有matrix也需要重设
       */


      if (maskHash.hasOwnProperty(_i8) && (maskEffectHash.hasOwnProperty(_i8) || _refreshLevel4 >= REPAINT$2 || contain$2(_refreshLevel4, TRANSFORM_ALL$1 | OP))) {
        var _maskHash$_i = maskHash[_i8],
            index = _maskHash$_i.index,
            _start2 = _maskHash$_i.start,
            _end2 = _maskHash$_i.end,
            isClip = _maskHash$_i.isClip;
        var target = __structs[index];
        var dom = target[STRUCT_NODE$1];
        var mChildren = []; // clip模式时，先添加兜底整个白色使得全部都可见，mask本身变反色（黑色）

        if (isClip) {
          mChildren.push({
            type: 'item',
            tagName: 'path',
            props: [['d', "M0,0L".concat(width, ",0L").concat(width, ",").concat(height, "L0,").concat(height, "L0,0")], ['fill', 'rgba(255,255,255,1)'], ['stroke-width', 0]]
          });
        }

        for (var j = _start2; j < _end2; j++) {
          var _node7 = __structs[j][STRUCT_NODE$1];
          var _node7$computedStyle = _node7.computedStyle,
              _display2 = _node7$computedStyle[DISPLAY$7],
              visibility = _node7$computedStyle[VISIBILITY$5],
              fill = _node7$computedStyle[FILL$2],
              _node7$virtualDom = _node7.virtualDom,
              children = _node7$virtualDom.children,
              _opacity2 = _node7$virtualDom.opacity;

          if (_display2 !== 'none' && visibility !== 'hidden') {
            // 引用相同无法diff，需要clone
            children = util.clone(children);
            mChildren = mChildren.concat(children);

            for (var k = 0, _len6 = children.length; k < _len6; k++) {
              var _children$k = children[k],
                  tagName = _children$k.tagName,
                  props = _children$k.props;

              if (tagName === 'path') {
                if (isClip) {
                  for (var _j10 = 0, _len7 = props.length; _j10 < _len7; _j10++) {
                    var item = props[_j10];

                    if (item[0] === 'fill') {
                      item[1] = util.int2invert(fill[0]);
                    }
                  }
                }

                var _matrix3 = _node7.matrix;
                var ivs = inverse$1(dom.matrix);
                _matrix3 = multiply$2(ivs, _matrix3); // path没有transform属性，在vd上，需要弥补

                props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_matrix3), ','), ")")]); // path没有opacity属性，在vd上，需要弥补

                if (!util.isNil(_opacity2) && _opacity2 !== 1) {
                  props.push(['opacity', _opacity2]);
                }
              } // img可能有matrix属性，需判断
              else if (tagName === 'image') {
                var hasTransform = -1;

                for (var _m2 = 0, _len8 = props.length; _m2 < _len8; _m2++) {
                  if (props[_m2][0] === 'transform') {
                    hasTransform = _m2;
                    break;
                  }
                }

                if (hasTransform === -1) {
                  var _ivs = inverse$1(dom.matrix);

                  if (!isE$3(_ivs)) {
                    props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_ivs), ','), ")")]);
                  }
                } else {
                  var _matrix4 = props[hasTransform][1].match(/[\d.]+/g).map(function (i) {
                    return parseFloat(i);
                  });

                  var _ivs2 = inverse$1(dom.matrix);

                  _matrix4 = multiply$2(_ivs2, _matrix4);
                  props[hasTransform][1] = "matrix(".concat(util.joinArr(mx.m2m6(_matrix4), ','), ")");
                }
              }
            }
          }
        } // 清掉上次的


        for (var _i9 = _defsCache.length - 1; _i9 >= 0; _i9--) {
          var _item3 = _defsCache[_i9];

          if (_item3.tagName === 'mask') {
            _defsCache.splice(_i9, 1);
          }
        }

        var o = {
          tagName: 'mask',
          props: [],
          children: mChildren
        };
        var id = ctx.add(o);

        _defsCache.push(o);

        id = 'url(#' + id + ')';
        dom.virtualDom.mask = id;
      } // mask不入children


      if (parentVd && !_node6.isMask) {
        parentVd.children.push(virtualDom);
      }

      if (_i8 === 0) {
        parentMatrix = __config[NODE_MATRIX$3];
        parentVd = virtualDom;
      }

      lastLv = lv;
    }
  }

  function renderWebgl(renderMode, gl, root) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height,
        texCache = root.texCache;
    var cx = width * 0.5,
        cy = height * 0.5; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var matrixList = [];
    var parentMatrix;
    var opacityList = [];
    var parentOpacity = 1;
    var pmList = [];
    var parentPm;
    var lastRefreshLevel;
    var lastConfig;
    var lastLv = 0;
    var mergeList = [];
    var hasMbm; // 是否有混合模式出现

    /**
     * 先一遍先序遍历每个节点绘制到自己__cache上，排除Text和已有的缓存以及局部根缓存，
     * 根据refreshLevel进行等级区分，可能是<REPAINT或>=REPAINT，REFLOW布局已前置处理完。
     * 首次绘制没有catchTotal等，后续则可能会有，在<REPAINT可据此跳过所有子节点加快循环，布局过程会提前删除它们。
     * lv的变化根据大小相等进行出入栈parent操作，实现获取节点parent数据的方式，
     * 同时过程中计算出哪些节点要生成局部根，存下来
     */

    for (var i = 0, len = __structs.length; i < len; i++) {
      var _structs$i5 = __structs[i],
          node = _structs$i5[STRUCT_NODE$1],
          lv = _structs$i5[STRUCT_LV$2],
          total = _structs$i5[STRUCT_TOTAL$1],
          hasMask = _structs$i5[STRUCT_HAS_MASK$1]; // Text特殊处理，webgl中先渲染为bitmap，再作为贴图绘制，缓存交由text内部判断，直接调用渲染纹理方法

      if (node instanceof Text) {
        if (lastRefreshLevel >= REPAINT$2) {
          node.render(renderMode, REPAINT$2, gl, SELF, 0, 0);
        }

        continue;
      }

      var __config = node.__config;
      var refreshLevel = __config[NODE_REFRESH_LV$1]; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点是第一个特殊处理

      if (i === 0) ; else if (lv > lastLv) {
        parentMatrix = lastConfig[NODE_MATRIX_EVENT$4];

        if (isE$3(parentMatrix)) {
          parentMatrix = null;
        }

        matrixList.push(parentMatrix);
        parentOpacity = lastConfig[NODE_OPACITY$2];
        opacityList.push(parentOpacity);
        parentPm = lastConfig[NODE_PERSPECTIVE_MATRIX$1];

        if (isE$3(parentPm)) {
          parentPm = null;
        }

        pmList.push(parentPm);
      } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
      else if (lv < lastLv) {
        var diff = lastLv - lv;
        matrixList.splice(-diff);
        parentMatrix = matrixList[lv - 1];
        opacityList.splice(-diff);
        parentOpacity = opacityList[lv - 1];
        pmList.splice(-diff);
        parentPm = pmList[lv - 1];
      } // 不变是同级兄弟，无需特殊处理 else {}


      lastRefreshLevel = refreshLevel;
      lastConfig = __config;
      lastLv = lv;
      var __cacheTotal = __config[NODE_CACHE_TOTAL$1],
          computedStyle = __config[NODE_COMPUTED_STYLE$3]; // 跳过display:none元素和它的所有子节点

      if (computedStyle[DISPLAY$7] === 'none') {
        i += total || 0; // 只跳过自身不能跳过后面的mask，mask要渲染自身并进行缓存cache，以备对象切换display用

        continue;
      }

      var hasRecordAsMask = void 0;
      /**
       * lv<REPAINT，一般会有__cache，跳过渲染过程，快速运算，没有cache则是自身超限或无内容，目前不感知
       * 可能有cacheTotal，为之前生成的局部根，清除逻辑在更新检查是否>=REPAINT那里，小变化不动
       * 当有遮罩时，如果被遮罩节点本身无变更，需要检查其next的遮罩节点有无变更，
       * 但其实不用检查，因为next变更一定会清空cacheMask，只要检查cacheMask即可
       * 如果没有或无效，直接添加，无视节点本身变化，后面防重即可
       */

      if (refreshLevel < REPAINT$2) {
        __config[NODE_REFRESH_LV$1] = NONE$2;
        var currentStyle = __config[NODE_CURRENT_STYLE$5],
            __cacheStyle = __config[NODE_CACHE_STYLE$1],
            matrixEvent = __config[NODE_MATRIX_EVENT$4];

        if (contain$2(refreshLevel, PPT)) {
          node.__calPerspective(__cacheStyle, currentStyle, computedStyle, __config);
        } // transform变化，父元素的perspective变化也会在Root特殊处理重新计算


        var matrix = void 0;

        if (contain$2(refreshLevel, TRANSFORM_ALL$1)) {
          matrix = node.__calMatrix(refreshLevel, __cacheStyle, currentStyle, computedStyle, __config);
          assignMatrix$1(__config[NODE_MATRIX$3], matrix);
        } else {
          matrix = __config[NODE_MATRIX$3];
        } // 先左乘perspective的矩阵，再左乘父级的总矩阵


        if (parentPm) {
          matrix = multiply$2(parentPm, matrix);
        }

        if (parentMatrix) {
          matrix = multiply$2(parentMatrix, matrix);
        } // 恶心的v8性能优化


        assignMatrix$1(matrixEvent, matrix);
        var opacity = void 0;

        if (contain$2(refreshLevel, OP)) {
          opacity = computedStyle[OPACITY$5] = currentStyle[OPACITY$5];
        } else {
          opacity = computedStyle[OPACITY$5];
        }

        __config[NODE_OPACITY$2] = parentOpacity * opacity; // filter会改变bbox范围

        if (contain$2(refreshLevel, FT)) {
          node.__bbox = null;
          node.__filterBbox = null;

          node.__calFilter(currentStyle, computedStyle);
        }

        if (contain$2(refreshLevel, MBM)) {
          computedStyle[MIX_BLEND_MODE$3] = currentStyle[MIX_BLEND_MODE$3];
        } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


        if (__cacheTotal && __cacheTotal.available) {
          i += total || 0;
        }
      }
      /**
       * >=REPAINT重新渲染，并根据结果判断是否离屏限制错误
       * Geom没有子节点无需汇总局部根，Dom中Img也是，它们的局部根等于自身的cache，其它符合条件的Dom需要生成
       */
      else {
        var res = node.render(renderMode, refreshLevel, gl, SELF, 0, 0); // geom可返回texture纹理，替代原有xom的__cache纹理

        if (res && inject.isWebGLTexture(res.texture)) {
          var _sx2 = node.__sx1,
              _sy2 = node.__sy1,
              w = node.offsetWidth,
              h = node.offsetHeight,
              bbox = node.bbox;
          __config[NODE_CACHE$3] = new MockCache(gl, res.texture, _sx2, _sy2, w, h, bbox);
          gl.viewport(0, 0, width, height);
          gl.useProgram(gl.program);
        }
      } // 每个元素检查cacheTotal生成，已有的上面会continue跳过


      var limitCache = __config[NODE_LIMIT_CACHE$2],
          cacheAsBitmap = __config[NODE_CACHE_AS_BITMAP$1];
      var overflow = computedStyle[OVERFLOW$3],
          filter = computedStyle[FILTER$6],
          mixBlendMode = computedStyle[MIX_BLEND_MODE$3],
          transform = computedStyle[TRANSFORM$4];
      var validMbm = isValidMbm$2(mixBlendMode); // 3d渲染上下文

      var isPerspective = transform$1.isPerspectiveMatrix(transform) || parentPm;

      if (cacheAsBitmap || hasMask || filter.length || overflow === 'hidden' && total || validMbm || isPerspective) {
        if (validMbm) {
          hasMbm = true;
        }

        if (hasRecordAsMask) {
          hasRecordAsMask[5] = limitCache;
          hasRecordAsMask[7] = filter;
          hasRecordAsMask[8] = overflow;
          hasRecordAsMask[9] = isPerspective;
          hasRecordAsMask[10] = cacheAsBitmap;
        } else {
          mergeList.push([i, lv, total, node, __config, limitCache, hasMask, filter, overflow, isPerspective, cacheAsBitmap]);
        }
      }
    }

    var limitHash = {}; // 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
    // 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩

    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a[1] === b[1]) {
          return b[0] - a[0];
        }

        return b[1] - a[1];
      }); // ppt只有嵌套才需要生成，最下面的孩子节点的ppt无需，因此记录一个hash存index，
      // 同时因为是后序遍历，孩子先存所有父亲的index即可保证父亲才能生成cacheTotal

      var pptHash = {};
      mergeList.forEach(function (item) {
        var _item4 = _slicedToArray(item, 11),
            i = _item4[0],
            lv = _item4[1],
            total = _item4[2],
            node = _item4[3],
            __config = _item4[4],
            limitCache = _item4[5],
            hasMask = _item4[6],
            filter = _item4[7],
            overflow = _item4[8],
            isPerspective = _item4[9],
            cacheAsBitmap = _item4[10]; // 有ppt的，向上查找所有父亲index记录，可能出现重复记得提前跳出


        if (isPerspective) {
          var parent = __config[NODE_DOM_PARENT$5];

          while (parent) {
            var config = parent.__config;
            var idx = config[NODE_STRUCT$4][STRUCT_INDEX$2];

            if (pptHash[idx]) {
              break;
            }

            if (transform$1.isPerspectiveMatrix(config[NODE_MATRIX$3]) || config[NODE_PERSPECTIVE_MATRIX$1]) {
              pptHash[idx] = true;
            }

            parent = config[NODE_DOM_PARENT$5];
          }

          if (!pptHash[i] && !hasMask && !filter.length && overflow !== 'hidden' && !cacheAsBitmap) {
            return;
          }
        }

        var __cache = __config[NODE_CACHE$3],
            __cacheTotal = __config[NODE_CACHE_TOTAL$1],
            __cacheFilter = __config[NODE_CACHE_FILTER$1],
            __cacheMask = __config[NODE_CACHE_MASK$1],
            __cacheOverflow = __config[NODE_CACHE_OVERFLOW$1];
        var needGen; // 可能没变化，比如被遮罩节点、filter变更等

        if (!__cacheTotal || !__cacheTotal.available) {
          var _genTotalWebgl = genTotalWebgl(gl, texCache, node, __config, i, total || 0, __structs, __cache, limitCache, hasMbm, width, height),
              _genTotalWebgl2 = _slicedToArray(_genTotalWebgl, 2),
              limit = _genTotalWebgl2[0],
              _res20 = _genTotalWebgl2[1];

          __cacheTotal = _res20;
          needGen = true;
          limitCache = limit; // 返回的limit包含各种情况超限，一旦超限，只能生成临时cacheTotal不能保存

          if (!limitCache) {
            __config[NODE_CACHE_TOTAL$1] = _res20;
          }
        } // 即使超限，也有total结果


        var target = __cacheTotal;

        if (overflow === 'hidden') {
          if (!__cacheOverflow || !__cacheOverflow.available || needGen) {
            var temp = genOverflowWebgl(gl, texCache, node, target, width, height);

            if (temp) {
              target = temp;
              needGen = true;

              if (!limitCache) {
                __config[NODE_CACHE_OVERFLOW$1] = target;
              }
            }
          } else {
            target = __cacheOverflow;
          }
        }

        if (filter.length) {
          if (!__cacheFilter || !__cacheFilter.available || needGen) {
            var old = target;
            target = genFilterWebgl(gl, texCache, node, target, filter, width, height);

            if (target !== old) {
              needGen = true;

              if (!limitCache) {
                __config[NODE_CACHE_FILTER$1] = target;
              }
            }
          } else {
            target = __cacheFilter;
          }
        }

        if (hasMask && (!__cacheMask || !__cacheMask.available || needGen)) {
          target = genMaskWebgl(gl, texCache, node, __config, target, width, height, lv, __structs);

          if (!limitCache) {
            __config[NODE_CACHE_MASK$1] = target;
          }
        } // 保存临时的局部根节点


        if (limitCache) {
          limitHash[i] = target;
        }
      });
    }
    /**
     * 最后先序遍历一次应用__cacheTotal即可，没有的用__cache，以及剩下的超尺寸的和Text
     * 由于mixBlendMode的存在，需先申请个fbo纹理，所有绘制默认向该纹理绘制，最后fbo纹理再进入主画布
     * 前面循环时有记录是否出现mbm，只有出现才申请，否则不浪费直接输出到主画布
     * 超尺寸的要走无cache逻辑render，和canvas很像，除了离屏canvas超限，汇总total也会纹理超限
     */


    var n, frameBuffer, texture;

    if (hasMbm) {
      var _genFrameBufferWithTe21 = genFrameBufferWithTexture(gl, texCache, width, height);

      var _genFrameBufferWithTe22 = _slicedToArray(_genFrameBufferWithTe21, 3);

      n = _genFrameBufferWithTe22[0];
      frameBuffer = _genFrameBufferWithTe22[1];
      texture = _genFrameBufferWithTe22[2];
    }

    for (var _i10 = 0, _len9 = __structs.length; _i10 < _len9; _i10++) {
      var _structs$_i6 = __structs[_i10],
          _node8 = _structs$_i6[STRUCT_NODE$1],
          _total12 = _structs$_i6[STRUCT_TOTAL$1],
          _hasMask5 = _structs$_i6[STRUCT_HAS_MASK$1];
      var _config5 = _node8.__config; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_node8 instanceof Text) {
        // text特殊之处，__config部分是复用parent的
        var __cache = _config5[NODE_CACHE$3],
            _limitCache = _config5[NODE_LIMIT_CACHE$2],
            _config5$NODE_DOM_PAR = _config5[NODE_DOM_PARENT$5].__config,
            _matrixEvent = _config5$NODE_DOM_PAR[NODE_MATRIX_EVENT$4],
            _opacity3 = _config5$NODE_DOM_PAR[NODE_OPACITY$2];

        if (__cache && __cache.available) {
          texCache.addTexAndDrawWhenLimit(gl, __cache, _opacity3, _matrixEvent, cx, cy, 0, 0, true);
        } // 超限特殊处理，先生成画布尺寸大小的纹理然后原始位置绘制
        else if (_limitCache) {
          var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

          _node8.render(renderMode, 0, gl, NA, 0, 0);

          var j = texCache.lockOneChannel();

          var _texture2 = webgl.createTexture(gl, c.canvas, j);

          var mockCache = new MockCache(gl, _texture2, 0, 0, width, height, [0, 0, width, height]);
          texCache.addTexAndDrawWhenLimit(gl, mockCache, _opacity3, _matrixEvent, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true);
          c.ctx.setTransform(1, 0, 0, 1, 0, 0);
          c.ctx.globalAlpha = 1;
          c.ctx.clearRect(0, 0, width, height);
          mockCache.release();
          texCache.releaseLockChannel(j);
        }
      } else {
        var _opacity4 = _config5[NODE_OPACITY$2],
            _matrixEvent2 = _config5[NODE_MATRIX_EVENT$4],
            _limitCache2 = _config5[NODE_LIMIT_CACHE$2],
            _cache2 = _config5[NODE_CACHE$3],
            _cacheTotal4 = _config5[NODE_CACHE_TOTAL$1],
            __cacheFilter = _config5[NODE_CACHE_FILTER$1],
            __cacheMask = _config5[NODE_CACHE_MASK$1],
            __cacheOverflow = _config5[NODE_CACHE_OVERFLOW$1],
            _refreshLevel5 = _config5[NODE_REFRESH_LV$1],
            _config5$NODE_COMPUTE = _config5[NODE_COMPUTED_STYLE$3],
            display = _config5$NODE_COMPUTE[DISPLAY$7],
            visibility = _config5$NODE_COMPUTE[VISIBILITY$5],
            _mixBlendMode2 = _config5$NODE_COMPUTE[MIX_BLEND_MODE$3];

        if (display === 'none') {
          _i10 += (_total12 || 0) + countMaskNum(__structs, _i10 + (_total12 || 0) + 1, _hasMask5 || 0);
          continue;
        } // 有total的可以直接绘制并跳过子节点索引，忽略total本身，其独占用纹理单元，注意特殊不取cacheTotal，
        // 这种情况发生在只有overflow:hidden声明但无效没有生成__cacheOverflow的情况，
        // 因为webgl纹理单元缓存原因，所以不用cacheTotal防止切换性能损耗
        // 已取消，因为perspective需要进行独立上下文渲染


        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, _cacheTotal4, _cache2]); // total和自身cache的尝试，visibility不可见时没有cache

        if (target) {
          // 有mbm先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
          if (hasMbm && isValidMbm$2(_mixBlendMode2)) {
            texCache.refresh(gl, cx, cy, true);

            var _genFrameBufferWithTe23 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe24 = _slicedToArray(_genFrameBufferWithTe23, 3),
                n2 = _genFrameBufferWithTe24[0],
                frameBuffer2 = _genFrameBufferWithTe24[1],
                texture2 = _genFrameBufferWithTe24[2];

            texCache.addTexAndDrawWhenLimit(gl, target, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
            texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

            var _genMbmWebgl3 = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName$2(_mixBlendMode2), width, height);

            var _genMbmWebgl4 = _slicedToArray(_genMbmWebgl3, 3);

            n = _genMbmWebgl4[0];
            frameBuffer = _genMbmWebgl4[1];
            texture = _genMbmWebgl4[2];
            gl.deleteFramebuffer(frameBuffer2);
            gl.deleteTexture(texture2);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, target, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
          }

          if (target !== _cache2) {
            _i10 += (_total12 || 0) + countMaskNum(__structs, _i10 + (_total12 || 0) + 1, _hasMask5 || 0);
          }
        } else if (limitHash.hasOwnProperty(_i10)) {
          var _target6 = limitHash[_i10];

          if (hasMbm && isValidMbm$2(_mixBlendMode2)) {
            texCache.refresh(gl, cx, cy, true);

            var _genFrameBufferWithTe25 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe26 = _slicedToArray(_genFrameBufferWithTe25, 3),
                _n2 = _genFrameBufferWithTe26[0],
                _frameBuffer2 = _genFrameBufferWithTe26[1],
                _texture3 = _genFrameBufferWithTe26[2];

            texCache.addTexAndDrawWhenLimit(gl, _target6, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
            texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

            var _genMbmWebgl5 = genMbmWebgl(gl, texCache, n, _n2, frameBuffer, texture, mbmName$2(_mixBlendMode2), width, height);

            var _genMbmWebgl6 = _slicedToArray(_genMbmWebgl5, 3);

            n = _genMbmWebgl6[0];
            frameBuffer = _genMbmWebgl6[1];
            texture = _genMbmWebgl6[2];
            gl.deleteFramebuffer(_frameBuffer2);
            gl.deleteTexture(_texture3);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, _target6, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
          }

          _i10 += (_total12 || 0) + countMaskNum(__structs, _i10 + (_total12 || 0) + 1, _hasMask5 || 0);
        } // 超限的情况，这里是普通单节点超限，没有合成total后再合成特殊cache如filter/mask/mbm之类的，
        // 直接按原始位置绘制到离屏canvas，再作为纹理绘制即可，特殊的在total那做过降级了
        else if (_limitCache2 && display !== 'none' && visibility !== 'hidden') {
          var _c2 = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

          _node8.render(renderMode, _refreshLevel5, gl, NA, 0, 0);

          var _j11 = texCache.lockOneChannel();

          var _texture4 = webgl.createTexture(gl, _c2.canvas, _j11);

          var _mockCache2 = new MockCache(gl, _texture4, 0, 0, width, height, [0, 0, width, height]);

          texCache.addTexAndDrawWhenLimit(gl, _mockCache2, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true);

          _c2.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _c2.ctx.globalAlpha = 1;

          _c2.ctx.clearRect(0, 0, width, height);

          _mockCache2.release();

          texCache.releaseLockChannel(_j11);
        } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


        if (_node8.hookGlRender) {
          _node8.hookGlRender(gl, _opacity4, _matrixEvent2, cx, cy, 0, 0, true);
        }
      }
    }

    texCache.refresh(gl, cx, cy, true); // 有mbm时将汇总的fbo绘入主画布，否则本身就是到主画布无需多余操作

    if (hasMbm) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      texCache.releaseLockChannel(n);
      gl.deleteFramebuffer(frameBuffer); // 顶点buffer

      var pointBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
      var a_position = gl.getAttribLocation(gl.program, 'a_position');
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position); // 纹理buffer

      var texBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
      var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
      gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_texCoords); // opacity buffer

      var opacityBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
      var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
      gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_opacity); // 纹理单元

      var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
      gl.uniform1i(u_texture, n);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.deleteBuffer(pointBuffer);
      gl.deleteBuffer(texBuffer);
      gl.deleteBuffer(opacityBuffer);
      gl.disableVertexAttribArray(a_position);
      gl.disableVertexAttribArray(a_texCoords);
      gl.deleteTexture(texture);
    }
  }

  function renderCanvas(renderMode, ctx, root) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height;
    var mergeList = [];
    /**
     * 先一遍先序遍历收集cacheAsBitmap的节点，说明这棵子树需要缓存，可能出现嵌套，高层级优先
     * 可能遇到已有缓存没变化的，这时候不要收集忽略掉，没有缓存的走后面遍历普通渲染
     */

    for (var i = 0, len = __structs.length; i < len; i++) {
      var _structs$i6 = __structs[i],
          node = _structs$i6[STRUCT_NODE$1],
          lv = _structs$i6[STRUCT_LV$2],
          total = _structs$i6[STRUCT_TOTAL$1],
          hasMask = _structs$i6[STRUCT_HAS_MASK$1]; // 排除Text，要么根节点直接绘制，要么被局部根节点汇总，自身并不缓存（fillText比位图更快）

      if (node instanceof Text) {
        continue;
      }

      var __config = node.__config;
      var refreshLevel = __config[NODE_REFRESH_LV$1],
          cacheAsBitmap = __config[NODE_CACHE_AS_BITMAP$1],
          computedStyle = __config[NODE_COMPUTED_STYLE$3];

      if (refreshLevel >= REPAINT$2) {
        node.__calCache(renderMode, ctx, __config[NODE_DOM_PARENT$5], __config[NODE_CACHE_STYLE$1], __config[NODE_CURRENT_STYLE$5], computedStyle, node.clientWidth, node.clientHeight, node.offsetWidth, node.offsetHeight, computedStyle[BORDER_TOP_WIDTH$7], computedStyle[BORDER_RIGHT_WIDTH$7], computedStyle[BORDER_BOTTOM_WIDTH$7], computedStyle[BORDER_LEFT_WIDTH$8], computedStyle[PADDING_TOP$6], computedStyle[PADDING_RIGHT$7], computedStyle[PADDING_BOTTOM$6], computedStyle[PADDING_LEFT$8], node.__sx1, node.__sx2, node.__sx3, node.__sx4, node.__sx5, node.__sx6, node.__sy1, node.__sy2, node.__sy3, node.__sy4, node.__sy5, node.__sy6);
      }

      if (cacheAsBitmap) {
        // 跳过display:none元素和它的所有子节点
        if (computedStyle[DISPLAY$7] === 'none') {
          i += (total || 0) + countMaskNum(__structs, i + (total || 0) + 1, hasMask || 0);
          continue;
        }

        mergeList.push([i, lv, total, node, __config, hasMask]);
      }
    }
    /**
     * 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
     * 这样保证子节点在前，后节点在前（mask在后面），渲染顺序正确
     */


    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a[1] === b[1]) {
          return b[0] - a[0];
        }

        return b[1] - a[1];
      });
      mergeList.forEach(function (item) {
        var _item5 = _slicedToArray(item, 6),
            i = _item5[0],
            lv = _item5[1],
            total = _item5[2],
            node = _item5[3],
            __config = _item5[4],
            hasMask = _item5[5];

        genTotal(renderMode, node, __config, i, lv, total || 0, __structs, hasMask, width, height);
      });
    }
    /**
     * 最后先序遍历一次并应用__cacheTotal即可，没有的普通绘制，以及剩下的超尺寸的和Text
     * 特殊离屏和cacheAsBitmap的离屏都已经产生了cacheTotal，除非超限
     * 离屏功能的数据结构和算法逻辑非常复杂，需用到下面2个hash，来完成一些filter、mask等离屏才能完成的绘制
     * 其中overflow、filter、mix-blend-mode是对自身及子节点，mask则是对自身和后续next遮罩节点
     * 一个节点在Xom渲染中申请离屏canvas，是按照一定顺序来的，且多个离屏后面的有前面的ctx引用，第一个则引用最初非离屏的ctx
     * 这个顺序在应用离屏时以反向顺序开始，这样最后ctx被还原到最初的ctx
     * mask是个十分特殊的离屏，因为除了自身外，next节点也需要汇总到另外一个离屏上，为了逻辑一致性
     * 所有离屏应用的索引都以最后一个节点的索引为准，即有mask时以最后一个mask，无mask则以自身节点的最后一个（+total)为索引
     * 由于存在普通非cache绘制，所以依然要用到栈代替递归计算matrix
     */


    var maskStartHash = {};
    var offscreenHash = {};

    for (var _i11 = 0, _len10 = __structs.length; _i11 < _len10; _i11++) {
      var _structs$_i7 = __structs[_i11],
          _node9 = _structs$_i7[STRUCT_NODE$1],
          _lv6 = _structs$_i7[STRUCT_LV$2],
          _total13 = _structs$_i7[STRUCT_TOTAL$1],
          _hasMask6 = _structs$_i7[STRUCT_HAS_MASK$1]; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_node9 instanceof Text) {
        _node9.render(renderMode, REPAINT$2, ctx, NA, 0, 0);

        if (offscreenHash.hasOwnProperty(_i11)) {
          ctx = applyOffscreen$1(ctx, offscreenHash[_i11], width, height);
        }
      } else {
        var _config6 = _node9.__config;
        var __cacheTotal = _config6[NODE_CACHE_TOTAL$1],
            __cacheFilter = _config6[NODE_CACHE_FILTER$1],
            __cacheMask = _config6[NODE_CACHE_MASK$1],
            __cacheOverflow = _config6[NODE_CACHE_OVERFLOW$1],
            _refreshLevel6 = _config6[NODE_REFRESH_LV$1],
            _config6$NODE_COMPUTE = _config6[NODE_COMPUTED_STYLE$3],
            display = _config6$NODE_COMPUTE[DISPLAY$7],
            mixBlendMode = _config6$NODE_COMPUTE[MIX_BLEND_MODE$3],
            opacity = _config6$NODE_COMPUTE[OPACITY$5]; // 遮罩对象申请了个离屏，其第一个mask申请另外一个离屏mask2，开始聚集所有mask元素的绘制，
        // 这是一个十分特殊的逻辑，保存的index是最后一个节点的索引，OFFSCREEN_MASK2是最低优先级，
        // 这样当mask本身有filter时优先自身，然后才是OFFSCREEN_MASK2

        if (maskStartHash.hasOwnProperty(_i11)) {
          var _maskStartHash$_i3 = _slicedToArray(maskStartHash[_i11], 3),
              idx = _maskStartHash$_i3[0],
              n = _maskStartHash$_i3[1],
              offscreenMask = _maskStartHash$_i3[2];

          var _target7 = inject.getCacheCanvas(width, height, null, 'mask2');

          offscreenMask.mask = _target7; // 应用mask用到

          offscreenMask.isClip = _node9.isClip; // 定位到最后一个mask元素上的末尾

          var j = _i11 + (_total13 || 0) + 1;

          while (--n) {
            var _total14 = __structs[j][STRUCT_TOTAL$1];
            j += (_total14 || 0) + 1;
          }

          j--;
          var list = offscreenHash[j] = offscreenHash[j] || [];
          list.push([idx, _lv6, OFFSCREEN_MASK$1, offscreenMask]);
          list.push([j, _lv6, OFFSCREEN_MASK2$1, {
            ctx: ctx,
            // 保存等待OFFSCREEN_MASK2时还原
            target: _target7
          }]);
          ctx = _target7.ctx;
        } // 有cache声明从而有total的可以直接绘制并跳过子节点索，total生成可能会因超限而失败


        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal]);

        if (target) {
          var _j12 = _i11;
          _i11 += (_total13 || 0) + countMaskNum(__structs, _i11 + (_total13 || 0) + 1, _hasMask6 || 0); // total的none直接跳过

          if (display === 'none') {
            continue;
          }

          if (isValidMbm$2(mixBlendMode)) {
            ctx.globalCompositeOperation = mbmName$2(mixBlendMode);
          } else {
            ctx.globalCompositeOperation = 'source-over';
          } // cache需要计算matrixEvent，因为局部根节点临时视为E，根据refreshLevel决定


          var matrix = _config6[NODE_MATRIX$3],
              matrixEvent = _config6[NODE_MATRIX_EVENT$4];
          var old = matrixEvent.slice(0);
          var parentMatrix = _config6[NODE_DOM_PARENT$5].matrixEvent;

          if (parentMatrix && !isE$3(parentMatrix)) {
            matrix = multiply$2(parentMatrix, matrix);
          }

          util.assignMatrix(matrixEvent, matrix);
          Cache.draw(ctx, opacity, matrixEvent, target); // total应用后记得设置回来

          ctx.globalCompositeOperation = 'source-over'; // 父超限但子有total的时候，i此时已经增加到了末尾，也需要检查

          if (offscreenHash.hasOwnProperty(_i11)) {
            ctx = applyOffscreen$1(ctx, offscreenHash[_i11], width, height);
          } // 有cache的可以跳过子节点，但如果matrixEvent变化还是需要遍历计算一下的，虽然跳过了渲染
          // 如果cache是新的，则需要完整遍历设置一次
          // 如果isNew为false，则计算下局部根节点再对比下看是否有变化，无变化可省略


          var needReset = __cacheTotal.isNew;

          if (!needReset && !util.equalArr(old, matrixEvent)) {
            needReset = true;
          }

          if (needReset) {
            resetMatrixCacheTotal(__structs, _j12, _total13 || 0, _lv6, matrixEvent);
          }

          __cacheTotal.__isNew = false;
        } // 没有cacheTotal是普通节点绘制
        else {
          var res = _node9.render(renderMode, _refreshLevel6, ctx, NA, 0, 0);

          var _ref3 = res || {},
              offscreenBlend = _ref3.offscreenBlend,
              _offscreenMask4 = _ref3.offscreenMask,
              offscreenFilter = _ref3.offscreenFilter,
              offscreenOverflow = _ref3.offscreenOverflow; // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


          if (offscreenBlend) {
            var _j13 = _i11 + (_total13 || 0) + countMaskNum(__structs, _i11 + (_total13 || 0) + 1, _hasMask6 || 0);

            var _list8 = offscreenHash[_j13] = offscreenHash[_j13] || [];

            _list8.push([_i11, _lv6, OFFSCREEN_BLEND$1, offscreenBlend]);

            ctx = offscreenBlend.target.ctx;
          } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
          // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


          if (_offscreenMask4) {
            var _j14 = _i11 + (_total13 || 0);

            maskStartHash[_j14 + 1] = [_i11, _hasMask6, _offscreenMask4];
            ctx = _offscreenMask4.target.ctx;
          } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


          if (offscreenFilter) {
            var _j15 = _i11 + (_total13 || 0) + countMaskNum(__structs, _i11 + (_total13 || 0) + 1, _hasMask6 || 0);

            var _list9 = offscreenHash[_j15] = offscreenHash[_j15] || [];

            _list9.push([_i11, _lv6, OFFSCREEN_FILTER$1, offscreenFilter]);

            ctx = offscreenFilter.target.ctx;
          } // overflow:hidden的离屏，最后孩子进行截取


          if (offscreenOverflow) {
            var _j16 = _i11 + (_total13 || 0) + countMaskNum(__structs, _i11 + (_total13 || 0) + 1, _hasMask6 || 0);

            var _list10 = offscreenHash[_j16] = offscreenHash[_j16] || [];

            _list10.push([_i11, _lv6, OFFSCREEN_OVERFLOW$1, offscreenOverflow]);

            ctx = offscreenOverflow.target.ctx;
          } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
          // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


          if (offscreenHash.hasOwnProperty(_i11)) {
            ctx = applyOffscreen$1(ctx, offscreenHash[_i11], width, height);
          } // render后判断可见状态，此时computedStyle才有值，none可以忽略渲染，但是可能会跳过offscreenHash预置的索引


          if (display === 'none') {
            var add = (_total13 || 0) + countMaskNum(__structs, _i11 + (_total13 || 0) + 1, _hasMask6 || 0);

            for (var _j17 = _i11 + 1; _j17 <= _i11 + add; _j17++) {
              if (offscreenHash.hasOwnProperty(_j17)) {
                ctx = applyOffscreen$1(ctx, offscreenHash[_j17], width, height);
              }
            }

            _i11 += add;
          }
        }
      }
    }
  }

  var struct = {
    renderCanvas: renderCanvas,
    renderSvg: renderSvg,
    renderWebgl: renderWebgl
  };

  var vertex = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;attribute float a_opacity;varying float v_opacity;void main(){gl_Position=a_position;v_texCoords=a_texCoords;v_opacity=a_opacity;}"; // eslint-disable-line

  var fragment = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;varying float v_opacity;uniform sampler2D u_texture;void main(){float opacity=v_opacity;if(opacity<=0.0){discard;}opacity=clamp(opacity,0.0,1.0);vec4 color=texture2D(u_texture,v_texCoords);gl_FragColor=color*opacity;}"; // eslint-disable-line

  var vertexMask = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentMask = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*color2.a;gl_FragColor=vec4(color1.rgb*color2.a,a);}"; // eslint-disable-line

  var fragmentClip = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*(1.0-color2.a);gl_FragColor=vec4(color1.rgb*(1.0-color2.a),a);}"; // eslint-disable-line

  var fragmentOverflow = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_texCoords);}"; // eslint-disable-line

  var vertexCm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentCm = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_m[20];void main(){vec4 c=texture2D(u_texture,v_texCoords);if(c.a>0.0){c.rgb/=c.a;}vec4 result;result.r=(u_m[0]*c.r);result.r+=(u_m[1]*c.g);result.r+=(u_m[2]*c.b);result.r+=(u_m[3]*c.a);result.r+=u_m[4];result.g=(u_m[5]*c.r);result.g+=(u_m[6]*c.g);result.g+=(u_m[7]*c.b);result.g+=(u_m[8]*c.a);result.g+=u_m[9];result.b=(u_m[10]*c.r);result.b+=(u_m[11]*c.g);result.b+=(u_m[12]*c.b);result.b+=(u_m[13]*c.a);result.b+=u_m[14];result.a=(u_m[15]*c.r);result.a+=(u_m[16]*c.g);result.a+=(u_m[17]*c.b);result.a+=(u_m[18]*c.a);result.a+=u_m[19];gl_FragColor=vec4(result.rgb*result.a,result.a);}"; // eslint-disable-line

  var vertexDs = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentDs = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_color[4];void main(){vec4 c=texture2D(u_texture,v_texCoords);gl_FragColor=vec4(u_color[0]*c.a,u_color[1]*c.a,u_color[2]*c.a,u_color[3]*c.a);}"; // eslint-disable-line

  var TexCache = /*#__PURE__*/function () {
    function TexCache(units) {
      _classCallCheck(this, TexCache);

      this.__units = units; // 通道数量限制，8~16

      this.__pages = []; // 存当前page列表，通道数量8~16，缓存收留尽可能多的page

      this.__list = []; // 本次渲染暂存的数据，[cache, opacity, matrix, dx, dy]

      this.__channels = []; // 每个纹理通道记录还是个数组，下标即纹理单元，内容为Page

      this.__locks = []; // 锁定纹理单元列表，下标即纹理单元，内容true为锁定

      this.__lockUnits = 0;
    }
    /**
     * webgl每次绘制为添加纹理并绘制，此处尝试尽可能收集所有纹理贴图，以达到尽可能多的共享纹理，再一次性绘制
     * 收集的是Page对象（从cache中取得），里面包含了若干个节点的贴图，canvas本身是2的幂次方大小
     * webgl最少有8个纹理单元最多16个，因此存了一个列表来放这些Page的canvas，刷新后清空，但纹理通道映射记录保留
     * 当8个纹理单元全部满了，进行绘制并清空这个队列，外部主循环结束时也会检查队列是否还有余留并绘制
     * 初始调用队列为空，存入Page对象，后续调用先查看是否存在以便复用，再决定是否存入Page，直到8个满了
     * Page上存有update表示是否更新，每次cache绘制时会变true，以此表示是否有贴图更新，删除可以忽视
     * 还需要一个记录上次纹理通道使用哪个Page的canvas的地方，即映射，清空后队列再次添加时，如果Page之前被添加过，
     * 此次又被添加且没有变更update，可以直接复用上次的纹理单元号且无需再次上传纹理，节省性能
     * 后续接入局部纹理更新也是复用单元号，如果update变更可以选择局部上传纹理而非整个重新上传
     * 判断上传的逻辑在收集满8个后绘制前进行，因为添加队列过程中可能会变更Page及其update
     * @param gl
     * @param cache
     * @param opacity
     * @param matrix
     * @param cx
     * @param cy
     * @param dx
     * @param dy
     * @param revertY
     */


    _createClass(TexCache, [{
      key: "addTexAndDrawWhenLimit",
      value: function addTexAndDrawWhenLimit(gl, cache, opacity, matrix, cx, cy) {
        var dx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var dy = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var revertY = arguments.length > 8 ? arguments[8] : undefined;
        var pages = this.__pages;
        var list = this.__list;
        var page = cache.page;
        var i = pages.indexOf(page); // 找到说明已有page在此索引的通道中，记录下来info

        if (i > -1) {
          list.push([cache, opacity, matrix, dx, dy]);
        } // 找不到说明是新的纹理贴图，此时看是否超过纹理单元限制，超过则刷新绘制并清空，然后/否则 存入纹理列表
        else {
          i = pages.length;

          if (i >= this.__units - this.__lockUnits) {
            // 绘制且清空，队列索引重新为0
            this.refresh(gl, cx, cy, revertY);
          }

          pages.push(page);
          list.push([cache, opacity, matrix, dx, dy]);
        }
      }
      /**
       * 刷新
       * @param gl
       * @param cx
       * @param cy
       * @param revertY
       */

    }, {
      key: "refresh",
      value: function refresh(gl, cx, cy, revertY) {
        var pages = this.__pages;
        var list = this.__list; // 防止空调用刷新，struct循环结尾会强制调用一次防止有未渲染的

        if (pages.length) {
          var channels = this.channels;
          var locks = this.locks; // 先将上次渲染的纹理单元使用的Page形成一个hash，键为page的uuid，值为纹理单元

          var lastHash = {};
          channels.forEach(function (item, i) {
            if (item) {
              var uuid = item.uuid;
              lastHash[uuid] = i;
            }
          });
          var units = this.__units; // 再遍历，查找相同的Page并保持其使用的纹理单元不变，存入相同索引下标oldList，不同的按顺序收集放newList

          var oldList = new Array(units),
              newList = [];
          pages.forEach(function (page) {
            var uuid = page.uuid;

            if (lastHash.hasOwnProperty(uuid)) {
              var index = lastHash[uuid];
              oldList[index] = page;
            } else {
              newList.push(page);
            }
          });
          /**
           * 以oldList为基准，将newList依次存入oldList中
           * 优先使用未用过的纹理单元，以便用过的可能下次用到无需重新上传
           * 找不到未用过的后，尝试NRU算法，优先淘汰最近未使用的Page，相等则尺寸小的
           */

          if (newList.length) {
            // 先循环找空的，oldList空且channels空且locks空
            for (var i = 0; i < units; i++) {
              if (!oldList[i] && !channels[i] && !locks[i]) {
                oldList[i] = newList.shift();

                if (!newList.length) {
                  break;
                }
              }
            }

            var len = newList.length;

            if (len) {
              // 按时间排序已使用channel且未被当前占用的，以便淘汰最久未使用的
              var cl = [];

              for (var _i = 0; _i < units; _i++) {
                if (!oldList[_i] && !locks[_i]) {
                  cl.push([_i, channels[_i]]);
                }
              }

              cl.sort(function (a, b) {
                if (a[1].time !== b[1].time) {
                  return (a[1].time || 0) - (b[1].time || 0);
                }

                if (a[1].fullSize !== b[1].fullSize) {
                  return a[1].fullSize - b[1].fullSize;
                }

                return a[0] - b[0];
              }); // cl靠前是时间小尺寸小的，优先使用替换

              for (var _i2 = 0; _i2 < len; _i2++) {
                oldList[cl[_i2][0]] = newList[_i2];
              }
            }
          }
          /**
           * 对比上帧渲染的和这次纹理单元情况，Page相同且!update可以省略更新，其它均重新赋值纹理
           * 后续局部更新Page相同但有update，会出现没有上帧的情况如初始渲染，此时先创建纹理单元再更新
           * 将新的数据赋给老的，可能新的一帧使用的少于上一帧，老的没用到的需继续保留
           */


          var hash = {};

          for (var _i3 = 0, _len = oldList.length; _i3 < _len; _i3++) {
            var page = oldList[_i3]; // 可能为空，不满的情况下前面单元保留老tex先用的后面的单元

            if (!page) {
              continue;
            }

            var last = channels[_i3];

            if (!last || last !== page || page.update) {
              // page可能为一个已有fbo纹理，或者贴图
              if (page instanceof MockPage) {
                webgl.bindTexture(gl, page.texture, _i3);
              } else {
                // 可能老的先删除，注意只删Page，MockPage是fbo生成的texture即total缓存不能自动清除
                if (last && !(last instanceof MockPage)) {
                  gl.deleteTexture(last.texture);
                }

                page.texture = webgl.createTexture(gl, page.canvas, _i3);
              }

              channels[_i3] = page;
            }

            hash[page.uuid] = _i3; // 标识没有更新，以及最后使用时间

            page.update = false;
            page.time = inject.now();
          } // 再次遍历开始本次渲染并清空


          webgl.drawTextureCache(gl, list, hash, cx, cy, revertY);
          pages.splice(0);
          list.splice(0);
        }
      }
    }, {
      key: "findExistTexChannel",
      value: function findExistTexChannel(page) {
        return this.channels.indexOf(page);
      }
      /**
       * 获取并锁定一个纹理单元优先使用空的，其次最久未使用的
       * @returns {number|*}
       */

    }, {
      key: "lockOneChannel",
      value: function lockOneChannel() {
        // 优先返回空单元
        var channels = this.channels;
        var locks = this.locks;

        for (var i = 0; i < this.__units; i++) {
          if (!channels[i] && !locks[i]) {
            locks[i] = true;
            this.__lockUnits++;
            return i;
          }
        } // 根据NRU返回最久未使用的


        var units = this.__units;
        var cl = [];

        for (var _i4 = 0; _i4 < units; _i4++) {
          if (!locks[_i4]) {
            cl.push([_i4, channels[_i4]]);
          }
        }

        if (cl.length) {
          cl.sort(function (a, b) {
            if (a[1].time !== b[1].time) {
              return (a[1].time || 0) - (b[1].time || 0);
            }

            if (a[1].fullSize !== b[1].fullSize) {
              return a[1].fullSize - b[1].fullSize;
            }

            return a[0] - b[0];
          });
          var _i5 = cl[0][0];
          channels[_i5] = null;
          locks[_i5] = true;
          this.__lockUnits++;
          return _i5;
        }

        throw new Error('No free texture unit');
      }
      /**
       * 释放掉i单元，并且设置内容到缓存channel中
       * @param i
       * @param setToChannel
       */

    }, {
      key: "releaseLockChannel",
      value: function releaseLockChannel(i, setToChannel) {
        if (this.locks[i]) {
          this.locks[i] = false;
          this.__lockUnits--;

          if (setToChannel) {
            this.channels[i] = setToChannel;
          }
        }
      } // 指定锁定一个单元

    }, {
      key: "lockChannel",
      value: function lockChannel(i) {
        var channels = this.channels;
        var locks = this.locks;

        if (!locks[i]) {
          channels[i] = null;
          locks[i] = true;
          this.__lockUnits++;
        }
      }
      /**
       * 释放纹理单元
       * @param gl
       */

    }, {
      key: "release",
      value: function release(gl) {
        this.channels.forEach(function (item) {
          if (item) {
            gl.deleteTexture(item.texture);
          }
        });
      }
    }, {
      key: "channels",
      get: function get() {
        return this.__channels;
      }
    }, {
      key: "locks",
      get: function get() {
        return this.__locks;
      }
    }, {
      key: "last",
      get: function get() {
        var list = this.__list,
            len = list.length;

        if (len) {
          return list[len - 1];
        }
      }
    }]);

    return TexCache;
  }();

  var _DIRECTION_HASH;
  var _enums$STYLE_KEY$k = enums.STYLE_KEY,
      TOP$4 = _enums$STYLE_KEY$k.TOP,
      RIGHT$2 = _enums$STYLE_KEY$k.RIGHT,
      BOTTOM$4 = _enums$STYLE_KEY$k.BOTTOM,
      LEFT$2 = _enums$STYLE_KEY$k.LEFT,
      POSITION$5 = _enums$STYLE_KEY$k.POSITION,
      DISPLAY$8 = _enums$STYLE_KEY$k.DISPLAY,
      VISIBILITY$6 = _enums$STYLE_KEY$k.VISIBILITY,
      COLOR$6 = _enums$STYLE_KEY$k.COLOR,
      WIDTH$8 = _enums$STYLE_KEY$k.WIDTH,
      HEIGHT$9 = _enums$STYLE_KEY$k.HEIGHT,
      Z_INDEX$4 = _enums$STYLE_KEY$k.Z_INDEX,
      MARGIN_TOP$5 = _enums$STYLE_KEY$k.MARGIN_TOP,
      MARGIN_LEFT$7 = _enums$STYLE_KEY$k.MARGIN_LEFT,
      MARGIN_BOTTOM$5 = _enums$STYLE_KEY$k.MARGIN_BOTTOM,
      PADDING_TOP$7 = _enums$STYLE_KEY$k.PADDING_TOP,
      PADDING_LEFT$9 = _enums$STYLE_KEY$k.PADDING_LEFT,
      PADDING_BOTTOM$7 = _enums$STYLE_KEY$k.PADDING_BOTTOM,
      BORDER_TOP_WIDTH$8 = _enums$STYLE_KEY$k.BORDER_TOP_WIDTH,
      BORDER_LEFT_WIDTH$9 = _enums$STYLE_KEY$k.BORDER_LEFT_WIDTH,
      BORDER_BOTTOM_WIDTH$8 = _enums$STYLE_KEY$k.BORDER_BOTTOM_WIDTH,
      POINTER_EVENTS$2 = _enums$STYLE_KEY$k.POINTER_EVENTS,
      WRITING_MODE$3 = _enums$STYLE_KEY$k.WRITING_MODE,
      _enums$UPDATE_KEY$5 = enums.UPDATE_KEY,
      UPDATE_NODE$5 = _enums$UPDATE_KEY$5.UPDATE_NODE,
      UPDATE_STYLE$2 = _enums$UPDATE_KEY$5.UPDATE_STYLE,
      UPDATE_KEYS$2 = _enums$UPDATE_KEY$5.UPDATE_KEYS,
      UPDATE_COMPONENT = _enums$UPDATE_KEY$5.UPDATE_COMPONENT,
      UPDATE_FOCUS$4 = _enums$UPDATE_KEY$5.UPDATE_FOCUS,
      UPDATE_OVERWRITE$1 = _enums$UPDATE_KEY$5.UPDATE_OVERWRITE,
      UPDATE_LIST = _enums$UPDATE_KEY$5.UPDATE_LIST,
      UPDATE_CONFIG$5 = _enums$UPDATE_KEY$5.UPDATE_CONFIG,
      UPDATE_ADD_DOM$1 = _enums$UPDATE_KEY$5.UPDATE_ADD_DOM,
      UPDATE_REMOVE_DOM$1 = _enums$UPDATE_KEY$5.UPDATE_REMOVE_DOM,
      _enums$NODE_KEY$9 = enums.NODE_KEY,
      NODE_TAG_NAME$1 = _enums$NODE_KEY$9.NODE_TAG_NAME,
      NODE_CACHE_STYLE$2 = _enums$NODE_KEY$9.NODE_CACHE_STYLE,
      NODE_CACHE_PROPS$1 = _enums$NODE_KEY$9.NODE_CACHE_PROPS,
      NODE_CURRENT_STYLE$6 = _enums$NODE_KEY$9.NODE_CURRENT_STYLE,
      NODE_COMPUTED_STYLE$4 = _enums$NODE_KEY$9.NODE_COMPUTED_STYLE,
      NODE_CURRENT_PROPS$1 = _enums$NODE_KEY$9.NODE_CURRENT_PROPS,
      NODE_DOM_PARENT$6 = _enums$NODE_KEY$9.NODE_DOM_PARENT,
      NODE_IS_MASK$3 = _enums$NODE_KEY$9.NODE_IS_MASK,
      NODE_REFRESH_LV$2 = _enums$NODE_KEY$9.NODE_REFRESH_LV,
      NODE_IS_DESTROYED$2 = _enums$NODE_KEY$9.NODE_IS_DESTROYED,
      NODE_STYLE$5 = _enums$NODE_KEY$9.NODE_STYLE,
      NODE_UPDATE_HASH = _enums$NODE_KEY$9.NODE_UPDATE_HASH,
      NODE_UNIQUE_UPDATE_ID = _enums$NODE_KEY$9.NODE_UNIQUE_UPDATE_ID,
      NODE_CACHE$4 = _enums$NODE_KEY$9.NODE_CACHE,
      NODE_CACHE_TOTAL$2 = _enums$NODE_KEY$9.NODE_CACHE_TOTAL,
      NODE_CACHE_FILTER$2 = _enums$NODE_KEY$9.NODE_CACHE_FILTER,
      NODE_CACHE_OVERFLOW$2 = _enums$NODE_KEY$9.NODE_CACHE_OVERFLOW,
      NODE_CACHE_MASK$2 = _enums$NODE_KEY$9.NODE_CACHE_MASK,
      NODE_STRUCT$5 = _enums$NODE_KEY$9.NODE_STRUCT,
      _enums$STRUCT_KEY$3 = enums.STRUCT_KEY,
      STRUCT_INDEX$3 = _enums$STRUCT_KEY$3.STRUCT_INDEX,
      STRUCT_TOTAL$2 = _enums$STRUCT_KEY$3.STRUCT_TOTAL,
      STRUCT_NODE$2 = _enums$STRUCT_KEY$3.STRUCT_NODE;
  var DIRECTION_HASH = (_DIRECTION_HASH = {}, _defineProperty(_DIRECTION_HASH, TOP$4, true), _defineProperty(_DIRECTION_HASH, RIGHT$2, true), _defineProperty(_DIRECTION_HASH, BOTTOM$4, true), _defineProperty(_DIRECTION_HASH, LEFT$2, true), _DIRECTION_HASH);
  var isNil$9 = util.isNil,
      isObject$2 = util.isObject,
      isFunction$9 = util.isFunction;
  var AUTO$8 = o.AUTO,
      PX$9 = o.PX,
      PERCENT$a = o.PERCENT,
      INHERIT$4 = o.INHERIT;
  var isRelativeOrAbsolute$2 = css.isRelativeOrAbsolute,
      equalStyle$1 = css.equalStyle;
  var contain$3 = o$3.contain,
      getLevel = o$3.getLevel,
      isRepaint = o$3.isRepaint,
      NONE$3 = o$3.NONE,
      FILTER$7 = o$3.FILTER,
      PERSPECTIVE$5 = o$3.PERSPECTIVE,
      REPAINT$3 = o$3.REPAINT,
      REFLOW$2 = o$3.REFLOW,
      REBUILD = o$3.REBUILD;
  var isIgnore = o$2.isIgnore,
      isGeom$2 = o$2.isGeom;
  var ROOT_DOM_NAME = {
    canvas: 'canvas',
    svg: 'svg',
    webgl: 'canvas'
  };

  function getDom(dom) {
    if (util.isString(dom) && dom) {
      var o = document.querySelector(dom);

      if (!o) {
        throw new Error('Can not find dom of selector: ' + dom);
      }

      return o;
    }

    if (!dom) {
      throw new Error('Can not find dom: ' + dom);
    }

    return dom;
  }

  function renderProp(k, v) {
    var s = Array.isArray(v) ? util.joinSourceArray(v) : util.stringify(v);

    if (k === 'className') {
      k = 'class';
    } else if (k === 'style') {
      return '';
    }

    return ' ' + k + '="' + util.encodeHtml(s, true) + '"';
  }

  var EVENT_LIST = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];

  function initEvent(dom, Root) {
    var list = [];
    EVENT_LIST.forEach(function (type) {
      function cb(e) {
        var root = dom.__root;

        if (root && root instanceof Root) {
          if (['touchend', 'touchcancel', 'touchmove'].indexOf(type) > -1) {
            var target = root.__touchstartTarget;

            var event = root.__wrapEvent(e);

            event.target = target;

            while (target) {
              target.__emitEvent(event, true);

              target = target.domParent;
            }
          } else {
            root.__cb(e);
          }
        }
      }

      dom.addEventListener(type, cb);
      list.push([type, cb]);
    });
    return list;
  }

  function removeEvent(dom, list) {
    list.forEach(function (item) {
      dom.removeEventListener(item[0], item[1]);
    });
  } // 提取出对比节点尺寸是否固定非AUTO


  function isFixedWidthOrHeight(node, k) {
    var c = node.currentStyle[k];
    return c[1] !== AUTO$8;
  } // 除了固定尺寸，父级也不能是flex或变化flex


  function isFixedSize(node, includeParentFlex) {
    var res = isFixedWidthOrHeight(node, WIDTH$8) && isFixedWidthOrHeight(node, HEIGHT$9);

    if (res && includeParentFlex) {
      var parent = node.domParent;

      if (parent) {
        if (parent.currentStyle[DISPLAY$8] === 'flex' || parent.computedStyle[DISPLAY$8] === 'flex') {
          return false;
        }
      }
    }

    return res;
  }

  function isLAYOUT(node) {
    return node.hasOwnProperty('__uniqueReflowId');
  }

  var __uniqueReflowId = 0;

  function setLAYOUT(node, hash, component, addDom) {
    if (!node.hasOwnProperty('__uniqueReflowId')) {
      node.__uniqueReflowId = __uniqueReflowId;
      hash[__uniqueReflowId++] = {
        node: node,
        component: component,
        addDom: addDom
      };
    }
  }
  /**
   * 单独提出共用检测影响的函数，从节点本身开始向上分析影响，找到最上层的影响节点设置其重新布局
   * 过程即__checkReflow中所提及的，各种情况
   * 将影响升至最近的父级节点，并添加布局标识，这样后面的深度遍历会以父级为准忽略本身
   * 如果最终是root，则返回true标识，直接整个重新开始布局
   * ====
   * addDom情况下的特殊影响检测，类似checkInfluence
   * 添加的是absolute则只影响自己，大部分交互游戏情况属于此类型优化
   * 添加的是inline/inlineBlock的话，影响最近非inline父节点
   * 父为flex则直接影响父节点，不管添加情况如何
   * 添加block/flex的话，上下都block/flex则只影响自己，否则还是影响父节点
   * 如果最终是root，则返回true标识，直接整个重新开始布局
   * @returns {boolean}
   */


  function checkInfluence(root, reflowHash, node, component, addDom) {
    // add情况abs节点特殊对待不影响其它节点，不能判断display，因为inline会强制block
    if (addDom && node.currentStyle[POSITION$5] === 'absolute') {
      return;
    }

    var target = node; // inline新老都影响，节点变为最近的父非inline

    if (['inline', 'inlineBlock'].indexOf(target.currentStyle[DISPLAY$8]) > -1 || ['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$8]) > -1) {
      do {
        target = target.domParent; // 父到root提前跳出

        if (target === root) {
          return true;
        } // 父已有LAYOUT跳出防重


        if (isLAYOUT(target)) {
          return;
        } // 遇到absolute跳出，设置其布局；如果absolute不变化普通处理，如果absolute发生变化，一定会存在于列表中，不用考虑


        if (target.currentStyle[POSITION$5] === 'absolute' || target.computedStyle[POSITION$5] === 'absolute') {
          setLAYOUT(target, reflowHash, component, addDom);
          return;
        }
      } while (target && (['inline', 'inlineBlock'].indexOf(target.currentStyle[DISPLAY$8]) > -1 || ['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$8]) > -1)); // target已不是inline，父固定宽高跳出直接父进行LAYOUT即可，不影响上下文，但不能是flex孩子，此时固定尺寸无用


      if (isFixedSize(target, true)) {
        setLAYOUT(target, reflowHash, component, addDom);
        return;
      }
    } // 此时target指向node，如果原本是inline则是其flow的非inline父


    var parent = target.domParent; // parent有LAYOUT跳出，已被包含

    if (isLAYOUT(parent)) {
      return;
    } // 向上检查flex，如果父级中有flex，以最上层的flex视作其更改，node本身flex不进入


    var topFlex;

    do {
      // 父已有LAYOUT跳出防重
      if (isLAYOUT(parent)) {
        return;
      } // flex相关，包含变化或不变化


      if (parent.computedStyle[DISPLAY$8] === 'flex' || parent.currentStyle[DISPLAY$8] === 'flex') {
        topFlex = parent;
      } // 遇到absolute跳出，如果absolute不变化普通处理，如果absolute发生变化，一定会存在于列表中，不用考虑


      if (parent.currentStyle[POSITION$5] === 'absolute' || parent.computedStyle[POSITION$5] === 'absolute') {
        break;
      } // 父固定宽高跳出


      if (isFixedSize(parent, true)) {
        break;
      }

      parent = parent.domParent;
    } while (parent); // 找到最上层flex，视作其更改


    if (topFlex) {
      target = topFlex;
    }

    if (target === root) {
      return true;
    }

    parent = target; // 向上检查非固定尺寸的absolute，找到则视为其变更，上面过程中一定没有出现absolute

    while (parent) {
      // 无论新老absolute，不变化则设置，变化一定会出现在列表中
      if (parent.currentStyle[POSITION$5] === 'absolute' || parent.computedStyle[POSITION$5] === 'absolute') {
        if (parent === root) {
          break;
        } // 固定尺寸的不用设置，需要跳出循环


        if (isFixedSize(parent)) {
          break;
        } else {
          setLAYOUT(parent, reflowHash, component, addDom);
          return;
        }
      }

      parent = parent.domParent;
    } // 向上查找了并且没提前跳出的target如果不等于自身则重新布局，自身外面设置过了


    if (target !== node) {
      setLAYOUT(target, reflowHash, component, addDom);
    } else if (addDom) {
      // 前后必须都是block，否则还是视为父布局
      var isSiblingBlock = true;
      var prev = node.prev,
          next = node.next;

      if (prev && ['inline', 'inlineBlock'].indexOf(prev.currentStyle[DISPLAY$8]) > -1) {
        isSiblingBlock = false;
      } else if (next && ['inline', 'inlineBlock'].indexOf(next.currentStyle[DISPLAY$8]) > -1) {
        isSiblingBlock = false;
      }

      if (!isSiblingBlock) {
        target = node.domParent;

        if (target === root) {
          return true;
        }

        setLAYOUT(target, reflowHash, false, true);
      }
    }
  }

  var uniqueUpdateId = 0;

  function parseUpdate(renderMode, root, target, reflowList, cacheHash, cacheList, zHash, zList) {
    var node = target[UPDATE_NODE$5],
        style = target[UPDATE_STYLE$2],
        overwrite = target[UPDATE_OVERWRITE$1],
        focus = target[UPDATE_FOCUS$4],
        component = target[UPDATE_COMPONENT],
        list = target[UPDATE_LIST],
        keys = target[UPDATE_KEYS$2],
        __config = target[UPDATE_CONFIG$5],
        addDom = target[UPDATE_ADD_DOM$1],
        removeDom = target[UPDATE_REMOVE_DOM$1];

    if (__config[NODE_IS_DESTROYED$2]) {
      return;
    } // updateStyle()这样的调用需要覆盖原有样式，因为是按顺序遍历，后面的优先级自动更高不怕重复


    if (overwrite) {
      Object.assign(__config[NODE_STYLE$5], overwrite);
    } // 多次调用更新才会有list，一般没有，优化；component无需，因为多次都是它自己


    if (list && !component) {
      keys = (keys || []).slice(0); // 防止原始值被更改

      var hash = {};
      keys.forEach(function (k) {
        hash[k] = true;
      });
      list.forEach(function (item) {
        var style2 = item[UPDATE_STYLE$2],
            overwrite = item[UPDATE_OVERWRITE$1],
            keys2 = item[UPDATE_KEYS$2];
        (keys2 || []).forEach(function (k2) {
          if (!hash.hasOwnProperty(k2)) {
            hash[k2] = true;
            keys.push(k2);
          }
        });

        if (overwrite) {
          Object.assign(__config[NODE_STYLE$5], overwrite);
        }

        if (style2) {
          if (style) {
            Object.assign(style, style2);
          } else {
            style = style2;
          }
        }
      });
    } // 按节点合并完style后判断改变等级


    var tagName = __config[NODE_TAG_NAME$1],
        __cacheStyle = __config[NODE_CACHE_STYLE$2],
        __cacheProps = __config[NODE_CACHE_PROPS$1],
        currentStyle = __config[NODE_CURRENT_STYLE$6],
        computedStyle = __config[NODE_COMPUTED_STYLE$4],
        currentProps = __config[NODE_CURRENT_PROPS$1],
        domParent = __config[NODE_DOM_PARENT$6],
        isMask = __config[NODE_IS_MASK$3];
    var lv = focus || NONE$3;
    var hasZ, hasVisibility, hasColor, hasDisplay; // component无需遍历直接赋值，img重新加载等情况没有样式更新

    if (!component && style && keys) {
      for (var i = 0, len = keys.length; i < len; i++) {
        var k = keys[i];
        var v = style[k]; // 只有geom的props和style2种可能

        if (node instanceof Geom$1 && isGeom$2(tagName, k)) {
          if (!equalStyle$1(k, v, currentProps[k], node)) {
            lv |= REPAINT$3;
            __cacheProps[k] = undefined;
            currentProps[k] = v;
          }
        } else {
          // 需和现在不等，且不是pointerEvents这种无关的
          if (!equalStyle$1(k, v, currentStyle[k], node)) {
            // pointerEvents这种无关的只需更新
            if (isIgnore(k)) {
              __cacheStyle[k] = undefined;
              currentStyle[k] = v;
            } else {
              // TRBL变化只对relative/absolute起作用，其它忽视
              if (DIRECTION_HASH.hasOwnProperty(k)) {
                var position = currentStyle[POSITION$5];

                if (position !== 'relative' && position !== 'absolute') {
                  delete style[k];
                  continue;
                }
              } else if (k === DISPLAY$8) {
                hasDisplay = true;
              } // repaint细化等级，reflow在checkReflow()


              lv |= getLevel(k); // repaint置空，如果reflow会重新生成空的

              __cacheStyle[k] = undefined;
              currentStyle[k] = v;

              if (k === Z_INDEX$4 && node !== root) {
                hasZ = true;
              }

              if (k === VISIBILITY$6) {
                hasVisibility = true;
              }

              if (k === COLOR$6) {
                hasColor = true;
              }
            }
          }
        }
      }
    } // 无任何改变处理的去除记录，如pointerEvents、无效的left
    // 但是perspective需考虑进来，虽然不影响自己但影响别人，要返回true表明有变更


    if (lv === NONE$3 && !component) {
      delete __config[NODE_UNIQUE_UPDATE_ID];
      return;
    } // 由于父节点中有display:none，或本身节点也为none，执行普通动画是无效的，此时没有display变化


    if (computedStyle[DISPLAY$8] === 'none' && !hasDisplay) {
      return;
    } // 记录下来清除parent的zIndexChildren缓存


    if (hasZ && domParent) {
      delete domParent.__zIndexChildren;
    } // visibility/color变化，影响子继承


    if (hasVisibility || hasColor) {
      for (var __structs = root.__structs, __struct = node.__config[NODE_STRUCT$5], _i = __struct[STRUCT_INDEX$3] + 1, _len = _i + __struct[STRUCT_TOTAL$2]; _i < _len; _i++) {
        var _structs$_i = __structs[_i],
            _node = _structs$_i[STRUCT_NODE$2],
            total = _structs$_i[STRUCT_TOTAL$2];
        var _config = _node.__config;
        var _currentStyle = _config[NODE_CURRENT_STYLE$6];

        var _need = void 0; // text的style指向parent，因此text一定变更


        if (hasVisibility && (_node instanceof Text || _currentStyle[VISIBILITY$6][1] === INHERIT$4)) {
          _need = true;
        }

        if (hasColor && (_node instanceof Text || _currentStyle[COLOR$6][1] === INHERIT$4)) {
          _need = true;
        }

        if (_need) {
          _config[NODE_REFRESH_LV$2] |= REPAINT$3;

          if (_node instanceof Xom$1) {
            _node.clearCache();
          }
        } else {
          _i += total || 0;
        }
      }
    } // mask需清除遮罩对象的缓存


    if (isMask) {
      var prev = node.prev;

      while (prev && prev.isMask) {
        prev = prev.prev;
      }

      if (prev && prev.__config[NODE_CACHE_MASK$2]) {
        prev.__config[NODE_CACHE_MASK$2].release();
      }
    } // 特殊情况，父节点display:none，子节点进行任意变更，应视为无效
    // 如果父节点由none变block，这里也return false，因为父节点会重新layout+render
    // 如果父节点由block变none，同上，所以只要current/computed里有none就return false


    var parent = domParent;

    if (hasDisplay && parent) {
      var _config2 = parent.__config;

      if (_config2[NODE_CURRENT_STYLE$6][DISPLAY$8] === 'none' || _config2[NODE_COMPUTED_STYLE$4][DISPLAY$8] === 'none') {
        computedStyle[DISPLAY$8] = 'none';
        return;
      }
    } // reflow/repaint相关的记录下来


    var isRp = !component && isRepaint(lv);

    if (isRp) {
      // zIndex变化需清空svg缓存
      if (hasZ && renderMode === mode.SVG) {
        lv |= REPAINT$3;
        domParent && cleanSvgCache(domParent);
      } // z改变影响struct局部重排，它的数量不会变因此不影响外围，此处先收集，最后统一对局部根节点进行更新


      if (hasZ && !component && zHash) {
        if (domParent && !domParent.hasOwnProperty('__uniqueZId')) {
          zHash[uniqueUpdateId] = true;
          domParent.__uniqueZId = uniqueUpdateId++;
          zList.push(domParent);
        }
      }
    } // reflow在root的refresh中做
    else {
      reflowList.push({
        node: node,
        style: style,
        component: component,
        addDom: addDom,
        removeDom: removeDom
      });
    } // 这里也需|运算，每次刷新会置0，但是如果父元素进行继承变更，会在此元素分析前更改，比如visibility，此时不能直接赋值


    __config[NODE_REFRESH_LV$2] |= lv;

    if (component || addDom || removeDom) {
      root.__rlv = REBUILD;
    } else {
      root.__rlv = Math.max(root.__rlv, lv);
    } // dom在>=REPAINT时total失效，svg的Geom比较特殊


    var need = lv >= REPAINT$3 || renderMode === mode.SVG && node instanceof Geom$1;

    if (need) {
      if (__config[NODE_CACHE$4]) {
        __config[NODE_CACHE$4].release();
      }
    } // perspective也特殊只清空total的cache，和>=REPAINT清空total共用


    if (need || contain$3(lv, PERSPECTIVE$5)) {
      if (__config[NODE_CACHE_TOTAL$2]) {
        __config[NODE_CACHE_TOTAL$2].release();
      }

      if (__config[NODE_CACHE_MASK$2]) {
        __config[NODE_CACHE_MASK$2].release();
      }

      if (__config[NODE_CACHE_OVERFLOW$2]) {
        __config[NODE_CACHE_OVERFLOW$2].release();
      }
    } // 特殊的filter清除cache


    if ((need || contain$3(lv, FILTER$7)) && __config[NODE_CACHE_FILTER$2]) {
      __config[NODE_CACHE_FILTER$2].release();
    } // 向上清除等级>=REPAINT的汇总缓存信息，过程中可能会出现重复，因此节点上记录一个临时标防止重复递归


    while (parent) {
      var _config3 = parent.__config; // 向上查找，出现重复跳出

      if (_config3.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
        var id = _config3[NODE_UNIQUE_UPDATE_ID];

        if (cacheHash.hasOwnProperty(id)) {
          break;
        }

        cacheHash[id] = true;
      } // 没有的需要设置一个标识
      else {
        cacheHash[uniqueUpdateId] = true;
        _config3[NODE_UNIQUE_UPDATE_ID] = uniqueUpdateId++;
        cacheList.push(_config3);
      }

      var _lv = _config3[NODE_REFRESH_LV$2];

      var _need2 = _lv >= REPAINT$3;

      if (_need2 && _config3[NODE_CACHE$4]) {
        _config3[NODE_CACHE$4].release();
      } // 前面已经过滤了无改变NONE的，只要孩子有任何改变父亲就要清除


      if (_config3[NODE_CACHE_TOTAL$2]) {
        _config3[NODE_CACHE_TOTAL$2].release();
      }

      if (_config3[NODE_CACHE_FILTER$2]) {
        _config3[NODE_CACHE_FILTER$2].release();
      }

      if (_config3[NODE_CACHE_MASK$2]) {
        _config3[NODE_CACHE_MASK$2].release();
      }

      if (_config3[NODE_CACHE_OVERFLOW$2]) {
        _config3[NODE_CACHE_OVERFLOW$2].release();
      }

      parent = _config3[NODE_DOM_PARENT$6];
    }

    return true;
  }

  function cleanSvgCache(node, child) {
    var __config = node.__config;

    if (child) {
      __config[NODE_REFRESH_LV$2] |= REPAINT$3;
    } else {
      __config[NODE_CACHE_TOTAL$2].release();
    }

    if (Array.isArray(node.children)) {
      node.children.forEach(function (child) {
        if (child instanceof Component$1) {
          child = child.shadowRoot;
        }

        if (!(child instanceof Text)) {
          cleanSvgCache(child, true);
        }
      });
    }
  }

  var uuid$2 = 0;

  var Root = /*#__PURE__*/function (_Dom) {
    _inherits(Root, _Dom);

    var _super = _createSuper(Root);

    function Root(tagName, props, children) {
      var _this;

      _classCallCheck(this, Root);

      _this = _super.call(this, tagName, props);
      _this.__cd = children || []; // 原始children，再初始化过程中生成真正的dom

      _this.__dom = null; // 真实DOM引用

      _this.__mw = 0; // 记录最大宽高，防止尺寸变化清除不完全

      _this.__mh = 0; // this.__scx = 1; // 默认缩放，css改变canvas/svg缩放后影响事件坐标，有值手动指定，否则自动计算
      // this.__scy = 1;

      _this.__taskUp = [];
      _this.__taskCp = [];
      _this.__ref = {};
      _this.__reflowList = [{
        node: _assertThisInitialized(_this)
      }]; // 初始化填自己，第一次布局时复用逻辑完全重新布局

      _this.__animateController = new Controller();
      Event.mix(_assertThisInitialized(_this));
      _this.__config[NODE_UPDATE_HASH] = _this.__updateHash = {};
      _this.__uuid = uuid$2++;
      _this.__rlv = REBUILD; // 每次刷新最大lv

      return _this;
    }

    _createClass(Root, [{
      key: "__initProps",
      value: function __initProps() {
        var w = this.props.width;

        if (!isNil$9(w)) {
          var value = parseFloat(w) || 0;

          if (value > 0) {
            this.__width = value;
          }
        }

        var h = this.props.height;

        if (!isNil$9(h)) {
          var _value = parseFloat(h) || 0;

          if (_value > 0) {
            this.__height = _value;
          }
        }
      }
    }, {
      key: "__genHtml",
      value: function __genHtml(domName) {
        var _this2 = this;

        var res = "<".concat(domName); // 拼接处理属性

        Object.keys(this.props).forEach(function (k) {
          var v = _this2.props[k]; // 忽略事件

          if (!/^on[a-zA-Z]/.test(k)) {
            res += renderProp(k, v);
          }
        });
        res += "></".concat(domName, ">");
        return res;
      }
    }, {
      key: "__wrapEvent",
      value: function __wrapEvent(e) {
        var x, y; // 触摸结束取消特殊没有touches

        if (['touchend', 'touchcancel'].indexOf(e.type) === -1) {
          var dom = this.dom,
              __scx = this.__scx,
              __scy = this.__scy;

          var _dom$getBoundingClien = dom.getBoundingClientRect(),
              x2 = _dom$getBoundingClien.x,
              y2 = _dom$getBoundingClien.y,
              left = _dom$getBoundingClien.left,
              top = _dom$getBoundingClien.top,
              width = _dom$getBoundingClien.width,
              height = _dom$getBoundingClien.height;

          x = x2 || left || 0;
          y = y2 || top || 0;

          var _ref = e.touches ? e.touches[0] : e,
              clientX = _ref.clientX,
              clientY = _ref.clientY;

          x = clientX - x;
          y = clientY - y; // 外边的scale影响元素事件响应，根据倍数计算真实的坐标，优先手动指定，否则自动计算

          if (!isNil$9(__scx)) {
            x /= __scx;
          } else {
            x *= this.width / width;
          }

          if (!isNil$9(__scy)) {
            y /= __scy;
          } else {
            y *= this.height / height;
          }
        }

        return {
          event: e,
          stopPropagation: function stopPropagation() {
            this.__stopPropagation = true;
            e.stopPropagation();
          },
          stopImmediatePropagation: function stopImmediatePropagation() {
            this.__stopPropagation = true;
            this.__stopImmediatePropagation = true;
            e.stopImmediatePropagation();
          },
          preventDefault: function preventDefault() {
            e.preventDefault();
          },
          x: x,
          y: y,
          __hasEmitted: false
        };
      } // 类似touchend/touchcancel/touchmove这种无需判断是否发生于元素上，直接响应

    }, {
      key: "__cb",
      value: function __cb(e) {
        if (e.type === 'touchmove' && !this.__touchstartTarget) {
          return;
        }

        var data = this.__wrapEvent(e);

        this.__emitEvent(data);

        return data;
      }
      /**
       * 添加到真实Dom上，优先已存在的同名canvas/svg节点，没有则dom下生成新的
       * @param dom
       */

    }, {
      key: "appendTo",
      value: function appendTo(dom) {
        dom = getDom(dom);
        this.__children = builder.initRoot(this.__cd, this);

        this.__initProps();

        this.__root = this;
        var tagName = this.tagName;
        var domName = ROOT_DOM_NAME[tagName]; // OffscreenCanvas兼容，包含worker的

        if (typeof window !== 'undefined' && window.OffscreenCanvas && dom instanceof window.OffscreenCanvas || typeof self !== 'undefined' && self.OffscreenCanvas && dom instanceof self.OffscreenCanvas) {
          this.__dom = dom;
          this.__width = dom.width;
          this.__height = dom.height;
        } // 已有root节点
        else if (dom.nodeName.toLowerCase() === domName) {
          this.__dom = dom;

          if (this.width) {
            dom.setAttribute('width', this.width);
          }

          if (this.height) {
            dom.setAttribute('height', this.height);
          }
        } // 没有canvas/svg节点则生成一个新的
        else {
          this.__dom = dom.querySelector(domName);

          if (!this.__dom) {
            dom.innerHTML = this.__genHtml(domName);
            this.__dom = dom.querySelector(domName);
          }
        }

        this.__defs = this.dom.__defs || Defs.getInstance(this.__uuid); // 没有设置width/height则采用css计算形式

        if (!this.width || !this.height) {
          var domCss = window.getComputedStyle(dom, null);

          if (!this.width) {
            this.__width = parseFloat(domCss.getPropertyValue('width')) || 0;
            dom.setAttribute('width', this.width);
          }

          if (!this.height) {
            this.__height = parseFloat(domCss.getPropertyValue('height')) || 0;
            dom.setAttribute('height', this.height);
          }
        } // 最终无宽高给出警告


        if (!this.width || !this.height) {
          inject.warn('Karas render target with a width or height of 0.');
        }

        var params = Object.assign({}, ca, this.props.contextAttributes); // 只有canvas有ctx，svg用真实dom

        if (this.tagName === 'canvas') {
          this.__ctx = this.__dom.getContext('2d', params);
          this.__renderMode = mode.CANVAS;
        } else if (this.tagName === 'svg') {
          this.__renderMode = mode.SVG;
        } else if (this.tagName === 'webgl') {
          var gl = this.__ctx = this.__dom.getContext('webgl', params);

          this.__renderMode = mode.WEBGL;
          gl.program = webgl.initShaders(gl, vertex, fragment);
          gl.programMask = webgl.initShaders(gl, vertexMask, fragmentMask);
          gl.programClip = webgl.initShaders(gl, vertexMask, fragmentClip);
          gl.programOverflow = webgl.initShaders(gl, vertexMask, fragmentOverflow);
          gl.programCm = webgl.initShaders(gl, vertexCm, fragmentCm);
          gl.programDs = webgl.initShaders(gl, vertexDs, fragmentDs);
          gl.useProgram(gl.program); // 第一次渲染生成纹理缓存管理对象，收集渲染过程中生成的纹理并在gl纹理单元满了时进行绘制和清空，减少texImage2d耗时问题

          var MAX_TEXTURE_IMAGE_UNITS = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
          this.__texCache = new TexCache(MAX_TEXTURE_IMAGE_UNITS);
        }

        this.refresh(null, true); // 第一次节点没有__root，渲染一次就有了才能diff

        if (this.dom.__root && this.dom.__root instanceof Root) {
          this.dom.__root.destroy();
        }

        this.__eventCbList = initEvent(this.dom, Root);
        this.dom.__root = this;
      }
    }, {
      key: "refresh",
      value: function refresh(cb, isFirst) {
        this.__hookTask = null;
        var isDestroyed = this.isDestroyed,
            renderMode = this.renderMode,
            ctx = this.ctx,
            defs = this.defs,
            width = this.width,
            height = this.height;

        if (isDestroyed) {
          return;
        }

        defs.clear(); // 首次递归测量整树的继承，后续更改各自更新机制做，防止每次整树遍历；root检查首次直接做，后续在checkUpdate()中插入

        if (isFirst) {
          this.__checkRoot(renderMode, width, height);
        } // 非首次刷新如果没有更新则无需继续
        else if (!this.__checkUpdate(renderMode, ctx, width, height)) {
          return;
        }

        this.__checkReflow(width, height);

        if (renderMode === mode.CANVAS && !this.props.noRender) {
          this.__clear(ctx, renderMode);

          struct.renderCanvas(renderMode, ctx, this);
        } // svg的特殊diff需要
        else if (renderMode === mode.SVG && !this.props.noRender) {
          struct.renderSvg(renderMode, defs, this, isFirst);
          var nvd = this.virtualDom;
          nvd.defs = defs.value;

          if (this.dom.__vd) {
            // console.log(this.dom.__vd);
            // console.log(nvd);
            diff$1(this.dom, this.dom.__vd, nvd);
          } else {
            this.dom.innerHTML = util.joinVirtualDom(nvd);
          }

          this.dom.__vd = nvd;
          this.dom.__defs = defs;
        } else if (renderMode === mode.WEBGL && !this.props.noRender) {
          this.__clear(ctx, renderMode);

          struct.renderWebgl(renderMode, ctx, this);
        } // 特殊cb，供小程序绘制完回调使用


        if (isFunction$9(cb)) {
          cb();
        }

        this.emit(Event.REFRESH, this.__rlv);
        this.__rlv = NONE$3;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.__destroy();

        this.animateController.__destroy();

        var n = this.dom;

        if (n) {
          removeEvent(n, this.__eventCbList || []);
          n.__root = null;
        }

        var gl = this.ctx;

        if (this.__texCache && gl) {
          this.__texCache.release(gl);

          if (gl.program) {
            gl.deleteShader(gl.program.vertexShader);
            gl.deleteShader(gl.program.fragmentShader);
            gl.deleteProgram(gl.program);
          }

          if (gl.programMask) {
            gl.deleteShader(gl.programMask.vertexShader);
            gl.deleteShader(gl.programMask.fragmentShader);
            gl.deleteProgram(gl.programMask);
          }

          if (gl.programOverflow) {
            gl.deleteShader(gl.programOverflow.vertexShader);
            gl.deleteShader(gl.programOverflow.fragmentShader);
            gl.deleteProgram(gl.programOverflow);
          }
        }
      }
    }, {
      key: "scale",
      value: function scale() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
        this.__scx = x;
        this.__scy = y;
      }
    }, {
      key: "resize",
      value: function resize(w, h, cb) {
        var self = this;

        if (w !== self.width || h !== self.height) {
          self.__width = w;
          self.__height = h;
          self.updateStyle({
            width: w,
            height: h
          }, cb);
        } else if (isFunction$9(cb)) {
          cb(-1);
        }
      }
    }, {
      key: "addRefreshTask",
      value: function addRefreshTask(cb) {
        var _this3 = this;

        var taskUp = this.taskUp,
            isDestroyed = this.isDestroyed;

        if (isDestroyed) {
          return;
        } // 第一个添加延迟侦听，后续放队列等待一并执行


        if (!taskUp.length) {
          var clone;
          frame.nextFrame({
            __before: function __before(diff) {
              if (_this3.isDestroyed) {
                return;
              }

              clone = taskUp.splice(0); // 前置一般是动画计算此帧样式应用，然后刷新后出发frame事件，图片加载等同

              if (clone.length) {
                clone.forEach(function (item, i) {
                  if (isObject$2(item) && isFunction$9(item.__before)) {
                    item.__before(diff);
                  }
                });
              }
            },
            __after: function __after(diff) {
              if (_this3.isDestroyed) {
                return;
              }

              clone.forEach(function (item) {
                if (isObject$2(item) && isFunction$9(item.__after)) {
                  item.__after(diff);
                } else if (isFunction$9(item)) {
                  item(diff);
                }
              });
            }
          });

          this.__frameHook();
        }

        if (taskUp.indexOf(cb) === -1) {
          taskUp.push(cb);
        }
      }
    }, {
      key: "addForceRefreshTask",
      value: function addForceRefreshTask(cb) {
        this.__hasRootUpdate = true;
        this.addRefreshTask(cb);
      }
    }, {
      key: "delRefreshTask",
      value: function delRefreshTask(cb) {
        if (!cb) {
          return;
        }

        var taskUp = this.taskUp;

        for (var i = 0, len = taskUp.length; i < len; i++) {
          if (taskUp[i] === cb) {
            taskUp.splice(i, 1);
            break;
          }
        }
      }
      /**
       * 为component的setState更新专门开辟个独立的流水线，root/frame中以taskCp存储更新列表
       * 普通的动画、img加载等都走普通的refresh的task，component走这里，frame中的结构同样
       * 在frame的每帧调用中，先执行普通的动画task，再执行component的task
       * 这样动画执行完后，某个cp的sr及子节点依旧先进行了动画变更，进入__addUpdate()环节
       * 然后此cp再更新sr及子节点，这样会被__addUpdate()添加到尾部，依赖目前浏览器默认实现
       * 上一行cp更新过程中是updater.check()进行的，如果有新老交换且有动画，动画的assigning是true，进行继承
       * root刷新parseUpdate()时，老的sr及子节点先进行，随后新的sr后进行且有component标识，sr子节点不会有更新
       * @param cb
       */

    }, {
      key: "addRefreshCp",
      value: function addRefreshCp(cb) {
        var _this4 = this;

        var taskCp = this.taskCp,
            isDestroyed = this.isDestroyed;

        if (isDestroyed) {
          return;
        } // 每次只执行1次


        if (!taskCp.length) {
          var clone;

          frame.__nextFrameCp({
            __before: function __before(diff) {
              if (_this4.isDestroyed) {
                return;
              }

              clone = taskCp.splice(0);

              if (clone.length) {
                clone.forEach(function (item) {
                  item.__before(diff);
                });
                updater.check(_this4);
                var len = updater.updateList.length;

                if (len) {
                  updater.updateList.forEach(function (cp) {
                    var root = cp.root; // 多个root并存时可能cp的引用不相同，需分别获取

                    var sr = cp.shadowRoot; // 可能返回text，需视为其parentNode

                    if (sr instanceof Text) {
                      sr = sr.domParent;
                    }

                    var res = {};
                    res[UPDATE_NODE$5] = sr;
                    res[UPDATE_STYLE$2] = sr.currentStyle;
                    res[UPDATE_FOCUS$4] = REFLOW$2;
                    res[UPDATE_COMPONENT] = cp;
                    res[UPDATE_CONFIG$5] = sr.__config;

                    _this4.__addUpdate(sr, sr.__config, root, root.__config, res);
                  });
                }
              }
            },
            __after: function __after(diff) {
              if (_this4.isDestroyed) {
                return;
              }

              clone.forEach(function (item) {
                item.__after(diff);
              }); // 触发didUpdate

              updater.did();
            }
          });

          this.__frameHook();
        }

        if (taskCp.indexOf(cb) === -1) {
          taskCp.push(cb);
        }
      }
    }, {
      key: "getTargetAtPoint",
      value: function getTargetAtPoint(x, y, includeIgnore) {
        function scan(vd, x, y, path, zPath) {
          var __sx1 = vd.__sx1,
              __sy1 = vd.__sy1,
              offsetWidth = vd.offsetWidth,
              offsetHeight = vd.offsetHeight,
              matrixEvent = vd.matrixEvent,
              children = vd.children,
              zIndexChildren = vd.zIndexChildren,
              _vd$computedStyle = vd.computedStyle,
              display = _vd$computedStyle[DISPLAY$8],
              pointerEvents = _vd$computedStyle[POINTER_EVENTS$2];

          if (!includeIgnore && display === 'none') {
            return;
          }

          if (Array.isArray(zIndexChildren)) {
            for (var i = 0, len = children.length; i < len; i++) {
              children[i].__index__ = i;
            }

            for (var _i2 = zIndexChildren.length - 1; _i2 >= 0; _i2--) {
              var item = zIndexChildren[_i2];

              if (item instanceof karas.Text) {
                continue;
              }

              var path2 = path.slice();
              path2.push(item.__index__);
              var zPath2 = zPath.slice();
              zPath2.push(_i2);
              var res = scan(item, x, y, path2, zPath2);

              if (res) {
                return res;
              }
            }
          }

          if (!includeIgnore && pointerEvents === 'none') {
            return;
          }

          var inThis = geom.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + offsetWidth, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight, __sx1, __sy1 + offsetHeight, matrixEvent);

          if (inThis) {
            return {
              target: vd,
              path: path,
              zPath: zPath
            };
          }
        }

        return scan(this, x, y, [], []);
      }
      /**
       * 每次刷新前检查root节点的样式，有些固定的修改无效，有些继承的作为根初始化
       * @param renderMode
       * @param width
       * @param height
       * @private
       */

    }, {
      key: "__checkRoot",
      value: function __checkRoot(renderMode, width, height) {
        var dom = this.dom,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle; // canvas/svg作为根节点一定是block或flex，不会是inline

        if (['flex', 'block'].indexOf(currentStyle[DISPLAY$8]) === -1) {
          computedStyle[DISPLAY$8] = currentStyle[DISPLAY$8] = 'block';
        } // 同理position不能为absolute


        if (currentStyle[POSITION$5] === 'absolute') {
          computedStyle[POSITION$5] = currentStyle[POSITION$5] = 'static';
        } // 根节点满宽高


        currentStyle[WIDTH$8] = [width, PX$9];
        currentStyle[HEIGHT$9] = [height, PX$9];
        computedStyle[WIDTH$8] = width;
        computedStyle[HEIGHT$9] = height; // 可能调用resize()导致变更，要重设，canvas无论离屏与否都可使用直接赋值，svg则按dom属性api

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          if (dom.width !== width) {
            dom.width = width;
          }

          if (dom.height !== height) {
            dom.height = height;
          }
        } else if (renderMode === mode.SVG) {
          dom.setAttribute('width', width);
          dom.setAttribute('height', height);
        }
      }
      /**
       * 添加更新入口，按节点汇总更新信息
       * @private
       */

    }, {
      key: "__addUpdate",
      value: function __addUpdate(node, nodeConfig, root, rootConfig, o) {
        var updateHash = rootConfig[NODE_UPDATE_HASH]; // root特殊处理，检查变更时优先看继承信息

        if (node === root) {
          updateHash = root.__updateRoot;

          if (updateHash) {
            if (o[UPDATE_FOCUS$4]) {
              updateHash[UPDATE_FOCUS$4] |= o[UPDATE_FOCUS$4];
            } // 后续存在新建list上，需增加遍历逻辑


            if (o[UPDATE_STYLE$2]) {
              var _list$push;

              var list = updateHash[UPDATE_LIST] = updateHash[UPDATE_LIST] || [];
              list.push((_list$push = {}, _defineProperty(_list$push, UPDATE_STYLE$2, o[UPDATE_STYLE$2]), _defineProperty(_list$push, UPDATE_OVERWRITE$1, o[UPDATE_OVERWRITE$1]), _defineProperty(_list$push, UPDATE_KEYS$2, o[UPDATE_KEYS$2]), _list$push));
            }
          } else {
            root.__updateRoot = o;
          }
        } else if (!nodeConfig.hasOwnProperty(NODE_UNIQUE_UPDATE_ID)) {
          nodeConfig[NODE_UNIQUE_UPDATE_ID] = uniqueUpdateId; // 大多数情况节点都只有一次更新，所以优化首次直接存在style上，后续存在list

          updateHash[uniqueUpdateId++] = o;
        } else if (updateHash.hasOwnProperty(nodeConfig[NODE_UNIQUE_UPDATE_ID])) {
          var target = updateHash[nodeConfig[NODE_UNIQUE_UPDATE_ID]];

          if (o[UPDATE_FOCUS$4]) {
            target[UPDATE_FOCUS$4] |= o[UPDATE_FOCUS$4];
          } // 后续存在新建list上，需增加遍历逻辑


          if (o[UPDATE_STYLE$2]) {
            var _list$push2;

            var _list = target[UPDATE_LIST] = target[UPDATE_LIST] || [];

            _list.push((_list$push2 = {}, _defineProperty(_list$push2, UPDATE_STYLE$2, o[UPDATE_STYLE$2]), _defineProperty(_list$push2, UPDATE_OVERWRITE$1, o[UPDATE_OVERWRITE$1]), _defineProperty(_list$push2, UPDATE_KEYS$2, o[UPDATE_KEYS$2]), _list$push2));
          }
        } else {
          inject.error('Update process miss uniqueUpdateId');
        }
      }
      /**
       * 除首次外每次刷新前检查更新列表，计算样式变化，以及测量信息
       * @private
       */

    }, {
      key: "__checkUpdate",
      value: function __checkUpdate(renderMode, ctx, width, height) {
        var root = this;
        var reflowList = [];
        var cacheHash = {};
        var cacheList = [];
        var zHash = {};
        var zList = [];
        var updateRoot = root.__updateRoot;
        var updateHash = root.__updateHash; // 给个方式使得外部可以强制刷新

        var hasUpdate = root.__hasRootUpdate;
        root.__hasRootUpdate = false; // root更新特殊提前，因为有继承因素

        if (updateRoot) {
          root.__updateRoot = null;
          hasUpdate = parseUpdate(renderMode, root, updateRoot, reflowList, cacheHash, cacheList); // 此时做root检查，防止root出现继承等无效样式，或者发生resize()

          if (hasUpdate) {
            root.__checkRoot(renderMode, width, height);
          }
        } // 汇总处理每个节点，k是递增数字直接循环遍历


        var keys = Object.keys(updateHash);

        for (var i = 0, len = keys.length; i < len; i++) {
          var t = parseUpdate(renderMode, root, updateHash[keys[i]], reflowList, cacheHash, cacheList, zHash, zList);
          hasUpdate = hasUpdate || t;
        } // 先做一部分reset避免下面measureList干扰，cacheList的是专门收集新增的额外节点


        root.__reflowList = reflowList;
        uniqueUpdateId = 0;
        root.__updateHash = root.__config[NODE_UPDATE_HASH] = {};
        cacheList.forEach(function (__config) {
          delete __config[NODE_UNIQUE_UPDATE_ID];
        }); // zIndex改变的汇总修改，防止重复操作

        zList.forEach(function (item) {
          if (item.hasOwnProperty('__uniqueZId')) {
            delete item.__uniqueZId;

            item.__updateStruct(root.__structs);
          }
        }); // 做完清空留待下次刷新重来

        for (var _i3 = 0, _len2 = keys.length; _i3 < _len2; _i3++) {
          delete updateHash[keys[_i3]][UPDATE_CONFIG$5][NODE_UNIQUE_UPDATE_ID];
        }

        return hasUpdate;
      }
      /**
       * 除首次外每次刷新前检查reflow列表，计算需要reflow的节点局部重新布局
       * 当一个元素absolute不变时，其变化不会影响父元素和兄弟元素，直接自己重新局部LAYOUT包含子节点
       * 当absolute发生改变时，其变化会影响父和兄弟，视作父重新布局
       * 当inline变化时，视为其最近block/flex父变化
       * 当block变化时，往上查找最上层flex视为其变化，如不是则影响后面兄弟offset和父resize
       * 当flex变化时，往上查找最上层flex视为其变化，如不是则影响所有递归子节点layout和父resize
       * 以上3种情况向上查找时遇到absolute父均提前跳出，并标记absolute父LAYOUT
       * 上面所有情况即便结束还得额外看是否处于absolute中，是还是标记absolute重新布局
       * 当relative只变化left/top/right/bottom时，自己重新layout
       * 检测节点时记录影响的所有节点，最终形成一棵或n棵局部树
       * 需要重新布局的记作LAYOUT，被兄弟影响只需偏移的记作OFFSET，OFFSET可能会重复变为LAYOUT
       * 上述情况倘若发生包含重复，去掉子树，因子树视为被包含的重新布局
       * 如果有从root开始的，直接重新布局像首次那样即可
       * 如果非root，所有树根按先根顺序记录下来，依次执行局部布局
       * =========================
       * addDom比较特殊，是向已有节点中添加新的节点，检查影响与普通domDiff变化不同
       * @private
       */

    }, {
      key: "__checkReflow",
      value: function __checkReflow(width, height) {
        var _this5 = this;

        var reflowList = this.__reflowList;

        if (!reflowList.length) {
          return;
        }

        var root = this;
        var uniqueList = [];
        var hasRoot;
        __uniqueReflowId = 0;
        var reflowHash = {}; // 遍历检查发生布局改变的节点列表，此时computedStyle还是老的，currentStyle是新的

        for (var i = 0, len = reflowList.length; i < len; i++) {
          var item = reflowList[i];
          var node = item.node,
              component = item.component,
              addDom = item.addDom,
              removeDom = item.removeDom; // root提前跳出，完全重新布局

          if (node === this) {
            hasRoot = true;
            break;
          } // 添加时如果是cp则node取sr来布局


          if (addDom && node instanceof Component$1) {
            node = node.shadowRoot;
          } // 每个节点生成唯一的布局识别id存入hash防止重复


          if (!node.hasOwnProperty('__uniqueReflowId')) {
            node.__uniqueReflowId = __uniqueReflowId;
            reflowHash[__uniqueReflowId++] = item;
          } // 每个节点都向上检查影响，以及是否从root开始完全重新，remove特殊对待，影响父节点视为普通父节点relay


          if (checkInfluence(root, reflowHash, node, component, addDom)) {
            hasRoot = true;

            if (addDom) {
              this.__zIndexChildren = null;
            }

            break;
          } // remove的要特殊对待，因为提前删除了父子兄弟关系，下面deepScan不会出现
          else if (removeDom) {
            uniqueList.push(item);
          }
        }

        __uniqueReflowId = 0;
        this.__reflowList = []; // 有root提前跳出

        if (hasRoot) {
          reflow.clearUniqueReflowId(reflowHash);
          var isUpright = this.currentStyle[WRITING_MODE$3].indexOf('vertical') === 0; // 布局分为两步，普通流和定位流，互相递归

          this.__layout({
            x: 0,
            y: 0,
            w: width,
            h: height,
            isUpright: isUpright
          }, false, false); // 绝对布局需要从根开始保存相对坐标系的容器引用，并根据relative/absolute情况变更


          this.__layoutAbs(this, {
            x: 0,
            y: 0,
            w: width,
            h: height,
            isUpright: isUpright
          });

          this.__structs = this.__structure(0, 0);
          return true;
        }
        /**
         * 修剪树，自顶向下深度遍历
         * LAYOUT节点作为局部根，其递归子节点无需重复任何操作，直接去重
         * OFFSET节点作为局部根，其递归子节点先执行任何操作，后续根节点再偏移一次
         */
        else {
          this.__deepScan(function (node, options) {
            if (node.hasOwnProperty('__uniqueReflowId')) {
              var o = reflowHash[node.__uniqueReflowId];
              options.uniqueList.push(o); // 返回true即可提前结束深度遍历，在reflowHash有记录时提前跳出，子节点交由上面逻辑执行

              return true;
            } // reflowHash没有记录则无返回继续递归执行

          }, {
            uniqueList: uniqueList
          });
          /**
           * 按顺序执行列表即可，上层LAYOUT先执行且停止递归子节点，上层OFFSET后执行等子节点先LAYOUT/OFFSET
           * 同级按先后顺序排列，过程中记录diff在结束后进行structs更新
           * 这里要注意margin合并的逻辑，因为最终都是block（flex等同），需要进行合并
           * 在处理一个block时，先判断是否是空block，同时看后面紧邻的有没有在uniqueList的下一个
           * 单独空block处理、2个相邻的非block处理直接可以进行判断
           * 中间的空block（即非空block的下一个是空block，且下一个不是最后一个），先记录下来list，合并后一并offset
           * 合并margin和Dom的逻辑一样，抽离共有方法
           **/


          var diffList = [];
          var diffI = 0;
          var mergeOffsetList = [];
          var __uniqueMergeOffsetId = 0;
          uniqueList.forEach(function (item) {
            var node = item.node,
                component = item.component,
                addDom = item.addDom,
                removeDom = item.removeDom; // 重新layout的w/h数据使用之前parent暂存的，x使用parent，y使用prev或者parent的

            var cps = node.computedStyle,
                cts = node.currentStyle;
            var zIndex = cps[Z_INDEX$4],
                position = cps[POSITION$5],
                display = cps[DISPLAY$8];
            var isLastAbs = position === 'absolute';
            var isNowAbs = cts[POSITION$5] === 'absolute';
            var isLastNone = display === 'none';
            var isNowNone = cts[DISPLAY$8] === 'none'; // none不可见布局无效可以无视

            if (isLastNone && isNowNone) {
              return;
            }

            var parent = node.domParent;
            var _parent$__layoutData = parent.__layoutData,
                x = _parent$__layoutData.x,
                y = _parent$__layoutData.y,
                h = _parent$__layoutData.h,
                width = parent.width,
                computedStyle = parent.computedStyle;
            var current = node; // cp的shadowRoot要向上到cp本身，考虑高阶组件在内到真正的顶层cp

            if (current.isShadowRoot) {
              current = current.hostRoot;
            } // y使用prev或者parent的，首个节点无prev，prev要忽略absolute的和display:none的


            var ref = current.prev;
            var hasFlowPrev;

            while (ref) {
              if (ref instanceof Text || ref.computedStyle[POSITION$5] !== 'absolute' && ref.computedStyle[DISPLAY$8] !== 'none') {
                y = ref.y + ref.outerHeight;
                hasFlowPrev = true;
                break;
              }

              ref = ref.prev;
            } // 找不到prev以parent为基准，找到则增加自身，排除remove


            if (!removeDom) {
              if (!hasFlowPrev) {
                y += computedStyle[MARGIN_TOP$5] + computedStyle[BORDER_TOP_WIDTH$8] + computedStyle[PADDING_TOP$7];
              }

              x += computedStyle[MARGIN_LEFT$7] + computedStyle[BORDER_LEFT_WIDTH$9] + computedStyle[PADDING_LEFT$9];
            } // 找到最上层容器，如果是组件的子节点，以sr为container，sr本身往上找


            var container = node; // remove的节点本身无需再次布局

            if (!removeDom) {
              if (isNowAbs) {
                container = container.domParent;

                while (container && container !== root) {
                  if (isRelativeOrAbsolute$2(container)) {
                    break;
                  } // 不能用domParent，必须在组件环境内


                  if (container.parent) {
                    container = container.parent;
                  } else if (container.host) {
                    break;
                  }
                }

                if (!container) {
                  container = root;
                } // 由setState引发的要检查是cp自身还是更上层，如果cp被abs包含，那么node是cp的父亲，否则node是cp的sr
                // 而这种情况下传cp或node都一样，所以最终统一传node


                parent.__layoutAbs(container, parent.__layoutData, node); // 优先判断dom变更


                if (addDom) {
                  var arr = parent.__modifyStruct(root, diffI);

                  diffI += arr[1];
                  diffList.push(arr);

                  parent.__updateStruct(root.__structs);

                  if (_this5.renderMode === mode.SVG) {
                    cleanSvgCache(parent);
                  }

                  return;
                } // 前后都是abs无需偏移后面兄弟和parent调整，component变化节点需更新struct
                else if (isLastAbs) {
                  if (component) {
                    var _arr = node.__modifyStruct(root, diffI);

                    diffI += _arr[1];
                    diffList.push(_arr);

                    if (position !== cts[POSITION$5] && (position === 'static' || cts[POSITION$5] === 'static') || zIndex !== cts[Z_INDEX$4]) {
                      parent.__updateStruct(root.__structs);

                      if (_this5.renderMode === mode.SVG) {
                        cleanSvgCache(parent);
                      }
                    }
                  } else if (isLastNone || isNowNone) {
                    node.__zIndexChildren = null;

                    var _arr2 = node.__modifyStruct(root, diffI);

                    diffI += _arr2[1];
                    diffList.push(_arr2);
                  }

                  return;
                } // 标识flow变abs，可能引发zIndex变更，重设struct和svg


                parent.__updateStruct(root.__structs);

                if (_this5.renderMode === mode.SVG) {
                  cleanSvgCache(parent);
                }
              } // 现在是普通流，不管之前是啥直接布局，排除remove删除的
              else {
                node.__layout({
                  x: x,
                  y: y,
                  w: width,
                  h: h
                }, false, false);

                y += node.outerHeight;

                if (component) {
                  container = node;
                } else {
                  container = container.domParent;

                  while (container && container !== root) {
                    if (isRelativeOrAbsolute$2(container)) {
                      break;
                    } // 不能用domParent，必须在组件环境内


                    if (container.parent) {
                      container = container.parent;
                    } else if (container.host) {
                      break;
                    }
                  }
                }

                if (!container) {
                  container = root;
                } // 防止geom


                if (node instanceof Dom$1) {
                  node.__layoutAbs(container, {
                    x: x,
                    y: y,
                    w: width,
                    h: h
                  });
                }
              }
            } // 向上查找最近的parent是relative，需再次累加ox/oy，无需继续向上递归，因为parent已经递归包含了
            // 这样node重新布局后再次设置其使用parent的偏移


            var p = node;

            while (p && p !== root) {
              p = p.domParent;
              computedStyle = p.computedStyle;

              if (computedStyle[POSITION$5] === 'relative') {
                var _p = p,
                    ox = _p.ox,
                    oy = _p.oy;
                ox && node.__offsetX(ox);
                oy && node.__offsetY(oy);
                break;
              }
            } // 向下调整next的flow位置，遇到重复LAYOUT的跳出等待其调用并处理其next，忽视掉abs，margin和abs在merge中做


            if (node.isShadowRoot) {
              node = node.hostRoot;
            }

            var next = node.next;

            while (next && !next.hasOwnProperty('__uniqueReflowId')) {
              if (next.computedStyle[POSITION$5] === 'absolute') {
                next = next.next;
                continue;
              }

              var _next = next,
                  _oy = _next.y;

              var _diff = y - _oy;

              if (_diff) {
                while (next && !next.hasOwnProperty('__uniqueReflowId')) {
                  var target = next;

                  if (target instanceof Component$1) {
                    target = target.shadowRoot;
                  }

                  var cs = target.computedStyle;

                  if (cs[POSITION$5] !== 'absolute' && cs[DISPLAY$8] !== 'none') {
                    target.__offsetY(_diff, true, REPAINT$3);
                  }

                  next = next.next;
                }
              }

              break;
            } // 去重防止abs并记录parent，整个结束后按先序顺序进行margin合并以及偏移，注意忽略有display:none变block同时为absolute的


            if (!parent.hasOwnProperty('__uniqueMergeOffsetId') && !(isNowAbs && isLastNone)) {
              parent.__uniqueMergeOffsetId = __uniqueMergeOffsetId++;
              mergeOffsetList.push(parent);
            } // add和remove都需父节点重新生成struct，zIndexChildren已在对应api操作的before()侦听做了


            if (addDom || removeDom) {
              var _arr3 = parent.__modifyStruct(root, diffI);

              diffI += _arr3[1];
              diffList.push(_arr3);

              if (_this5.renderMode === mode.SVG) {
                cleanSvgCache(parent);
              }
            } // component未知dom变化，所以强制重新struct，text则为其父节点，同时防止zIndex变更影响父节点
            else if (component) {
              var _arr4 = node.__modifyStruct(root, diffI);

              diffI += _arr4[1];
              diffList.push(_arr4);

              if (position !== cts[POSITION$5] && (position === 'static' || cts[POSITION$5] === 'static') || zIndex !== cts[Z_INDEX$4]) {
                node.domParent.__updateStruct(root.__structs);

                if (_this5.renderMode === mode.SVG) {
                  cleanSvgCache(node.domParent);
                }
              }
            } // display有none变化，重置struct和zIndexChildren
            else if (isLastNone || isNowNone) {
              node.__zIndexChildren = null;

              var _arr5 = node.__modifyStruct(root, diffI);

              diffI += _arr5[1];
              diffList.push(_arr5);
            }
          });
          /**
           * mergeMargin后续调整，记录的是变更节点的父节点，因此每个节点内部直接遍历孩子进行
           * 由于保持先根遍历的顺序，因此会从最上最里的节点开始，先进行margin合并
           * 由于之前忽略掉abs节点，因此再检查直接abs是否要调整
           * 完成后对此父节点的后续兄弟节点进行调整，多次不会干扰影响
           * 然后继续往上循环，直到root结束
           */

          var inDirectAbsList = [];
          mergeOffsetList.forEach(function (parent) {
            delete parent.__uniqueMergeOffsetId;
            var flowChildren = parent.flowChildren,
                absChildren = parent.absChildren;
            var mergeMarginBottomList = [],
                mergeMarginTopList = [];
            var length = flowChildren.length,
                lastChild;
            var isStart, startIndex; // 遍历flow孩子，从开始变化的节点开始，看变化造成的影响，对其后面节点进行偏移，并统计总偏移量

            for (var _i4 = 0; _i4 < length; _i4++) {
              var _item = flowChildren[_i4];

              if (_item instanceof Component$1) {
                _item = _item.shadowRoot;
              }

              var isXom = _item instanceof Xom$1; // 忽略掉前面没有变更的节点，不能合并

              if (!isStart && isXom) {
                if (_item.hasOwnProperty('__uniqueReflowId')) {
                  isStart = true;
                  startIndex = _i4;
                }
              } // 开始变更的节点，至少不是第0个


              var _cs = isXom && _item.currentStyle;

              var isInline = isXom && _cs[DISPLAY$8] === 'inline';
              var isInlineBlock = isXom && _cs[DISPLAY$8] === 'inlineBlock';
              lastChild = _item; // 每次循环开始前，这次不是block的话，看之前遗留的，可能是以空block结束，需要特殊处理，单独一个空block也包含

              if (!isXom || isInline || isInlineBlock) {
                if (mergeMarginBottomList.length && mergeMarginTopList.length && isStart) {
                  var _diff2 = reflow.getMergeMargin(mergeMarginTopList, mergeMarginBottomList);

                  if (_diff2) {
                    for (var j = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); j < length; j++) {
                      flowChildren[j].__offsetY(_diff2, true, REPAINT$3);
                    }
                  }
                }

                mergeMarginTopList = [];
                mergeMarginBottomList = [];
              } // 和普通布局类似，只是不用重新布局只需处理合并margin再根据差值偏移


              if (isXom && !isInline) {
                var isNone = isXom && _cs[DISPLAY$8] === 'none';
                var isEmptyBlock = void 0;

                if (!isNone && _item.flowChildren && _item.flowChildren.length === 0) {
                  var _item$computedStyle = _item.computedStyle,
                      marginTop = _item$computedStyle[MARGIN_TOP$5],
                      marginBottom = _item$computedStyle[MARGIN_BOTTOM$5],
                      paddingTop = _item$computedStyle[PADDING_TOP$7],
                      paddingBottom = _item$computedStyle[PADDING_BOTTOM$7],
                      _height = _item$computedStyle[HEIGHT$9],
                      borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH$8],
                      borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH$8]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

                  if (paddingTop <= 0 && paddingBottom <= 0 && _height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                    mergeMarginBottomList.push(marginBottom);
                    mergeMarginTopList.push(marginTop);
                    isEmptyBlock = true;
                  }
                } // 空block要留下轮循环看，除非是最后一个，非空本轮处理掉看是否要合并


                if (!isNone && !isEmptyBlock) {
                  var _item$computedStyle2 = _item.computedStyle,
                      _marginTop = _item$computedStyle2[MARGIN_TOP$5],
                      _marginBottom = _item$computedStyle2[MARGIN_BOTTOM$5]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
                  // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

                  if (mergeMarginBottomList.length) {
                    mergeMarginTopList.push(_marginTop);

                    if (isStart) {
                      var _diff3 = reflow.getMergeMargin(mergeMarginTopList, mergeMarginBottomList); // 需要合并的情况，根据记录数和索引向上向下遍历节点设置偏移，同时设置总偏移量供父级使用


                      if (_diff3) {
                        for (var _j = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); _j < length; _j++) {
                          flowChildren[_j].__offsetY(_diff3, true, REPAINT$3);
                        }
                      }
                    }
                  } // 同时自己保存bottom，为后续block准备


                  mergeMarginTopList = [];
                  mergeMarginBottomList = [_marginBottom];
                } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0，最后一个一定有不必判断isStart
                else if (_i4 === length - 1) {
                  var _diff4 = reflow.getMergeMargin(mergeMarginTopList, mergeMarginBottomList);

                  if (_diff4) {
                    for (var _j2 = Math.max(startIndex, _i4 - mergeMarginBottomList.length + 1); _j2 < length; _j2++) {
                      flowChildren[_j2].__offsetY(_diff4, true, REPAINT$3);
                    }
                  }
                }
              }
            } // 先检查parent的尺寸是否发生了变化，从而决定是否调整next以及向上递归调整


            var cs = parent.currentStyle;
            var height = cs[HEIGHT$9];
            var isContainer = parent === root || parent.isShadowRoot || cs[POSITION$5] === 'absolute' || cs[POSITION$5] === 'relative';

            if (height[1] === AUTO$8 && lastChild) {
              var oldH = parent.height + parent.computedStyle[PADDING_TOP$7];
              var nowH = lastChild.y + lastChild.outerHeight - parent.y;

              var _diff5 = nowH - oldH; // 调整next以及非固定PX的abs，再递归向上


              if (_diff5) {
                parent.__resizeY(_diff5, REPAINT$3);

                var container;

                for (var _i5 = 0, _len3 = absChildren.length; _i5 < _len3; _i5++) {
                  var _item2 = absChildren[_i5];
                  var _item2$currentStyle = _item2.currentStyle,
                      top = _item2$currentStyle[TOP$4],
                      bottom = _item2$currentStyle[BOTTOM$4],
                      _height2 = _item2$currentStyle[HEIGHT$9]; // 是容器，所有的都调整，不是容器，其偏移是上级parent的某一个，根据情况具体不同

                  if (top[1] === AUTO$8) {
                    if (bottom[1] === AUTO$8) {
                      var prev = _item2.prev;

                      while (prev) {
                        var target = prev;

                        if (target instanceof Component$1) {
                          target = target.shadowRoot;
                        }

                        var _isXom = target instanceof Xom$1;

                        var _cs2 = _isXom && target.currentStyle;

                        var isAbs = _isXom && _cs2[POSITION$5] === 'absolute';

                        if (!isAbs) {
                          var y = target.y + target.outerHeight;
                          var d = y - _item2.y;

                          if (d) {
                            _item2.__offsetY(d, true, REPAINT$3);
                          }

                          break;
                        }

                        prev = prev.prev;
                      }
                    } else if (bottom[1] === PX$9) {
                      _item2.__offsetY(_diff5, true, REPAINT$3);
                    } else if (bottom[1] === PERCENT$a) {
                      var v = (1 - bottom[0] * 0.01) * _diff5;

                      _item2.__offsetY(v, true, REPAINT$3);
                    }
                  } else if (top[1] === PERCENT$a) {
                    if (isContainer) {
                      var _v = top[0] * 0.01 * _diff5;

                      _item2.__offsetY(_v, true, REPAINT$3);
                    } // 非容器的特殊处理
                    else {
                      if (!container) {
                        container = parent.domParent;

                        while (container) {
                          if (container === root || container.isShadowRoot) {
                            break;
                          }

                          var _cs3 = container.currentStyle;

                          if (_cs3[POSITION$5] === 'absolute' || _cs3[POSITION$5] === 'relative') {
                            break;
                          }

                          container = container.domParent;
                        }
                      }

                      if (container.currentStyle[HEIGHT$9][1] !== PX$9) {
                        var _v2 = top[0] * 0.01 * _diff5;

                        _item2.__offsetY(_v2, true, REPAINT$3);
                      }
                    }
                  } // 高度百分比需发生变化的重新布局，需要在容器内


                  if (_height2[1] === PERCENT$a) {
                    if (isContainer) {
                      parent.__layoutAbs(parent, parent.__layoutData, _item2);
                    } // 不在容器内说明在上级，存入等结束后统一重新布局
                    else {
                      if (!container) {
                        container = parent.domParent;

                        while (container) {
                          if (container === root || container.isShadowRoot) {
                            break;
                          }

                          var _cs4 = container.currentStyle;

                          if (_cs4[POSITION$5] === 'absolute' || _cs4[POSITION$5] === 'relative') {
                            break;
                          }

                          container = container.domParent;
                        }
                      }

                      inDirectAbsList.push([parent, container, _item2]);
                    }
                  }
                }

                reflow.offsetAndResizeByNodeOnY(parent, root, reflowHash, _diff5, inDirectAbsList);
                return;
              }
            } // 没有diff变化或者固定尺寸，可能内部发生变化，调整AUTO的abs，不递归向上


            for (var _i6 = 0, _len4 = absChildren.length; _i6 < _len4; _i6++) {
              var _item3 = absChildren[_i6];
              var _item3$currentStyle = _item3.currentStyle,
                  _top = _item3$currentStyle[TOP$4],
                  _bottom = _item3$currentStyle[BOTTOM$4];

              if (_top[1] === AUTO$8 && _bottom[1] === AUTO$8) {
                var _prev = _item3.prev;

                while (_prev) {
                  var _target = _prev;

                  if (_target instanceof Component$1) {
                    _target = _target.shadowRoot;
                  }

                  var _isXom2 = _target instanceof Xom$1;

                  var _cs5 = _isXom2 && _target.currentStyle;

                  var _isAbs = _isXom2 && _cs5[POSITION$5] === 'absolute';

                  if (!_isAbs) {
                    var _y = _target.y + _target.outerHeight;

                    var _d = _y - _item3.y;

                    if (_d) {
                      _item3.__offsetY(_d, true, REPAINT$3);
                    }

                    break;
                  }

                  _prev = _prev.prev;
                }
              }
            }
          }); // merge过程中需要重新布局的abs

          inDirectAbsList.forEach(function (arr) {
            arr[0].__layoutAbs(arr[1], arr[0].__layoutData, arr[2]);
          }); // 调整因reflow造成的原struct数据索引数量偏差，纯zIndex的已经在repaint里面重新生成过了
          // 这里因为和update保持一致的顺序，因此一定是先根顺序且互不包含

          var diff = 0,
              lastIndex = 0,
              isFirst = true,
              structs = root.__structs;
          diffList.forEach(function (item) {
            var _item4 = _slicedToArray(item, 2),
                ns = _item4[0],
                d = _item4[1]; // 第一个有变化的，及后面无论有无变化都需更新
            // 第1个变化区域无需更改前面一段


            if (isFirst) {
              isFirst = false;
              lastIndex = ns[STRUCT_INDEX$3] + (ns[STRUCT_TOTAL$2] || 0) + 1;
              diff += d;
            } // 第2+个变化区域看是否和前面一个相连，有不变的段则先偏移它，然后再偏移自己
            else {
              var j = ns[STRUCT_INDEX$3] + (ns[STRUCT_TOTAL$2] || 0) + 1 + diff;

              for (var _i7 = lastIndex; _i7 < j; _i7++) {
                structs[_i7][STRUCT_INDEX$3] += diff;
              }

              lastIndex = j;
              diff += d;
            }
          }); // 后面的要根据偏移量校正索引

          if (diff) {
            for (var _i8 = lastIndex, _len5 = structs.length; _i8 < _len5; _i8++) {
              structs[_i8][STRUCT_INDEX$3] += diff;
            }
          } // 清除id


          reflow.clearUniqueReflowId(reflowHash);
        }
      } // 每个root拥有一个刷新hook，多个root塞到frame的__hookTask里
      // frame在所有的帧刷新逻辑执行后检查hook列表，进行root刷新操作

    }, {
      key: "__frameHook",
      value: function __frameHook() {
        var _this6 = this;

        if (!this.__hookTask) {
          var r = this.__hookTask = function () {
            _this6.refresh();
          };

          frame.__hookTask.push(r);
        }
      }
    }, {
      key: "__clear",
      value: function __clear(ctx, renderMode) {
        if (renderMode === mode.CANVAS) {
          // 可能会调整宽高，所以每次清除用最大值
          this.__mw = Math.max(this.__mw, this.width);
          this.__mh = Math.max(this.__mh, this.height); // 清除前得恢复默认matrix，防止每次布局改变了属性

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, this.__mw, this.__mh);
        } else if (renderMode === mode.WEBGL) {
          ctx.clearColor(0, 0, 0, 0);
          ctx.clear(ctx.COLOR_BUFFER_BIT);
        }
      }
    }, {
      key: "dom",
      get: function get() {
        return this.__dom;
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "renderMode",
      get: function get() {
        return this.__renderMode;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__ctx;
      }
    }, {
      key: "defs",
      get: function get() {
        return this.__defs;
      }
    }, {
      key: "taskUp",
      get: function get() {
        return this.__taskUp;
      }
    }, {
      key: "taskCp",
      get: function get() {
        return this.__taskCp;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "animateController",
      get: function get() {
        return this.__animateController;
      }
    }, {
      key: "texCache",
      get: function get() {
        return this.__texCache;
      }
    }]);

    return Root;
  }(Dom$1);

  var STROKE_WIDTH$2 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$a = util.isNil;

  function reBuild(target, origin, base, isMulti) {
    if (isMulti) {
      return target.map(function (item) {
        return origin + item * base;
      });
    } else {
      return origin + target * base;
    }
  }

  function reBuildC(target, originX, originY, width, height, isMulti) {
    if (isMulti) {
      if (target) {
        return target.map(function (item) {
          return reBuildC(item, originX, originY, width, height);
        });
      }
    } else {
      if (target && target.length >= 2) {
        return [originX + target[0] * width, originY + target[1] * height];
      }
    }

    return [];
  }

  function curveNum(controlA, controlB) {
    var num = 0;

    if (controlA && controlA.length >= 2) {
      num++;
    }

    if (controlB && controlB.length >= 2) {
      num += 2;
    }

    return num;
  }

  function getNewPoint(x1, y1, x2, y2, controlA, controlB, num) {
    var start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

    if (start === 0 && end === 1) {
      return [x1, y1, x2, y2, controlA, controlB];
    }

    if (start === end) {
      return [];
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    }

    start = Math.max(0, start);
    end = Math.min(1, end);

    if (num === 3) {
      var _geom$sliceBezier2Bot = geom.sliceBezier2Both([[x1, y1], controlA, controlB, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot2 = _slicedToArray(_geom$sliceBezier2Bot, 4);

      var _geom$sliceBezier2Bot3 = _slicedToArray(_geom$sliceBezier2Bot2[0], 2);

      x1 = _geom$sliceBezier2Bot3[0];
      y1 = _geom$sliceBezier2Bot3[1];
      controlA = _geom$sliceBezier2Bot2[1];
      controlB = _geom$sliceBezier2Bot2[2];

      var _geom$sliceBezier2Bot4 = _slicedToArray(_geom$sliceBezier2Bot2[3], 2);

      x2 = _geom$sliceBezier2Bot4[0];
      y2 = _geom$sliceBezier2Bot4[1];
    } else if (num === 2) {
      var _geom$sliceBezier2Bot5 = geom.sliceBezier2Both([[x1, y1], controlB, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot6 = _slicedToArray(_geom$sliceBezier2Bot5, 3);

      var _geom$sliceBezier2Bot7 = _slicedToArray(_geom$sliceBezier2Bot6[0], 2);

      x1 = _geom$sliceBezier2Bot7[0];
      y1 = _geom$sliceBezier2Bot7[1];
      controlB = _geom$sliceBezier2Bot6[1];

      var _geom$sliceBezier2Bot8 = _slicedToArray(_geom$sliceBezier2Bot6[2], 2);

      x2 = _geom$sliceBezier2Bot8[0];
      y2 = _geom$sliceBezier2Bot8[1];
    } else if (num === 1) {
      var _geom$sliceBezier2Bot9 = geom.sliceBezier2Both([[x1, y1], controlA, [x2, y2]], start, end);

      var _geom$sliceBezier2Bot10 = _slicedToArray(_geom$sliceBezier2Bot9, 3);

      var _geom$sliceBezier2Bot11 = _slicedToArray(_geom$sliceBezier2Bot10[0], 2);

      x1 = _geom$sliceBezier2Bot11[0];
      y1 = _geom$sliceBezier2Bot11[1];
      controlA = _geom$sliceBezier2Bot10[1];

      var _geom$sliceBezier2Bot12 = _slicedToArray(_geom$sliceBezier2Bot10[2], 2);

      x2 = _geom$sliceBezier2Bot12[0];
      y2 = _geom$sliceBezier2Bot12[1];
    } else {
      var a = x2 - x1;
      var b = y2 - y1;
      x1 += a * start;
      y1 += b * start;
      x2 += a * (1 - end);
      y2 += b * (1 - end);
    }

    return [x1, y1, x2, y2, controlA, controlB];
  }

  var Line = /*#__PURE__*/function (_Geom) {
    _inherits(Line, _Geom);

    var _super = _createSuper(Line);

    function Line(tagName, props) {
      var _this;

      _classCallCheck(this, Line);

      _this = _super.call(this, tagName, props); // x1,y1和x2,y2表明线段的首尾坐标，control表明控制点坐标

      if (_this.isMulti) {
        _this.__x1 = [0];
        _this.__y1 = [0];
        _this.__x2 = [1];
        _this.__y2 = [1];
        _this.__controlA = [[]];
        _this.__controlB = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.x1)) {
          _this.__x1 = props.x1.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$a(props.x1)) {
          _this.__x1 = [parseFloat(props.x1) || 0];
        }

        if (Array.isArray(props.y1)) {
          _this.__y1 = props.y1.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$a(props.y1)) {
          _this.__y1 = [parseFloat(props.y1) || 0];
        }

        if (Array.isArray(props.x2)) {
          _this.__x2 = props.x2.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$a(props.x2)) {
          _this.__x2 = [parseFloat(props.x2) || 0];
        }

        if (Array.isArray(props.y2)) {
          _this.__y2 = props.y2.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$a(props.y2)) {
          _this.__y2 = [parseFloat(props.y2) || 0];
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__x1.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$a(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__x1.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i = _this.__end.length; _i < _this.__x1.length; _i++) {
            _this.__end.push(1);
          }
        } else if (!isNil$a(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__x1.map(function () {
            return _v;
          });
        }
      } else {
        _this.__x1 = _this.__y1 = _this.__start = 0;
        _this.__x2 = _this.__y2 = _this.__end = 1;
        _this.__controlA = [];
        _this.__controlB = [];

        if (!isNil$a(props.x1)) {
          _this.__x1 = parseFloat(props.x1) || 0;
        }

        if (!isNil$a(props.y1)) {
          _this.__y1 = parseFloat(props.y1) || 0;
        }

        if (!isNil$a(props.x2)) {
          _this.__x2 = parseFloat(props.x2) || 0;
        }

        if (!isNil$a(props.y2)) {
          _this.__y2 = parseFloat(props.y2) || 0;
        }

        if (!isNil$a(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$a(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA;
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB;
        }
      }

      return _this;
    }

    _createClass(Line, [{
      key: "buildCache",
      value: function buildCache(originX, originY, focus) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;
        ['x1', 'x2'].forEach(function (k) {
          if (isNil$a(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originX, width, isMulti);
          }
        });
        ['y1', 'y2'].forEach(function (k) {
          if (isNil$a(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originY, height, isMulti);
          }
        });
        ['controlA', 'controlB'].forEach(function (k) {
          if (isNil$a(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuildC(_this2[k], originX, originY, width, height, isMulti);
          }
        });
        ['start', 'end'].forEach(function (k) {
          if (isNil$a(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = _this2[k];
          }
        });
        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx2, dy2) {
        var _this3 = this;

        var res = _get(_getPrototypeOf(Line.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx2, dy2);

        if (res["break"]) {
          return res;
        }

        ctx = res.ctx;
        var sx3 = res.sx3,
            sy3 = res.sy3,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild = this.buildCache(sx3, sy3);

        if (rebuild && renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            __cacheProps.x1.forEach(function (xa, i) {
              var xb = __cacheProps.x2[i];
              var ya = __cacheProps.y1[i];
              var yb = __cacheProps.y2[i];
              var ca = __cacheProps.controlA[i];
              var cb = __cacheProps.controlB[i];
              var start = __cacheProps.start[i];
              var end = __cacheProps.end[i];
              var curve = curveNum(ca, cb);

              if (start !== 0 || end !== 1) {
                var _getNewPoint = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                var _getNewPoint2 = _slicedToArray(_getNewPoint, 6);

                xa = _getNewPoint2[0];
                ya = _getNewPoint2[1];
                xb = _getNewPoint2[2];
                ya = _getNewPoint2[3];
                ca = _getNewPoint2[4];
                cb = _getNewPoint2[5];
              }

              d += painter.svgLine(xa, ya, xb, yb, ca, cb, curve);
            });
          } else {
            var curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);
            var x1 = __cacheProps.x1,
                y1 = __cacheProps.y1,
                x2 = __cacheProps.x2,
                y2 = __cacheProps.y2,
                controlA = __cacheProps.controlA,
                controlB = __cacheProps.controlB,
                start = __cacheProps.start,
                end = __cacheProps.end;

            if (start !== 0 || end !== 1) {
              var _getNewPoint3 = getNewPoint(x1, y1, x2, y2, controlA, controlB, curve, start, end, __cacheProps.len);

              var _getNewPoint4 = _slicedToArray(_getNewPoint3, 6);

              x1 = _getNewPoint4[0];
              y1 = _getNewPoint4[1];
              x2 = _getNewPoint4[2];
              y2 = _getNewPoint4[3];
              controlA = _getNewPoint4[4];
              controlB = _getNewPoint4[5];
            }

            d = painter.svgLine(x1, y1, x2, y2, controlA, controlB, curve);
          }

          __cacheProps.d = d;
        }

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

            if (strokeWidth > 0 && stroke !== 'none') {
              _this3.__preSetCanvas(renderMode, ctx, {
                stroke: stroke,
                strokeWidth: strokeWidth,
                strokeDasharray: strokeDasharrays[i],
                strokeLinecap: strokeLinecaps[i],
                strokeLinejoin: strokeLinejoins[i],
                strokeMiterlimit: strokeMiterlimits[i]
              });

              if (isStrokeRE) {
                ctx.strokeStyle = stroke.v[0];
              }

              ctx.beginPath();

              if (isMulti) {
                __cacheProps.x1.forEach(function (xa, i) {
                  var xb = __cacheProps.x2[i];
                  var ya = __cacheProps.y1[i];
                  var yb = __cacheProps.y2[i];
                  var ca = __cacheProps.controlA[i];
                  var cb = __cacheProps.controlB[i];
                  var start = __cacheProps.start[i];
                  var end = __cacheProps.end[i];
                  var curve = curveNum(ca, cb);

                  if (start !== 0 || end !== 1) {
                    var _getNewPoint5 = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                    var _getNewPoint6 = _slicedToArray(_getNewPoint5, 6);

                    xa = _getNewPoint6[0];
                    ya = _getNewPoint6[1];
                    xb = _getNewPoint6[2];
                    ya = _getNewPoint6[3];
                    ca = _getNewPoint6[4];
                    cb = _getNewPoint6[5];
                  }

                  painter.canvasLine(ctx, xa, ya, xb, yb, ca, cb, curve, dx, dy);
                });
              } else {
                var _curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);

                var _x = __cacheProps.x1,
                    _y = __cacheProps.y1,
                    _x2 = __cacheProps.x2,
                    _y2 = __cacheProps.y2,
                    _controlA = __cacheProps.controlA,
                    _controlB = __cacheProps.controlB,
                    _start = __cacheProps.start,
                    _end = __cacheProps.end;

                if (_start !== 0 || _end !== 1) {
                  var _getNewPoint7 = getNewPoint(_x, _y, _x2, _y2, _controlA, _controlB, _curve, _start, _end, __cacheProps.len);

                  var _getNewPoint8 = _slicedToArray(_getNewPoint7, 6);

                  _x = _getNewPoint8[0];
                  _y = _getNewPoint8[1];
                  _x2 = _getNewPoint8[2];
                  _y2 = _getNewPoint8[3];
                  _controlA = _getNewPoint8[4];
                  _controlB = _getNewPoint8[5];
                }

                painter.canvasLine(ctx, _x, _y, _x2, _y2, _controlA, _controlB, _curve, dx, dy);
              }

              ctx.stroke();
              ctx.closePath();
            }
          });
        } else if (renderMode === mode.SVG) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);
            var props = [['d', __cacheProps.d], ['fill', 'none'], ['stroke', isStrokeRE ? stroke.v[0] : stroke.v || stroke], ['stroke-width', strokeWidth]];

            _this3.__propsStrokeStyle(props, strokeDasharrayStrs[i], strokeLinecaps[i], strokeLinejoins[i], strokeMiterlimits[i]);

            _this3.addGeom('path', props);
          });
        }

        return res;
      }
    }, {
      key: "x1",
      get: function get() {
        return this.getProps('x1');
      }
    }, {
      key: "y1",
      get: function get() {
        return this.getProps('y1');
      }
    }, {
      key: "x2",
      get: function get() {
        return this.getProps('x2');
      }
    }, {
      key: "y2",
      get: function get() {
        return this.getProps('y2');
      }
    }, {
      key: "controlA",
      get: function get() {
        return this.getProps('controlA');
      }
    }, {
      key: "controlB",
      get: function get() {
        return this.getProps('controlB');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            originX = this.__sx3,
            originY = this.__sy3,
            strokeWidth = this.computedStyle[STROKE_WIDTH$2];
        this.buildCache(originX, originY);
        var x1 = __cacheProps.x1,
            y1 = __cacheProps.y1,
            x2 = __cacheProps.x2,
            y2 = __cacheProps.y2,
            controlA = __cacheProps.controlA,
            controlB = __cacheProps.controlB;

        var bbox = _get(_getPrototypeOf(Line.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          half = Math.max(half, item);
        });
        half = Math.ceil(half * 0.5) + 1;

        if (!isMulti) {
          x1 = [x1];
          x2 = [x2];
          y1 = [y1];
          y2 = [y2];
          controlA = [controlA];
          controlB = [controlB];
        }

        x1.forEach(function (xa, i) {
          var ya = y1[i];
          var xb = x2[i];
          var yb = y2[i];
          var ca = controlA[i];
          var cb = controlB[i];

          if ((isNil$a(ca) || ca.length < 2) && (isNil$a(cb) || cb.length < 2)) {
            bbox[0] = Math.min(bbox[0], xa - half);
            bbox[0] = Math.min(bbox[0], xb - half);
            bbox[1] = Math.min(bbox[1], ya - half);
            bbox[1] = Math.min(bbox[1], yb - half);
            bbox[2] = Math.max(bbox[2], xa + half);
            bbox[2] = Math.max(bbox[2], xb + half);
            bbox[3] = Math.max(bbox[3], ya + half);
            bbox[3] = Math.max(bbox[3], yb + half);
          } else if (isNil$a(ca) || ca.length < 2) {
            var bezierBox = geom.bboxBezier(xa, ya, cb[0], cb[1], xb, yb);
            bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
          } else if (isNil$a(cb) || cb.length < 2) {
            var _bezierBox = geom.bboxBezier(xa, ya, ca[0], ca[1], xb, yb);

            bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
          } else {
            var _bezierBox2 = geom.bboxBezier(xa, ya, ca[0], ca[1], cb[0], cb[1], xb, yb);

            bbox[0] = Math.min(bbox[0], _bezierBox2[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox2[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[3] + half);
          }
        });
        return bbox;
      }
    }]);

    return Line;
  }(Geom$1);

  var STROKE_WIDTH$3 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$b = util.isNil;

  function concatPointAndControl(point, control) {
    if (Array.isArray(control) && (control.length === 2 || control.length === 4) && Array.isArray(point) && point.length === 2) {
      return control.concat(point);
    }

    return point;
  }

  function getLength(list, isMulti) {
    var res = [];
    var total = 0;
    var increase = [];

    if (isMulti) {
      total = [];
      list.forEach(function (list) {
        var temp = getLength(list);
        res.push(temp.list);
        total.push(temp.total);
        increase.push([0].concat(temp.increase));
      });
    } else if (Array.isArray(list)) {
      total = 0;
      increase.push(0);
      var start = 0;

      for (var i = 0, len = list.length; i < len; i++) {
        var item = list[i];

        if (Array.isArray(item)) {
          start = i;
          break;
        }
      }

      var prev = list[start];

      for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
        var _item = list[_i];

        if (!Array.isArray(_item)) {
          continue;
        }

        if (_item.length === 2) {
          var a = Math.abs(_item[0] - prev[0]);
          var b = Math.abs(_item[1] - prev[1]);
          var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
          res.push(c);
          total += c;
          increase.push(total);
          prev = _item;
        } else if (_item.length === 4) {
          var _c = geom.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]]], 2);

          res.push(_c);
          total += _c;
          increase.push(total);
          prev = [_item[2], _item[3]];
        } else if (_item.length === 6) {
          var _c2 = geom.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]], [_item[4], _item[5]]], 3);

          res.push(_c2);
          total += _c2;
          increase.push(total);
          prev = [_item[4], _item[5]];
        }
      }
    }

    return {
      list: res,
      total: total,
      increase: increase
    };
  }

  function getIndex(list, t, i, j) {
    if (i === j) {
      if (list[i] > t) {
        return i - 1;
      }

      return i;
    }

    var middle = i + (j - i >> 1);

    if (list[middle] === t) {
      return middle;
    } else if (list[middle] > t) {
      return getIndex(list, t, i, Math.max(middle - 1, i));
    } else {
      return getIndex(list, t, Math.min(middle + 1, j), j);
    }
  }

  function getNewList(list, len) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    if (start === 0 && end === 1) {
      return list;
    }

    if (start === end) {
      return [];
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    } // start和end只能相差<=1，如果>1则校正


    while (end - start > 1) {
      end--;
    } // 将start和end统一至最接近0的正值


    while (end < 0 || start < 0) {
      end++;
      start++;
    }

    while (end >= 1 && start >= 1) {
      end--;
      start--;
    } // clone出原本顶点列表，防止干扰


    var length = list.length;
    list = util.clone(list);
    var res = [];
    var start2 = start > 1 ? start - 1 : start;
    var end2 = end > 1 ? end - 1 : end;
    var i = getIndex(len.increase, start2 * len.total, 0, length - 1);
    var j = getIndex(len.increase, end2 * len.total, 0, length - 1); // start<0或者end>1或者普通情况，一共3种，start和end不可能同时超限

    var isStartLt0 = start < 0;
    var isEndGt1 = end > 1;
    end2 *= len.total;
    var prePercent = 1;
    var endPoint;

    if (end2 > len.increase[j]) {
      var prev = list[j].slice(list[j].length - 2); // 最后2个点是x,y，前面是control

      var current = list[j + 1];
      var l = len.list[j];
      var diff = end2 - len.increase[j];
      var t = diff / l;
      prePercent = t;

      if (current.length === 2) {
        var a = current[0] - prev[0];
        var b = current[1] - prev[1];

        if (isEndGt1) {
          endPoint = [prev[0] + t * a, prev[1] + t * b];
        } else {
          t = 1 - t;
          endPoint = [current[0] - t * a, current[1] - t * b];
        }
      } else if (current.length === 4) {
        var r = geom.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]]], t);
        endPoint = [r[1][0], r[1][1], r[2][0], r[2][1]];
      } else if (current.length === 6) {
        var _r = geom.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]], [current[4], current[5]]], t);

        endPoint = [_r[1][0], _r[1][1], _r[2][0], _r[2][1], _r[3][0], _r[3][1]];
      }
    }

    start2 *= len.total;

    if (start2 > len.increase[i]) {
      var _current;

      var _prev = list[i].slice(list[i].length - 2);

      var _l = len.list[i]; // 同一条线段时如果有end裁剪，会影响start长度，这里还要防止头尾绕了一圈的情况

      if (i === j && !isStartLt0 && !isEndGt1 && prePercent !== 1) {
        _l *= prePercent;

        if (endPoint) {
          _current = endPoint;
        }
      }

      if (!_current) {
        _current = list[i + 1];
      }

      var _diff = start2 - len.increase[i];

      var _t = _diff / _l;

      if (_current.length === 2) {
        var _a = _current[0] - _prev[0];

        var _b = _current[1] - _prev[1];

        if (isStartLt0) {
          _t = 1 - _t;
          res.push([_current[0] - _t * _a, _current[1] - _t * _b]);
        } else {
          res.push([_prev[0] + _t * _a, _prev[1] + _t * _b]);
        }

        res.push(_current);
      } else if (_current.length === 4) {
        var _r2 = geom.sliceBezier([[_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

        res.push(_r2[0]);
        res.push([_r2[1][0], _r2[1][1], _r2[2][0], _r2[2][1]]); // 同一条线段上去除end冲突

        if (i === j && !isStartLt0 && !isEndGt1) {
          endPoint = null;
        }
      } else if (_current.length === 6) {
        var _r3 = geom.sliceBezier([[_current[4], _current[5]], [_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

        res.push(_r3[0]);
        res.push([_r3[1][0], _r3[1][1], _r3[2][0], _r3[2][1], _current[4], _current[5]]);

        if (i === j && !isStartLt0 && !isEndGt1) {
          endPoint = null;
        }
      }
    } // start和end之间的线段，注意头尾饶了一圈的情况，以及起始点被上方考虑过了


    for (var k = i + 2; k <= j + (!isStartLt0 && !isEndGt1 ? 0 : length); k++) {
      res.push(list[k % length]);
    }

    if (endPoint) {
      res.push(endPoint);
    }

    return res;
  }

  var Polyline = /*#__PURE__*/function (_Geom) {
    _inherits(Polyline, _Geom);

    var _super = _createSuper(Polyline);

    function Polyline(tagName, props) {
      var _this;

      _classCallCheck(this, Polyline);

      _this = _super.call(this, tagName, props); // 所有点的列表

      if (_this.isMulti) {
        _this.__points = [[]];
        _this.__controls = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__points.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$b(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__points.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i2 = _this.__end.length; _i2 < _this.__points.length; _i2++) {
            _this.__end.push(1);
          }
        } else if (!isNil$b(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__points.map(function () {
            return _v;
          });
        }
      } else {
        _this.__points = []; // 控制点

        _this.__controls = [];
        _this.__start = 0;
        _this.__end = 1;

        if (!isNil$b(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$b(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }
      }

      if (Array.isArray(props.controls)) {
        _this.__controls = props.controls;
      }

      if (Array.isArray(props.points)) {
        _this.__points = props.points;
      }

      return _this;
    }

    _createClass(Polyline, [{
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        return points.map(function (item, i) {
          if (!Array.isArray(item)) {
            return;
          }

          var len = item.length;

          if (isControl) {
            if (len !== 0 && len !== 2 && len !== 4) {
              return;
            }
          } else {
            if (len !== 0 && len !== 2) {
              return;
            }
          }

          var res = [];

          for (var _i3 = 0; _i3 < len; _i3++) {
            if (_i3 % 2 === 0) {
              res.push(originX + item[_i3] * width);
            } else {
              res.push(originY + item[_i3] * height);
            }
          }

          return res;
        });
      } // 供polygon覆盖，后处理booleanOperations

    }, {
      key: "__reprocessing",
      value: function __reprocessing(list) {
        return list;
      } // 同polygon覆盖，booleanOperations改变时需刷新缓冲顶点坐标

    }, {
      key: "__needRebuildSE",
      value: function __needRebuildSE() {}
    }, {
      key: "buildCache",
      value: function buildCache(originX, originY) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            points = this.points,
            controls = this.controls,
            start = this.start,
            end = this.end,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild, rebuildSE;

        if (isNil$b(__cacheProps.points)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.points = points.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item);
              }
            });
          } else {
            __cacheProps.points = this.__getPoints(originX, originY, width, height, points);
          }
        }

        if (isNil$b(__cacheProps.controls)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.controls = controls.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item, true);
              }

              return item;
            });
          } else {
            __cacheProps.controls = this.__getPoints(originX, originY, width, height, controls, true);
          }
        }

        if (isNil$b(__cacheProps.start)) {
          rebuildSE = true;
          __cacheProps.start = start;
        }

        if (isNil$b(__cacheProps.end)) {
          rebuildSE = true;
          __cacheProps.end = end;
        } // polygon会覆盖检查booleanOperations缓存


        if (this.__needRebuildSE(__cacheProps)) {
          rebuildSE = true;
        } // points/controls有变化就需要重建顶点


        if (rebuild) {
          var _points = __cacheProps.points,
              _controls = __cacheProps.controls;

          if (isMulti) {
            __cacheProps.list2 = _points.map(function (item, i) {
              var cl = _controls[i];

              if (Array.isArray(item)) {
                return item.map(function (point, j) {
                  if (j) {
                    return concatPointAndControl(point, cl && cl[j - 1]);
                  }

                  return point;
                });
              }
            });
            __cacheProps.len = getLength(__cacheProps.list2, isMulti);
          } else {
            __cacheProps.list2 = _points.map(function (point, i) {
              if (i) {
                return concatPointAndControl(point, _controls[i - 1]);
              }

              return point;
            });
            __cacheProps.len = getLength(__cacheProps.list2, isMulti);
          }
        }

        if (rebuild || rebuildSE) {
          if (isMulti) {
            __cacheProps.list = __cacheProps.list2.map(function (item, i) {
              if (Array.isArray(item)) {
                var len = __cacheProps.len;
                return getNewList(item, {
                  list: len.list[i],
                  total: len.total[i],
                  increase: len.increase[i]
                }, __cacheProps.start[i], __cacheProps.end[i]);
              }
            });
          } else {
            __cacheProps.list = getNewList(__cacheProps.list2, __cacheProps.len, __cacheProps.start, __cacheProps.end);
          } // 后处理一次，让polygon支持布尔运算


          __cacheProps.list = this.__reprocessing(__cacheProps.list, isMulti);
        }

        return rebuild || rebuildSE;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Polyline.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (res["break"]) {
          return res;
        }

        this.buildCache(res.sx3, res.sy3);
        ctx = res.ctx;

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "points",
      get: function get() {
        return this.getProps('points');
      }
    }, {
      key: "controls",
      get: function get() {
        return this.getProps('controls');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              strokeWidth = this.computedStyle[STROKE_WIDTH$3];
          this.buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Polyline.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var points = __cacheProps.points,
              controls = __cacheProps.controls;

          if (!isMulti) {
            points = [points];
            controls = [controls];
          }

          points.forEach(function (pointList, i) {
            if (!pointList || pointList.length < 2 || !pointList[0] || !pointList[1] || pointList[0].length < 2 || pointList[1].length < 2) {
              return;
            }

            var controlList = controls[i] || [];

            var _pointList$ = _slicedToArray(pointList[0], 2),
                xa = _pointList$[0],
                ya = _pointList$[1];

            for (var _i4 = 1, len = pointList.length; _i4 < len; _i4++) {
              var _pointList$_i = _slicedToArray(pointList[_i4], 2),
                  xb = _pointList$_i[0],
                  yb = _pointList$_i[1];

              var c = controlList[_i4 - 1];

              if (c && c.length === 4) {
                var bezierBox = geom.bboxBezier(xa, ya, c[0], c[1], c[2], c[3], xb, yb);
                bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
              } else if (c && c.length === 2) {
                var _bezierBox = geom.bboxBezier(xa, ya, c[0], c[1], xb, yb);

                bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
              } else {
                bbox[0] = Math.min(bbox[0], xa - half);
                bbox[1] = Math.min(bbox[1], ya - half);
                bbox[2] = Math.max(bbox[2], xa + half);
                bbox[3] = Math.max(bbox[3], ya + half);
              }

              xa = xb;
              ya = yb;
            }
          });
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Polyline;
  }(Geom$1);

  var Polygon = /*#__PURE__*/function (_Polyline) {
    _inherits(Polygon, _Polyline);

    var _super = _createSuper(Polygon);

    function Polygon(tagName, props) {
      var _this;

      _classCallCheck(this, Polygon);

      _this = _super.call(this, tagName, props);

      if (props.booleanOperations) {
        _this.__booleanOperations = props.booleanOperations;
      }

      return _this;
    }

    _createClass(Polygon, [{
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        var res = _get(_getPrototypeOf(Polygon.prototype), "__getPoints", this).call(this, originX, originY, width, height, points, isControl);

        if (!isControl) {
          res.push(res[0]);
        }

        return res;
      } // 布尔运算覆盖，仅multi才发生，因为需要多个多边形数据

    }, {
      key: "__reprocessing",
      value: function __reprocessing(list, isMulti) {
        if (!isMulti) {
          return list;
        }

        var bo = this.booleanOperations,
            len = list.length;

        if (!Array.isArray(bo) && bo) {
          var old = bo;
          bo = [bo];

          for (var i = 1; i < len - 1; i++) {
            bo.push(old);
          }
        }

        if (Array.isArray(bo) && bo.length) {
          var _ret = function () {
            var res = [];
            var last;

            for (var _i = 0; _i < len - 1; _i++) {
              var a = list[_i],
                  b = list[_i + 1];

              switch (bo[_i]) {
                case 'intersection':
                  if (!a || !a.length || !b || !b.length) {
                    res.push(null);
                  } else {
                    intersection$1([a], [b]).forEach(function (item) {
                      res.push(item[0]);
                    });
                  }

                  last = true;
                  break;

                case 'union':
                  if ((!a || !a.length) && (!b || !b.length)) {
                    res.push(null);
                  } else if (!a || !a.length) {
                    res.push(b);
                  } else if (!b || !b.length) {
                    res.push(a);
                  } else {
                    union([a], [b]).forEach(function (item) {
                      res.push(item[0]);
                    });
                  }

                  last = true;
                  break;

                case 'diff':
                  if (!a || !a.length) {
                    res.push(null);
                  } else if (!b || !b.length) {
                    res.push(a);
                  } else {
                    diff([a], [b]).forEach(function (item) {
                      res.push(item[0]);
                    });
                  }

                  last = true;
                  break;

                case 'xor':
                  if ((!a || !a.length) && (!b || !b.length)) {
                    res.push(null);
                  } else if (!a || !a.length) {
                    res.push(b);
                  } else if (!b || !b.length) {
                    res.push(a);
                  } else {
                    xor([a], [b]).forEach(function (item) {
                      res.push(item[0]);
                    });
                  }

                  last = true;
                  break;

                default:
                  res.push(list[_i]);
                  last = false;
                  break;
              }
            } // 最后一个没参与布尔运算，原封不动装载


            if (!last) {
              res.push(list[len - 1]);
            }

            return {
              v: res
            };
          }();

          if (_typeof(_ret) === "object") return _ret.v;
        }

        return list;
      } // 覆盖，当booleanOperations动画改变时刷新顶点缓存

    }, {
      key: "__needRebuildSE",
      value: function __needRebuildSE(__cacheProps) {
        if (util.isNil(__cacheProps.booleanOperations)) {
          __cacheProps.booleanOperations = true;
          return true;
        }
      }
    }, {
      key: "booleanOperations",
      get: function get() {
        return this.getProps('booleanOperations');
      }
    }]);

    return Polygon;
  }(Polyline);

  var _enums$STYLE_KEY$l = enums.STYLE_KEY,
      STROKE_WIDTH$4 = _enums$STYLE_KEY$l.STROKE_WIDTH,
      BOX_SHADOW$4 = _enums$STYLE_KEY$l.BOX_SHADOW;
  var isNil$c = util.isNil;
  var sectorPoints$1 = geom.sectorPoints;

  function getR(v, dft) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = dft;
    }

    return v;
  }

  var Sector = /*#__PURE__*/function (_Geom) {
    _inherits(Sector, _Geom);

    var _super = _createSuper(Sector);

    function Sector(tagName, props) {
      var _this;

      _classCallCheck(this, Sector);

      _this = _super.call(this, tagName, props); // 角度

      if (_this.isMulti) {
        _this.__begin = [0];
        _this.__end = [0];
        _this.__r = [1];

        if (Array.isArray(props.begin)) {
          _this.__begin = props.begin.map(function (i) {
            return getR(i, 0);
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            return getR(i, 0);
          });
        }

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR(i, 1);
          });
        }

        if (Array.isArray(props.edge)) {
          _this.__edge = props.edge.map(function (i) {
            return !!i;
          });
        }

        if (Array.isArray(props.closure)) {
          _this.__closure = props.closure.map(function (i) {
            return !!i;
          });
        }
      } else {
        _this.__begin = _this.__end = 0; // 半径[0, ∞)，默认1

        _this.__r = 1; // 扇形两侧是否有边

        _this.__edge = false; // 扇形大于180°时，是否闭合两端

        _this.__closure = false;

        if (!isNil$c(props.begin)) {
          _this.__begin = getR(props.begin, 0);
        }

        if (!isNil$c(props.end)) {
          _this.__end = getR(props.end, 0);
        }

        if (!isNil$c(props.r)) {
          _this.__r = getR(props.r, 1);
        }

        if (!isNil$c(props.edge)) {
          _this.__edge = !!props.edge;
        }

        if (!isNil$c(props.closure)) {
          _this.__closure = !!props.closure;
        }
      }

      return _this;
    }

    _createClass(Sector, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            begin = this.begin,
            end = this.end,
            r = this.r,
            edge = this.edge,
            closure = this.closure,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$c(__cacheProps.begin) || focus) {
          rebuild = true;
          __cacheProps.begin = (begin || 0) % 360;
        }

        if (isNil$c(__cacheProps.end) || focus) {
          rebuild = true;
          __cacheProps.end = (end || 0) % 360;
        }

        if (isNil$c(__cacheProps.r) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.r = r.map(function (r) {
              return r * width * 0.5;
            });
          } else {
            __cacheProps.r = r * width * 0.5;
          }
        }

        r = __cacheProps.r;

        if (isNil$c(__cacheProps.edge) || focus) {
          rebuild = true;
          __cacheProps.edge = edge;
        }

        if (isNil$c(__cacheProps.closure) || focus) {
          rebuild = true;
          __cacheProps.closure = closure;
        }

        if (rebuild) {
          if (isMulti) {
            __cacheProps.list = [];
            __cacheProps.sList = [];
            begin.forEach(function (begin, i) {
              var r2 = isNil$c(r[i]) ? width * 0.5 : r[i];
              var list = sectorPoints$1(cx, cy, r2, parseFloat(begin || 0) % 360, parseFloat(end[i] || 0) % 360);
              var sList = list.slice(0);

              if (closure[i]) {
                list.push(list[0].slice(0));

                if (edge) {
                  sList.push(sList[0].slice(0));
                }
              } else {
                list.unshift([cx, cy]);
                list.push([cx, cy]);

                if (edge) {
                  sList.unshift([cx, cy]);
                  sList.push([cx, cy]);
                }
              }

              __cacheProps.list.push(list);

              __cacheProps.sList.push(sList);
            });
          } else {
            var list = sectorPoints$1(cx, cy, r, parseFloat(begin || 0), parseFloat(end || 0));
            var sList = list.slice(0);

            if (closure) {
              list.push(list[0].slice(0));

              if (edge) {
                sList.push(sList[0].slice(0));
              }
            } else {
              list.unshift([cx, cy]);
              list.push([cx, cy]);

              if (edge) {
                sList.unshift([cx, cy]);
                sList.push([cx, cy]);
              }
            }

            __cacheProps.list = list;
            __cacheProps.sList = sList;
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx2, dy2) {
        var res = _get(_getPrototypeOf(Sector.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx2, dy2);

        if (res["break"]) {
          return res;
        }

        this.buildCache(res.cx, res.cy);
        ctx = res.ctx;
        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var _this$__cacheProps = this.__cacheProps,
            list = _this$__cacheProps.list,
            sList = _this$__cacheProps.sList,
            isMulti = this.isMulti; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy
          };

          this.__renderOneSector(renderMode, ctx, isMulti, list, sList, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy
              };

              this.__renderOneSector(renderMode, ctx, isMulti, list, sList, _o);
            }
          }

          for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
            var stroke = strokes[_i];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i],
                strokeDasharray: strokeDasharrays[_i],
                strokeDasharrayStr: strokeDasharrayStrs[_i],
                strokeLinecap: strokeLinecaps[_i],
                strokeLinejoin: strokeLinejoins[_i],
                strokeMiterlimit: strokeMiterlimits[_i],
                dx: dx,
                dy: dy
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, sList, _o2);
            }
          }
        }

        return res;
      }
    }, {
      key: "__renderOneSector",
      value: function __renderOneSector(renderMode, ctx, isMulti, list, sList, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill.k === 'conic';
        var isStrokeCE = stroke.k === 'conic';
        var isFillRE = fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else {
          if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, false);
          }

          if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        }
      }
    }, {
      key: "__genSector",
      value: function __genSector(edge, d, fill, stroke, strokeWidth, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (edge) {
          var props = [['d', d[0]], ['fill', fill.v || fill], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

          this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

          this.addGeom('path', props);
        } else {
          this.addGeom('path', [['d', d[0]], ['fill', fill.v || fill]]);

          if (strokeWidth > 0) {
            var _props = [['d', d[1]], ['fill', 'none'], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

            this.__propsStrokeStyle(_props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

            this.addGeom('path', _props);
          }
        }
      }
    }, {
      key: "begin",
      get: function get() {
        return this.getProps('begin');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "edge",
      get: function get() {
        return this.getProps('edge');
      } // >180°时是否链接端点

    }, {
      key: "closure",
      get: function get() {
        return this.getProps('closure');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              _this$computedStyle = this.computedStyle,
              strokeWidth = _this$computedStyle[STROKE_WIDTH$4],
              boxShadow = _this$computedStyle[BOX_SHADOW$4];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Sector.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var xb = cx + r - half;
          var ya = cy - r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Sector;
  }(Geom$1);

  var STROKE_WIDTH$5 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$d = util.isNil;

  function genVertex(x, y, width, height) {
    var rx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var ry = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (rx === 0 || ry === 0) {
      return [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]];
    }

    var ox = rx * geom.H;
    var oy = ry * geom.H;
    return [[x + rx, y], [x + width - rx, y], [x + width + ox - rx, y, x + width, y + ry - oy, x + width, y + ry], [x + width, y + height - ry], [x + width, y + height + oy - ry, x + width + ox - rx, y + height, x + width - rx, y + height], [x + rx, y + height], [x + rx - ox, y + height, x, y + height + oy - ry, x, y + height - ry], [x, y + ry], [x, y + ry - oy, x + rx - ox, y, x + rx, y]];
  }

  function getR$1(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 0;
    }

    return v;
  }

  var Rect = /*#__PURE__*/function (_Geom) {
    _inherits(Rect, _Geom);

    var _super = _createSuper(Rect);

    function Rect(tagName, props) {
      var _this;

      _classCallCheck(this, Rect);

      _this = _super.call(this, tagName, props); // 圆角

      if (_this.isMulti) {
        _this.__rx = [0];
        _this.__ry = [0];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR$1(i);
          });
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR$1(i);
          });
        }
      } else {
        _this.__rx = _this.__ry = 0;

        if (!isNil$d(props.rx)) {
          _this.__rx = getR$1(props.rx);
        }

        if (!isNil$d(props.ry)) {
          _this.__ry = getR$1(props.ry);
        }
      }

      return _this;
    }

    _createClass(Rect, [{
      key: "buildCache",
      value: function buildCache(originX, originY, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$d(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (rx) {
              return Math.min(rx, 0.5) * width;
            });
          } else {
            __cacheProps.rx = Math.min(rx, 0.5) * width;
          }
        }

        if (isNil$d(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = rx.map(function (ry) {
              return Math.min(ry, 0.5) * height;
            });
          } else {
            __cacheProps.ry = Math.min(ry, 0.5) * height;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return genVertex(originX, originY, width, height, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = genVertex(originX, originY, width, height, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Rect.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (res["break"]) {
          return res;
        }

        this.buildCache(res.sx3, res.sy3);
        ctx = res.ctx;

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$5];
          this.buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Rect.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          bbox[0] = Math.min(bbox[0], originX - half);
          bbox[1] = Math.min(bbox[1], originY - half);
          bbox[2] = Math.max(bbox[2], originX + width + half);
          bbox[3] = Math.max(bbox[3], originY + height + half);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Rect;
  }(Geom$1);

  var STROKE_WIDTH$6 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$e = util.isNil;

  function getR$2(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Circle = /*#__PURE__*/function (_Geom) {
    _inherits(Circle, _Geom);

    var _super = _createSuper(Circle);

    function Circle(tagName, props) {
      var _this;

      _classCallCheck(this, Circle);

      _this = _super.call(this, tagName, props); // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__r = [1];

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR$2(i);
          });
        } else if (!isNil$e(props.r)) {
          _this.__r = getR$2(props.r);
        }
      } else {
        _this.__r = 1;

        if (!isNil$e(props.r)) {
          _this.__r = getR$2(props.r);
        }
      }

      return _this;
    }

    _createClass(Circle, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            r = this.r,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;

        if (isNil$e(__cacheProps.r) || focus) {
          if (isMulti) {
            __cacheProps.r = r.map(function (i) {
              return i * width * 0.5;
            });
            __cacheProps.list = __cacheProps.r.map(function (r) {
              return geom.ellipsePoints(cx, cy, r, r);
            });
          } else {
            __cacheProps.r = r * width * 0.5;
            __cacheProps.list = geom.ellipsePoints(cx, cy, __cacheProps.r, __cacheProps.r);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Circle.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (res["break"]) {
          return res;
        }

        this.buildCache(res.cx, res.cy);
        ctx = res.ctx;

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$6];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Circle.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var ya = cy - r - half;
          var xb = cx + r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Circle;
  }(Geom$1);

  var STROKE_WIDTH$7 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$f = util.isNil;

  function getR$3(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Ellipse = /*#__PURE__*/function (_Geom) {
    _inherits(Ellipse, _Geom);

    var _super = _createSuper(Ellipse);

    function Ellipse(tagName, props) {
      var _this;

      _classCallCheck(this, Ellipse);

      _this = _super.call(this, tagName, props); // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__rx = [1];
        _this.__ry = [1];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR$3(i);
          });
        } else if (!isNil$f(props.rx)) {
          _this.__rx = [getR$3(props.rx)];
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR$3(i);
          });
        } else if (!isNil$f(props.ry)) {
          _this.__ry = [getR$3(props.ry)];
        }
      } else {
        _this.__rx = 1;

        if (!isNil$f(props.rx)) {
          _this.__rx = getR$3(props.rx);
        }

        _this.__ry = 1;

        if (!isNil$f(props.ry)) {
          _this.__ry = getR$3(props.ry);
        }
      }

      return _this;
    }

    _createClass(Ellipse, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$f(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (i) {
              return i * width * 0.5;
            });
          } else {
            __cacheProps.rx = rx * width * 0.5;
          }
        }

        if (isNil$f(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = ry.map(function (i) {
              return i * height * 0.5;
            });
          } else {
            __cacheProps.ry = ry * height * 0.5;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return geom.ellipsePoints(cx, cy, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = geom.ellipsePoints(cx, cy, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, lv, ctx, cache, dx, dy) {
        var res = _get(_getPrototypeOf(Ellipse.prototype), "render", this).call(this, renderMode, lv, ctx, cache, dx, dy);

        if (res["break"]) {
          return res;
        }

        this.buildCache(res.cx, res.cy);
        ctx = res.ctx;

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$7];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var rx = 0,
              ry = 0;

          if (isMulti) {
            var mx = 0,
                my = 0;

            __cacheProps.rx.forEach(function (rx, i) {
              mx = Math.max(rx, mx);
              my = Math.max(ry, __cacheProps.ry[i]);
            });

            rx = mx;
            ry = my;
          } else {
            rx = __cacheProps.rx;
            ry = __cacheProps.ry;
          }

          var bbox = _get(_getPrototypeOf(Ellipse.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - rx - half;
          var xb = cx + rx - half;
          var ya = cy - ry + half;
          var yb = cy + ry + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Ellipse;
  }(Geom$1);

  var fullCssProperty = {
    skewX: 'kx',
    skewY: 'ky',
    transform: 'tf',
    fontSize: 'fz',
    offset: 'os',
    easing: 'e',
    filter: 'ft',
    boxShadow: 'bd',
    overflow: 'of',
    backgroundClip: 'bp',
    textOverflow: 'tof',
    flexWrap: 'fp',
    perspective: 'ppt',
    rotate3d: 'r3'
  };
  var abbrCssProperty = {
    os: 'offset',
    // 非css属性不会被下面反向遍历插入，手动
    e: 'easing'
  };
  var fullAnimate = {
    value: 'v',
    options: 'o'
  };
  var abbrAnimate = {};
  var fullAnimateOption = {
    duration: 'dt',
    delay: 'd',
    endDelay: 'ed',
    iterations: 'i',
    direction: 'dc',
    fill: 'f',
    fps: 'fp',
    playbackRate: 'p',
    spfLimit: 'sl'
  };
  var abbrAnimateOption = {};
  reset.DOM_KEY_SET.concat(reset.GEOM_KEY_SET).forEach(function (k) {
    if (fullCssProperty.hasOwnProperty(k)) {
      abbrCssProperty[fullCssProperty[k]] = k;
      return;
    }

    var v = k.charAt(0) + k.replace(/[a-z]/g, '').toLowerCase();
    fullCssProperty[k] = v;
    abbrCssProperty[v] = k;
  });
  Object.keys(fullAnimate).forEach(function (k) {
    abbrAnimate[fullAnimate[k]] = k;
  });
  Object.keys(fullAnimateOption).forEach(function (k) {
    abbrAnimateOption[fullAnimateOption[k]] = k;
  });
  var abbr$1 = {
    fullCssProperty: fullCssProperty,
    abbrCssProperty: abbrCssProperty,
    fullAnimate: fullAnimate,
    abbrAnimate: abbrAnimate,
    fullAnimateOption: fullAnimateOption,
    abbrAnimateOption: abbrAnimateOption
  };

  var TYPE_VD$4 = $$type.TYPE_VD,
      TYPE_GM$4 = $$type.TYPE_GM,
      TYPE_CP$4 = $$type.TYPE_CP;
  var isNil$g = util.isNil,
      isFunction$a = util.isFunction,
      isPrimitive = util.isPrimitive,
      clone$4 = util.clone,
      extend$3 = util.extend;
  var abbrCssProperty$1 = abbr$1.abbrCssProperty,
      abbrAnimateOption$1 = abbr$1.abbrAnimateOption,
      abbrAnimate$1 = abbr$1.abbrAnimate;
  /**
   * 还原缩写到全称，涉及样式和动画属性
   * @param target 还原的对象
   * @param hash 缩写映射
   */

  function abbr2full(target, hash) {
    // 也许节点没写样式
    if (target) {
      Object.keys(target).forEach(function (k) {
        // var-attr格式特殊考虑，仅映射attr部分，var-还要保留
        if (k.indexOf('var-') === 0) {
          var k2 = k.slice(4);

          if (hash.hasOwnProperty(k2)) {
            var fk = hash[k2];
            target['var-' + fk] = target[k]; // delete target[k];
          }
        } // 普通样式缩写还原
        else if (hash.hasOwnProperty(k)) {
          var _fk = hash[k];
          target[_fk] = target[k]; // 删除以免二次解析

          delete target[k];
        }
      });
    }
  }

  function replaceVars(json, vars) {
    if (json && vars) {
      // 新版vars语法
      if (json.hasOwnProperty('vars')) {
        var slot = json.vars;

        if (!Array.isArray(slot)) {
          slot = [slot];
        }

        if (Array.isArray(slot)) {
          slot.forEach(function (item) {
            var id = item.id,
                member = item.member;

            if (!Array.isArray(member)) {
              member = [member];
            } // 排除特殊的library


            if (Array.isArray(member) && member.length && member[0] !== 'library' && vars.hasOwnProperty(id)) {
              var target = json;

              for (var i = 0, len = member.length; i < len; i++) {
                var k = member[i]; // 最后一个属性可以为空

                if (target.hasOwnProperty(k) || i === len - 1) {
                  // 最后一个member表达式替换
                  if (i === len - 1) {
                    var v = vars[id]; // undefined和null意义不同

                    if (v === undefined) {
                      return;
                    } // 支持函数模式和值模式


                    if (isFunction$a(v)) {
                      v = v(target(k));
                    }

                    target[k] = v;
                  } else {
                    target = target[k];
                  }
                } else {
                  inject.error('Slot miss ' + k);
                  return;
                }
              }
            }
          });
        }
      } else {
        Object.keys(json).forEach(function (k) {
          if (k.indexOf('var-') === 0) {
            var v = json[k];

            if (!v) {
              return;
            }

            var k2 = k.slice(4); // 有id且变量里面传入了替换的值，值可为null，因为某些情况下空为自动

            if (k2 && v.id && vars.hasOwnProperty(v.id)) {
              var value = vars[v.id]; // undefined和null意义不同

              if (value === undefined) {
                return;
              }

              var target = json; // 如果有.则特殊处理子属性

              if (k2.indexOf('.') > -1) {
                var list = k2.split('.');
                var len = list.length;

                for (var i = 0; i < len - 1; i++) {
                  k2 = list[i]; // 避免异常

                  if (target[k2]) {
                    target = target[k2];
                  } else {
                    inject.warn('parseJson vars is not exist: ' + v.id + ', ' + k + ', ' + list.slice(0, i).join('.'));
                    return;
                  }
                }

                k2 = list[len - 1];
              } // 支持函数模式和值模式


              if (isFunction$a(value)) {
                value = value(v);
              }

              target[k2] = value;
            }
          }
        });
      }
    }
  }

  function replaceAnimateOptions(options, opt) {
    ['iterations', 'fill', 'duration', 'direction', 'easing', 'fps', 'delay', 'endDelay', 'playbackRate', 'spfLimit'].forEach(function (k) {
      if (opt.hasOwnProperty(k)) {
        options[k] = opt[k];
      }
    });
  }

  function replaceLibraryVars(json, hash, vars) {
    if (vars) {
      // 新版同级vars语法
      if (json.hasOwnProperty('vars')) {
        var slot = json.vars;

        if (!Array.isArray(slot)) {
          slot = [slot];
        }

        if (Array.isArray(slot)) {
          slot.forEach(function (item) {
            var id = item.id,
                member = item.member;

            if (!Array.isArray(member)) {
              member = [member];
            } // library.xxx，需要>=2的长度


            if (Array.isArray(member) && member.length > 1 && vars.hasOwnProperty(id)) {
              if (member[0] === 'library') {
                var target = hash;

                for (var i = 1, len = member.length; i < len; i++) {
                  var k = member[i]; // 最后一个属性可以为空

                  if (target.hasOwnProperty(k) || i === len - 1) {
                    // 最后一个member表达式替换
                    if (i === len - 1) {
                      var v = vars[id]; // 支持函数模式和值模式

                      if (isFunction$a(v)) {
                        v = v(target(k));
                      }

                      var old = target[k]; // 直接替换library的子对象，需补充id和tagName

                      if (i === 1) {
                        target[k] = Object.assign({
                          id: old.id,
                          tagName: old.tagName
                        }, v);
                      } // 替换library中子对象的一个属性直接赋值
                      else {
                        target[k] = v;
                      }
                    } else {
                      target = target[k];
                    }
                  } else {
                    inject.error('Library slot miss ' + k);
                    return;
                  }
                }
              }
            }
          });
        }
      } // 兼容老版var-
      else {
        Object.keys(json).forEach(function (k) {
          if (k.indexOf('var-library.') === 0) {
            var v = json[k]; // 直接移除library插槽，防止下面调用replaceVars(json, vars)时报错

            delete json[k];

            if (!v) {
              return;
            }

            var k2 = k.slice(12); // 有id且变量里面传入了替换的值

            if (k2 && v.id && vars.hasOwnProperty(v.id)) {
              var value = vars[v.id];

              if (isFunction$a(value)) {
                value = value(v);
              } // 替换图层的值必须是一个有tagName的对象


              if (!value || !value.tagName) {
                return;
              } // library对象也要加上id，与正常的library保持一致


              hash[k2] = Object.assign({
                id: k2
              }, value);
            }
          }
        });
      }
    }
  }
  /**
   * 遍历一遍library的一级，将一级的id存到hash上，无需递归二级，
   * 因为顺序前提要求排好且无循环依赖，所以被用到的一定在前面出现，
   * 一般是无children的元件在前，包含children的div在后
   * 即便library中的元素有children或library，在linkChild时将其link过去，parse递归会继续处理
   * @param item：library的一级孩子
   * @param hash：存放library的key/value引用
   */


  function linkLibrary(item, hash) {
    var id = item.id; // library中一定有id，因为是一级，二级+特殊需求才会出现放开

    if (isNil$g(id)) {
      throw new Error('Library item miss id: ' + JSON.stringify(item));
    } else {
      hash[id] = item;
    }
  }
  /**
   * 链接child到library文件，
   * props需要是clone的，因为防止多个child使用同一个库文件
   * children则直接引用，无需担心多个使用同一个
   * library也需要带上，在library直接子元素还包含library时会用到
   * @param child
   * @param libraryItem
   */


  function linkChild(child, libraryItem) {
    // 规定图层child只有init和动画，属性和子图层来自库
    child.tagName = libraryItem.tagName;
    child.props = clone$4(libraryItem.props);
    child.children = libraryItem.children;
    child.library = libraryItem.library; // library的var-也要继承过来，本身的var-优先级更高，目前只有children会出现优先级情况

    Object.keys(libraryItem).forEach(function (k) {
      if (k.indexOf('var-') === 0 && !child.hasOwnProperty(k)) {
        child[k] = libraryItem[k];
      }
    }); // 删除以免二次解析

    child.libraryId = null; // 规定图层实例化的属性和样式在init上，优先使用init，然后才取原型链的props

    var init = child.init;

    if (init) {
      var props = child.props = child.props || {};
      var style = props.style;
      extend$3(props, init); // style特殊处理，防止被上面覆盖丢失原始值

      if (style) {
        extend$3(style, init.style);
        props.style = style;
      } // 删除以免二次解析


      child.init = null;
    }
  }

  function parse(karas, json, animateRecords, opt) {
    var hash = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    if (isPrimitive(json) || json instanceof Node || json instanceof Component$1) {
      return json;
    }

    if (Array.isArray(json)) {
      return json.map(function (item) {
        return parse(karas, item, animateRecords, opt, hash);
      });
    } // 先判断是否是个链接到库的节点，是则进行链接操作


    var libraryId = json.libraryId;

    if (!isNil$g(libraryId)) {
      var libraryItem = hash[libraryId]; // 规定图层child只有init和动画，tagName和属性和子图层来自库

      if (libraryItem) {
        linkChild(json, libraryItem);
      } else {
        throw new Error('Link library miss id: ' + libraryId);
      }

      json.libraryId = null;
    } // 再判断是否有library形成一个新的作用域，会出现library下的library使得一个链接节点链接后出现library的情况


    var library = json.library;

    if (Array.isArray(library)) {
      hash = {};
      library.forEach(function (item) {
        linkLibrary(item, hash);
      }); // 替换library插槽

      replaceLibraryVars(json, hash, opt.vars);
      json.library = null;
    }

    var tagName = json.tagName,
        _json$props = json.props,
        props = _json$props === void 0 ? {} : _json$props,
        _json$children = json.children,
        children = _json$children === void 0 ? [] : _json$children,
        _json$animate = json.animate,
        animate = _json$animate === void 0 ? [] : _json$animate;

    if (!tagName) {
      throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
    }

    var style = props.style;
    opt.abbr !== false && abbr2full(style, abbrCssProperty$1); // 先替换style的

    replaceVars(style, opt.vars); // 再替换静态属性，style也作为属性的一种，目前尚未被设计为被替换

    replaceVars(props, opt.vars); // 替换children里的内容，如文字，无法直接替换tagName/props/children/animate本身，因为下方用的还是原引用

    replaceVars(json, opt.vars);

    if (!Array.isArray(children)) {
      throw new Error('children must be an array');
    }

    var vd;

    if (tagName.charAt(0) === '$') {
      vd = karas.createGm(tagName, props);
    } else if (/^[A-Z]/.test(tagName)) {
      var cp = Component$1.getRegister(tagName);
      vd = karas.createCp(cp, props, children.map(function (item) {
        if (item && [TYPE_VD$4, TYPE_GM$4, TYPE_CP$4].indexOf(item.$$type) > -1) {
          return item;
        }

        return parse(karas, item, animateRecords, opt, hash);
      }));
    } else {
      vd = karas.createVd(tagName, props, children.map(function (item) {
        if (item && [TYPE_VD$4, TYPE_GM$4, TYPE_CP$4].indexOf(item.$$type) > -1) {
          return item;
        }

        return parse(karas, item, animateRecords, opt, hash);
      }));
    }

    if (animate) {
      if (!Array.isArray(animate)) {
        animate = [animate];
      }

      var has;
      animate.forEach(function (item) {
        opt.abbr !== false && abbr2full(item, abbrAnimate$1);
        var value = item.value,
            options = item.options; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          has = true;
          value.forEach(function (item) {
            opt.abbr !== false && abbr2full(item, abbrCssProperty$1);
            replaceVars(item, opt.vars);
          });
        }

        if (options) {
          opt.abbr !== false && abbr2full(options, abbrAnimateOption$1);
          replaceVars(options, opt.vars);
          replaceAnimateOptions(options, opt);
        }
      }); // 产生实际动画运行才存入列表供root调用执行

      if (has) {
        animateRecords.push({
          animate: animate,
          target: vd
        });
      }
    }

    return vd;
  }

  var o$4 = {
    parse: function parse$1(karas, json, dom) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!json) {
        return;
      } // 根节点的fonts字段定义字体信息


      var fonts = json.fonts;

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var fontFamily = item.fontFamily,
              data = item.data;

          if (fontFamily && data) {
            o$1.register(fontFamily, data);
          }
        });
      } // json中定义无abbr


      if (json.abbr === false) {
        options.abbr = false;
      }

      if (options.abbr !== false) {
        inject.warn('Abbr in json is deprecated');
      } // 重载，在确定dom传入选择器字符串或html节点对象时作为渲染功能，否则仅创建vd返回


      if (!inject.isDom(dom)) {
        options = dom || {};
        dom = null;
      } // 特殊单例声明无需clone加速解析


      if (!options.singleton && !json.singleton) {
        json = util.clone(json);
      } // 暂存所有动画声明，等root的生成后开始执行


      var animateRecords = [];

      var vd = parse(karas, json, animateRecords, options); // 有dom时parse作为根方法渲染


      if (dom) {
        var _json = json,
            tagName = _json.tagName;

        if (['canvas', 'svg', 'webgl'].indexOf(tagName) === -1) {
          throw new Error('Parse dom must be canvas/svg/webgl');
        } // parse直接（非递归）的动画记录


        var ac = options.controller instanceof Controller ? options.controller : vd.animateController; // 第一次render，收集递归json里面的animateRecords，它在xom的__layout最后生成

        karas.render(vd, dom); // 由于vd首先生成的都是json，根parse要特殊处理将target指向真正的vd引用，json的vd在builder中赋值

        animateRecords.forEach(function (item) {
          item.target = item.target.vd;
        }); // 直接的json里的animateRecords，再加上递归的parse的json的（第一次render布局时处理）动画一并播放

        if (options.autoPlay !== false) {
          ac.__records = ac.__records.concat(animateRecords);

          ac.__playAuto();
        } // 不自动播放进入记录列表，初始化并等待手动调用
        else {
          ac.__records2 = ac.__records2.concat(animateRecords);
          ac.init(ac.__records2, ac.list2);
        }
      } // 递归的parse，如果有动画，此时还没root，先暂存下来，等上面的root的render第一次布局时收集
      else {
        if (animateRecords.length) {
          vd.__animateRecords = {
            options: options,
            list: animateRecords,
            controller: options.controller instanceof Controller ? options.controller : null
          };
        }
      }

      return vd;
    },
    loadAndParse: function loadAndParse(karas, json, dom, options) {
      var fonts = json.fonts,
          components = json.components,
          imgs = json.imgs;
      var list1 = [];
      var list2 = [];
      var list3 = [];

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var url = item.url;

          if (url) {
            list1.push(item);
          }
        });
      }

      if (components) {
        if (!Array.isArray(components)) {
          components = [components];
        }

        components.forEach(function (item) {
          var tagName = item.tagName,
              url = item.url,
              reload = item.reload; // 如果没申明reload且已经被注册，则无需重复加载

          if (tagName && karas.Component.hasRegister(tagName) && !reload) {
            return;
          } // 即便没有tagName也要加载，可能组件内部执行了注册逻辑


          if (url) {
            list2.push(item);
          }
        });
      }

      if (imgs) {
        if (!Array.isArray(imgs)) {
          imgs = [imgs];
        }

        imgs.forEach(function (item) {
          var url = item.url;

          if (url) {
            list3.push(url);
          }
        });
      }

      var a = list1.length,
          b = list2.length,
          c = list3.length;
      var count = 0;

      var cb = function cb() {
        if (count === a + b + c) {
          var res = o$4.parse(karas, json, dom, options);

          if (options && util.isFunction(options.callback)) {
            options.callback(res);
          }
        }
      };

      if (a || b || c) {
        karas.inject.loadFont(list1, function () {
          count += a;
          cb();
        });
        karas.inject.loadComponent(list2.map(function (item) {
          return item.url;
        }), function () {
          count += b; // 默认约定加载的js组件会在全局变量申明同名tagName，已有不覆盖，防止组件代码内部本身有register

          list2.forEach(function (item) {
            var tagName = item.tagName;

            if (tagName && window[tagName] && !karas.Component.hasRegister(tagName)) {
              karas.Component.register(tagName, window[tagName]);
            }
          });
          cb();
        });
        karas.inject.measureImg(list3, function () {
          count += c;
          cb();
        });
      } else {
        cb();
      }
    },
    abbr: abbr$1
  };

  var style = {
    css: css,
    reset: reset,
    unit: o,
    font: o$1,
    abbr: abbr,
    transform: transform$1
  };

  var animate = {
    Animation: Animation,
    Controller: Controller,
    easing: easing,
    frame: frame
  };

  var refresh = {
    level: o$3,
    change: o$2,
    Page: Page,
    Cache: Cache
  };

  var version = "0.73.4";

  Geom$1.register('$line', Line);
  Geom$1.register('$polyline', Polyline);
  Geom$1.register('$polygon', Polygon);
  Geom$1.register('$sector', Sector);
  Geom$1.register('$rect', Rect);
  Geom$1.register('$circle', Circle);
  Geom$1.register('$ellipse', Ellipse);
  var karas$1 = {
    version: version,
    render: function render(root, dom) {
      if (!(root instanceof Root)) {
        throw new Error('Render dom must be canvas/svg/webgl');
      }

      if (dom) {
        root.appendTo(dom);
      }

      return root;
    },
    createElement: function createElement(tagName, props) {
      props = props || {};
      var children = [];

      for (var i = 2, len = arguments.length; i < len; i++) {
        children.push(arguments[i]);
      }

      if (util.isString(tagName)) {
        if (tagName.charAt(0) === '$') {
          return this.createGm(tagName, props);
        } else {
          return this.createVd(tagName, props, children);
        }
      } else if (tagName) {
        // 特殊的$匿名类
        if (tagName instanceof Geom$1) {
          return this.createGm(tagName, props);
        }

        return this.createCp(tagName, props, children);
      }
    },
    createVd: function createVd(tagName, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      if (['canvas', 'svg', 'webgl'].indexOf(tagName) > -1) {
        return new Root(tagName, props, children);
      }

      if (tag.TAG_NAME.hasOwnProperty(tagName)) {
        return {
          tagName: tagName,
          props: props,
          children: children,
          $$type: $$type.TYPE_VD
        };
      }

      throw new Error("Can not use <".concat(tagName, ">"));
    },
    createGm: function createGm(tagName, props) {
      return {
        tagName: tagName,
        props: props,
        $$type: $$type.TYPE_GM
      };
    },
    createCp: function createCp(klass, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      props.children = children;
      return {
        klass: klass,
        props: props,
        $$type: $$type.TYPE_CP
      };
    },
    parse: function parse(json, dom, options) {
      return o$4.parse(this, json, dom, options);
    },
    loadAndParse: function loadAndParse(json, dom, options) {
      return o$4.loadAndParse(this, json, dom, options);
    },
    mode: mode,
    Component: Component$1,
    Node: Node,
    Text: Text,
    Geom: Geom$1,
    Xom: Xom$1,
    Dom: Dom$1,
    Img: Img$1,
    Root: Root,
    Event: Event,
    util: util,
    inject: inject,
    style: style,
    parser: o$4,
    animate: animate,
    math: math,
    builder: builder,
    updater: updater,
    refresh: refresh,
    enums: enums,

    set debug(v) {
      debug.flag = !!v;
    }

  };
  builder.ref({
    Xom: Xom$1,
    Dom: Dom$1,
    Img: Img$1,
    Geom: Geom$1,
    Component: Component$1
  });

  if (typeof window !== 'undefined') {
    window.karas = karas$1;
  } else if (typeof self !== 'undefined') {
    self.karas = karas$1;
  }

  return karas$1;

})));
//# sourceMappingURL=index.js.map
