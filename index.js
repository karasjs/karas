(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.karas = factory());
})(this, (function () { 'use strict';

  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

    _regeneratorRuntime = function () {
      return exports;
    };

    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");

          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }

          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);

            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }

            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if ("throw" !== record.type) {
          var result = record.arg,
              value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }

        reject(record.arg);
      }

      var previousPromise;

      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

            return next.value = undefined, next.done = !0, next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }

    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];

      for (var key in object) keys.push(key);

      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }

        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;

        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
              record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var Node$1 = /*#__PURE__*/function () {
    function Node() {
      this.__x = 0;
      this.__y = 0;
      this.__width = 0;
      this.__height = 0;
      this.__baseline = 0;
      this.__verticalBaseline = 0;
      this.__prev = null;
      this.__next = null;
      this.__parent = null;
      this.__domParent = null;
      this.__root = null;
      this.__host = null;
      this.__hostRoot = null;
      this.__virtualDom = null;
      this.__bbox = null;
      this.__filterBbox = null;
      this.__isDestroyed = true;
      this.__cache = null;
      this.__cacheTarget = null;
      this.__wasmNode = null;
    }

    _createClass(Node, [{
      key: "__structure",
      value: function __structure(lv, j) {
        this.__struct = {
          node: this,
          childIndex: j,
          lv: lv
        };
        var wn = this.__wasmNode;

        if (wn) {
          wn.lv = lv;
        }

        return this.__struct;
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.__x += diff;
        var wn = this.__wasmNode;

        if (wn) {
          wn.offset_x(diff);
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.__y += diff;
        var wn = this.__wasmNode;

        if (wn) {
          wn.offset_y(diff);
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__isDestroyed = true;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      } // canvas/svg根节点

    }, {
      key: "root",
      get: function get() {
        return this.__root;
      } // component根节点

    }, {
      key: "host",
      get: function get() {
        return this.__host;
      } // 考虑高阶组件在内的component根节点

    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.__baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.__verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return false;
      }
    }]);

    return Node;
  }();

  var mode = {
    CANVAS: 0,
    SVG: 1,
    WEBGL: 2
  };

  var AUTO$8 = 0;
  var PX$b = 1;
  var PERCENT$a = 2;
  var NUMBER$6 = 3;
  var INHERIT$5 = 4;
  var DEG$5 = 5;
  var STRING$3 = 6;
  var RGBA$4 = 7;
  var REM$a = 8;
  var EM$1 = 9;
  var VW$a = 10;
  var VH$a = 11;
  var VMAX$a = 12;
  var VMIN$a = 13;
  var GRADIENT$4 = 14;
  var o$4 = {
    AUTO: AUTO$8,
    PX: PX$b,
    PERCENT: PERCENT$a,
    NUMBER: NUMBER$6,
    INHERIT: INHERIT$5,
    DEG: DEG$5,
    STRING: STRING$3,
    RGBA: RGBA$4,
    REM: REM$a,
    EM: EM$1,
    VW: VW$a,
    VH: VH$a,
    VMAX: VMAX$a,
    VMIN: VMIN$a,
    GRADIENT: GRADIENT$4,
    // 特殊格式，color/fill/stroke用给ctx传值

    /**
     * 通用的格式化计算数值单位的方法，百分比/像素/REM/VW/auto和纯数字
     * @param v value
     * @returns 格式化好的[number, unit]
     */
    calUnit: function calUnit(v) {
      if (v === 'auto') {
        return {
          v: 0,
          u: AUTO$8
        };
      }

      var n = parseFloat(v) || 0;

      if (/%$/.test(v)) {
        return {
          v: n,
          u: PERCENT$a
        };
      } else if (/px$/i.test(v)) {
        return {
          v: n,
          u: PX$b
        };
      } else if (/deg$/i.test(v)) {
        return {
          v: n,
          u: DEG$5
        };
      } else if (/rem$/i.test(v)) {
        return {
          v: n,
          u: REM$a
        };
      } else if (/vw$/i.test(v)) {
        return {
          v: n,
          u: VW$a
        };
      } else if (/vh$/i.test(v)) {
        return {
          v: n,
          u: VH$a
        };
      } else if (/em$/i.test(v)) {
        return {
          v: n,
          u: EM$1
        };
      } else if (/vw$/i.test(v)) {
        return {
          v: n,
          u: VW$a
        };
      } else if (/vh$/i.test(v)) {
        return {
          v: n,
          u: VH$a
        };
      } else if (/vmax$/i.test(v)) {
        return {
          v: n,
          u: VMAX$a
        };
      } else if (/vmin$/i.test(v)) {
        return {
          v: n,
          u: VMIN$a
        };
      }

      return {
        v: n,
        u: NUMBER$6
      };
    }
  };

  // 生成4*4单位矩阵
  function identity$2() {
    return new Float64Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  } // 矩阵a*b，固定两个matrix都是长度16


  function multiply$4(a, b) {
    if (!a && !b) {
      return identity$2();
    }

    if (isE$5(a)) {
      return new Float64Array(b);
    }

    if (isE$5(b)) {
      return new Float64Array(a);
    }

    var c = identity$2();

    for (var i = 0; i < 4; i++) {
      var a0 = a[i] || 0;
      var a1 = a[i + 4] || 0;
      var a2 = a[i + 8] || 0;
      var a3 = a[i + 12] || 0;
      c[i] = a0 * b[0] + a1 * b[1] + a2 * b[2] + a3 * b[3];
      c[i + 4] = a0 * b[4] + a1 * b[5] + a2 * b[6] + a3 * b[7];
      c[i + 8] = a0 * b[8] + a1 * b[9] + a2 * b[10] + a3 * b[11];
      c[i + 12] = a0 * b[12] + a1 * b[13] + a2 * b[14] + a3 * b[15];
    }

    return c;
  } // function multiply2(a, b) {
  //   if(isE(a)) {
  //     assignMatrix(a, b);
  //     return a;
  //   }
  //   if(isE(b)) {
  //     return a;
  //   }
  //   for(let i = 0; i < 4; i++) {
  //     let a0 = a[i] || 0;
  //     let a1 = a[i + 4] || 0;
  //     let a2 = a[i + 8] || 0;
  //     let a3 = a[i + 12] || 0;
  //     a[i] = a0 * b[0] + a1 * b[1] + a2 * b[2] + a3 * b[3];
  //     a[i + 4] = a0 * b[4] + a1 * b[5] + a2 * b[6] + a3 * b[7];
  //     a[i + 8] = a0 * b[8] + a1 * b[9] + a2 * b[10] + a3 * b[11];
  //     a[i + 12] = a0 * b[12] + a1 * b[13] + a2 * b[14] + a3 * b[15];
  //   }
  //   return a;
  // }
  // 特殊优化，b为tfo，因此既只有12/13/14有值


  function multiplyTfo$1(m, x, y) {
    if (!x && !y) {
      return m;
    }

    m[12] += m[0] * x + m[4] * y;
    m[13] += m[1] * x + m[5] * y;
    m[14] += m[2] * x + m[6] * y;
    m[15] += m[3] * x + m[7] * y;
    return m;
  }

  function tfoMultiply$1(x, y, m) {
    if (!x && !y) {
      return m;
    }

    var d = m[3],
        h = m[7],
        l = m[11],
        p = m[15];
    m[0] += d * x;
    m[1] += d * y;
    m[4] += h * x;
    m[5] += h * y;
    m[8] += l * x;
    m[9] += l * y;
    m[12] += p * x;
    m[13] += p * y;
    return m;
  } // 几种特殊的transform变换优化


  function multiplyTranslateX$1(m, v) {
    if (!v) {
      return m;
    }

    m[12] += m[0] * v;
    m[13] += m[1] * v;
    m[14] += m[2] * v;
    m[15] += m[3] * v;
    return m;
  }

  function multiplyTranslateY$1(m, v) {
    if (!v) {
      return m;
    }

    m[12] += m[4] * v;
    m[13] += m[5] * v;
    m[14] += m[6] * v;
    m[15] += m[7] * v;
    return m;
  }

  function multiplyTranslateZ$1(m, v) {
    if (!v) {
      return m;
    }

    m[12] += m[8] * v;
    m[13] += m[9] * v;
    m[14] += m[10] * v;
    m[15] += m[11] * v;
    return m;
  }

  function multiplyRotateX$2(m, v) {
    if (!v) {
      return m;
    }

    var sin = Math.sin(v);
    var cos = Math.cos(v);
    var e = m[4],
        f = m[5],
        g = m[6],
        h = m[7],
        i = m[8],
        k = m[10],
        l = m[11];
    m[4] = e * cos + i * sin;
    m[5] = f * cos + g * sin;
    m[6] = g * cos + k * sin;
    m[7] = h * cos + l * sin;
    m[8] = e * -sin + i * cos;
    m[9] = f * -sin + g * cos;
    m[10] = g * -sin + k * cos;
    m[11] = h * -sin + l * cos;
    return m;
  }

  function multiplyRotateY$2(m, v) {
    if (!v) {
      return m;
    }

    var sin = Math.sin(v);
    var cos = Math.cos(v);
    var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        i = m[8],
        j = m[9],
        k = m[10],
        l = m[11];
    m[0] = a * cos + i * -sin;
    m[1] = b * cos + j * -sin;
    m[2] = c * cos + k * -sin;
    m[3] = d * cos + l * -sin;
    m[8] = a * sin + i * cos;
    m[9] = b * sin + j * cos;
    m[10] = c * sin + k * cos;
    m[11] = d * sin + l * cos;
    return m;
  }

  function multiplyRotateZ$2(m, v) {
    if (!v) {
      return m;
    }

    var sin = Math.sin(v);
    var cos = Math.cos(v);
    var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        e = m[4],
        f = m[5],
        g = m[6],
        h = m[7];
    m[0] = a * cos + e * sin;
    m[1] = b * cos + f * sin;
    m[2] = c * cos + g * sin;
    m[3] = d * cos + h * sin;
    m[4] = a * -sin + e * cos;
    m[5] = b * -sin + f * cos;
    m[6] = c * -sin + g * cos;
    m[7] = d * -sin + h * cos;
    return m;
  }

  function multiplySkewX$2(m, v) {
    if (!v) {
      return m;
    }

    var tan = Math.tan(v);
    m[4] += m[0] * tan;
    m[5] += m[1] * tan;
    m[6] += m[2] * tan;
    m[7] += m[3] * tan;
    return m;
  }

  function multiplySkewY$2(m, v) {
    if (!v) {
      return m;
    }

    var tan = Math.tan(v);
    m[0] += m[4] * tan;
    m[1] += m[5] * tan;
    m[2] += m[6] * tan;
    m[3] += m[7] * tan;
    return m;
  }

  function multiplyScaleX$2(m, v) {
    if (v === 1) {
      return m;
    }

    m[0] *= v;
    m[1] *= v;
    m[2] *= v;
    m[3] *= v;
    return m;
  }

  function multiplyScaleY$2(m, v) {
    if (v === 1) {
      return m;
    }

    m[4] *= v;
    m[5] *= v;
    m[6] *= v;
    m[7] *= v;
    return m;
  }

  function multiplyScaleZ$2(m, v) {
    if (v === 1) {
      return m;
    }

    m[8] *= v;
    m[9] *= v;
    m[10] *= v;
    m[11] *= v;
    return m;
  }

  function multiplyPerspective$1(m, v) {
    if (!v || v <= 0) {
      return m;
    }

    v = Math.max(v, 1);
    v = -1 / v;
    m[8] += m[12] * v;
    m[9] += m[13] * v;
    m[10] += m[14] * v;
    m[11] += m[15] * v;
    return m;
  }

  function calPoint$2(point, m) {
    if (m && !isE$5(m)) {
      var x = point.x,
          y = point.y,
          z = point.z,
          w = point.w;
      z = z || 0;

      if (w === undefined || w === null) {
        w = 1;
      }

      var a1 = m[0],
          b1 = m[1],
          c1 = m[2],
          d1 = m[3];
      var a2 = m[4],
          b2 = m[5],
          c2 = m[6],
          d2 = m[7];
      var a3 = m[8],
          b3 = m[9],
          c3 = m[10],
          d3 = m[11];
      var a4 = m[12],
          b4 = m[13],
          c4 = m[14],
          d4 = m[15];
      var o = {
        x: (a1 === 1 ? x : x * a1) + (a2 ? y * a2 : 0) + (w === 1 ? a4 : a4 * w),
        y: (b1 === 1 ? x : x * b1) + (b2 ? y * b2 : 0) + (w === 1 ? b4 : b4 * w),
        z: 0,
        w: w
      };

      if (d1 || d2 || d3) {
        o.w = x * d1 + y * d2 + z * d3 + d4 * w;
      } else if (d4 !== 1) {
        o.w *= d4;
      }

      if (z) {
        o.x += z * a3;
        o.y += z * b3;
        o.z = x * c1 + y * c2 + c4 + z * c3;
      } else if (c1 || c2 || c4) {
        o.z = x * c1 + y * c2 + c4;
      }

      return o;
    }

    return point;
  }

  function calPointWasm(point, m, i) {
    if (m && !isE$5(m)) {
      var x = point.x,
          y = point.y,
          z = point.z,
          w = point.w;
      z = z || 0;

      if (w === undefined || w === null) {
        w = 1;
      }

      var a1 = m[i],
          b1 = m[i + 1],
          c1 = m[i + 2],
          d1 = m[i + 3];
      var a2 = m[i + 4],
          b2 = m[i + 5],
          c2 = m[i + 6],
          d2 = m[i + 7];
      var a3 = m[i + 8],
          b3 = m[i + 9],
          c3 = m[i + 10],
          d3 = m[i + 11];
      var a4 = m[i + 12],
          b4 = m[i + 13],
          c4 = m[i + 14],
          d4 = m[i + 15];
      var o = {
        x: (a1 === 1 ? x : x * a1) + (a2 ? y * a2 : 0) + (w === 1 ? a4 : a4 * w),
        y: (b1 === 1 ? x : x * b1) + (b2 ? y * b2 : 0) + (w === 1 ? b4 : b4 * w),
        z: 0,
        w: w
      };

      if (d1 || d2 || d3) {
        o.w = x * d1 + y * d2 + z * d3 + d4 * w;
      } else if (d4 !== 1) {
        o.w *= d4;
      }

      if (z) {
        o.x += z * a3;
        o.y += z * b3;
        o.z = x * c1 + y * c2 + c4 + z * c3;
      } else if (c1 || c2 || c4) {
        o.z = x * c1 + y * c2 + c4;
      }

      return o;
    }

    return point;
  }
  /**
   * 初等行变换求3*3特定css的matrix方阵，一维6长度
   * https://blog.csdn.net/iloveas2014/article/details/82930946
   */


  function inverse$1(m) {
    if (m.length === 16) {
      return inverse4(m);
    }

    var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        e = m[4],
        f = m[5];

    if (a === 1 && b === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
      return m;
    }

    var divisor = a * d - b * c;

    if (divisor === 0) {
      return m;
    }

    return [d / divisor, -b / divisor, -c / divisor, a / divisor, (c * f - d * e) / divisor, (b * e - a * f) / divisor];
  } // 16位或者6位单位矩阵判断，空也认为是


  function isE$5(m) {
    if (!m || !m.length) {
      return true;
    }

    if (m.length === 16) {
      return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }

    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
  }

  function toE$1(m) {
    m[0] = 1;
    m[1] = 0;
    m[2] = 0;
    m[3] = 0;
    m[4] = 0;
    m[5] = 1;
    m[6] = 0;
    m[7] = 0;
    m[8] = 0;
    m[9] = 0;
    m[10] = 1;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    return m;
  }
  /**
   * 求任意4*4矩阵的逆矩阵，行列式为 0 则返回单位矩阵兜底
   * 格式：matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)
   * 参见: https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d()
   * 对应：
   * [
   *   a1,a2,a3,a4,
   *   b1,b2,b3,b4,
   *   c1,c2,c3,c4,
   *   d1,d2,d3,d4,
   * ]
   *
   * 根据公式 A* = |A|A^-1 来计算
   * A* 表示矩阵 A 的伴随矩阵，A^-1 表示矩阵 A 的逆矩阵，|A| 表示行列式的值
   *
   * @returns {number[]}
   */


  function inverse4(s) {
    var inv = [];
    inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
    inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
    inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
    inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
    inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
    inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
    inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
    inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
    inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
    inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
    inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
    inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
    inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
    inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
    inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
    inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
    var det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];

    if (det === 0) {
      return identity$2();
    }

    det = 1 / det;
    var d = [];

    for (var i = 0; i < 16; i++) {
      d[i] = inv[i] * det;
    }

    return d;
  } // 将4*4的16长度矩阵转成css/canvas的6位标准使用，忽略transform3d


  function m2m6(m) {
    return [m[0], m[1], m[4], m[5], m[12], m[13]];
  }

  function point2d$1(point) {
    var w = point[3];

    if (w && w !== 1) {
      point = point.slice(0, 2);
      point[0] /= w;
      point[1] /= w;
    }

    return point;
  }

  function calRectPoint$2(xa, ya, xb, yb, matrix) {
    var _calPoint = calPoint$2({
      x: xa,
      y: ya,
      z: 0,
      w: 1
    }, matrix),
        x1 = _calPoint.x,
        y1 = _calPoint.y,
        z1 = _calPoint.z,
        w1 = _calPoint.w;

    var _calPoint2 = calPoint$2({
      x: xb,
      y: yb,
      z: 0,
      w: 1
    }, matrix),
        x3 = _calPoint2.x,
        y3 = _calPoint2.y,
        z3 = _calPoint2.z,
        w3 = _calPoint2.w;

    var x2, y2, z2, w2, x4, y4, z4, w4; // 无旋转的时候可以少算2个点

    if (w1 === 1 && w3 === 1 && (!matrix || !matrix.length || !matrix[1] && !matrix[2] && !matrix[4] && !matrix[6] && !matrix[7] && !matrix[8])) {
      x2 = x3;
      y2 = y1;
      z2 = z3;
      x4 = x1;
      y4 = y3;
      z2 = z4 = z1;
      w2 = w4 = 1;
    } else {
      var t = calPoint$2({
        x: xb,
        y: ya,
        z: 0,
        w: 1
      }, matrix);
      x2 = t.x;
      y2 = t.y;
      z2 = t.z;
      w2 = t.w;
      t = calPoint$2({
        x: xa,
        y: yb,
        z: 0,
        w: 1
      }, matrix);
      x4 = t.x;
      y4 = t.y;
      z4 = t.z;
      w4 = t.w;
    }

    return {
      x1: x1,
      y1: y1,
      z1: z1,
      w1: w1,
      x2: x2,
      y2: y2,
      z2: z2,
      w2: w2,
      x3: x3,
      y3: y3,
      z3: z3,
      w3: w3,
      x4: x4,
      y4: y4,
      z4: z4,
      w4: w4
    };
  }

  function calRectPointWasm$1(xa, ya, xb, yb, matrix, index) {
    var i = index * 16;

    var _calPointWasm = calPointWasm({
      x: xa,
      y: ya,
      z: 0,
      w: 1
    }, matrix, i),
        x1 = _calPointWasm.x,
        y1 = _calPointWasm.y,
        z1 = _calPointWasm.z,
        w1 = _calPointWasm.w;

    var _calPointWasm2 = calPointWasm({
      x: xb,
      y: yb,
      z: 0,
      w: 1
    }, matrix, i),
        x3 = _calPointWasm2.x,
        y3 = _calPointWasm2.y,
        z3 = _calPointWasm2.z,
        w3 = _calPointWasm2.w;

    var x2, y2, z2, w2, x4, y4, z4, w4; // 无旋转的时候可以少算2个点

    if (w1 === 1 && w3 === 1 && (!matrix || !matrix.length || !matrix[i + 1] && !matrix[i + 2] && !matrix[i + 4] && !matrix[i + 6] && !matrix[i + 7] && !matrix[i + 8])) {
      x2 = x3;
      y2 = y1;
      z2 = z3;
      x4 = x1;
      y4 = y3;
      z2 = z4 = z1;
      w2 = w4 = 1;
    } else {
      var t = calPointWasm({
        x: xb,
        y: ya,
        z: 0,
        w: 1
      }, matrix, i);
      x2 = t.x;
      y2 = t.y;
      z2 = t.z;
      w2 = t.w;
      t = calPointWasm({
        x: xa,
        y: yb,
        z: 0,
        w: 1
      }, matrix, i);
      x4 = t.x;
      y4 = t.y;
      z4 = t.z;
      w4 = t.w;
    }

    return {
      x1: x1,
      y1: y1,
      z1: z1,
      w1: w1,
      x2: x2,
      y2: y2,
      z2: z2,
      w2: w2,
      x3: x3,
      y3: y3,
      z3: z3,
      w3: w3,
      x4: x4,
      y4: y4,
      z4: z4,
      w4: w4
    };
  }

  function assignMatrix$3(t, v) {
    if (t && v) {
      t[0] = v[0];
      t[1] = v[1];
      t[2] = v[2];
      t[3] = v[3];
      t[4] = v[4];
      t[5] = v[5];
      t[6] = v[6];
      t[7] = v[7];
      t[8] = v[8];
      t[9] = v[9];
      t[10] = v[10];
      t[11] = v[11];
      t[12] = v[12];
      t[13] = v[13];
      t[14] = v[14];
      t[15] = v[15];
    }

    return t;
  }

  var matrix = {
    identity: identity$2,
    multiply: multiply$4,
    // multiply2,
    multiplyTfo: multiplyTfo$1,
    tfoMultiply: tfoMultiply$1,
    multiplyTranslateX: multiplyTranslateX$1,
    multiplyTranslateY: multiplyTranslateY$1,
    multiplyTranslateZ: multiplyTranslateZ$1,
    multiplyRotateX: multiplyRotateX$2,
    multiplyRotateY: multiplyRotateY$2,
    multiplyRotateZ: multiplyRotateZ$2,
    multiplySkewX: multiplySkewX$2,
    multiplySkewY: multiplySkewY$2,
    multiplyScaleX: multiplyScaleX$2,
    multiplyScaleY: multiplyScaleY$2,
    multiplyScaleZ: multiplyScaleZ$2,
    multiplyPerspective: multiplyPerspective$1,
    calPoint: calPoint$2,
    calRectPoint: calRectPoint$2,
    calRectPointWasm: calRectPointWasm$1,
    point2d: point2d$1,
    inverse: inverse$1,
    isE: isE$5,
    toE: toE$1,
    m2m6: m2m6,
    assignMatrix: assignMatrix$3
  };

  var toString = {}.toString;

  function isType(type) {
    return function (obj) {
      return toString.call(obj) === '[object ' + type + ']';
    };
  }

  function isTypes(types) {
    return function (obj) {
      var s = toString.call(obj);

      for (var i = 0, len = types.length; i < len; i++) {
        if (s === '[object ' + types[i] + ']') {
          return true;
        }
      }

      return false;
    };
  }

  var isObject$1 = isType('Object');
  var isString$3 = isType('String');
  var isFunction$b = isTypes(['Function', 'AsyncFunction', 'GeneratorFunction']);
  var isNumber$2 = isType('Number');
  var isBoolean = isType('Boolean');
  var isDate = isType('Date');
  var hasOwn = {}.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);

  function isNil$h(v) {
    return v === undefined || v === null;
  }

  function _joinSourceArray(arr) {
    var res = '';

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        res += _joinSourceArray(item);
      } else {
        res += stringify(item);
      }
    }

    return res;
  }

  function stringify(s) {
    if (isNil$h(s)) {
      return '';
    }

    return s.toString();
  }

  function encodeHtml(s, prop) {
    if (prop) {
      return s.replace(/"/g, '&quot;');
    }

    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/ /g, '&nbsp;');
  } // 根元素专用


  function joinVirtualDom(vd) {
    var s = '<defs>';
    vd.defs.forEach(function (item) {
      s += joinDef$1(item);
    });
    s += '</defs><g>';
    vd.bb.forEach(function (item) {
      s += joinVd$1(item);
    });
    s += '</g><g';

    if (vd.conClip) {
      s += ' clip-path="' + vd.conClip + '"';
    }

    s += '>';
    (vd.children || []).forEach(function (item) {
      s += joinVd$1(item);
    });
    s += '</g>';
    return s;
  } // 普通元素


  function joinVd$1(vd) {
    if (vd.type === 'item' || vd.type === 'img') {
      var s = '';
      (vd.props || []).forEach(function (item) {
        s += ' ' + item[0] + '="' + item[1] + '"';
      });

      if (vd.tagName === 'text') {
        return '<text' + s + '>' + vd.content + '</text>';
      }

      return '<' + vd.tagName + s + '/>';
    } else if (vd.type === 'text') {
      var _s = ''; // text有许多lineBox

      (vd.children || []).forEach(function (item) {
        _s += joinVd$1(item);
      });
      return '<g>' + _s + '</g>';
    } else if (vd.type === 'dom' || vd.type === 'geom') {
      var _s2 = '<g>';
      vd.bb.forEach(function (item) {
        _s2 += joinVd$1(item);
      });
      _s2 += '</g><g';

      if (vd.conClip) {
        _s2 += ' clip-path="' + vd.conClip + '"';
      }

      _s2 += '>';
      (vd.children || []).forEach(function (item) {
        _s2 += joinVd$1(item);
      });
      _s2 += '</g>';
      var opacity = vd.opacity,
          transform = vd.transform,
          visibility = vd.visibility,
          mask = vd.mask,
          overflow = vd.overflow,
          filter = vd.filter,
          mixBlendMode = vd.mixBlendMode;
      return '<g' + (opacity !== 1 && opacity !== undefined ? ' opacity="' + opacity + '"' : '') + (transform ? ' transform="' + transform + '"' : '') + ' visibility="' + visibility + '"' + (mask ? ' mask="' + mask + '"' : '') + (overflow ? ' clip-path="' + overflow + '"' : '') + (filter || mixBlendMode ? ' style="' : '') + (filter ? 'filter:' + filter + ';' : '') + (mixBlendMode ? 'mix-blend-mode:' + mixBlendMode + ';' : '') + (filter || mixBlendMode ? '"' : '') + '>' + _s2 + '</g>';
    }
  }

  function joinDef$1(def) {
    var s = '<' + def.tagName + ' id="' + def.uuid + '"';

    if (def.tagName === 'mask' || def.tagName === 'clipPath') ; else if (def.tagName === 'filter') ; else {
      s += ' gradientUnits="userSpaceOnUse"';
    }

    (def.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '>';
    (def.children || []).forEach(function (item) {
      s += joinItem(item);
    });
    s += '</' + def.tagName + '>';
    return s;
  }

  function joinItem(item) {
    var s = '<' + item.tagName;
    (item.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '></' + item.tagName + '>';
    return s;
  }

  function rgba2int$3(color) {
    if (Array.isArray(color)) {
      return color;
    }

    var res = [];

    if (!color || color === 'transparent') {
      res = [0, 0, 0, 0];
    } else if (color.charAt(0) === '#') {
      color = color.slice(1);

      if (color.length === 3) {
        res.push(parseInt(color.charAt(0) + color.charAt(0), 16));
        res.push(parseInt(color.charAt(1) + color.charAt(1), 16));
        res.push(parseInt(color.charAt(2) + color.charAt(2), 16));
        res[3] = 1;
      } else if (color.length === 6) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4), 16));
        res[3] = 1;
      } else if (color.length === 8) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4, 6), 16));
        res.push(parseInt(color.slice(6), 16) / 255);
      } else {
        res[0] = res[1] = res[2] = 0;
        res[3] = 1;
      }
    } else {
      var c = color.match(/rgba?\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);

      if (c) {
        res = [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];

        if (!isNil$h(c[4])) {
          res[3] = parseFloat(c[4]);
        } else {
          res[3] = 1;
        }
      } else {
        res = [0, 0, 0, 0];
      }
    }

    return res;
  }

  function int2rgba$4(color) {
    if (Array.isArray(color)) {
      if (color.length === 3 || color.length === 4) {
        color[0] = Math.floor(Math.max(color[0], 0));
        color[1] = Math.floor(Math.max(color[1], 0));
        color[2] = Math.floor(Math.max(color[2], 0));

        if (color.length === 4) {
          color[3] = Math.max(color[3], 0);
          return 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + color[3] + ')';
        }

        return 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',1)';
      }
    }

    return color || 'rgba(0,0,0,0)';
  }

  function int2invert(color) {
    if (Array.isArray(color)) {
      color = color.slice(0);
      color[0] = 255 - color[0];
      color[1] = 255 - color[1];
      color[2] = 255 - color[2];

      if (color.length === 4) {
        return 'rgba(' + joinArr$3(color, ',') + ')';
      } else if (color.length === 3) {
        return 'rgba(' + joinArr$3(color, ',') + ',1)';
      }
    }

    return 'rgba(0,0,0,0)';
  }

  function arr2hash(arr) {
    var hash = {};

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        hash[item[0]] = item[1];
      } else {
        for (var list = Object.keys(item), j = list.length - 1; j >= 0; j--) {
          var k = list[j];
          hash[k] = item[k];
        }
      }
    }

    return hash;
  }

  function hash2arr(hash) {
    if (Array.isArray(hash)) {
      return hash;
    }

    var arr = [];

    for (var list = Object.keys(hash), i = 0, len = list.length; i < len; i++) {
      var k = list[i];
      arr.push([k, hash[k]]);
    }

    return arr;
  }

  function clone$3(obj) {
    if (isNil$h(obj) || _typeof(obj) !== 'object') {
      return obj;
    }

    if (util.isDate(obj)) {
      return new Date(obj);
    }

    if (!isPlainObject(obj) && !Array.isArray(obj)) {
      return obj;
    }

    var n = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(function (i) {
      n[i] = clone$3(obj[i]);
    });
    return n;
  }
  /**
   * 简化的arr对比，arr中只有arr和其它类型，其它类型对比值或引用，arr递归
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equalArr$2(a, b) {
    if (!a || !b) {
      return a === b;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0, len = a.length; i < len; i++) {
      var ai = a[i];
      var bi = b[i];
      var isArrayA = Array.isArray(ai);
      var isArrayB = Array.isArray(bi);

      if (isArrayA && isArrayB) {
        if (!equalArr$2(ai, bi)) {
          return false;
        }
      } else if (isArrayA || isArrayB) {
        return false;
      } else if (ai !== bi) {
        return false;
      }
    }

    return true;
  }
  /**
   * 深度对比对象
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equal$1(a, b) {
    if (a === b) {
      return true;
    }

    if (isObject$1(a) && isObject$1(b)) {
      var hash = {};

      for (var i = 0, arr = Object.keys(a), len = arr.length; i < len; i++) {
        var k = arr[i];

        if (!b.hasOwnProperty(k) || !equal$1(a[k], b[k])) {
          return false;
        }

        hash[k] = true;
      } // a没有b有则false


      for (var _i = 0, _arr = Object.keys(b), _len = _arr.length; _i < _len; _i++) {
        var _k = _arr[_i];

        if (!hash.hasOwnProperty(_k)) {
          return false;
        }
      }
    } else if (isDate(a) && isDate(b)) {
      return a.getTime() === b.getTime();
    } else if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        if (!equal$1(a[_i2], b[_i2])) {
          return false;
        }
      }
    } else {
      return a === b;
    }

    return true;
  }

  function extend$3(target, source, keys) {
    if (source === null || _typeof(source) !== 'object') {
      return target;
    }

    if (!keys) {
      keys = Object.keys(source);
    }

    var i = 0;
    var len = keys.length;

    while (i < len) {
      var k = keys[i];
      target[k] = source[k];
      i++;
    }

    return target;
  }

  function joinArr$3(arr, split) {
    var s = arr.length ? arr[0] : '';

    for (var i = 1, len = arr.length; i < len; i++) {
      s += split + arr[i];
    }

    return s;
  }

  function transformBbox$1(bbox, matrix$1) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (!matrix.isE(matrix$1)) {
      var _bbox = bbox,
          _bbox2 = _slicedToArray(_bbox, 4),
          x1 = _bbox2[0],
          y1 = _bbox2[1],
          x2 = _bbox2[2],
          y2 = _bbox2[3]; // 可能因filter的原因扩展范围


      if (dx) {
        x1 -= dx;
        x2 += dx;
      }

      if (dy) {
        y1 -= dy;
        y2 += dy;
      }

      var list = [x2, y1, x1, y2, x2, y2];
      var w;
      var t = matrix.calPoint({
        x: x1,
        y: y1,
        z: 0,
        w: 1
      }, matrix$1);
      x1 = t.x;
      y1 = t.y;
      w = t.w;

      if (w && w !== 1) {
        x1 /= w;
        y1 /= w;
      }

      var xa = x1,
          ya = y1,
          xb = x1,
          yb = y1;

      for (var i = 0; i < 6; i += 2) {
        var x = list[i],
            y = list[i + 1];

        var _t = matrix.calPoint({
          x: x,
          y: y,
          z: 0,
          w: 1
        }, matrix$1);

        x = _t.x;
        y = _t.y;
        w = _t.w;

        if (w && w !== 1) {
          x /= w;
          y /= w;
        }

        xa = Math.min(xa, x);
        xb = Math.max(xb, x);
        ya = Math.min(ya, y);
        yb = Math.max(yb, y);
      }

      return [xa, ya, xb, yb];
    } else {
      bbox = bbox.slice(0);

      if (dx || dy) {
        bbox = bbox.slice(0);
        bbox[0] -= dx;
        bbox[1] -= dy;
        bbox[2] += dx;
        bbox[3] += dy;
      }
    }

    return bbox;
  }

  function isPlainObject(obj) {
    if (!obj || toString.call(obj) !== '[object Object]') {
      return false;
    }

    var proto = Object.getPrototypeOf(obj);

    if (!proto) {
      return true;
    }

    var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
  }

  function prefixHex(s) {
    if (s.length === 1) {
      return '0' + s;
    }

    return s;
  }

  function replaceRgba2Hex$1(s) {
    return (s || '').replace(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/ig, function ($0, $1, $2, $3, $4) {
      var res = '#' + prefixHex(parseInt($1).toString(16)) + prefixHex(parseInt($2).toString(16)) + prefixHex(parseInt($3).toString(16));

      if ($4) {
        res += prefixHex(Math.floor(parseFloat($4) * 255).toString(16));
      }

      return res;
    });
  }

  var util = {
    isObject: isObject$1,
    isString: isString$3,
    isFunction: isFunction$b,
    isNumber: isNumber$2,
    isBoolean: isBoolean,
    isDate: isDate,
    isNil: isNil$h,
    isPrimitive: function isPrimitive(v) {
      return util.isNil(v) || util.isBoolean(v) || util.isString(v) || util.isNumber(v);
    },
    // css中常用undefined/null表示auto本身
    isAuto: function isAuto(v) {
      return isNil$h(v) || v === 'auto';
    },
    isPlainObject: isPlainObject,
    stringify: stringify,
    joinSourceArray: function joinSourceArray(arr) {
      return _joinSourceArray(arr);
    },
    encodeHtml: encodeHtml,
    joinVirtualDom: joinVirtualDom,
    joinVd: joinVd$1,
    joinDef: joinDef$1,
    rgba2int: rgba2int$3,
    int2rgba: int2rgba$4,
    int2invert: int2invert,
    arr2hash: arr2hash,
    hash2arr: hash2arr,
    clone: clone$3,
    equalArr: equalArr$2,
    equal: equal$1,
    extend: extend$3,
    joinArr: joinArr$3,
    transformBbox: transformBbox$1,
    prefixHex: prefixHex,
    replaceRgba2Hex: replaceRgba2Hex$1
  };

  var config = {
    debug: false,
    offscreenCanvas: true
  };

  var SPF = 1000 / 60;
  var CANVAS$5 = {};
  var SUPPORT_OFFSCREEN_CANVAS = typeof OffscreenCanvas === 'function' && OffscreenCanvas.prototype.getContext;

  function offscreenCanvas(width, height, key, message, contextAttributes) {
    var o;

    if (!key) {
      o = !config.debug && config.offscreenCanvas && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
    } else if (!CANVAS$5[key]) {
      o = CANVAS$5[key] = !config.debug && config.offscreenCanvas && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
    } else {
      o = CANVAS$5[key];
    }

    o.width = width;
    o.height = height;

    if (config.debug) {
      o.style.width = width + 'px';
      o.style.height = height + 'px';

      if (key) {
        o.setAttribute('key', key);
      }

      if (message) {
        o.setAttribute('message', message);
      }

      document.body.appendChild(o);
    }

    var ctx = o.getContext('2d', contextAttributes);

    if (!ctx) {
      inject.error('Total canvas memory use exceeds the maximum limit');
    }

    return {
      canvas: o,
      ctx: ctx,
      __enabled: true,
      __available: true,

      get enabled() {
        return this.__enabled;
      },

      get available() {
        return this.__available;
      },

      release: function release() {
        ctx.globalAlpha = 1;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        ctx.globalCompositeOperation = 'source-over';
        o.width = o.height = 0;
        this.__available = false;

        if (config.debug && o) {
          document.body.removeChild(o);
        }

        o = null;
        ctx = null;
      }
    };
  }

  var IMG = {};
  var INIT = 0;
  var LOADING = 1;
  var LOADED = 2;
  var FONT = {};
  var COMPONENT = {};
  var MAX_LOAD_NUM = 0;
  var imgCount = 0,
      imgQueue = [],
      fontCount = 0,
      fontQueue = [],
      componentCount = 0,
      componentQueue = [];
  var div;
  var SUPPORT_FONT = {};
  var defaultFontFamilyData;

  function createDiv() {
    div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '99999px';
    div.style.top = '-99999px';
    div.style.visibility = 'hidden';
    div.style.whiteSpace = 'nowrap';
    document.body.appendChild(div);
  }

  var inject = {
    CANVAS: CANVAS$5,
    measureTextSync: function measureTextSync(str, ff, fs, fw, isUpright) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;

      if (isUpright) {
        div.style.writingMode = 'vertical-lr';
      } else {
        div.style.writingMode = 'horizontal-tb';
      }

      div.innerHTML = str.replace(/</g, '&lt;').replace(/[ \n]/g, '&nbsp;');

      if (isUpright) {
        return parseFloat(window.getComputedStyle(div, null).height);
      } else {
        return parseFloat(window.getComputedStyle(div, null).width);
      }
    },
    measureTextListMax: function measureTextListMax(str, ff, fs, fw) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;
      var s = '';

      for (var i = 0, len = str.length; i < len; i++) {
        s += '<span style="position:absolute">' + str.charAt(i).replace('<', '&lt;').replace(/[ \n]/, '&nbsp;') + '</span>';
      }

      div.innerHTML = s;
      var max = 0;
      var cns = div.childNodes;

      for (var _i = 0, _len = cns.length; _i < _len; _i++) {
        var node = cns[_i]; // clientWidth只返回ceil整数，精度必须用getComputedStyle

        max = Math.max(max, parseFloat(window.getComputedStyle(node, null).width));
      }

      return max;
    },
    IMG: IMG,
    INIT: INIT,
    LOADED: LOADED,
    LOADING: LOADING,

    get MAX_LOAD_NUM() {
      return MAX_LOAD_NUM;
    },

    set MAX_LOAD_NUM(v) {
      MAX_LOAD_NUM = parseInt(v) || 0;
    },

    measureImg: function measureImg(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb && cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.measureImg(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb && cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Measure img invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = IMG[url] = IMG[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        var load = function load(url, cache) {
          var img = new Image();

          img.onload = function () {
            cache.state = LOADED;
            cache.success = true;
            cache.width = img.width;
            cache.height = img.height;
            cache.source = img;
            cache.url = url;
            var list = cache.task.splice(0);
            list.forEach(function (cb) {
              cb(cache);
            });
            imgCount--;

            if (imgQueue.length) {
              var o = imgQueue.shift();
              load(o, IMG[o]);
            }
          };

          img.onerror = function (e) {
            cache.state = LOADED;
            cache.success = false;
            cache.url = url;
            var list = cache.task.splice(0);
            list.forEach(function (cb) {
              return cb(cache);
            });
            imgCount--;

            if (imgQueue.length) {
              var o = imgQueue.shift();
              load(o, cache);
            }
          };

          if (url.substr(0, 5) !== 'data:') {
            var host = /^(?:\w+:)?\/\/([^/:]+)/.exec(url);

            if (host) {
              if (typeof location === 'undefined' || location.hostname !== host[1]) {
                img.crossOrigin = 'anonymous';
              }
            }
          }

          img.src = url;

          if (config.debug && typeof document !== 'undefined') {
            document.body.appendChild(img);
          }
        };

        cache.state = LOADING;
        cb && cache.task.push(cb);

        if (MAX_LOAD_NUM > 0 && imgCount >= MAX_LOAD_NUM) {
          imgQueue.push(url);
          return;
        }

        imgCount++;
        load(url, cache);
      }
    },
    log: function log(s) {
      console.log(s);
    },
    warn: function warn(s) {
      console.warn(s);
    },
    error: function error(s) {
      console.error(s);
    },
    requestAnimationFrame: function (_requestAnimationFrame) {
      function requestAnimationFrame(_x) {
        return _requestAnimationFrame.apply(this, arguments);
      }

      requestAnimationFrame.toString = function () {
        return _requestAnimationFrame.toString();
      };

      return requestAnimationFrame;
    }(function (cb) {
      if (!cb) {
        return;
      }

      var res;

      if (typeof requestAnimationFrame !== 'undefined') {
        inject.requestAnimationFrame = requestAnimationFrame.bind(null);
        res = requestAnimationFrame(cb);
      } else {
        res = setTimeout(cb, SPF);

        inject.requestAnimationFrame = function (cb) {
          return setTimeout(cb, SPF);
        };
      }

      return res;
    }),
    cancelAnimationFrame: function (_cancelAnimationFrame) {
      function cancelAnimationFrame(_x2) {
        return _cancelAnimationFrame.apply(this, arguments);
      }

      cancelAnimationFrame.toString = function () {
        return _cancelAnimationFrame.toString();
      };

      return cancelAnimationFrame;
    }(function (id) {
      var res;

      if (typeof cancelAnimationFrame !== 'undefined') {
        inject.cancelAnimationFrame = cancelAnimationFrame.bind(null);
        res = cancelAnimationFrame(id);
      } else {
        res = clearTimeout(id);

        inject.cancelAnimationFrame = function (id) {
          return clearTimeout(id);
        };
      }

      return res;
    }),
    now: function now() {
      if (typeof performance !== 'undefined') {
        inject.now = function () {
          return Math.floor(performance.now());
        };

        return Math.floor(performance.now());
      }

      inject.now = Date.now.bind(Date);
      return Date.now();
    },
    hasOffscreenCanvas: function hasOffscreenCanvas(key) {
      return key && CANVAS$5.hasOwnProperty(key);
    },
    getOffscreenCanvas: function getOffscreenCanvas(width, height, key, message, contextAttributes) {
      return offscreenCanvas(width, height, key, message, contextAttributes);
    },
    isDom: function isDom(o) {
      if (o) {
        if (util.isString(o)) {
          return true;
        }

        if (typeof window !== 'undefined' && window.Element && o instanceof window.Element) {
          return true;
        }

        if (typeof window !== 'undefined' && window.OffscreenCanvas && o instanceof window.OffscreenCanvas) {
          return true;
        } // worker


        if (typeof self !== 'undefined' && self.OffscreenCanvas && o instanceof self.OffscreenCanvas) {
          return true;
        }

        if (util.isFunction(o.getElementsByTagName)) {
          return true;
        }
      }

      return false;
    },
    isWebGLTexture: function isWebGLTexture(o) {
      if (o && typeof WebGLTexture !== 'undefined') {
        return o instanceof WebGLTexture;
      }
    },
    defaultFontFamily: 'arial',
    getFontCanvas: function getFontCanvas(contextAttributes) {
      return inject.getOffscreenCanvas(16, 16, '__$$CHECK_SUPPORT_FONT_FAMILY$$__', null, contextAttributes);
    },
    // TODO 移入font且设置默认字体可用
    checkSupportFontFamily: function checkSupportFontFamily(ff) {
      ff = ff.toLowerCase(); // 强制arial兜底

      if (ff === this.defaultFontFamily) {
        return true;
      }

      if (SUPPORT_FONT.hasOwnProperty(ff)) {
        return SUPPORT_FONT[ff];
      }

      var canvas = inject.getFontCanvas({
        willReadFrequently: true
      });
      var context = canvas.ctx;
      context.textAlign = 'center';
      context.fillStyle = '#000';
      context.textBaseline = 'middle';

      if (!defaultFontFamilyData) {
        context.clearRect(0, 0, 16, 16);
        context.font = '16px ' + this.defaultFontFamily;
        context.fillText('a', 8, 8);
        defaultFontFamilyData = context.getImageData(0, 0, 16, 16).data;
      }

      context.clearRect(0, 0, 16, 16);

      if (/\s/.test(ff)) {
        ff = '"' + ff.replace(/"/g, '\\"') + '"';
      }

      context.font = '16px ' + ff + ',' + this.defaultFontFamily;
      context.fillText('a', 8, 8);
      var data = context.getImageData(0, 0, 16, 16).data;

      for (var i = 0, len = data.length; i < len; i++) {
        if (defaultFontFamilyData[i] !== data[i]) {
          return SUPPORT_FONT[ff] = true;
        }
      }

      return SUPPORT_FONT[ff] = false;
    },
    FONT: FONT,
    loadFont: function loadFont(fontFamily, url, cb) {
      if (util.isFunction(url)) {
        cb = url;
        url = fontFamily;
      }

      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadFont(item.fontFamily, item.url, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load font invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = FONT[url] = FONT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        var load = function load(fontFamily, url, cache) {
          if (url instanceof ArrayBuffer) {
            success(url);
          } else {
            var request = new XMLHttpRequest();
            request.open('get', url, true);
            request.responseType = 'arraybuffer';

            request.onload = function () {
              if (request.response) {
                success(request.response);
              } else {
                error();
              }
            };

            request.onerror = error;
            request.send();
          }

          function success(ab) {
            var f = new FontFace(fontFamily, ab);
            f.load().then(function () {
              if (typeof document !== 'undefined') {
                document.fonts.add(f);
              }

              cache.state = LOADED;
              cache.success = true;
              cache.url = url;
              var list = cache.task.splice(0);
              list.forEach(function (cb) {
                return cb(cache, ab);
              });
            })["catch"](error);
            fontCount++;

            if (fontQueue.length) {
              var o = fontQueue.shift();
              load(o.fontFamily, o.url, FONT[o.url]);
            }
          }

          function error() {
            cache.state = LOADED;
            cache.success = false;
            cache.url = url;
            var list = cache.task.splice(0);
            list.forEach(function (cb) {
              return cb(cache);
            });
            fontCount--;

            if (fontQueue.length) {
              var o = fontQueue.shift();
              load(o.fontFamily, o.url, FONT[o.url]);
            }
          }
        };

        cache.state = LOADING;
        cb && cache.task.push(cb);

        if (MAX_LOAD_NUM > 0 && fontCount >= MAX_LOAD_NUM) {
          fontQueue.push({
            fontFamily: fontFamily,
            url: url
          });
          return;
        }

        fontCount++;
        load(fontFamily, url, cache);
      }
    },
    loadComponent: function loadComponent(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadComponent(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load component invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = COMPONENT[url] = COMPONENT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        var load = function load(url, cache) {
          var script = document.createElement('script');
          script.src = url;
          script.async = true;

          script.onload = function () {
            cache.state = LOADED;
            cache.success = true;
            cache.url = url;
            var list = cache.task.splice(0);
            list.forEach(function (cb) {
              return cb(cache);
            });
            document.head.removeChild(script);
            componentCount--;

            if (componentQueue.length) {
              var o = componentQueue.shift();
              load(o, COMPONENT[o]);
            }
          };

          script.onerror = function () {
            cache.state = LOADED;
            cache.success = false;
            cache.url = url;
            var list = cache.task.splice(0);
            list.forEach(function (cb) {
              return cb(cache);
            });
            document.head.removeChild(script);
            componentCount--;

            if (componentQueue.length) {
              var o = componentQueue.shift();
              load(o, COMPONENT[o]);
            }
          };

          document.head.appendChild(script);
        };

        cache.state = LOADING;
        cb && cache.task.push(cb);

        if (MAX_LOAD_NUM > 0 && componentCount >= MAX_LOAD_NUM) {
          componentQueue.push(url);
          return;
        }

        componentCount++;
        load(url, cache);
      }
    }
  };

  var TINF_OK = 0;
  var TINF_DATA_ERROR = -3;

  function Tree() {
    this.table = new Uint16Array(16);
    /* table of code length counts */

    this.trans = new Uint16Array(288);
    /* code -> symbol translation table */
  }

  function Data(source, dest) {
    this.source = source;
    this.sourceIndex = 0;
    this.tag = 0;
    this.bitcount = 0;
    this.dest = dest;
    this.destLen = 0;
    this.ltree = new Tree();
    /* dynamic length/symbol tree */

    this.dtree = new Tree();
    /* dynamic distance tree */
  }
  /* --------------------------------------------------- *
   * -- uninitialized global data (static structures) -- *
   * --------------------------------------------------- */


  var sltree = new Tree();
  var sdtree = new Tree();
  /* extra bits and base tables for length codes */

  var length_bits = new Uint8Array(30);
  var length_base = new Uint16Array(30);
  /* extra bits and base tables for distance codes */

  var dist_bits = new Uint8Array(30);
  var dist_base = new Uint16Array(30);
  /* special ordering of code length codes */

  var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  /* used by tinf_decode_trees, avoids allocations every call */

  var code_tree = new Tree();
  var lengths = new Uint8Array(288 + 32);
  /* ----------------------- *
   * -- utility functions -- *
   * ----------------------- */

  /* build extra bits and base tables */

  function tinf_build_bits_base(bits, base, delta, first) {
    var i, sum;
    /* build bits table */

    for (i = 0; i < delta; ++i) {
      bits[i] = 0;
    }

    for (i = 0; i < 30 - delta; ++i) {
      bits[i + delta] = i / delta | 0;
    }
    /* build base table */


    for (sum = first, i = 0; i < 30; ++i) {
      base[i] = sum;
      sum += 1 << bits[i];
    }
  }
  /* build the fixed huffman trees */


  function tinf_build_fixed_trees(lt, dt) {
    var i;
    /* build fixed length tree */

    for (i = 0; i < 7; ++i) {
      lt.table[i] = 0;
    }

    lt.table[7] = 24;
    lt.table[8] = 152;
    lt.table[9] = 112;

    for (i = 0; i < 24; ++i) {
      lt.trans[i] = 256 + i;
    }

    for (i = 0; i < 144; ++i) {
      lt.trans[24 + i] = i;
    }

    for (i = 0; i < 8; ++i) {
      lt.trans[24 + 144 + i] = 280 + i;
    }

    for (i = 0; i < 112; ++i) {
      lt.trans[24 + 144 + 8 + i] = 144 + i;
    }
    /* build fixed distance tree */


    for (i = 0; i < 5; ++i) {
      dt.table[i] = 0;
    }

    dt.table[5] = 32;

    for (i = 0; i < 32; ++i) {
      dt.trans[i] = i;
    }
  }
  /* given an array of code lengths, build a tree */


  var offs = new Uint16Array(16);

  function tinf_build_tree(t, lengths, off, num) {
    var i, sum;
    /* clear code length count table */

    for (i = 0; i < 16; ++i) {
      t.table[i] = 0;
    }
    /* scan symbol lengths, and sum code length counts */


    for (i = 0; i < num; ++i) {
      t.table[lengths[off + i]]++;
    }

    t.table[0] = 0;
    /* compute offset table for distribution sort */

    for (sum = 0, i = 0; i < 16; ++i) {
      offs[i] = sum;
      sum += t.table[i];
    }
    /* create code->symbol translation table (symbols sorted by code) */


    for (i = 0; i < num; ++i) {
      if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
    }
  }
  /* ---------------------- *
   * -- decode functions -- *
   * ---------------------- */

  /* get one bit from source stream */


  function tinf_getbit(d) {
    /* check if tag is empty */
    if (!d.bitcount--) {
      /* load next tag */
      d.tag = d.source[d.sourceIndex++];
      d.bitcount = 7;
    }
    /* shift bit out of tag */


    var bit = d.tag & 1;
    d.tag >>>= 1;
    return bit;
  }
  /* read a num bit value from a stream and add base */


  function tinf_read_bits(d, num, base) {
    if (!num) return base;

    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }

    var val = d.tag & 0xffff >>> 16 - num;
    d.tag >>>= num;
    d.bitcount -= num;
    return val + base;
  }
  /* given a data stream and a tree, decode a symbol */


  function tinf_decode_symbol(d, t) {
    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }

    var sum = 0,
        cur = 0,
        len = 0;
    var tag = d.tag;
    /* get more bits while code value is above sum */

    do {
      cur = 2 * cur + (tag & 1);
      tag >>>= 1;
      ++len;
      sum += t.table[len];
      cur -= t.table[len];
    } while (cur >= 0);

    d.tag = tag;
    d.bitcount -= len;
    return t.trans[sum + cur];
  }
  /* given a data stream, decode dynamic trees from it */


  function tinf_decode_trees(d, lt, dt) {
    var hlit, hdist, hclen;
    var i, num, length;
    /* get 5 bits HLIT (257-286) */

    hlit = tinf_read_bits(d, 5, 257);
    /* get 5 bits HDIST (1-32) */

    hdist = tinf_read_bits(d, 5, 1);
    /* get 4 bits HCLEN (4-19) */

    hclen = tinf_read_bits(d, 4, 4);

    for (i = 0; i < 19; ++i) {
      lengths[i] = 0;
    }
    /* read code lengths for code length alphabet */


    for (i = 0; i < hclen; ++i) {
      /* get 3 bits code length (0-7) */
      var clen = tinf_read_bits(d, 3, 0);
      lengths[clcidx[i]] = clen;
    }
    /* build code length tree */


    tinf_build_tree(code_tree, lengths, 0, 19);
    /* decode code lengths for the dynamic trees */

    for (num = 0; num < hlit + hdist;) {
      var sym = tinf_decode_symbol(d, code_tree);

      switch (sym) {
        case 16:
          /* copy previous code length 3-6 times (read 2 bits) */
          var prev = lengths[num - 1];

          for (length = tinf_read_bits(d, 2, 3); length; --length) {
            lengths[num++] = prev;
          }

          break;

        case 17:
          /* repeat code length 0 for 3-10 times (read 3 bits) */
          for (length = tinf_read_bits(d, 3, 3); length; --length) {
            lengths[num++] = 0;
          }

          break;

        case 18:
          /* repeat code length 0 for 11-138 times (read 7 bits) */
          for (length = tinf_read_bits(d, 7, 11); length; --length) {
            lengths[num++] = 0;
          }

          break;

        default:
          /* values 0-15 represent the actual code lengths */
          lengths[num++] = sym;
          break;
      }
    }
    /* build dynamic trees */


    tinf_build_tree(lt, lengths, 0, hlit);
    tinf_build_tree(dt, lengths, hlit, hdist);
  }
  /* ----------------------------- *
   * -- block inflate functions -- *
   * ----------------------------- */

  /* given a stream and two trees, inflate a block of data */


  function tinf_inflate_block_data(d, lt, dt) {
    while (1) {
      var sym = tinf_decode_symbol(d, lt);
      /* check for end of block */

      if (sym === 256) {
        return TINF_OK;
      }

      if (sym < 256) {
        d.dest[d.destLen++] = sym;
      } else {
        var length = void 0,
            dist = void 0,
            _offs = void 0;

        var i = void 0;
        sym -= 257;
        /* possibly get more bits from length code */

        length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
        dist = tinf_decode_symbol(d, dt);
        /* possibly get more bits from distance code */

        _offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
        /* copy match */

        for (i = _offs; i < _offs + length; ++i) {
          d.dest[d.destLen++] = d.dest[i];
        }
      }
    }
  }
  /* inflate an uncompressed block of data */


  function tinf_inflate_uncompressed_block(d) {
    var length, invlength;
    var i;
    /* unread from bitbuffer */

    while (d.bitcount > 8) {
      d.sourceIndex--;
      d.bitcount -= 8;
    }
    /* get length */


    length = d.source[d.sourceIndex + 1];
    length = 256 * length + d.source[d.sourceIndex];
    /* get one's complement of length */

    invlength = d.source[d.sourceIndex + 3];
    invlength = 256 * invlength + d.source[d.sourceIndex + 2];
    /* check length */

    if (length !== (~invlength & 0x0000ffff)) return TINF_DATA_ERROR;
    d.sourceIndex += 4;
    /* copy block */

    for (i = length; i; --i) {
      d.dest[d.destLen++] = d.source[d.sourceIndex++];
    }
    /* make sure we start next block on a byte boundary */


    d.bitcount = 0;
    return TINF_OK;
  }
  /* inflate stream from source to dest */


  function tinf_uncompress(source, dest) {
    var d = new Data(source, dest);
    var bfinal, btype, res;

    do {
      /* read final block flag */
      bfinal = tinf_getbit(d);
      /* read block type (2 bits) */

      btype = tinf_read_bits(d, 2, 0);
      /* decompress block */

      switch (btype) {
        case 0:
          /* decompress uncompressed block */
          res = tinf_inflate_uncompressed_block(d);
          break;

        case 1:
          /* decompress block with fixed huffman trees */
          res = tinf_inflate_block_data(d, sltree, sdtree);
          break;

        case 2:
          /* decompress block with dynamic huffman trees */
          tinf_decode_trees(d, d.ltree, d.dtree);
          res = tinf_inflate_block_data(d, d.ltree, d.dtree);
          break;

        default:
          res = TINF_DATA_ERROR;
      }

      if (res !== TINF_OK) throw new Error('Data error');
    } while (!bfinal);

    if (d.destLen < d.dest.length) {
      if (typeof d.dest.slice === 'function') return d.dest.slice(0, d.destLen);else return d.dest.subarray(0, d.destLen);
    }

    return d.dest;
  }
  /* -------------------- *
   * -- initialization -- *
   * -------------------- */

  /* build fixed huffman trees */


  tinf_build_fixed_trees(sltree, sdtree);
  /* build extra bits and base tables */

  tinf_build_bits_base(length_bits, length_base, 4, 3);
  tinf_build_bits_base(dist_bits, dist_base, 2, 1);
  /* fix a special case */

  length_bits[28] = 0;
  length_base[28] = 258;

  var decode = {};
  /**
   * @param {DataView} data
   * @param {number} offset
   * @param {number} numBytes
   * @returns {string}
   */

  decode.UTF16 = function (data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;

    for (var j = 0; j < numChars; j++, offset += 2) {
      codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
  }; // Data for converting old eight-bit Macintosh encodings to Unicode.
  // This representation is optimized for decoding; encoding is slower
  // and needs more memory. The assumption is that all opentype.js users
  // want to open fonts, but saving a font will be comparatively rare
  // so it can be more expensive. Keyed by IANA character set name.
  //
  // Python script for generating these strings:
  //
  //     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
  //     print(s.encode('utf-8'))

  /**
   * @private
   */


  var eightBitMacEncodings = {
    'x-mac-croatian': // Python: 'mac_croatian'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' + '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
    'x-mac-cyrillic': // Python: 'mac_cyrillic'
    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' + 'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' + 'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
    'x-mac-greek': // Python: 'mac_greek'
    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' + "\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD",
    'x-mac-icelandic': // Python: 'mac_iceland'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' + 'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
    'x-mac-ce': // Python: 'mac_latin2'
    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' + 'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
    macintosh: // Python: 'mac_roman'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-romanian': // Python: 'mac_romanian'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-turkish': // Python: 'mac_turkish'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' + '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
  };
  /**
   * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
   * string, or 'undefined' if the encoding is unsupported. For example, we do
   * not support Chinese, Japanese or Korean because these would need large
   * mapping tables.
   * @param {DataView} dataView
   * @param {number} offset
   * @param {number} dataLength
   * @param {string} encoding
   * @returns {string}
   */

  decode.MACSTRING = function (dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];

    if (table === undefined) {
      return undefined;
    }

    var result = '';

    for (var i = 0; i < dataLength; i++) {
      var c = dataView.getUint8(offset + i); // In all eight-bit Mac encodings, the characters 0x00..0x7F are
      // mapped to U+0000..U+007F; we only need to look up the others.

      if (c <= 0x7F) {
        result += String.fromCharCode(c);
      } else {
        result += table[c & 0x7F];
      }
    }

    return result;
  };

  function getTag(dataView, offset) {
    var tag = '';

    for (var i = offset; i < offset + 4; i++) {
      tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
  }

  function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
  }

  function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
  }

  function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
  }

  var typeOffsets = {
    "byte": 1,
    uShort: 2,
    "short": 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
  };

  function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;

    for (var i = 0; i < numTables; i += 1) {
      var tag = getTag(data, p);
      var checksum = getULong(data, p + 4);
      var offset = getULong(data, p + 8);
      var length = getULong(data, p + 12);
      tableEntries.push({
        tag: tag,
        checksum: checksum,
        offset: offset,
        length: length,
        compression: false
      });
      p += 16;
    }

    return tableEntries;
  }

  function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.

    for (var i = 0; i < numTables; i += 1) {
      var tag = getTag(data, p);
      var offset = getULong(data, p + 4);
      var compLength = getULong(data, p + 8);
      var origLength = getULong(data, p + 12);
      var compression = void 0;

      if (compLength < origLength) {
        compression = 'WOFF';
      } else {
        compression = false;
      }

      tableEntries.push({
        tag: tag,
        offset: offset,
        compression: compression,
        compressedLength: compLength,
        length: origLength
      });
      p += 20;
    }

    return tableEntries;
  }

  function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
      var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
      var outBuffer = new Uint8Array(tableEntry.length);
      tinf_uncompress(inBuffer, outBuffer);

      if (outBuffer.byteLength !== tableEntry.length) {
        inject.error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
      }

      var view = new DataView(outBuffer.buffer, 0);
      return {
        data: view,
        offset: 0
      };
    } else {
      return {
        data: data,
        offset: tableEntry.offset
      };
    }
  }

  var Parser = /*#__PURE__*/function () {
    function Parser(data, offset) {
      this.data = data;
      this.offset = offset;
      this.relativeOffset = 0;
    }

    _createClass(Parser, [{
      key: "parseUShort",
      value: function parseUShort() {
        var v = this.data.getUint16(this.offset + this.relativeOffset);
        this.relativeOffset += 2;
        return v;
      }
    }, {
      key: "parseULong",
      value: function parseULong() {
        var v = getULong(this.data, this.offset + this.relativeOffset);
        this.relativeOffset += 4;
        return v;
      }
    }, {
      key: "parseShort",
      value: function parseShort() {
        var v = this.data.getInt16(this.offset + this.relativeOffset);
        this.relativeOffset += 2;
        return v;
      }
    }, {
      key: "parseFixed",
      value: function parseFixed() {
        var v = getFixed(this.data, this.offset + this.relativeOffset);
        this.relativeOffset += 4;
        return v;
      }
    }, {
      key: "parseVersion",
      value: function parseVersion(minorBase) {
        var major = getUShort(this.data, this.offset + this.relativeOffset);
        var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
        this.relativeOffset += 4;

        if (minorBase === undefined) {
          minorBase = 0x1000;
        }

        return major + minor / minorBase / 10;
      }
    }, {
      key: "skip",
      value: function skip(type, amount) {
        if (amount === undefined) {
          amount = 1;
        }

        this.relativeOffset += typeOffsets[type] * amount;
      }
    }]);

    return Parser;
  }();

  var nameTableNames = ['copyright', // 0
  'fontFamily', // 1
  'fontSubfamily', // 2
  'uniqueID', // 3
  'fullName', // 4
  'version', // 5
  'postScriptName', // 6
  'trademark', // 7
  'manufacturer', // 8
  'designer', // 9
  'description', // 10
  'manufacturerURL', // 11
  'designerURL', // 12
  'license', // 13
  'licenseURL', // 14
  'reserved', // 15
  'preferredFamily', // 16
  'preferredSubfamily', // 17
  'compatibleFullName', // 18
  'sampleText', // 19
  'postScriptFindFontName', // 20
  'wwsFamily', // 21
  'wwsSubfamily' // 22
  ];
  var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
  }; // While Microsoft indicates a region/country for all its language
  // IDs, we omit the region code if it's equal to the "most likely
  // region subtag" according to Unicode CLDR. For scripts, we omit
  // the subtag if it is equal to the Suppress-Script entry in the
  // IANA language subtag registry for IETF BCP 47.
  //
  // For example, Microsoft states that its language code 0x041A is
  // Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
  // and not 'hr-HR' because Croatia is the default country for Croatian,
  // according to Unicode CLDR. As another example, Microsoft states
  // that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
  // this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
  // for the Croatian language, according to IANA.
  //
  // http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
  // http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

  var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',
    // Microsoft has defined two different language codes for
    // “Spanish with modern sorting” and “Spanish with traditional
    // sorting”. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give “es” in both cases.
    0x0C0A: 'es',
    0x040A: 'es',
    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
  }; // MacOS script ID → encoding. This table stores the default case,
  // which can be overridden by macLanguageEncodings.

  var macScriptEncodings = {
    0: 'macintosh',
    // smRoman
    1: 'x-mac-japanese',
    // smJapanese
    2: 'x-mac-chinesetrad',
    // smTradChinese
    3: 'x-mac-korean',
    // smKorean
    6: 'x-mac-greek',
    // smGreek
    7: 'x-mac-cyrillic',
    // smCyrillic
    9: 'x-mac-devanagai',
    // smDevanagari
    10: 'x-mac-gurmukhi',
    // smGurmukhi
    11: 'x-mac-gujarati',
    // smGujarati
    12: 'x-mac-oriya',
    // smOriya
    13: 'x-mac-bengali',
    // smBengali
    14: 'x-mac-tamil',
    // smTamil
    15: 'x-mac-telugu',
    // smTelugu
    16: 'x-mac-kannada',
    // smKannada
    17: 'x-mac-malayalam',
    // smMalayalam
    18: 'x-mac-sinhalese',
    // smSinhalese
    19: 'x-mac-burmese',
    // smBurmese
    20: 'x-mac-khmer',
    // smKhmer
    21: 'x-mac-thai',
    // smThai
    22: 'x-mac-lao',
    // smLao
    23: 'x-mac-georgian',
    // smGeorgian
    24: 'x-mac-armenian',
    // smArmenian
    25: 'x-mac-chinesesimp',
    // smSimpChinese
    26: 'x-mac-tibetan',
    // smTibetan
    27: 'x-mac-mongolian',
    // smMongolian
    28: 'x-mac-ethiopic',
    // smEthiopic
    29: 'x-mac-ce',
    // smCentralEuroRoman
    30: 'x-mac-vietnamese',
    // smVietnamese
    31: 'x-mac-extarabic' // smExtArabic

  }; // MacOS language ID → encoding. This table stores the exceptional
  // cases, which override macScriptEncodings. For writing MacOS naming
  // tables, we need to emit a MacOS script ID. Therefore, we cannot
  // merge macScriptEncodings into macLanguageEncodings.
  //
  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt

  var macLanguageEncodings = {
    15: 'x-mac-icelandic',
    // langIcelandic
    17: 'x-mac-turkish',
    // langTurkish
    18: 'x-mac-croatian',
    // langCroatian
    24: 'x-mac-ce',
    // langLithuanian
    25: 'x-mac-ce',
    // langPolish
    26: 'x-mac-ce',
    // langHungarian
    27: 'x-mac-ce',
    // langEstonian
    28: 'x-mac-ce',
    // langLatvian
    30: 'x-mac-icelandic',
    // langFaroese
    37: 'x-mac-romanian',
    // langRomanian
    38: 'x-mac-ce',
    // langCzech
    39: 'x-mac-ce',
    // langSlovak
    40: 'x-mac-ce',
    // langSlovenian
    143: 'x-mac-inuit',
    // langInuktitut
    146: 'x-mac-gaelic' // langIrishGaelicScript

  }; // Returns a IETF BCP 47 language code, for example 'zh-Hant'
  // for 'Chinese in the traditional script'.

  function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
      case 0:
        // Unicode
        if (languageID === 0xFFFF) {
          return 'und';
        } else if (ltag) {
          return ltag[languageID];
        }

        break;

      case 1:
        // Macintosh
        return macLanguages[languageID];

      case 3:
        // Windows
        return windowsLanguages[languageID];
    }

    return undefined;
  }

  var utf16 = 'utf-16';

  function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
      case 0:
        // Unicode
        return utf16;

      case 1:
        // Apple Macintosh
        return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

      case 3:
        // Microsoft Windows
        if (encodingID === 1 || encodingID === 10) {
          return utf16;
        }

        break;
    }

    return undefined;
  }

  var platforms = {
    0: 'unicode',
    1: 'macintosh',
    2: 'reserved',
    3: 'windows'
  };

  function getPlatform(platformID) {
    return platforms[platformID];
  }

  function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();

    for (var i = 0; i < count; i++) {
      var platformID = p.parseUShort();
      var encodingID = p.parseUShort();
      var languageID = p.parseUShort();
      var nameID = p.parseUShort();
      var property = nameTableNames[nameID] || nameID;
      var byteLength = p.parseUShort();
      var offset = p.parseUShort();
      var language = getLanguageCode(platformID, languageID, ltag);
      var encoding = getEncoding(platformID, encodingID, languageID);
      var platformName = getPlatform(platformID);

      if (encoding !== undefined && language !== undefined && platformName !== undefined) {
        var text = void 0;

        if (encoding === utf16) {
          text = decode.UTF16(data, stringOffset + offset, byteLength);
        } else {
          text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
        }

        if (text) {
          var platform = name[platformName];

          if (platform === undefined) {
            platform = name[platformName] = {};
          }

          var translations = platform[property];

          if (translations === undefined) {
            translations = platform[property] = {};
          }

          translations[language] = text;
        }
      }
    }

    if (format === 1) {
      // FIXME: Also handle Microsoft's 'name' table 1.
      p.parseUShort();
    }

    return name;
  } // Precondition function that checks if the given predicate is true.
  // If not, it will throw an error.


  function argument(predicate, message) {
    if (!predicate) {
      fail(message);
    }
  }

  function parseLtagTable(data, start) {
    var p = new Parser(data, start);
    var tableVersion = p.parseULong();
    argument(tableVersion === 1, 'Unsupported ltag table version.'); // The 'ltag' specification does not define any flags; skip the field.

    p.skip('uLong', 1);
    var numTags = p.parseULong();
    var tags = [];

    for (var i = 0; i < numTags; i++) {
      var tag = '';
      var offset = start + p.parseUShort();
      var length = p.parseUShort();

      for (var j = offset; j < offset + length; ++j) {
        tag += String.fromCharCode(data.getInt8(j));
      }

      tags.push(tag);
    }

    return tags;
  }

  var opentype = {
    parse: function parse(arrayBuffer) {
      var data = new DataView(arrayBuffer, 0);
      var signature = getTag(data, 0);
      var numTables, tableEntries;

      if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        numTables = getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === 'OTTO') {
        numTables = getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === 'wOFF') {
        var flavor = getTag(data, 4);

        if (flavor !== String.fromCharCode(0, 1, 0, 0) && flavor !== 'OTTO') {
          inject.error('Unsupported OpenType flavor ' + signature);
          return;
        }

        numTables = getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
      } else if (signature === 'wOF2') {
        var issue = 'https://github.com/opentypejs/opentype.js/issues/183#issuecomment-1147228025';
        inject.error('WOFF2 require an external decompressor library, see examples at: ' + issue);
      } else {
        inject.error('Unsupported OpenType signature ' + signature);
      }

      var emSquare = 2048,
          ascent,
          descent,
          lineGap = 0,
          name,
          ltagTable;

      for (var i = 0; i < numTables; i++) {
        var tableEntry = tableEntries[i];

        if (tableEntry.tag === 'head') {
          var table = uncompressTable(data, tableEntry);
          var p = new Parser(table.data, table.offset);
          p.parseVersion();
          p.parseFixed();
          p.parseULong();
          p.parseULong();
          p.parseUShort();
          emSquare = p.parseUShort();
        } else if (tableEntry.tag === 'hhea') {
          var _table = uncompressTable(data, tableEntry);

          var _p = new Parser(_table.data, _table.offset);

          _p.parseVersion();

          ascent = Math.abs(_p.parseShort());
          descent = Math.abs(_p.parseShort());
          lineGap = Math.abs(_p.parseShort() || 0);
        } else if (tableEntry.tag === 'ltag') {
          var _table2 = uncompressTable(data, tableEntry);

          ltagTable = parseLtagTable(_table2.data, _table2.offset);
        } else if (tableEntry.tag === 'name') {
          var _table3 = uncompressTable(data, tableEntry);

          var n = parseNameTable(_table3.data, _table3.offset, ltagTable); // https://learn.microsoft.com/en-us/typography/opentype/spec/name

          if (n.macintosh) {
            name = n.macintosh.fontFamily.en;
          } else if (n.windows) {
            name = n.windows.fontFamily.en;
          }
        }
      }

      return {
        name: name,
        emSquare: emSquare,
        ascent: ascent,
        descent: descent,
        lineGap: lineGap
      };
    }
  };

  var isString$2 = util.isString;
  var CALLBACK = {};
  var o$3 = {
    info: {
      arial: {
        lhr: 1.14990234375,
        // 默认line-height ratio，(67+1854+434)/2048
        // car: 1.1171875, // content-area ratio，(1854+434)/2048
        blr: 0.9052734375,
        // base-line ratio，1854/2048
        // mdr: 0.64599609375, // middle ratio，(1854-1062/2)/2048
        lgr: 0.03271484375 // line-gap ratio，67/2048，默认0

      },
      // Times, Helvetica, Courier，3个特殊字体偏移，逻辑来自webkit历史
      // 查看字体发现非推荐标准，先统一取osx的hhea字段，然后ascent做整体15%放大
      // https://github.com/WebKit/WebKit/blob/main/Source/WebCore/platform/graphics/coretext/FontCoreText.cpp#L173
      helvetica: {
        lhr: 1.14990234375,
        // ((1577 + Round((1577 + 471) * 0.15)) + 471) / 2048
        blr: 0.919921875 // (1577 + Round((1577 + 471) * 0.15)) / 2048

      },
      verdana: {
        lhr: 1.21533203125,
        // (0+2059+430)/2048
        blr: 1.00537109375 // 2059/2048

      },
      tahoma: {
        lhr: 1.20703125,
        // (0+2049+423)/2048
        blr: 1.00048828125 // 2049/2048

      },
      georgia: {
        lhr: 1.13623046875,
        // (0+1878+449)/2048
        blr: 0.9169921875 // 1878/2048

      },
      'courier new': {
        lhr: 1.1328125,
        // (0+1705+615)/2048
        blr: 0.83251953125 // 1705/2048

      },
      'pingfang sc': {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06 // 1060/1000

      },
      simsun: {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06
      }
    },
    register: function register(name, url, data) {
      // url和data同时需要，也可以先data后url，不能先url后data
      name = name.toLowerCase();

      if (!isString$2(url) && !(url instanceof ArrayBuffer)) {
        data = url;
        url = null;
      }

      var info = this.info;
      var fontInfo = info[name] = info[name] || {};

      if (url && !fontInfo.url) {
        // 不能覆盖
        fontInfo.url = url;
        inject.loadFont(name, url, function (res, ab) {
          fontInfo.success = res.success;

          if (res.success) {
            // 手动指定更高优先级，不解析
            if (!fontInfo.lhr && ab) {
              var r = opentype.parse(ab);
              setData(r);
            } // 回调


            var list = CALLBACK[name] || [];

            while (list.length) {
              var node = list.pop();

              node.__emitFontRegister(name);
            }
          }
        });
      } // 防止先没url只注册，再调用只传url的情况


      if (!data || fontInfo.lhr) {
        return;
      }

      setData(data);

      function setData(data) {
        var _data$emSquare = data.emSquare,
            emSquare = _data$emSquare === void 0 ? 2048 : _data$emSquare,
            ascent = data.ascent,
            descent = data.descent,
            _data$lineGap = data.lineGap,
            lineGap = _data$lineGap === void 0 ? 0 : _data$lineGap;

        if (!ascent || !descent) {
          return;
        }

        Object.assign(fontInfo, {
          lhr: (ascent + descent + lineGap) / emSquare,
          blr: ascent / emSquare
        });
      }
    },
    hasRegister: function hasRegister(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].hasOwnProperty('lhr');
    },
    hasLoaded: function hasLoaded(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].success;
    },
    onRegister: function onRegister(fontFamily, node) {
      var list = CALLBACK[fontFamily] = CALLBACK[fontFamily] || [];
      list.push(node);
    },
    offRegister: function offRegister(fontFamily, node) {
      var list = CALLBACK[fontFamily] = CALLBACK[fontFamily] || [];
      var i = list.indexOf(node);

      if (i > -1) {
        list.splice(i, 1);
      }
    }
  };
  o$3.info['宋体'] = o$3.info.simsun;
  o$3.info['pingfang'] = o$3.info['pingfang sc'];

  var DOM = {
    position: 'static',
    display: 'block',
    boxSizing: 'contentBox',
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto',
    marginTop: 0,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    fontSize: 'inherit',
    fontFamily: 'inherit',
    color: 'inherit',
    fontStyle: 'inherit',
    fontWeight: 'inherit',
    lineHeight: 'inherit',
    backgroundImage: null,
    backgroundColor: 'transparent',
    backgroundSize: 'auto',
    backgroundRepeat: 'repeat',
    backgroundPositionX: 0,
    backgroundPositionY: 0,
    backgroundClip: 'borderBox',
    borderTopWidth: 0,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    borderLeftWidth: 0,
    borderTopColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderTopStyle: 'none',
    borderRightStyle: 'none',
    borderBottomStyle: 'none',
    borderLeftStyle: 'none',
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0,
    width: 'auto',
    height: 'auto',
    flexGrow: 0,
    flexShrink: 1,
    flexBasis: 'auto',
    flexDirection: 'row',
    flexWrap: 'nowrap',
    order: 0,
    justifyContent: 'flexStart',
    alignItems: 'stretch',
    alignSelf: 'auto',
    alignContent: 'stretch',
    textAlign: 'inherit',
    letterSpacing: 'inherit',
    transformOrigin: 'center',
    visibility: 'inherit',
    opacity: 1,
    zIndex: 0,
    transform: null,
    translateX: 0,
    translateY: 0,
    translateZ: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    skewX: 0,
    skewY: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    rotate3d: '0, 0, 0, 0',
    perspective: 0,
    perspectiveOrigin: 'center',
    transformStyle: 'flat',
    backfaceVisibility: 'visible',
    filter: null,
    boxShadow: null,
    pointerEvents: 'inherit',
    overflow: 'visible',
    mixBlendMode: 'normal',
    whiteSpace: 'inherit',
    textOverflow: 'clip',
    lineClamp: 0,
    textStrokeWidth: 'inherit',
    textStrokeColor: 'inherit',
    textStrokeOver: 'inherit',
    writingMode: 'inherit',
    fontSizeShrink: 0
  };
  var GEOM$4 = {
    fill: 'transparent',
    stroke: '#000',
    strokeWidth: 1,
    strokeDasharray: '',
    strokeLinecap: 'butt',
    strokeLinejoin: 'miter',
    strokeMiterlimit: 4,
    fillRule: 'nonzero'
  };
  var DOM_ENTRY_SET = [];
  var DOM_KEY_SET = [];
  Object.keys(DOM).forEach(function (k) {
    DOM_KEY_SET.push(k);
    var v = DOM[k];
    DOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var GEOM_ENTRY_SET = [];
  var GEOM_KEY_SET$2 = [];
  Object.keys(GEOM$4).forEach(function (k) {
    GEOM_KEY_SET$2.push(k);
    var v = GEOM$4[k];
    GEOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var INHERIT$4 = {
    get fontFamily() {
      return inject.defaultFontFamily;
    },

    fontSize: 16,
    fontWeight: 400,
    fontStyle: 'normal',
    color: '#000',
    textAlign: 'left',
    visibility: 'visible',
    pointerEvents: 'auto',
    textStrokeColor: '#000',
    textStrokeWidth: 0,
    textStrokeOver: 'none',
    writingMode: 'horizontalTb'
  };
  var INHERIT_KEY_SET = [];
  Object.keys(INHERIT$4).forEach(function (k) {
    INHERIT_KEY_SET.push(k);
  }); // 默认值放第一个

  var VALID_STRING_VALUE$1 = {
    position: ['static', 'relative', 'absolute'],
    display: ['block', 'inlineBlock', 'inline', 'flex', 'none'],
    flexDirection: ['row', 'column', 'rowReverse', 'columnReverse'],
    flexWrap: ['wrap', 'wrapReverse', 'nowrap'],
    justifyContent: ['flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround', 'spaceEvenly'],
    alignItems: ['stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    alignSelf: ['auto', 'stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    overflow: ['visible', 'hidden'],
    mixBlendMode: ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'colorDodge', 'colorBurn', 'hardLight', 'softLight', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
    borderTopStyle: ['solid', 'dashed', 'dotted'],
    borderRightStyle: ['solid', 'dashed', 'dotted'],
    borderBottomStyle: ['solid', 'dashed', 'dotted'],
    borderLeftStyle: ['solid', 'dashed', 'dotted'],
    backgroundClip: ['borderBox', 'paddingBox', 'contentBox'],
    textOverflow: ['clip', 'ellipsis'],
    alignContent: ['stretch', 'flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround'],
    transformStyle: ['flat', 'preserve3d'],
    backfaceVisibility: ['visible', 'hidden'],
    boxSizing: ['contentBox', 'borderBox']
  };
  var reset = {
    DOM: DOM,
    GEOM: GEOM$4,
    isValid: function isValid(i) {
      return DOM.hasOwnProperty(i) || GEOM$4.hasOwnProperty(i);
    },
    DOM_KEY_SET: DOM_KEY_SET,
    GEOM_KEY_SET: GEOM_KEY_SET$2,
    DOM_ENTRY_SET: DOM_ENTRY_SET,
    GEOM_ENTRY_SET: GEOM_ENTRY_SET,
    INHERIT: INHERIT$4,
    INHERIT_KEY_SET: INHERIT_KEY_SET,
    VALID_STRING_VALUE: VALID_STRING_VALUE$1
  };

  var reg = {
    position: /(([-+]?[\d.]+[pxremvwhina%]*)|(left|top|right|bottom|center)){1,2}/ig,
    gradient: /\b(\w+)-?gradient\((.+)\)/i,
    img: /(?:\burl\((['"]?)(.*?)\1\))|(?:\b((data:)))/i
  };

  // 向量点乘积
  function dotProduct(x1, y1, x2, y2) {
    return x1 * x2 + y1 * y2;
  }

  function dotProduct3$1(x1, y1, z1, x2, y2, z2) {
    if (z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
      x2 = y1.x;
      z2 = y1.z;
      y2 = y1.y;
      y1 = x1.y;
      z1 = x1.z;
      x1 = x1.x;
    }

    return x1 * x2 + y1 * y2 + z1 * z2;
  } // 向量叉乘积


  function crossProduct$1(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }

  function crossProduct3$1(x1, y1, z1, x2, y2, z2) {
    if (z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
      x2 = y1.x;
      z2 = y1.z;
      y2 = y1.y;
      y1 = x1.y;
      z1 = x1.z;
      x1 = x1.x;
    }

    return {
      x: y1 * z2 - y2 * z1,
      y: z1 * x2 - z2 * x1,
      z: x1 * y2 - x2 * y1
    };
  } // 归一化


  function unitize(x, y) {
    var n = length(x, y);
    return {
      x: x / n,
      y: y / n
    };
  }

  function unitize3$1(x, y, z) {
    if (y === undefined && z === undefined) {
      y = x.y;
      z = x.z;
      x = x.x;
    }

    var n = length3$1(x, y, z);
    return {
      x: x / n,
      y: y / n,
      z: z / n
    };
  } // 是否平行


  function isParallel$1(x1, y1, x2, y2) {
    if (isZero(x1, y1, x2, y2)) {
      return true;
    }

    var ag = angle(x1, y1, x2, y2);

    if (Math.abs(ag) < 1e-9) {
      return true;
    }

    if (Math.PI - Math.abs(ag) < 1e-9) {
      return true;
    }

    return false;
  }

  function isParallel3$1(x1, y1, z1, x2, y2, z2) {
    if (z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
      x2 = y1.x;
      z2 = y1.z;
      y2 = y1.y;
      y1 = x1.y;
      z1 = x1.z;
      x1 = x1.x;
    }

    if (isZero3$1(x1, y1, z1, x2, y2, z2)) {
      return true;
    }

    var ag = angle3(x1, y1, z1, x2, y2, z2);

    if (Math.abs(ag) < 1e-9) {
      return true;
    }

    if (Math.PI - Math.abs(ag) < 1e-9) {
      return true;
    }

    return false;
  } // 是否是零，考虑误差


  function isZero(x1, y1, x2, y2) {
    return Math.abs(x1) < 1e-9 && Math.abs(y1) < 1e-9 && Math.abs(x2) < 1e-9 && Math.abs(y2) < 1e-9;
  }

  function isZero3$1(x1, y1, z1, x2, y2, z2) {
    if (z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
      x2 = y1.x;
      z2 = y1.z;
      y2 = y1.y;
      y1 = x1.y;
      z1 = x1.z;
      x1 = x1.x;
    }

    return Math.abs(x1) < 1e-9 && Math.abs(y1) < 1e-9 && Math.abs(z1) < 1e-9 && Math.abs(x2) < 1e-9 && Math.abs(y2) < 1e-9 && Math.abs(z2) < 1e-9;
  } // 向量夹角


  function angle(x1, y1, x2, y2) {
    var cos = dotProduct(x1, y1, x2, y2) / (length(x1, y1) * length(x2, y2));

    if (cos < -1) {
      cos = -1;
    } else if (cos > 1) {
      cos = 1;
    }

    return Math.acos(cos);
  }

  function angle3(x1, y1, z1, x2, y2, z2) {
    if (z1 === undefined && x2 === undefined && y2 === undefined && z2 === undefined) {
      x2 = y1.x;
      z2 = y1.z;
      y2 = y1.y;
      y1 = x1.y;
      z1 = x1.z;
      x1 = x1.x;
    }

    var cos = dotProduct3$1(x1, y1, z1, x2, y2, z2) / (length3$1(x1, y1, z1) * length3$1(x2, y2, z2));

    if (cos < -1) {
      cos = -1;
    } else if (cos > 1) {
      cos = 1;
    }

    return Math.acos(cos);
  } // 向量长度


  function length(x, y) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }

  function length3$1(x, y, z) {
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
  } // 获取任意一个垂直于目标的向量


  function getPerpendicularVector3(x, y, z) {
    var i, j, k, a, b;

    if (Math.abs(y) > Math.abs(x)) {
      if (Math.abs(z) > Math.abs(y)) {
        i = 2;
        j = 1;
        k = 0;
        a = z;
        b = -y;
      } else if (Math.abs(z) > Math.abs(x)) {
        i = 1;
        j = 2;
        k = 0;
        a = y;
        b = -z;
      } else {
        i = 1;
        j = 0;
        k = 2;
        a = y;
        b = -x;
      }
    } else if (Math.abs(z) > Math.abs(x)) {
      i = 2;
      j = 0;
      k = 1;
      a = z;
      b = -x;
    } else if (Math.abs(z) > Math.abs(y)) {
      i = 0;
      j = 2;
      k = 1;
      a = x;
      b = -z;
    } else {
      i = 0;
      j = 1;
      k = 2;
      a = x;
      b = -y;
    }

    var arr = [0, 0, 0];
    arr[i] = b;
    arr[j] = a;
    arr[k] = 0;
    return unitize3$1(arr[0], arr[1], arr[2]);
  }

  var vector = {
    dotProduct: dotProduct,
    dotProduct3: dotProduct3$1,
    crossProduct: crossProduct$1,
    crossProduct3: crossProduct3$1,
    unitize: unitize,
    unitize3: unitize3$1,
    isParallel: isParallel$1,
    isParallel3: isParallel3$1,
    isZero: isZero,
    isZero3: isZero3$1,
    angle: angle,
    angle3: angle3,
    length: length,
    length3: length3$1,
    getPerpendicularVector3: getPerpendicularVector3
  };

  var _WASM_STYLE_KEY;

  var STYLE_KEY$4 = {
    POSITION: 0,
    DISPLAY: 1,
    TOP: 2,
    RIGHT: 3,
    BOTTOM: 4,
    LEFT: 5,
    MARGIN_TOP: 6,
    MARGIN_RIGHT: 7,
    MARGIN_BOTTOM: 8,
    MARGIN_LEFT: 9,
    PADDING_TOP: 10,
    PADDING_RIGHT: 11,
    PADDING_BOTTOM: 12,
    PADDING_LEFT: 13,
    FONT_SIZE: 14,
    FONT_FAMILY: 15,
    COLOR: 16,
    FONT_STYLE: 17,
    FONT_WEIGHT: 18,
    LINE_HEIGHT: 19,
    BACKGROUND_IMAGE: 20,
    BACKGROUND_COLOR: 21,
    BACKGROUND_SIZE: 22,
    BACKGROUND_REPEAT: 23,
    BACKGROUND_POSITION_X: 24,
    BACKGROUND_POSITION_Y: 25,
    BORDER_TOP_WIDTH: 26,
    BORDER_RIGHT_WIDTH: 27,
    BORDER_BOTTOM_WIDTH: 28,
    BORDER_LEFT_WIDTH: 29,
    BORDER_TOP_COLOR: 30,
    BORDER_RIGHT_COLOR: 31,
    BORDER_BOTTOM_COLOR: 32,
    BORDER_LEFT_COLOR: 33,
    BORDER_TOP_STYLE: 34,
    BORDER_RIGHT_STYLE: 35,
    BORDER_BOTTOM_STYLE: 36,
    BORDER_LEFT_STYLE: 37,
    BORDER_TOP_LEFT_RADIUS: 38,
    BORDER_TOP_RIGHT_RADIUS: 39,
    BORDER_BOTTOM_RIGHT_RADIUS: 40,
    BORDER_BOTTOM_LEFT_RADIUS: 41,
    WIDTH: 42,
    HEIGHT: 43,
    FLEX_GROW: 44,
    FLEX_SHRINK: 45,
    FLEX_BASIS: 46,
    FLEX_DIRECTION: 47,
    JUSTIFY_CONTENT: 48,
    ALIGN_ITEMS: 49,
    ALIGN_SELF: 50,
    TEXT_ALIGN: 51,
    TRANSFORM_ORIGIN: 52,
    VISIBILITY: 53,
    OPACITY: 54,
    Z_INDEX: 55,
    TRANSFORM: 56,
    TRANSLATE_X: 57,
    TRANSLATE_Y: 58,
    TRANSLATE_Z: 59,
    SCALE_X: 60,
    SCALE_Y: 61,
    SCALE_Z: 62,
    SKEW_X: 63,
    SKEW_Y: 64,
    ROTATE_X: 65,
    ROTATE_Y: 66,
    ROTATE_Z: 67,
    ROTATE_3D: 68,
    PERSPECTIVE: 69,
    PERSPECTIVE_ORIGIN: 70,
    FILTER: 71,
    BOX_SHADOW: 72,
    POINTER_EVENTS: 73,
    OVERFLOW: 74,
    MIX_BLEND_MODE: 75,
    BACKGROUND_CLIP: 76,
    WHITE_SPACE: 77,
    TEXT_OVERFLOW: 78,
    LETTER_SPACING: 79,
    LINE_CLAMP: 80,
    ORDER: 81,
    FLEX_WRAP: 82,
    ALIGN_CONTENT: 83,
    TEXT_STROKE_WIDTH: 84,
    TEXT_STROKE_COLOR: 85,
    TEXT_STROKE_OVER: 86,
    WRITING_MODE: 87,
    TRANSFORM_STYLE: 88,
    BACKFACE_VISIBILITY: 89,
    BOX_SIZING: 90,
    FONT_SIZE_SHRINK: 91,
    // GEOM
    FILL: 92,
    STROKE: 93,
    STROKE_WIDTH: 94,
    STROKE_DASHARRAY: 95,
    STROKE_DASHARRAY_STR: 96,
    STROKE_LINECAP: 97,
    STROKE_LINEJOIN: 98,
    STROKE_MITERLIMIT: 99,
    FILL_RULE: 100,
    // 无此样式，仅cache或特殊情况需要
    MATRIX: 101,
    BORDER_TOP: 102,
    BORDER_RIGHT: 103,
    BORDER_BOTTOM: 104,
    BORDER_LEFT: 105,
    TRANSLATE_PATH: 106
  };
  var STYLE2LOWER_MAP = {};

  function style2Lower(s) {
    var res = STYLE2LOWER_MAP[s];

    if (!res) {
      res = STYLE2LOWER_MAP[s] = s.toLowerCase().replace(/_([a-z])/g, function ($0, $1) {
        return $1.toUpperCase();
      });
    }

    return res;
  }

  var STYLE2UPPER_MAP = {};

  function style2Upper$2(s) {
    var res = STYLE2UPPER_MAP[s];

    if (!res) {
      res = STYLE2UPPER_MAP[s] = s.replace(/([a-z\d_])([A-Z])/g, function ($0, $1, $2) {
        return $1 + '_' + $2;
      }).toUpperCase();
    }

    return res;
  }

  var STYLE_R_KEY = {};
  var STYLE_RV_KEY$1 = {};
  var STYLE_V_KEY = {};
  Object.keys(STYLE_KEY$4).forEach(function (k) {
    var k2 = STYLE_KEY$4[k];
    STYLE_R_KEY[k2] = k;
    var l = style2Lower(k);
    STYLE_RV_KEY$1[k2] = l;
    STYLE_V_KEY[l] = k2;
  });
  var WASM_STYLE_KEY$2 = (_WASM_STYLE_KEY = {}, _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.TRANSLATE_X, 0), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.TRANSLATE_Y, 1), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.TRANSLATE_Z, 2), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.ROTATE_X, 3), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.ROTATE_Y, 4), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.ROTATE_Z, 5), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.ROTATE_3D, 6), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.SCALE_X, 10), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.SCALE_Y, 11), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.SCALE_Z, 12), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.SKEW_X, 13), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.SKEW_Y, 14), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.OPACITY, 15), _defineProperty(_WASM_STYLE_KEY, STYLE_KEY$4.TRANSFORM_ORIGIN, 16), _WASM_STYLE_KEY);
  var DIRECTION$1 = {
    reverse: 1,
    alternate: 2,
    'alternate-reverse': 3,
    alternateReverse: 3
  };
  var FILLS$1 = {
    forwards: 1,
    backwards: 2,
    both: 3
  };
  var EASING$1 = {
    DEFAULT: 0,
    LINEAR: 1,
    EASE_IN: 2,
    EASE_OUT: 3,
    EASE: 4,
    EASE_IN_OUT: 5,
    EASE_CUSTOM: 6
  };
  var PLAY_STATE$1 = {
    IDLE: 0,
    RUNNING: 1,
    PAUSED: 2,
    FINISHED: 3
  };
  var enums = {
    STYLE_KEY: STYLE_KEY$4,
    // 大写常量为k，数字为值
    STYLE_R_KEY: STYLE_R_KEY,
    // 数字为k，大写常量为值
    STYLE_RV_KEY: STYLE_RV_KEY$1,
    // 数字为k，小写为值
    STYLE_V_KEY: STYLE_V_KEY,
    // 小写为k，数字为值
    style2Lower: style2Lower,
    style2Upper: style2Upper$2,
    ELLIPSIS: '…',
    WASM_STYLE_KEY: WASM_STYLE_KEY$2,
    DIRECTION: DIRECTION$1,
    FILLS: FILLS$1,
    EASING: EASING$1,
    PLAY_STATE: PLAY_STATE$1
  };

  var H$1 = 4 * (Math.sqrt(2) - 1) / 3;
  var crossProduct = vector.crossProduct;
  var calPoint$1 = matrix.calPoint,
      isE$4 = matrix.isE;
  var _enums$STYLE_KEY$l = enums.STYLE_KEY,
      WIDTH$a = _enums$STYLE_KEY$l.WIDTH,
      HEIGHT$a = _enums$STYLE_KEY$l.HEIGHT,
      TRANSFORM_ORIGIN$7 = _enums$STYLE_KEY$l.TRANSFORM_ORIGIN;
  /**
   * 圆弧拟合公式，根据角度求得3阶贝塞尔控制点比例长度，一般<=90，超过拆分
   * @param deg
   * @returns {number}
   */

  function h(deg) {
    deg *= 0.5;
    return 4 * ((1 - Math.cos(deg)) / Math.sin(deg)) / 3;
  }
  /**
   * 判断点是否在多边形内
   * @param x 点坐标
   * @param y
   * @param vertexes 多边形顶点坐标
   * @returns {boolean}
   */


  function pointInConvexPolygon(x, y, vertexes) {
    // 先取最大最小值得一个外围矩形，在外边可快速判断false
    var _vertexes$ = vertexes[0],
        xmax = _vertexes$.x,
        ymax = _vertexes$.y;
    var _vertexes$2 = vertexes[0],
        xmin = _vertexes$2.x,
        ymin = _vertexes$2.y;
    var len = vertexes.length;

    for (var i = 1; i < len; i++) {
      var _vertexes$i = vertexes[i],
          _x = _vertexes$i.x,
          _y = _vertexes$i.y;
      xmax = Math.max(xmax, _x);
      ymax = Math.max(ymax, _y);
      xmin = Math.min(xmin, _x);
      ymin = Math.min(ymin, _y);
    }

    if (x < xmin || y < ymin || x > xmax || y > ymax) {
      return false;
    }

    var first; // 所有向量积均为非负数（逆时针，反过来顺时针是非正）说明在多边形内或边上

    for (var _i = 0, _len = vertexes.length; _i < _len; _i++) {
      var _vertexes$_i = vertexes[_i],
          x1 = _vertexes$_i.x,
          y1 = _vertexes$_i.y;
      var _vertexes = vertexes[(_i + 1) % _len],
          x2 = _vertexes.x,
          y2 = _vertexes.y;
      var n = crossProduct(x2 - x1, y2 - y1, x - x1, y - y1);

      if (n !== 0) {
        n = n > 0 ? 1 : 0; // 第一个赋值，后面检查是否正负一致性，不一致是反例就跳出

        if (first === undefined) {
          first = n;
        } else if (first ^ n) {
          return false;
        }
      }
    }

    return true;
  } // 判断点是否在一个4边形内，比如事件发生是否在节点上


  function pointInQuadrilateral(x, y, x1, y1, x2, y2, x4, y4, x3, y3, matrix) {
    if (matrix && !isE$4(matrix)) {
      var w1, w2, w3, w4;
      var t = calPoint$1({
        x: x1,
        y: y1
      }, matrix);
      x1 = t.x;
      y1 = t.y;
      w1 = t.w;
      t = calPoint$1({
        x: x2,
        y: y2
      }, matrix);
      x2 = t.x;
      y2 = t.y;
      w2 = t.w;
      t = calPoint$1({
        x: x3,
        y: y3
      }, matrix);
      x3 = t.x;
      y3 = t.y;
      w3 = t.w;
      t = calPoint$1({
        x: x4,
        y: y4
      }, matrix);
      x4 = t.x;
      y4 = t.y;
      w4 = t.w;

      if (w1 && w1 !== 1) {
        x1 /= w1;
        y1 /= w1;
      }

      if (w2 && w2 !== 1) {
        x2 /= w2;
        y2 /= w2;
      }

      if (w3 && w3 !== 1) {
        x3 /= w3;
        y3 /= w3;
      }

      if (w4 && w4 !== 1) {
        x4 /= w4;
        y4 /= w4;
      }

      return pointInConvexPolygon(x, y, [{
        x: x1,
        y: y1
      }, {
        x: x2,
        y: y2
      }, {
        x: x4,
        y: y4
      }, {
        x: x3,
        y: y3
      }]);
    } else {
      return x >= x1 && y >= y1 && x <= x4 && y <= y4;
    }
  }
  /**
   * 余弦定理3边长求夹角
   * @param a
   * @param b
   * @param c
   */


  function angleBySide(a, b, c) {
    var theta = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
    return Math.acos(theta);
  }
  /**
   * 余弦定理2边长和夹角求3边
   * @param alpha 弧度
   * @param a
   * @param b
   */


  function sideByAngle(alpha, a, b) {
    var cos = Math.cos(alpha);
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * cos);
  }
  /**
   * 两点距离
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   */


  function pointsDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  /**
   * 三角形内心
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @param x3
   * @param y3
   */


  function triangleIncentre(x1, y1, x2, y2, x3, y3) {
    var a = pointsDistance(x2, y2, x3, y3);
    var b = pointsDistance(x1, y1, x3, y3);
    var c = pointsDistance(x1, y1, x2, y2);
    return {
      x: (a * x1 + b * x2 + c * x3) / (a + b + c),
      y: (a * y1 + b * y2 + c * y3) / (a + b + c)
    };
  }
  /**
   * 椭圆圆心和长短轴生成4个端点和控制点
   */


  function ellipsePoints(x, y, a) {
    var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a;
    var ox = a * H$1;
    var oy = b === a ? ox : b * H$1;
    return [[x - a, y], [x - a, y - oy, x - ox, y - b, x, y - b], [x + ox, y - b, x + a, y - oy, x + a, y], [x + a, y + oy, x + ox, y + b, x, y + b], [x - ox, y + b, x - a, y + oy, x - a, y]];
  }
  /**
   * 扇形圆心和半径起始角度生成4个端点和控制点
   * 分为4个象限进行拟合，0、1、2、3
   */


  function sectorPoints$1(x, y, r, begin, end) {
    if (begin > end) {
      var _ref = [end, begin];
      begin = _ref[0];
      end = _ref[1];
    }

    if (begin === end) {
      return [];
    }

    var list = [];
    var b = Math.floor(begin / 90);
    var e = Math.floor(end / 90); // 同象限直接算

    if (b === e || e - b === 1 && end % 90 === 0) {
      var h2 = h(d2r$3(Math.abs(begin - end)));
      var d = h2 * r;
      var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
      var alpha = Math.atan(d / r);

      if (b < 90) {
        // 第1个交点
        var rx = Math.sin(d2r$3(begin)) * r;
        var ry = Math.cos(d2r$3(begin)) * r;
        var p1 = [x + rx, y - ry]; // 第1个控制点

        var deg = alpha + d2r$3(begin);
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p2 = [x + rx, y - ry]; // 第2个交点

        rx = Math.sin(d2r$3(end)) * r;
        ry = Math.cos(d2r$3(end)) * r;
        var p4 = [x + rx, y - ry]; // 第2个控制点

        deg = d2r$3(end) - alpha;
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p3 = [x + rx, y - ry];
        list.push(p1);
        list.push(p2.concat(p3).concat(p4));
      } else if (b < 180) {
        // 第1个交点
        var _rx = Math.cos(d2r$3(begin - 90)) * r;

        var _ry = Math.sin(d2r$3(begin - 90)) * r;

        var _p = [x + _rx, y + _ry]; // 第1个控制点

        var _deg = alpha + d2r$3(begin - 90);

        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p2 = [x + _rx, y + _ry]; // 第2个交点

        _rx = Math.cos(d2r$3(end - 90)) * r;
        _ry = Math.sin(d2r$3(end - 90)) * r;
        var _p3 = [x + _rx, y + _ry]; // 第2个控制点

        _deg = d2r$3(end - 90) - alpha;
        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p4 = [x + _rx, y + _ry];
        list.push(_p);
        list.push(_p2.concat(_p4).concat(_p3));
      } else if (b < 270) {
        // 第1个交点
        var _rx2 = Math.sin(d2r$3(begin - 180)) * r;

        var _ry2 = Math.cos(d2r$3(begin - 180)) * r;

        var _p5 = [x - _rx2, y + _ry2]; // 第1个控制点

        var _deg2 = alpha + d2r$3(begin - 180);

        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p6 = [x - _rx2, y + _ry2]; // 第2个交点

        _rx2 = Math.sin(d2r$3(end - 180)) * r;
        _ry2 = Math.cos(d2r$3(end - 180)) * r;
        var _p7 = [x - _rx2, y + _ry2]; // 第2个控制点

        _deg2 = d2r$3(end - 180) - alpha;
        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p8 = [x - _rx2, y + _ry2];
        list.push(_p5);
        list.push(_p6.concat(_p8).concat(_p7));
      } else {
        // 第1个交点
        var _rx3 = Math.cos(d2r$3(begin - 270)) * r;

        var _ry3 = Math.sin(d2r$3(begin - 270)) * r;

        var _p9 = [x - _rx3, y + _ry3]; // 第1个控制点

        var _deg3 = alpha + d2r$3(begin - 270);

        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p10 = [x - _rx3, y + _ry3]; // 第2个交点

        _rx3 = Math.cos(d2r$3(end - 270)) * r;
        _ry3 = Math.sin(d2r$3(end - 270)) * r;
        var _p11 = [x - _rx3, y + _ry3]; // 第2个控制点

        _deg3 = d2r$3(end - 270) - alpha;
        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p12 = [x - _rx3, y + _ry3];
        list.push(_p9);
        list.push(_p10.concat(_p12).concat(_p11));
      }
    } // 跨象限循环算
    else {
      var i = b;
      var temp = [];

      for (; i <= e; i++) {
        if (i === 0) {
          var res = sectorPoints$1(x, y, r, begin, 90);
          temp.push(res);
        } else if (i === 1) {
          // 防止90~90这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 90) {
            var _res = sectorPoints$1(x, y, r, begin < 90 ? 90 : begin, end > 180 ? 180 : end);

            temp.push(_res);
          }
        } else if (i === 2) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 180) {
            var _res2 = sectorPoints$1(x, y, r, begin < 180 ? 180 : begin, end > 270 ? 270 : end);

            temp.push(_res2);
          }
        } else if (i === 3) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 270) {
            var _res3 = sectorPoints$1(x, y, r, begin < 270 ? 270 : begin, end);

            temp.push(_res3);
          }
        }
      } // 去掉重复的首尾扇弧点


      list = temp[0];

      for (var _i2 = 1, len = temp.length; _i2 < len; _i2++) {
        list.push(temp[_i2][1]);
      }
    }

    return list;
  }
  /**
   * 获取2个矩形重叠区域，如不重叠返回null
   * @param a
   * @param b
   */


  function getRectsIntersection(a, b) {
    if (!isRectsOverlap$2(a, b)) {
      return null;
    }

    var _a = _slicedToArray(a, 4),
        ax1 = _a[0],
        ay1 = _a[1],
        ax4 = _a[2],
        ay4 = _a[3];

    var _b = _slicedToArray(b, 4),
        bx1 = _b[0],
        by1 = _b[1],
        bx4 = _b[2],
        by4 = _b[3];

    return [Math.max(ax1, bx1), Math.max(ay1, by1), Math.min(ax4, bx4), Math.min(ay4, by4)];
  }
  /**
   * 2个矩形是否重叠
   */


  function isRectsOverlap$2(a, b, includeIntersect) {
    var _a2 = _slicedToArray(a, 4),
        ax1 = _a2[0],
        ay1 = _a2[1],
        ax4 = _a2[2],
        ay4 = _a2[3];

    var _b2 = _slicedToArray(b, 4),
        bx1 = _b2[0],
        by1 = _b2[1],
        bx4 = _b2[2],
        by4 = _b2[3];

    if (includeIntersect) {
      if (ax1 > bx4 || ay1 > by4 || bx1 > ax4 || by1 > ay4) {
        return false;
      }
    } else if (ax1 >= bx4 || ay1 >= by4 || bx1 >= ax4 || by1 >= ay4) {
      return false;
    }

    return true;
  }
  /**
   * 2个矩形是否包含，a包含b
   */


  function isRectsInside(a, b, includeIntersect) {
    var _a3 = _slicedToArray(a, 4),
        ax1 = _a3[0],
        ay1 = _a3[1],
        ax4 = _a3[2],
        ay4 = _a3[3];

    var _b3 = _slicedToArray(b, 4),
        bx1 = _b3[0],
        by1 = _b3[1],
        bx4 = _b3[2],
        by4 = _b3[3];

    if (includeIntersect) {
      if (ax1 <= bx1 && ay1 <= by1 && ax4 >= bx4 && ay4 >= by4) {
        return true;
      }
    } else if (ax1 < bx1 && ay1 < by1 && ax4 > bx4 && ay4 > by4) {
      return true;
    }

    return false;
  }

  function calCoordsInNode(px, py, node) {
    var _node$matrix = node.matrix,
        matrix = _node$matrix === void 0 ? [1, 0, 0, 1, 0, 0] : _node$matrix,
        _node$computedStyle = node.computedStyle,
        computedStyle = _node$computedStyle === void 0 ? [] : _node$computedStyle;
    var width = computedStyle[WIDTH$a],
        height = computedStyle[HEIGHT$a],
        _computedStyle$TRANSF = computedStyle[TRANSFORM_ORIGIN$7];
    _computedStyle$TRANSF = _computedStyle$TRANSF === void 0 ? [width * 0.5, height * 0.5] : _computedStyle$TRANSF;

    var _computedStyle$TRANSF2 = _slicedToArray(_computedStyle$TRANSF, 2),
        ox = _computedStyle$TRANSF2[0],
        oy = _computedStyle$TRANSF2[1];

    var t = calPoint$1({
      x: px * width - ox,
      y: py * height - oy
    }, matrix);
    return {
      x: t.x + ox,
      y: t.y + oy
    };
  }

  function calPercentInNode(x, y, node) {
    var _node$computedStyle2 = node.computedStyle,
        width = _node$computedStyle2[WIDTH$a],
        height = _node$computedStyle2[HEIGHT$a],
        _node$computedStyle2$ = _slicedToArray(_node$computedStyle2[TRANSFORM_ORIGIN$7], 2),
        ox = _node$computedStyle2$[0],
        oy = _node$computedStyle2$[1]; // 先求无旋转时右下角相对于原点的角度ds


    var ds = Math.atan((height - oy) / (width - ox));

    var _calCoordsInNode = calCoordsInNode(1, 1, node),
        x1 = _calCoordsInNode.x,
        y1 = _calCoordsInNode.y;

    var d1;
    var deg; // 根据旋转后的坐标，分4个象限，求旋转后的右下角相对于原点的角度d1，得出偏移角度deg，分顺逆时针[-180, 180]

    if (x1 >= ox && y1 >= oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((y1 - oy) / (x1 - ox));
      }

      deg = d1 - ds;
    } else if (x1 >= ox && y1 < oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((oy - y1) / (x1 - ox));
      }

      deg = d1 + ds;
    } else if (x1 < ox && y1 >= oy) {
      d1 = Math.atan((y1 - oy) / (ox - x1));
      deg = d1 - ds;
    } else if (x1 < ox && y1 < oy) {
      d1 = Math.atan((y1 - oy) / (x1 - ox));

      if (ds >= d1) {
        deg = d1 + Math.PI - ds;
      } else {
        deg = Math.PI - d1 + ds;
        deg = -deg;
      }
    } else {
      deg = 0;
    } // 目标点到原点的边长不会变


    var dt = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2)); // 分4个象限，先求目标点到原点的角度d2，再偏移deg后求得原始坐标

    var d2;

    if (x >= ox && y >= oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = Math.atan((y - oy) / (x - ox));
      }
    } else if (x >= ox && y < oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = -Math.atan((y - oy) / (ox - x));
      }
    } else if (x < ox && y >= oy) {
      d2 = Math.PI - Math.atan((y - oy) / (ox - x));
    } else {
      d2 = Math.atan((y - oy) / (x - ox)) - Math.PI;
    }

    d2 -= deg;

    if (d2 > Math.PI) {
      d2 -= Math.PI;
      return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    if (d2 > Math.PI * 0.5) {
      d2 = Math.PI - d2;
      return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
    }

    if (d2 >= 0) {
      return {
        x: (ox + dt * Math.cos(d2)) / width,
        y: (oy + dt * Math.sin(d2)) / height
      };
    }

    if (d2 >= -Math.PI * 0.5) {
      d2 = -d2;
      return {
        x: (ox + dt * Math.cos(d2)) / width,
        y: (oy - dt * Math.sin(d2)) / height
      };
    }

    if (d2 >= -Math.PI) {
      d2 = Math.PI + d2;
      return {
        x: (ox - dt * Math.cos(d2)) / width,
        y: (oy - dt * Math.sin(d2)) / height
      };
    }

    d2 = -Math.PI - d2;
    return {
      x: (ox - dt * Math.cos(d2)) / width,
      y: (oy + dt * Math.sin(d2)) / height
    };
  }

  function d2r$3(n) {
    return n * Math.PI / 180;
  }

  function r2d(n) {
    return n * 180 / Math.PI;
  }

  function pointOnCircle(x, y, r, deg) {
    if (deg >= 270) {
      deg -= 270;
      deg = d2r$3(deg);
      return {
        x: x - Math.cos(deg) * r,
        y: y - Math.sin(deg) * r
      };
    } else if (deg >= 180) {
      deg -= 180;
      deg = d2r$3(deg);
      return {
        x: x - Math.sin(deg) * r,
        y: y + Math.cos(deg) * r
      };
    } else if (deg >= 90) {
      deg -= 90;
      deg = d2r$3(deg);
      return {
        x: x + Math.cos(deg) * r,
        y: y + Math.sin(deg) * r
      };
    } else {
      deg = d2r$3(deg);
      return {
        x: x + Math.sin(deg) * r,
        y: y - Math.cos(deg) * r
      };
    }
  } // 3个点确定平面标准方程


  function getPlainNormalEquation$1(points) {
    var _points$ = points[0],
        x1 = _points$.x,
        y1 = _points$.y,
        z1 = _points$.z;
    var _points$2 = points[1],
        x2 = _points$2.x,
        y2 = _points$2.y,
        z2 = _points$2.z;
    var _points$3 = points[2],
        x3 = _points$3.x,
        y3 = _points$3.y,
        z3 = _points$3.z;
    var a = (y2 - y1) * (z3 - z1) - (z2 - z1) * (y3 - y1);
    var b = (x3 - x1) * (z2 - z1) - (x2 - x1) * (z3 - z1);
    var c = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
    var d = -(a * x1 + b * y1 + c * z1);
    return {
      a: a,
      b: b,
      c: c,
      d: d
    };
  }

  var geom = {
    pointInConvexPolygon: pointInConvexPolygon,
    pointInQuadrilateral: pointInQuadrilateral,
    d2r: d2r$3,
    r2d: r2d,
    // 贝塞尔曲线模拟1/4圆弧比例
    H: H$1,
    // <90任意角度贝塞尔曲线拟合圆弧的比例公式
    h: h,
    angleBySide: angleBySide,
    sideByAngle: sideByAngle,
    pointsDistance: pointsDistance,
    triangleIncentre: triangleIncentre,
    ellipsePoints: ellipsePoints,
    sectorPoints: sectorPoints$1,
    getRectsIntersection: getRectsIntersection,
    isRectsOverlap: isRectsOverlap$2,
    isRectsInside: isRectsInside,
    calCoordsInNode: calCoordsInNode,
    calPercentInNode: calPercentInNode,
    pointOnCircle: pointOnCircle,
    getPlainNormalEquation: getPlainNormalEquation$1
  };

  /**
   * @typedef {Object} gradientStatement
   * @property {Array<number>} color - 颜色rgba，0～255，如 [0, 255, 0, 255]
   * @property {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
   */

  /**
   * 获取渐变图像像素数组
   * @param {number} originX - 渐变中心x坐标（相对图片左上角(0,0)的值，可在图片外，下同）
   * @param {number} originY - 渐变中心y坐标
   * @param {number} width - 图片宽度
   * @param {number} height - 图片高度
   * @param {Array<stop>} stop - 渐变声明列表
   * @param data - canvas的imgData.data
   * @returns {Array<number>} 图像像素数组，每4个元素（rgba）构成一个像素点
   * @example
       // 矩形宽度为200*200，此时坐标为0～199，渐变中心为中点时，应传入99.5，可消除零点问题
       // 若渐变中心在某一整数轴上，就会引入零点问题，此时零点取y轴正半轴的色值，要消除这个问题，可以对渐变中心增加一个偏移量，使其不为整数
       let w = 200;
       let h = 200;
       let ctx = document.getElementById('example').getContext('2d');
       let imgData = ctx.getImageData(0,0, w, h);
       let data = getConicGradientImage(99.5, 99.5, w, h, [{
         color: [0,0,0,255],
         angle: 0,
       } ,{
         color: [255,0,0,255],
         angle: 2 * Math.PI,
       }]);
       for (let i = 0; i < imgData.data.length; i++) {
         imgData.data[i] = data[i];
       }
       ctx.putImageData(imgData, 0, 0);
   */
  function getConicGradientImage(originX, originY, width, height, stop, data) {
    if (stop.length < 2) {
      throw new Error('Conic gradient should recieve at least 2 gradient statements (start line and end line).');
    }

    width = Math.floor(width);
    height = Math.floor(height);
    /**
     * 根据坐标获取角度
     * @param {number} x - x坐标，左上角为原点
     * @param {number} y - y坐标，左上角为原点
     * @returns {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
     */

    var getAngle = function getAngle(x, y) {
      // 此函数注释内的x、y轴基于 (originX, originY)
      // 计算相对 (originX, originY) 的坐标(dx, dy)
      var dx = x - originX;
      var dy = originY - y; // 在y轴上

      if (dx === 0) {
        return dy < 0 ? // y轴负半轴，
        Math.PI : // y轴正半轴，因此，(originX, originY) 的angle视作0
        0;
      } // 在x轴上


      if (dy === 0) {
        return dx < 0 ? // x轴负半轴
        1.5 * Math.PI : // x轴正半轴
        0.5 * Math.PI;
      }

      var atan = Math.atan(dy / dx);
      /**
       *  2   |  1
       * -----|-----
       *  3   |  4
       */
      // 第一象限，atan > 0
      // 第四象限，atan < 0

      if (dx > 0) {
        return 0.5 * Math.PI - atan;
      } // 第二象限，atan < 0
      // 第三象限，atan > 0


      if (dx < 0) {
        return 1.5 * Math.PI - atan;
      }
    };

    var increasingList = stop.map(function (item) {
      return {
        color: item[0],
        angle: item[1] * Math.PI * 2
      };
    });

    for (var y = 0; y < height; y++) {
      var _loop = function _loop(x) {
        // step 1. 找到当前点坐标相对 (originX, originY) 的角度
        var angle = getAngle(x, y); // step 2. 找到当前点坐标对应的渐变区间

        var j = void 0;

        for (j = 0; j < increasingList.length && increasingList[j].angle <= angle; j++) {}

        var start = increasingList[j - 1];
        var end = increasingList[j];

        if (!(start && end)) {
          // step 2-1. 不在渐变区间里
          return "continue";
        } // step 3. 计算色值并填充


        var factor = (angle - start.angle) / (end.angle - start.angle);
        var color = end.color.map(function (v, idx) {
          return factor * (v - start.color[idx]) + start.color[idx];
        });
        var i = (x + y * width) * 4;
        data[i] = color[0];
        data[i + 1] = color[1];
        data[i + 2] = color[2];
        data[i + 3] = Math.min(255, color[3] * 255);
      };

      for (var x = 0; x < width; x++) {
        var _ret = _loop(x);

        if (_ret === "continue") continue;
      }
    }

    return data;
  }

  var gradient$1 = {
    getConicGradientImage: getConicGradientImage
  };

  var int2rgba$3 = util.int2rgba;

  function canvasPolygon$7(ctx, list) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var close = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (!list || !list.length) {
      return;
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return;
    }

    var first = list[start],
        xa,
        ya; // 特殊的情况，布尔运算数学库会打乱原有顺序，致使第一个点可能有冗余的贝塞尔值，move到正确的索引坐标

    if (first.length === 2) {
      xa = first[0] + dx;
      ya = first[1] + dy;
      ctx.moveTo(xa, ya);
    } else if (first.length === 4) {
      xa = first[2] + dx;
      ya = first[3] + dy;
      ctx.moveTo(xa, ya);
    } else if (first.length === 6) {
      xa = first[4] + dx;
      ya = first[5] + dy;
      ctx.moveTo(xa, ya);
    }

    var xb, yb;

    for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
      var _item = list[_i];

      if (!Array.isArray(_item)) {
        continue;
      }

      if (_item.length === 2) {
        xb = _item[0] + dx;
        yb = _item[1] + dy;
        ctx.lineTo(xb, yb);
      } else if (_item.length === 4) {
        xb = _item[2] + dx;
        yb = _item[3] + dy;
        ctx.quadraticCurveTo(_item[0] + dx, _item[1] + dy, xb, yb);
      } else if (_item.length === 6) {
        xb = _item[4] + dx;
        yb = _item[5] + dy;
        ctx.bezierCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy, xb, yb);
      }
    }

    if (close && xa === xb && ya === yb) {
      ctx.closePath();
    }
  }

  function svgPolygon$6(list) {
    if (!list || !list.length) {
      return '';
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return '';
    }

    var first = list[start];
    var s = 'M' + first[0] + ',' + first[1];

    if (first.length === 4) {
      s = 'M' + first[2] + ',' + first[3];
    } else if (first.length === 6) {
      s = 'M' + first[4] + ',' + first[5];
    }

    for (var _i2 = start + 1, _len2 = list.length; _i2 < _len2; _i2++) {
      var _item2 = list[_i2];

      if (!Array.isArray(_item2)) {
        continue;
      }

      if (_item2.length === 2) {
        s += 'L' + _item2[0] + ',' + _item2[1];
      } else if (_item2.length === 4) {
        s += 'Q' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3];
      } else if (_item2.length === 6) {
        s += 'C' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3] + ' ' + _item2[4] + ',' + _item2[5];
      }
    }

    return s;
  }

  function canvasLine(ctx, x1, y1, x2, y2, controlA, controlB, num) {
    var dx = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var dy = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    ctx.moveTo(x1 + dx, y1 + dy);

    if (num === 3) {
      ctx.bezierCurveTo(controlA[0] + dx, controlA[1] + dy, controlB[0] + dx, controlB[1], x2 + dx, y2 + dy);
      return 2;
    } else if (num === 2) {
      ctx.quadraticCurveTo(controlB[0] + dx, controlB[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else if (num === 1) {
      ctx.quadraticCurveTo(controlA[0] + dx, controlA[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else {
      ctx.lineTo(x2 + dx, y2 + dy);
      return 1;
    }
  }

  function svgLine(x1, y1, x2, y2, controlA, controlB, num) {
    if (num === 3) {
      return 'M' + x1 + ',' + y1 + 'C' + controlA[0] + ',' + controlA[1] + ' ' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 2) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 1) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlA[0] + ',' + controlA[1] + ' ' + x2 + ',' + y2;
    } else {
      return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;
    }
  }

  function canvasFilter(filter) {
    var s = '';
    filter.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (k === 'blur') {
        s += "blur(".concat(v, "px)");
      } else if (k === 'dropShadow') {
        // 浏览器暂未支持spread，去掉v[3]
        s += "drop-shadow(".concat(v[0], "px ").concat(v[1], "px ").concat(v[2], "px ").concat(int2rgba$3(v[4]), ")");
      } else if (k === 'hueRotate') {
        s += "hue-rotate(".concat(v, "deg)");
      } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
        s += "".concat(k, "(").concat(v, "%)");
      }
    });
    return s;
  }

  var painter = {
    canvasPolygon: canvasPolygon$7,
    svgPolygon: svgPolygon$6,
    canvasLine: canvasLine,
    svgLine: svgLine,
    canvasFilter: canvasFilter,
    svgFilter: canvasFilter
  };

  var H = geom.H;
  var PX$a = o$4.PX,
      PERCENT$9 = o$4.PERCENT,
      REM$9 = o$4.REM,
      VW$9 = o$4.VW,
      VH$9 = o$4.VH,
      VMAX$9 = o$4.VMAX,
      VMIN$9 = o$4.VMIN;
  var canvasPolygon$6 = painter.canvasPolygon,
      svgPolygon$5 = painter.svgPolygon;
  var _enums$STYLE_KEY$k = enums.STYLE_KEY,
      BORDER_LEFT_WIDTH$a = _enums$STYLE_KEY$k.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH$8 = _enums$STYLE_KEY$k.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$7 = _enums$STYLE_KEY$k.BORDER_BOTTOM_WIDTH,
      PADDING_LEFT$a = _enums$STYLE_KEY$k.PADDING_LEFT,
      PADDING_BOTTOM$7 = _enums$STYLE_KEY$k.PADDING_BOTTOM,
      PADDING_TOP$8 = _enums$STYLE_KEY$k.PADDING_TOP,
      BORDER_TOP_LEFT_RADIUS$5 = _enums$STYLE_KEY$k.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$5 = _enums$STYLE_KEY$k.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$5 = _enums$STYLE_KEY$k.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$5 = _enums$STYLE_KEY$k.BORDER_BOTTOM_RIGHT_RADIUS,
      FONT_SIZE$c = _enums$STYLE_KEY$k.FONT_SIZE;
  /* 获取合适的虚线实体空白宽度ps/pd和数量n
   * 总长total，start边长bs，end边长be，内容长w，
   * 实体长范围[smin,smax]，空白长范围[dmin,dmax]
   */

  function calFitDashed(total, bs, be, w, smin, smax, dmin, dmax) {
    var n = 1;
    var ps = 1;
    var pd = 1; // 从最大实体空白长开始尝试

    outer: for (var i = smax; i >= smin; i--) {
      for (var j = dmax; j >= dmin; j--) {
        // 已知实体空白长度，n实体和n-1空白组成total，计算获取n数量
        var per = i + j;
        var num = Math.floor((total + j) / per);
        var k = j; // 可能除不尽，此时扩展空白长

        if (num * per < j + total) {
          var free = total - num * i;
          k = free / (num - 1);

          if (k > dmax) {
            continue;
          }
        }

        per = i + k; // bs比实体大才有效，因为小的话必定和第一个实体完整相连

        if (bs > 1 && bs > i) {
          var mo = bs % per;

          if (mo > i) {
            continue;
          }

          if (be > 1) {
            var _mo = (bs + w) % per;

            if (_mo > i) {
              continue;
            }
          }
        }

        if (be > 1) {
          var _mo2 = (bs + w) % per;

          if (_mo2 > i) {
            continue;
          }
        }

        if (num > 0) {
          n = num;
          ps = i;
          pd = k;
        }

        break outer;
      }
    }

    return {
      n: n,
      ps: ps,
      pd: pd
    };
  } // dashed时n个实线和n-1虚线默认以3:1宽度组成，dotted则是n和n以1:1组成


  function calDashed(style, m1, m2, m3, m4, bw) {
    var total = m4 - m1;
    var w = m3 - m2;
    var bs = m2 - m1;
    var be = m4 - m3;

    if (style === 'dotted') {
      return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
    } else {
      var _calFitDashed = calFitDashed(total, bs, be, w, bw, bw * 3, Math.max(1, bw * 0.25), bw * 2),
          n = _calFitDashed.n,
          ps = _calFitDashed.ps,
          pd = _calFitDashed.pd;

      if (n === 1) {
        return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
      } // 降级为dotted


      return {
        n: n,
        ps: ps,
        pd: pd
      };
    }
  } // 获取边框分割为几块的坐标，虚线分割为若干四边形、三边型、五边形
  // 三边形重复内外边交点形成四边形，五边形进行切割形成2个四边形
  // direction为上右下左0123


  function calPoints(borderWidth, borderStyle, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, direction, beginRadius, endRadius) {
    var points = [];

    if (borderStyle === 'none') {
      return points;
    }

    if (['dashed', 'dotted'].indexOf(borderStyle) > -1) {
      // 寻找一个合适的虚线线段长度和之间空白边距长度
      var _ref = direction === 0 || direction === 2 ? calDashed(borderStyle, x1, x2, x3, x4, borderWidth) : calDashed(borderStyle, y1, y2, y3, y4, borderWidth),
          n = _ref.n,
          ps = _ref.ps,
          pd = _ref.pd;

      if (n > 1) {
        for (var i = 0; i < n; i++) {
          // 最后一个可能没有到底，延长之
          var isLast = i === n - 1;
          var main1 = void 0;
          var main2 = void 0;
          var cross1 = void 0;
          var cross2 = void 0;

          if (direction === 0 || direction === 2) {
            main1 = i ? x1 + ps * i + pd * i : x1;
          } else {
            main1 = i ? y1 + ps * i + pd * i : y1;
          }

          main2 = main1 + ps;

          if (direction === 0) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y1], [x4, y1], [x3, y2], [x2, y2]]);
              } else {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                cross2 = y1 + (main2 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y1 + (x4 - main1) * Math.tan(deg2);
              cross2 = y1 + (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, y1], [x4, y1], [x4, y1], [main1, cross1]]);
              } else {
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross1]]);

                if (isLast) {
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                  points.push([[x3, y1], [x4, y1], [x4, y1], [x2, y2]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y1 + (x4 - main2) * Math.tan(deg2);
                    points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                    points.push([[x3, y1], [main2, y1], [main2, cross2], [x3, y2]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y1], [main2, y1], [main2, y2], [x2, y2]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y1 + (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y1 + (main1 - x1) * Math.tan(deg1);
                  points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross2]]);
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y1], [x3, y1], [x3, y2], [main1, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y1], [x4, y1], [x3, y2], [main1, y2]]);
                } else {
                  points.push([[main1, y1], [main2, y1], [main2, y2], [main1, y2]]);
                }
              }
            }
          } else if (direction === 1) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x3, y2], [x4, y1], [x4, y4], [x3, y3]]);
              } else {
                cross1 = x4 - (main1 - y1) * Math.tan(deg1);
                cross2 = x4 - (main2 - y1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x3 + (main1 - y3) * Math.tan(deg2);
              cross2 = x3 + (main2 - y3) * Math.tan(deg2);

              if (isLast) {
                points.push([[cross1, main1], [x4, main1], [x4, y4], [x4, y4]]);
              } else {
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x3 + (y2 - main1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, y2], [x3, y2]]);

                if (isLast) {
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                  points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x3 + (main2 - y3) * Math.tan(deg2);
                    points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross2, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x3, y2], [x4, y2], [x4, main2], [x3, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x3 + (main2 - y3) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x3 + (y2 - main1) * Math.tan(deg1);
                  points.push([[cross2, main1], [x4, main1], [x4, y2], [x3, y2]]);
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, x4], [x4, x4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x3, main1], [x4, main1], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x3, main1], [x4, main1], [x4, y4], [x3, y3]]);
                } else {
                  points.push([[x3, main1], [x4, main1], [x4, main2], [x3, main2]]);
                }
              }
            }
          } else if (direction === 2) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y4], [x2, y3], [x3, y3], [x4, y4]]);
              } else {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                cross2 = y4 - (main2 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y4 - (x4 - main1) * Math.tan(deg2);
              cross2 = y4 - (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, cross1], [x4, y4], [x4, y4], [main1, y4]]);
              } else {
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [x2, y3], [x2, y4], [main1, y4]]);

                if (isLast) {
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                  points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y4 - (main2 - x3) * Math.tan(deg2);
                    points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                    points.push([[x3, y3], [main2, cross2], [main2, y4], [x3, y4]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y3], [main2, y3], [main2, y4], [x2, y4]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y4 - (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y4 - (main1 - x3) * Math.tan(deg1);
                  points.push([[main1, cross2], [x2, y3], [x2, y4], [main1, y4]]);
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y3], [x3, y3], [x3, y4], [main1, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y3], [x3, y3], [x4, y4], [main1, y4]]);
                } else {
                  points.push([[main1, y3], [main2, y3], [main2, y4], [main1, y4]]);
                }
              }
            }
          } else if (direction === 3) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x1, y1], [x2, y2], [x2, y3], [x1, y4]]);
              } else {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                cross2 = x1 + (main2 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x1 + (y4 - main1) * Math.tan(deg2);
              cross2 = x1 + (y4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[x1, main1], [cross1, main1], [x1, y4], [x1, y4]]);
              } else {
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [x2, y2], [x1, y2]]);

                if (isLast) {
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                  points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x1 + (y4 - main2) * Math.tan(deg2);
                    points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                    points.push([[x1, y3], [x2, y3], [cross2, main2], [x1, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x1, y2], [x2, y2], [x2, main2], [x1, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x1 + (y4 - main2) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x1 + (main1 - y1) * Math.tan(deg1);
                  points.push([[x1, main1], [cross2, main1], [x2, y2], [x1, y1]]);
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y4]]);
                } else {
                  points.push([[x1, main1], [x2, main1], [x2, main2], [x1, main2]]);
                }
              }
            }
          }
        }

        if (direction === 0) {
          return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 1) {
          return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 2) {
          return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 3) {
          return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        }
      }
    } // 兜底返回实线


    if (direction === 0) {
      if (x2 > x1) {
        points.push([[x1, y1], [x2, y1], [x2, y2], [x1, y1]]);
      }

      points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

      if (x4 > x3) {
        points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
      }

      return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 1) {
      if (y2 > y1) {
        points.push([[x4, y1], [x4, y1], [x4, y2], [x3, y2]]);
      }

      points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

      if (y4 > y3) {
        points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
      }

      return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 2) {
      if (x2 > x1) {
        points.push([[x1, y4], [x2, y3], [x2, y4], [x1, y4]]);
      }

      points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

      if (x4 > x3) {
        points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
      }

      return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 3) {
      if (y2 > y1) {
        points.push([[x1, y1], [x1, y1], [x2, y2], [x1, y2]]);
      }

      points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

      if (y4 > y3) {
        points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
      }

      return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    }
  }

  function calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius = _slicedToArray(beginRadius, 2),
        brx = _beginRadius[0],
        bry = _beginRadius[1];

    var _endRadius = _slicedToArray(endRadius, 2),
        erx = _endRadius[0],
        ery = _endRadius[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[1][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[0][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[1][0] > oxr && points[0][0] < oxl) {
        var ya = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        beginList.push([points[0], [oxl, y1], [oxl, ya], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y1], [oxr, y1], [oxr, y2], [oxl, y2]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y1], [x3, y1], [x3, y2], [oxl, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [oxr, y1], [oxr, y2], [x2, y2]]);
          } else {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          }
        }

        endList.push([[oxr, y1], points[1], points[2], [oxr, yb]]);
      } // 跨越右圆角
      else if (points[1][0] > oxr) {
        var y = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        centerList.push([points[0], [oxr, y1], [oxr, y], points[3]]);
        endList.push([[oxr, y1], points[1], points[2], [oxr, y]]);
      } // 跨越左圆角
      else if (points[0][0] < oxl) {
        var _y = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;

        beginList.push([points[0], [oxl, y1], [oxl, _y], points[3]]);
        centerList.push([[oxl, y1], points[1], points[2], [oxl, _y]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y1 + bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya, xb, _yb;

      var ca = calBezierTopLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$ = _slicedToArray(ca[0], 2);

      xa = _ca$[0];
      _ya = _ca$[1];
      var cb;

      if (needInner) {
        cb = calBezierTopLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$ = _slicedToArray(cb[0], 2);

        xb = _cb$[0];
        _yb = _cb$[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierTopLeft(points[0], points[1], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierTopLeft(points[3], points[2], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i = 0, _len = controls1.length; _i < _len; _i++) {
          limit(controls1[_i], xa, _ya, 0);
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }

        if (needInner) {
          for (var _i2 = 0, _len2 = controls2.length; _i2 < _len2; _i2++) {
            limit(controls2[_i2], xb, _yb, 0);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg = Math.atan((x4 - x3) / (y2 - y1));

      var _rx = erx;
      var _ry = ery;

      var _sx = _ry / _rx;

      var oyr = y1 + ery;

      var _rx2 = erx - (x4 - x3);

      var _ry2 = ery - (y2 - y1);

      var _sx2 = _ry2 / _rx2; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa, _ya2, _xb, _yb2;

      var _ca = calBezierTopRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx, _ry, true, Math.tan(_crossDeg) * _ry);

      var _ca2 = _slicedToArray(_ca[_ca.length - 1], 2);

      _xa = _ca2[0];
      _ya2 = _ca2[1];

      var _cb;

      if (_needInner) {
        _cb = calBezierTopRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx2, _ry2, true, Math.tan(_crossDeg) * _ry2);

        var _cb2 = _slicedToArray(_cb[_cb.length - 1], 2);

        _xb = _cb2[0];
        _yb2 = _cb2[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca;

          if (_needInner) {
            controls2 = _cb;
          }
        } else {
          controls1 = calBezierTopRight(points[0], points[1], oxr, oyr, _sx, _ry);

          if (_needInner) {
            controls2 = calBezierTopRight(points[3], points[2], oxr, oyr, _sx2, _ry2);
          }
        }

        for (var _i3 = 0, _len3 = controls1.length; _i3 < _len3; _i3++) {
          limit(controls1[_i3], _xa, _ya2, 1);
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }

        if (_needInner) {
          for (var _i4 = 0, _len4 = controls2.length; _i4 < _len4; _i4++) {
            limit(controls2[_i4], _xb, _yb2, 1);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierTopLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p = _slicedToArray(p1, 2),
        p1x = _p[0],
        p1y = _p[1];

    var _p2 = _slicedToArray(p2, 2),
        p2x = _p2[0],
        p2y = _p2[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(p1x, p1y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(p2x, p2y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierTopRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p3 = _slicedToArray(p1, 2),
        p1x = _p3[0],
        p1y = _p3[1];

    var _p4 = _slicedToArray(p2, 2),
        p2x = _p4[0],
        p2y = _p4[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (oy - p1y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy - Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy - Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (oy - p2y));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy - Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius2 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius2[0],
        bry = _beginRadius2[1];

    var _endRadius2 = _slicedToArray(endRadius, 2),
        erx = _endRadius2[0],
        ery = _endRadius2[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[2][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[1][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[2][1] > oyb && points[1][1] < oyt) {
        var xa = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;
        var xb = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        beginList.push([points[0], points[1], [x4, oyt], [xa, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x3, oyt], [x4, oyt], [x4, oyb], [x3, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, oyb], [x3, oyb]]);
          } else {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          }
        }

        endList.push([[xb, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[2][1] > oyb) {
        var x = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        centerList.push([points[0], points[1], [x4, oyb], [x, oyb]]);
        endList.push([[x, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;

        beginList.push([points[0], points[1], [x4, oyt], [_x, oyt]]);
        centerList.push([[_x, oyt], [x4, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x4 - x3) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x4 - brx;
      var rx2 = brx - (x4 - x3);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa2, ya, _xb2, yb;

      var ca = calBezierRightTop(beginList[0][1], beginList[0][2], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca3 = _slicedToArray(ca[ca.length - 1], 2);

      _xa2 = _ca3[0];
      ya = _ca3[1];
      var cb;

      if (needInner) {
        cb = calBezierRightTop(beginList[0][0], beginList[0][3], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb3 = _slicedToArray(cb[cb.length - 1], 2);

        _xb2 = _cb3[0];
        yb = _cb3[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierRightTop(points[1], points[2], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierRightTop(points[0], points[3], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i5 = 0, _len5 = controls1.length; _i5 < _len5; _i5++) {
          limit(controls1[_i5], _xa2, ya, 2);
        }

        if (needInner) {
          for (var _i6 = 0, _len6 = controls2.length; _i6 < _len6; _i6++) {
            limit(controls2[_i6], _xb2, yb, 2);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner2 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg2 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx3 = erx;
      var _ry3 = ery;

      var _sx3 = _ry3 / _rx3;

      var oxb = x4 - erx;

      var _rx4 = erx - (x4 - x3);

      var _ry4 = ery - (y4 - y3);

      var _sx4 = _ry4 / _rx4; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa3, _ya3, _xb3, _yb3;

      var _ca4 = calBezierRightBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx3, _ry3, true, Math.tan(_crossDeg2) * _ry3);

      var _ca4$ = _slicedToArray(_ca4[0], 2);

      _xa3 = _ca4$[0];
      _ya3 = _ca4$[1];

      var _cb4;

      if (_needInner2) {
        _cb4 = calBezierRightBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx4, _ry4, true, Math.tan(_crossDeg2) * _ry4);

        var _cb4$ = _slicedToArray(_cb4[0], 2);

        _xb3 = _cb4$[0];
        _yb3 = _cb4$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca4;

          if (_needInner2) {
            controls2 = _cb4;
          }
        } else {
          controls1 = calBezierRightBottom(points[1], points[2], oxb, oyb, _sx3, _ry3);

          if (_needInner2) {
            controls2 = calBezierRightBottom(points[0], points[3], oxb, oyb, _sx4, _ry4);
          }
        }

        for (var _i7 = 0, _len7 = controls1.length; _i7 < _len7; _i7++) {
          limit(controls1[_i7], _xa3, _ya3, 3);
        }

        if (_needInner2) {
          for (var _i8 = 0, _len8 = controls2.length; _i8 < _len8; _i8++) {
            limit(controls2[_i8], _xb3, _yb3, 3);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierRightTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p5 = _slicedToArray(p1, 2),
        p1x = _p5[0],
        p1y = _p5[1];

    var _p6 = _slicedToArray(p2, 2),
        p2x = _p6[0],
        p2y = _p6[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox + Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox + Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox + Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierRightBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p7 = _slicedToArray(p1, 2),
        p1x = _p7[0],
        p1y = _p7[1];

    var _p8 = _slicedToArray(p2, 2),
        p2x = _p8[0],
        p2y = _p8[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius3 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius3[0],
        bry = _beginRadius3[1];

    var _endRadius3 = _slicedToArray(endRadius, 2),
        erx = _endRadius3[0],
        ery = _endRadius3[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[2][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[3][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[2][0] > oxr && points[3][0] < oxl) {
        var ya = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        beginList.push([points[0], [oxl, ya], [oxl, y4], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y3], [oxr, y3], [oxr, y4], [oxl, y4]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y3], [x3, y3], [x3, y4], [oxl, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [oxr, y3], [oxr, y4], [x2, y4]]);
          } else {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          }
        }

        endList.push([[oxr, yb], points[1], points[2], [oxr, y4]]);
      } // 跨越右圆角
      else if (points[2][0] > oxr) {
        var y = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        centerList.push([points[0], [oxr, y], [oxr, y4], points[3]]);
        endList.push([[oxr, y], points[1], points[2], [oxr, y4]]);
      } // 跨越左圆角
      else if (points[3][0] < oxl) {
        var _y2 = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y3;

        beginList.push([points[0], [oxl, _y2], [oxl, y4], points[3]]);
        centerList.push([[oxl, _y2], points[1], points[2], [oxl, y4]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y4 - y3));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y4 - bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y4 - y3);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya4, xb, _yb4;

      var ca = calBezierBottomLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$2 = _slicedToArray(ca[0], 2);

      xa = _ca$2[0];
      _ya4 = _ca$2[1];
      var cb;

      if (needInner) {
        cb = calBezierBottomLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$2 = _slicedToArray(cb[0], 2);

        xb = _cb$2[0];
        _yb4 = _cb$2[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierBottomLeft(points[3], points[2], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierBottomLeft(points[0], points[1], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i9 = 0, _len9 = controls1.length; _i9 < _len9; _i9++) {
          limit(controls1[_i9], xa, _ya4, 4);
        }

        if (needInner) {
          for (var _i10 = 0, _len10 = controls2.length; _i10 < _len10; _i10++) {
            limit(controls2[_i10], xb, _yb4, 4);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner3 = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg3 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx5 = erx;
      var _ry5 = ery;

      var _sx5 = _ry5 / _rx5;

      var oyr = y4 - ery;

      var _rx6 = erx - (x4 - x3);

      var _ry6 = ery - (y4 - y3);

      var _sx6 = _ry6 / _rx6; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa4, _ya5, _xb4, _yb5;

      var _ca5 = calBezierBottomRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx5, _ry5, true, Math.tan(_crossDeg3) * _ry5);

      var _ca6 = _slicedToArray(_ca5[_ca5.length - 1], 2);

      _xa4 = _ca6[0];
      _ya5 = _ca6[1];

      var _cb5;

      if (_needInner3) {
        _cb5 = calBezierBottomRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx6, _ry6, true, Math.tan(_crossDeg3) * _ry6);

        var _cb6 = _slicedToArray(_cb5[_cb5.length - 1], 2);

        _xb4 = _cb6[0];
        _yb5 = _cb6[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca5;

          if (_needInner3) {
            controls2 = _cb5;
          }
        } else {
          controls1 = calBezierBottomRight(points[3], points[2], oxr, oyr, _sx5, _ry5);

          if (_needInner3) {
            controls2 = calBezierBottomRight(points[0], points[1], oxr, oyr, _sx6, _ry6);
          }
        }

        for (var _i11 = 0, _len11 = controls1.length; _i11 < _len11; _i11++) {
          limit(controls1[_i11], _xa4, _ya5, 5);
        }

        if (_needInner3) {
          for (var _i12 = 0, _len12 = controls2.length; _i12 < _len12; _i12++) {
            limit(controls2[_i12], _xb4, _yb5, 5);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierBottomLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p9 = _slicedToArray(p1, 2),
        p1x = _p9[0],
        p1y = _p9[1];

    var _p10 = _slicedToArray(p2, 2),
        p2x = _p10[0],
        p2y = _p10[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (p2y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy + Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy + Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (p1y - oy));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy + Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierBottomRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p11 = _slicedToArray(p1, 2),
        p1x = _p11[0],
        p1y = _p11[1];

    var _p12 = _slicedToArray(p2, 2),
        p2x = _p12[0],
        p2y = _p12[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius4 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius4[0],
        bry = _beginRadius4[1];

    var _endRadius4 = _slicedToArray(endRadius, 2),
        erx = _endRadius4[0],
        ery = _endRadius4[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[3][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[0][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[3][1] > oyb && points[0][1] < oyt) {
        var xa = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;
        var xb = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        beginList.push([points[0], points[1], [xa, oyt], [x1, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, oyb], [x1, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, oyb], [x1, oyb]]);
          } else {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          }
        }

        endList.push([[x1, oyb], [xb, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[3][1] > oyb) {
        var x = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        centerList.push([points[0], points[1], [x, oyb], [x1, oyb]]);
        endList.push([[x1, oyb], [x, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x2 = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;

        beginList.push([points[0], points[1], [_x2, oyt], [x1, oyt]]);
        centerList.push([[x1, oyt], [_x2, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x1 + brx;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa5, ya, _xb5, yb;

      var ca = calBezierLeftTop(beginList[0][0], beginList[0][3], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca7 = _slicedToArray(ca[ca.length - 1], 2);

      _xa5 = _ca7[0];
      ya = _ca7[1];
      var cb;

      if (needInner) {
        cb = calBezierLeftTop(beginList[0][1], beginList[0][2], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb7 = _slicedToArray(cb[cb.length - 1], 2);

        _xb5 = _cb7[0];
        yb = _cb7[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierLeftTop(points[0], points[3], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierLeftTop(points[1], points[2], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i13 = 0, _len13 = controls1.length; _i13 < _len13; _i13++) {
          limit(controls1[_i13], _xa5, ya, 6);
        }

        if (needInner) {
          for (var _i14 = 0, _len14 = controls2.length; _i14 < _len14; _i14++) {
            limit(controls2[_i14], _xb5, yb, 6);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner4 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg4 = Math.atan((x2 - x1) / (y4 - y3));

      var _rx7 = erx;
      var _ry7 = ery;

      var _sx7 = _ry7 / _rx7;

      var oxb = x1 + erx;

      var _rx8 = erx - (x2 - x1);

      var _ry8 = ery - (y4 - y3);

      var _sx8 = _ry8 / _rx8; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa6, _ya6, _xb6, _yb6;

      var _ca8 = calBezierLeftBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx7, _ry7, true, Math.tan(_crossDeg4) * _ry7);

      var _ca8$ = _slicedToArray(_ca8[0], 2);

      _xa6 = _ca8$[0];
      _ya6 = _ca8$[1];

      var _cb8;

      if (_needInner4) {
        _cb8 = calBezierLeftBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx8, _ry8, true, Math.tan(_crossDeg4) * _ry8);

        var _cb8$ = _slicedToArray(_cb8[0], 2);

        _xb6 = _cb8$[0];
        _yb6 = _cb8$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca8;

          if (_needInner4) {
            controls2 = _cb8;
          }
        } else {
          controls1 = calBezierLeftBottom(points[0], points[3], oxb, oyb, _sx7, _ry7);

          if (_needInner4) {
            controls2 = calBezierLeftBottom(points[1], points[2], oxb, oyb, _sx8, _ry8);
          }
        }

        for (var _i15 = 0, _len15 = controls1.length; _i15 < _len15; _i15++) {
          limit(controls1[_i15], _xa6, _ya6, 7);
        }

        if (_needInner4) {
          for (var _i16 = 0, _len16 = controls2.length; _i16 < _len16; _i16++) {
            limit(controls2[_i16], _xb6, _yb6, 7);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierLeftTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p13 = _slicedToArray(p1, 2),
        p1x = _p13[0],
        p1y = _p13[1];

    var _p14 = _slicedToArray(p2, 2),
        p2x = _p14[0],
        p2y = _p14[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierLeftBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p15 = _slicedToArray(p1, 2),
        p1x = _p15[0],
        p1y = _p15[1];

    var _p16 = _slicedToArray(p2, 2),
        p2x = _p16[0],
        p2y = _p16[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox - Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox - Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox - Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }
  /**
   * 简单计算椭圆的圆化坐标控制点，视作重合位置，外面判断backgroundClip并调整坐标
   * @param x 起始x
   * @param y 起始y
   * @param w 宽
   * @param h 高
   * @param btlr borderTopLeftRadius
   * @param btrr borderTopRightRadius
   * @param bbrr borderBottomRightRadius
   * @param bblr borderBottomLeftRadius
   * @returns {[]} 多边形的顶点和曲线控制点
   */


  function calRadius(x, y, w, h, btlr, btrr, bbrr, bblr) {
    var need;

    var _btlr = _slicedToArray(btlr, 2),
        btlx = _btlr[0],
        btly = _btlr[1];

    var _btrr = _slicedToArray(btrr, 2),
        btrx = _btrr[0],
        btry = _btrr[1];

    var _bbrr = _slicedToArray(bbrr, 2),
        bbrx = _bbrr[0],
        bbry = _bbrr[1];

    var _bblr = _slicedToArray(bblr, 2),
        bblx = _bblr[0],
        bbly = _bblr[1];

    btlx = Math.max(btlx, 0);
    btly = Math.max(btly, 0);
    btrx = Math.max(btrx, 0);
    btry = Math.max(btry, 0);
    bbrx = Math.max(bbrx, 0);
    bbry = Math.max(bbry, 0);
    bblx = Math.max(bblx, 0);
    bbly = Math.max(bbly, 0); // 圆角必须x/y都>0才有效，否则视为不绘制

    if (btlx > 0 && btly > 0 || btrx > 0 && btry > 0 || bbrx > 0 && bbry > 0 || bblx > 0 && bbly > 0) {
      need = true;
    }

    if (need) {
      var list = [];

      if (btlx > 0 && btly > 0) {
        list.push([x, y + btly]);
        list.push([x, y + btly * (1 - H), x + btlx * (1 - H), y, x + btlx, y]);
      } else {
        list.push([x, y]);
      }

      if (btrx > 0 && btry > 0) {
        list.push([x + w - btrx, y]);
        list.push([x + w - btrx * (1 - H), y, x + w, y + btry * (1 - H), x + w, y + btry]);
      } else {
        list.push([x + w, y]);
      }

      if (bbrx > 0 && bbry > 0) {
        list.push([x + w, y + h - bbry]);
        list.push([x + w, y + h - bbry * (1 - H), x + w - bbrx * (1 - H), y + h, x + w - bbrx, y + h]);
      } else {
        list.push([x + w, y + h]);
      }

      if (bblx > 0 && bbly > 0) {
        list.push([x + bblx, y + h]);
        list.push([x + bblx * (1 - H), y + h, x, y + h - bbly * (1 - H), x, y + h - bbly]);
      } else {
        list.push([x, y + h]);
      }

      return list;
    }
  }

  function limit(points, x, y, direction) {
    if (direction === 0) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 1) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 2) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 3) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 4) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 5) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 6) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 7) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    }
  }

  var BR_KS = [BORDER_TOP_LEFT_RADIUS$5, BORDER_TOP_RIGHT_RADIUS$5, BORDER_BOTTOM_RIGHT_RADIUS$5, BORDER_BOTTOM_LEFT_RADIUS$5];

  function calBorderRadius(w, h, currentStyle, computedStyle, root) {
    var noRadius = true;
    BR_KS.forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        if (item.v > 0) {
          noRadius = false;
        } else {
          return 0;
        }

        if (item.u === PX$a) {
          return Math.max(0, item.v);
        } else if (item.u === PERCENT$9) {
          return Math.max(0, item.v * (i ? h : w) * 0.01);
        } else if (item.u === REM$9) {
          return Math.max(0, item.v * root.computedStyle[FONT_SIZE$c]);
        } else if (item.u === VW$9) {
          return Math.max(0, item.v * root.width * 0.01);
        } else if (item.u === VH$9) {
          return Math.max(0, item.v * root.height * 0.01);
        } else if (item.u === VMAX$9) {
          return Math.max(0, item.v * Math.max(root.width, root.height) * 0.01);
        } else if (item.u === VMIN$9) {
          return Math.max(0, item.v * Math.min(root.width, root.height) * 0.01);
        }

        return 0;
      });
    }); // 优化提前跳出

    if (noRadius) {
      return;
    } // radius限制，相交的2个之和不能超过边长，如果2个都超过中点取中点，只有1个超过取交点，这包含了单个不能超过总长的逻辑


    BR_KS.forEach(function (k, i) {
      var j = i % 2 === 0 ? 0 : 1;
      var target = j ? h : w;
      var prev = computedStyle[k];
      var next = computedStyle[BR_KS[(i + 1) % 4]]; // 相加超过边长则是相交

      if (prev[j] + next[j] > target) {
        var half = target * 0.5; // 都超过一半中点取中点

        if (prev[j] >= half && next[j] >= half) {
          prev[j] = next[j] = half;
        } // 仅1个超过中点，因相交用总长减去另一方即可
        else if (prev[j] > half) {
          prev[j] = target - next[j];
        } else if (next[j] > half) {
          next[j] = target - prev[j];
        }
      }
    });
  }

  function calBorderRadiusInline(contentBoxList, currentStyle, computedStyle) {
    var first, last;

    if (contentBoxList.length) {
      first = contentBoxList[0];
      last = contentBoxList[contentBoxList.length - 1]; // 不用instanceof防止循环依赖

      if (last.isEllipsis) {
        last = contentBoxList[contentBoxList.length - 2];
      }
    } // 先看first的左侧


    var w = first ? first.outerWidth : 0,
        h = first ? first.outerHeight : 0;
    w += computedStyle[BORDER_LEFT_WIDTH$a] + computedStyle[PADDING_LEFT$a];
    h += computedStyle[BORDER_TOP_WIDTH$8] + computedStyle[BORDER_BOTTOM_WIDTH$7] + computedStyle[PADDING_TOP$8] + computedStyle[PADDING_BOTTOM$7];
    [BORDER_TOP_LEFT_RADIUS$5, BORDER_BOTTOM_LEFT_RADIUS$5].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item.u === PX$a) {
          v = Math.max(0, item.v);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item.v * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    }); // 再看end的右侧

    w = last ? last.outerWidth : 0;
    h = last ? last.outerHeight : 0;
    [BORDER_TOP_RIGHT_RADIUS$5, BORDER_BOTTOM_RIGHT_RADIUS$5].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item.u === PX$a) {
          v = Math.max(0, item.v);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item.v * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    });
  }

  function renderBorder(xom, renderMode, ctx, points, color, dx, dy) {
    if (renderMode === mode.CANVAS) {
      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      points.forEach(function (point) {
        canvasPolygon$6(ctx, point, dx, dy, true);
      });
      ctx.fill();
    } else if (renderMode === mode.SVG) {
      var s = '';
      points.forEach(function (point) {
        s += svgPolygon$5(point);
      });
      xom.virtualDom.bb.push({
        type: 'item',
        tagName: 'path',
        props: [['d', s], ['fill', color]]
      });
    }
  }

  var border = {
    calPoints: calPoints,
    calRadius: calRadius,
    calBorderRadius: calBorderRadius,
    calBorderRadiusInline: calBorderRadiusInline,
    renderBorder: renderBorder
  };

  var rgba2int$2 = util.rgba2int,
      isNil$g = util.isNil;
  var PX$9 = o$4.PX,
      PERCENT$8 = o$4.PERCENT,
      DEG$4 = o$4.DEG,
      NUMBER$5 = o$4.NUMBER,
      REM$8 = o$4.REM,
      VW$8 = o$4.VW,
      VH$8 = o$4.VH,
      VMAX$8 = o$4.VMAX,
      VMIN$8 = o$4.VMIN,
      calUnit$2 = o$4.calUnit;
  var d2r$2 = geom.d2r;
  var canvasPolygon$5 = painter.canvasPolygon;
  var FONT_SIZE$b = enums.STYLE_KEY.FONT_SIZE;

  function getLinearDeg(v) {
    var deg = 180;

    if (v === 'to top') {
      deg = 0;
    } else if (v === 'to top right') {
      deg = 45;
    } else if (v === 'to right') {
      deg = 90;
    } else if (v === 'to bottom right') {
      deg = 135;
    } else if (v === 'to bottom') ; else if (v === 'to bottom left') {
      deg = 225;
    } else if (v === 'to left') {
      deg = 270;
    } else if (v === 'to top left') {
      deg = 315;
    } // 数字角度，没有的话取默认角度
    else {
      var match = /([-+]?[\d.]+)deg/.exec(v);

      if (match) {
        deg = parseFloat(match[1]);
      }
    }

    return deg % 360;
  }

  function getRadialPosition(data) {
    if (/^[-+]?[\d.]/.test(data)) {
      var v = calUnit$2(data);

      if ([NUMBER$5, DEG$4].indexOf(v.u) > -1) {
        v.u = PX$9;
      }

      return v;
    } else {
      return {
        v: {
          top: 0,
          left: 0,
          center: 50,
          right: 100,
          bottom: 100
        }[data] || 50,
        u: PERCENT$8
      };
    }
  } // 获取color-stop区间范围，去除无用值


  function getColorStop(v, length, root) {
    var list = [];
    var firstColor = v[0][0]; // 先把已经声明距离的换算成[0,1]以数组形式存入，未声明的原样存入

    for (var i = 0, len = v.length; i < len; i++) {
      var item = v[i]; // 考虑是否声明了位置

      if (item.length > 1) {
        var p = item[1];

        if (p.u === PERCENT$8) {
          list.push([item[0], p.v * 0.01]);
        } else if (p.u === REM$8) {
          list.push([item[0], p.v * root.computedStyle[FONT_SIZE$b] / length]);
        } else if (p.u === VW$8) {
          list.push([item[0], p.v * root.width / length]);
        } else if (p.u === VH$8) {
          list.push([item[0], p.v * root.height / length]);
        } else if (p.u === VMAX$8) {
          list.push([item[0], p.v * Math.max(root.width, root.height) / length]);
        } else if (p.u === VMIN$8) {
          list.push([item[0], p.v * Math.min(root.width, root.height) / length]);
        } else {
          list.push([item[0], p.v / length]);
        }
      } else {
        list.push([item[0]]);
      }
    }

    if (list.length === 1) {
      list.push(util.clone(list[0]));
    } // 首尾不声明默认为[0, 1]


    if (list[0].length === 1) {
      list[0].push(0);
    }

    if (list.length > 1) {
      var _i = list.length - 1;

      if (list[_i].length === 1) {
        list[_i].push(1);
      }
    } // 找到未声明位置的，需区间计算，找到连续的未声明的，前后的区间平分


    var start = list[0][1];

    for (var _i2 = 1, _len = list.length; _i2 < _len - 1; _i2++) {
      var _item = list[_i2];

      if (_item.length > 1) {
        start = _item[1];
      } else {
        var j = _i2 + 1;
        var end = list[list.length - 1][1];

        for (; j < _len - 1; j++) {
          var _item2 = list[j];

          if (_item2.length > 1) {
            end = _item2[1];
            break;
          }
        }

        var num = j - _i2 + 1;
        var per = (end - start) / num;

        for (var k = _i2; k < j; k++) {
          var _item3 = list[k];

          _item3.push(start + per * (k + 1 - _i2));
        }

        _i2 = j;
      }
    } // 每个不能小于前面的，按大小排序，canvas/svg兼容这种情况，无需处理
    // 0之前的和1之后的要过滤掉


    for (var _i3 = 0, _len2 = list.length; _i3 < _len2; _i3++) {
      var _item4 = list[_i3];

      if (_item4[1] > 1) {
        list.splice(_i3);
        var prev = list[_i3 - 1];

        if (prev && prev[1] < 1) {
          var dr = _item4[0][0] - prev[0][0];
          var dg = _item4[0][1] - prev[0][1];
          var db = _item4[0][2] - prev[0][2];
          var da = _item4[0][3] - prev[0][3];

          var _p = (1 - prev[1]) / (_item4[1] - prev[1]);

          list.push([[_item4[0][0] + dr * _p, _item4[0][1] + dg * _p, _item4[0][2] + db * _p, _item4[0][3] + da * _p], 1]);
        }

        break;
      }
    }

    for (var _i4 = list.length - 1; _i4 >= 0; _i4--) {
      var _item5 = list[_i4];

      if (_item5[1] < 0) {
        list.splice(0, _i4 + 1);
        var next = list[_i4];

        if (next && next[1] > 0) {
          var _dr = next[0][0] - _item5[0][0];

          var _dg = next[0][1] - _item5[0][1];

          var _db = next[0][2] - _item5[0][2];

          var _da = next[0][3] - _item5[0][3];

          var _p2 = -_item5[1] / (next[1] - _item5[1]);

          list.unshift([[_item5[0][0] + _dr * _p2, _item5[0][1] + _dg * _p2, _item5[0][2] + _db * _p2, _item5[0][3] + _da * _p2], 0]);
        }

        break;
      }
    } // 可能存在超限情况，如在使用px单位超过len或<len时，canvas会报错超过[0,1]区间，需手动换算至区间内


    list.forEach(function (item) {
      // item[0] = int2rgba(item[0]);
      if (item[1] < 0) {
        item[1] = 0;
      } else if (item[1] > 1) {
        item[1] = 1;
      }
    }); // 都超限时，第一个颜色兜底

    if (!list.length) {
      list.push([firstColor, 0]);
    }

    return list;
  } // 根据角度和圆心获取渐变的4个点坐标


  function calLinearCoords(deg, length, cx, cy) {
    var x0;
    var y0;
    var x1;
    var y1;

    if (deg >= 270) {
      var r = d2r$2(360 - deg);
      x0 = cx + Math.sin(r) * length;
      y0 = cy + Math.cos(r) * length;
      x1 = cx - Math.sin(r) * length;
      y1 = cy - Math.cos(r) * length;
    } else if (deg >= 180) {
      var _r = d2r$2(deg - 180);

      x0 = cx + Math.sin(_r) * length;
      y0 = cy - Math.cos(_r) * length;
      x1 = cx - Math.sin(_r) * length;
      y1 = cy + Math.cos(_r) * length;
    } else if (deg >= 90) {
      var _r2 = d2r$2(180 - deg);

      x0 = cx - Math.sin(_r2) * length;
      y0 = cy - Math.cos(_r2) * length;
      x1 = cx + Math.sin(_r2) * length;
      y1 = cy + Math.cos(_r2) * length;
    } else {
      var _r3 = d2r$2(deg);

      x0 = cx - Math.sin(_r3) * length;
      y0 = cy + Math.cos(_r3) * length;
      x1 = cx + Math.sin(_r3) * length;
      y1 = cy - Math.cos(_r3) * length;
    }

    return [x0, y0, x1, y1];
  }

  function calCircleCentre(position, x1, y1, iw, ih, root) {
    var cx, cy;
    var positionX = position[0],
        positionY = position[1];

    if (positionX.u === PERCENT$8) {
      cx = x1 + positionX.v * iw * 0.01;
    } else if (positionX.u === REM$8) {
      cx = x1 + positionX.v * root.computedStyle[FONT_SIZE$b];
    } else if (positionX.u === VW$8) {
      cx = x1 + positionX.v * root.width * 0.01;
    } else if (positionX.u === VH$8) {
      cx = x1 + positionX.v * root.height * 0.01;
    } else if (positionX.u === VMAX$8) {
      cx = x1 + positionX.v * Math.max(root.width, root.height) * 0.01;
    } else if (positionX.u === VMIN$8) {
      cx = x1 + positionX.v * Math.min(root.width, root.height) * 0.01;
    } else {
      cx = x1 + positionX.v;
    }

    if (positionY.u === PERCENT$8) {
      cy = y1 + positionY.v * ih * 0.01;
    } else if (positionY.u === REM$8) {
      cy = y1 + positionY.v * root.computedStyle[FONT_SIZE$b];
    } else if (positionY.u === VW$8) {
      cy = y1 + positionY.v * root.width * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * root.height * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * Math.max(root.width, root.height) * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * Math.min(root.width, root.height) * 0.01;
    } else {
      cy = y1 + positionY.v;
    }

    return [cx, cy];
  } // 获取径向渐变圆心半径


  function calRadialRadius(shape, size, position, iw, ih, x1, y1, x2, y2, root) {
    var cx,
        cy,
        xl,
        yl,
        r,
        tx,
        ty,
        d = 0; // 扩展的from to ratio格式，圆心、长轴坐标、短轴缩放比

    if (Array.isArray(size)) {
      cx = x1 + size[0] * iw;
      cy = y1 + size[1] * ih;
      tx = x1 + size[4] * iw;
      ty = y1 + size[5] * ih;

      if (size[6] <= 0) {
        r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
      } else {
        xl = Math.sqrt(Math.pow((size[2] - size[0]) * iw, 2) + Math.pow((size[3] - size[1]) * ih, 2));
        yl = xl * size[6];
        r = Math.max(xl, yl); // 看旋转

        if (xl !== yl) {
          if (size[2] >= size[0]) {
            if (size[3] >= size[1]) {
              d = Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = -Math.asin((size[1] - size[3]) * ih / xl);
            }
          } else {
            if (size[3] >= size[1]) {
              d = d2r$2(180) - Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = Math.asin((size[1] - size[3]) * ih / xl) - d2r$2(180);
            }
          }
        }
      }
    } else {
      // 默认椭圆a是水平轴，b是垂直轴
      var _calCircleCentre = calCircleCentre(position, x1, y1, iw, ih, root);

      var _calCircleCentre2 = _slicedToArray(_calCircleCentre, 2);

      cx = _calCircleCentre2[0];
      cy = _calCircleCentre2[1];
      tx = cx;
      ty = cy;
      var ratio = 1;

      if (size === 'closest-corner' && shape === 'circle') {
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.sqrt(Math.pow(xl, 2) + Math.pow(yl, 2));
        }
      } else if (size === 'closest-side' || size === 'closest-corner') {
        // 在边外特殊情况只有end颜色填充
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          var _ratio = 1;

          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.min(xl, yl); // css的角和边有对应关系，即边扩展倍数，计算为固定值

          if (size === 'closest-corner') {
            _ratio = Math.sqrt(2);
          }

          xl *= _ratio;
          yl *= _ratio;
          r *= _ratio;
        }
      } else {
        if (cx <= x1) {
          xl = x1 - cx + iw;
        } else if (cx >= x2) {
          xl = cx - x2 + iw;
        } else if (cx < x1 + iw * 0.5) {
          xl = x2 - cx;
        } else {
          xl = cx - x1;
        }

        if (cy <= y1) {
          yl = y1 - cy + ih;
        } else if (cy >= y2) {
          yl = cy - y2 + ih;
        } else if (cy < y1 + ih * 0.5) {
          yl = y2 - cy;
        } else {
          yl = cy - y1;
        }

        r = Math.max(xl, yl);

        if (size !== 'farthest-side') {
          ratio = Math.sqrt(2);
        }

        xl *= ratio;
        yl *= ratio;
        r *= ratio;
      }
    }

    if (shape === 'circle') {
      xl = yl = r;
    }

    return [cx, cy, r, xl, yl, tx, ty, d];
  }

  function parseGradient(s) {
    var gradient = reg.gradient.exec(s);

    if (gradient) {
      var o = {
        k: gradient[1]
      };

      if (o.k === 'linear') {
        var deg = /([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?deg)|(to\s+[toprighbml]+)/i.exec(gradient[2]);

        if (deg) {
          o.d = getLinearDeg(deg[0].toLowerCase());
        } // 扩展支持从a点到b点相对坐标，而不是css角度，sketch等ui软件中用此格式
        else {
          var points = /([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?)\s+([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?)\s+([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?)\s+([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?)/.exec(gradient[2]);

          if (points) {
            o.d = [parseFloat(points[1]), parseFloat(points[2]), parseFloat(points[3]), parseFloat(points[4])];
          } else {
            o.d = 180;
          }
        }
      } else if (o.k === 'radial') {
        o.s = gradient[2].indexOf('circle') > -1 ? 'circle' : 'ellipse';
        var size = /(closest|farthest)-(side|corner)/i.exec(gradient[2]);

        if (size) {
          o.z = size[0].toLowerCase();
        } // 扩展支持从a点到b点相对坐标，而不是size，sketch等ui软件中用此格式
        else {
          var _points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?/.exec(gradient[2]);

          if (_points) {
            o.z = [parseFloat(_points[1]), parseFloat(_points[2]), parseFloat(_points[3]), parseFloat(_points[4])];
            var i5 = !isNil$g(_points[5]),
                i6 = !isNil$g(_points[6]),
                i7 = !isNil$g(_points[7]); // 重载，567是偏移x/y和ratio，都可省略即不偏移和半径1，只有5是ratio，只有56是x/y

            if (i5 && i6 && i7) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(parseFloat(_points[7]));
            } else if (i5 && i6) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(1);
            } else if (i5) {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(parseFloat(_points[5]));
            } else {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(1);
            }
          } else {
            o.z = 'farthest-corner';
          }
        }

        var position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (position) {
          var x = getRadialPosition(position[1]);
          var y = position[2] ? getRadialPosition(position[2]) : x;
          o.p = [x, y];
        } else {
          o.p = [{
            v: 50,
            u: PERCENT$8
          }, {
            v: 50,
            u: PERCENT$8
          }];
        }
      } else if (o.k === 'conic') {
        var _deg = /([-+]?[\d.]+deg)/i.exec(gradient[2]);

        if (_deg) {
          o.d = parseFloat(_deg[0]) % 360;
        } else {
          o.d = 0;
        }

        var _position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (_position) {
          var _x = getRadialPosition(_position[1]);

          var _y = _position[2] ? getRadialPosition(_position[2]) : _x;

          o.p = [_x, _y];
        } else {
          o.p = [{
            v: 50,
            u: PERCENT$8
          }, {
            v: 50,
            u: PERCENT$8
          }];
        }
      }

      var v = gradient[2].match(/(([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?[pxremvwhina%]+)?\s*((#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))\s*([-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?[pxremvwhina%]+)?)|(transparent)/ig) || [];
      o.v = v.map(function (item) {
        var color = /(?:#[0-9a-f]{3,8})|(?:rgba?\s*\(.+?\))|(?:transparent)/i.exec(item);
        var arr = [rgba2int$2(color[0])];
        var percent = /[-+]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e[-+]?\d+)?[pxremvwhina%]+/.exec(item);

        if (percent) {
          var _v = calUnit$2(percent[0]);

          if ([NUMBER$5, DEG$4].indexOf(_v.u) > -1) {
            _v.u = PX$9;
          }

          arr[1] = _v;
        }

        return arr;
      });
      return o;
    }
  }

  function getLinear(v, d, ox, oy, cx, cy, w, h, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    ox += dx;
    oy += dy;
    cx += dx;
    cy += dy; // d为数组是2个坐标点，数字是css标准角度

    var x1, y1, x2, y2, stop;

    if (Array.isArray(d)) {
      x1 = ox + d[0] * w;
      y1 = oy + d[1] * h;
      x2 = ox + d[2] * w;
      y2 = oy + d[3] * h;
      var total = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      stop = getColorStop(v, total);
    } else {
      while (d >= 360) {
        d -= 360;
      }

      while (d < 0) {
        d += 360;
      } // 根据角度求直线上2点，设置半径为长宽最大值，这样一定在矩形外，看做一个向量A


      var len = Math.max(w, h);
      var coords = calLinearCoords(d, len, cx, cy);
      len *= 2; // start和4个顶点的向量在A上的投影长度

      var l1 = vector.dotProduct(ox - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l2 = vector.dotProduct(ox + w - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l3 = vector.dotProduct(ox + w - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l4 = vector.dotProduct(ox - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len; // 最小和最大值为0~100%

      var min = l1,
          max = l1;
      min = Math.min(min, Math.min(l2, Math.min(l3, l4)));
      max = Math.max(max, Math.max(l2, Math.max(l3, l4))); // 求得0和100%的长度和坐标

      var _total = max - min;

      var r1 = min / len;

      var _dx = coords[2] - coords[0];

      var _dy = coords[3] - coords[1];

      x1 = coords[0] + _dx * r1;
      y1 = coords[1] + _dy * r1;
      x2 = coords[2] - _dx * r1;
      y2 = coords[3] - _dy * r1;
      stop = getColorStop(v, _total, root);
    }

    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      stop: stop
    };
  }

  function getRadial(v, shape, size, position, x1, y1, x2, y2, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var w = x2 - x1;
    var h = y2 - y1;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _calRadialRadius = calRadialRadius(shape, size, position, w, h, x1, y1, x2, y2, root),
        _calRadialRadius2 = _slicedToArray(_calRadialRadius, 8),
        cx = _calRadialRadius2[0],
        cy = _calRadialRadius2[1],
        r = _calRadialRadius2[2],
        xl = _calRadialRadius2[3],
        yl = _calRadialRadius2[4],
        tx = _calRadialRadius2[5],
        ty = _calRadialRadius2[6],
        d = _calRadialRadius2[7]; // 圆形取最小值，椭圆根据最小圆进行transform，椭圆其中一边轴和r一样，另一边则大小缩放可能


    var matrix$1,
        scx = 1,
        scy = 1;

    if (xl !== yl || d) {
      matrix$1 = [1, 0, 0, 1, 0, 0];

      if (d) {
        var sin = Math.sin(d);
        var cos = Math.cos(d);
        matrix$1 = [cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      if (xl !== r) {
        scx = xl / r;
        var m = [scx, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix$1 = matrix.multiply(matrix$1, m);
      }

      if (yl !== r) {
        scy = yl / r;
        var _m = [1, 0, 0, 0, 0, scy, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix$1 = matrix.multiply(matrix$1, _m);
      }
    }

    var stop = getColorStop(v, r, root);
    return {
      cx: cx,
      cy: cy,
      tx: tx,
      ty: ty,
      r: r,
      stop: stop,
      scx: scx,
      scy: scy,
      matrix: matrix$1,
      d: d
    };
  }

  function getConic(v, d, p, x1, y1, x2, y2, ratio, root) {
    var _calConicRadius = calConicRadius(v, d, p, x1, y1, x2, y2, root),
        _calConicRadius2 = _slicedToArray(_calConicRadius, 4),
        cx = _calConicRadius2[0],
        cy = _calConicRadius2[1],
        r = _calConicRadius2[2],
        deg = _calConicRadius2[3];

    var stop = getColorStop(v, 1, root);
    r <<= 1; // 锥形半径*2，这样分割画圆时保证一定会填满原有矩形

    r *= ratio; // 矢量图形比较特殊，有可能超限，传入个倍数扩大半径

    return {
      cx: cx,
      cy: cy,
      w: x2 - x1,
      h: y2 - y1,
      r: r,
      deg: deg,
      stop: stop
    };
  }

  function calConicRadius(v, deg, position, x1, y1, x2, y2, root) {
    var iw = x2 - x1;
    var ih = y2 - y1;

    var _calCircleCentre3 = calCircleCentre(position, x1, y1, iw, ih, root),
        _calCircleCentre4 = _slicedToArray(_calCircleCentre3, 2),
        cx = _calCircleCentre4[0],
        cy = _calCircleCentre4[1];

    var r, a, b;

    if (cx >= x1 + iw * 0.5) {
      a = cx - x1;
    } else {
      a = x2 - cx;
    }

    if (cy >= y1 + ih * 0.5) {
      b = cy - y1;
    } else {
      b = y2 - cy;
    }

    r = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
    return [cx, cy, r, deg];
  }

  function renderConic(xom, renderMode, ctx, res, x, y, w, h, btlr, btrr, bbrr, bblr, isInline) {
    // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间
    var list = border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    }

    if (renderMode === mode.CANVAS) {
      var offscreen = inject.getOffscreenCanvas(w, h, '__$$CONIC_GRADIENT$$__', null);
      var imgData = offscreen.ctx.getImageData(0, 0, w, h);
      gradient$1.getConicGradientImage(res.cx - x, res.cy - y, res.w, res.h, res.stop, imgData.data);
      offscreen.ctx.putImageData(imgData, 0, 0);
      ctx.save();
      ctx.beginPath();
      canvasPolygon$5(ctx, list, 0, 0, true);
      ctx.clip();
      ctx.drawImage(offscreen.canvas, x, y);
      ctx.restore();
      offscreen.ctx.clearRect(0, 0, w, h);
    }
  }

  var gradient = {
    parseGradient: parseGradient,
    getLinear: getLinear,
    getRadial: getRadial,
    getConic: getConic,
    renderConic: renderConic
  };

  var isNil$f = util.isNil;

  function parseFlex(style, grow, shrink, basis) {
    if (isNil$f(style.flexGrow)) {
      style.flexGrow = grow || 0;
    }

    if (isNil$f(style.flexShrink)) {
      style.flexShrink = shrink || 0;
    }

    if (isNil$f(style.flexBasis)) {
      style.flexBasis = basis || 0;
    }
  }

  function parseMarginPadding(style, key, list) {
    var temp = style[key];

    if (!isNil$f(temp)) {
      var match = temp.toString().match(/([-+]?[\d.]+[pxremvwhina%]*)|(auto)/ig);

      if (match) {
        if (match.length === 1) {
          match[3] = match[2] = match[1] = match[0];
        } else if (match.length === 2) {
          match[2] = match[0];
          match[3] = match[1];
        } else if (match.length === 3) {
          match[3] = match[1];
        }

        list.forEach(function (k, i) {
          if (isNil$f(style[k])) {
            style[k] = match[i];
          }
        });
      }
    }
  }

  function parseOneBorder(style, k) {
    var v = style[k];

    if (isNil$f(v)) {
      return;
    } // 后面会统一格式化处理


    if (isNil$f(style[k + 'Width'])) {
      var w = /\b[\d.]+[pxremvwhina%]*\b/i.exec(v);
      style[k + 'Width'] = w ? w[0] : 0;
    }

    if (isNil$f(style[k + 'Style'])) {
      var s = /\b(solid|dashed|dotted)\b/i.exec(v);
      style[k + 'Style'] = s ? s[1] : 'solid';
    }

    if (isNil$f(style[k + 'Color'])) {
      var c = /#[0-9a-f]{3,8}/i.exec(v);

      if (c && [4, 7, 9].indexOf(c[0].length) > -1) {
        style[k + 'Color'] = c[0];
      } else if (/\btransparent\b/i.test(v)) {
        style[k + 'Color'] = 'transparent';
      } else {
        c = /rgba?\s*\(.+\)/i.exec(v);
        style[k + 'Color'] = c ? c[0] : 'transparent';
      }
    }
  }

  var abbr = {
    margin: ['marginTop', 'marginRight', 'marginBottom', 'marginLeft'],
    padding: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
    border: ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'],
    borderTop: ['borderTopWidth', 'borderTopStyle', 'borderTopColor'],
    borderRight: ['borderRightWidth', 'borderRightStyle', 'borderRightColor'],
    borderBottom: ['borderBottomWidth', 'borderBottomStyle', 'borderBottomColor'],
    borderLeft: ['borderLeftWidth', 'borderLeftStyle', 'borderLeftColor'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    background: ['backgroundColor', 'backgroundImage', 'backgroundRepeat', 'backgroundPosition'],
    backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
    flex: ['flexGrow', 'flexShrink', 'flexBasis'],
    translate: ['translateX', 'translateY'],
    translate3d: ['translateX', 'translateY', 'translateY'],
    scale: ['scaleX', 'scaleY'],
    scale3d: ['scaleX', 'scaleY', 'scaleZ'],
    rotate: ['rotateZ'],
    skew: ['skewX', 'skewY'],
    textStroke: ['textStrokeWidth', 'textStrokeColor', 'textStrokeOver'],
    toFull: function toFull(style, k) {
      var _this = this;

      var v = style[k];

      if (k === 'background') {
        // bg缩写多个时有color则必须是最后一个
        if (Array.isArray(v)) {
          var length = v.length;

          if (isNil$f(style.backgroundColor)) {
            var bgc = /^\s*((transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))/i.exec(v[length - 1]);

            if (bgc) {
              style.backgroundColor = bgc[0];
              v = v.slice(0, length - 1);
            }
          }

          var bgi = [];
          var bgr = [];
          var bgp = [];
          v.forEach(function (item) {
            if (isNil$f(style.backgroundImage)) {
              var gd = reg.gradient.exec(item);

              if (gd) {
                bgi.push(gd[0]);
                item = item.replace(gd[0], '');
              } else {
                var img = reg.img.exec(v);

                if (img) {
                  bgi.push(img[0]);
                  item = item.replace(img[0], '');
                }
              }
            }

            if (isNil$f(style.backgroundRepeat)) {
              var repeat = /(no-?)?repeat(-?[xy])?/i.exec(item);

              if (repeat) {
                bgr.push(repeat[0].toLowerCase());
              }
            }

            if (isNil$f(style.backgroundPosition)) {
              var position = item.match(reg.position);

              if (position) {
                bgp.push(position.join(' '));
              }
            }
          });

          if (bgi.length) {
            style.backgroundImage = bgi;
          }

          if (bgr.length) {
            style.backgroundRepeat = bgr;
          }

          if (bgp.length) {
            style.backgroundPosition = bgp;
            this.toFull(style, 'backgroundPosition');
          }
        } else {
          if (isNil$f(style.backgroundImage)) {
            var gd = reg.gradient.exec(v);

            if (gd) {
              style.backgroundImage = gd[0];
              v = v.replace(gd[0], '');
            } else {
              var img = reg.img.exec(v);

              if (img) {
                style.backgroundImage = img[0];
                v = v.replace(img[0], '');
              }
            }
          }

          if (isNil$f(style.backgroundRepeat)) {
            var repeat = /(no-?)?repeat(-?[xy])?/i.exec(v);

            if (repeat) {
              style.backgroundRepeat = repeat[0].toLowerCase();
            }
          }

          if (isNil$f(style.backgroundColor)) {
            var _bgc = /^(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

            if (_bgc) {
              style.backgroundColor = _bgc[0];
              v = v.replace(_bgc[0], '');
            }
          }

          if (isNil$f(style.backgroundPosition)) {
            var position = v.match(reg.position);

            if (position) {
              style.backgroundPosition = position.join(' ');
              this.toFull(style, 'backgroundPosition');
            }
          }
        }
      } else if (k === 'flex') {
        if (v === 'none') {
          parseFlex(style, 0, 0, 'auto');
        } else if (v === 'auto') {
          parseFlex(style, 1, 1, 'auto');
        } else if (/^[\d.]+\s+[\d.]+\s+(auto|none|content)/.test(v) || /^[\d.]+\s+[\d.]+\s+[\d.]+[pxremvwhina%]*/.test(v)) {
          var arr = v.split(/\s+/);
          parseFlex(style, parseFloat(arr[0]), parseFloat(arr[1]), arr[2]);
        } else if (/^[\d.]+\s+[\d.]+$/.test(v)) {
          var _arr = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr[0]), parseFloat(_arr[1]), 0);
        } else if (/^[\d.]+\s+[\d.]+[pxremvwhina%]+/.test(v)) {
          var _arr2 = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr2[0]), 1, _arr2[1]);
        } else if (/^[\d.]+$/.test(v)) {
          parseFlex(style, parseFloat(v), 1, 0);
        } else if (/^[\d.]+[pxremvwhina%]+/i.test(v)) {
          parseFlex(style, 1, 1, v);
        } else {
          parseFlex(style, 0, 1, 'auto');
        }
      } else if (k === 'flexFlow') {
        v = v.toString().split(/\s+/);

        if (v.length) {
          if (isNil$f(style.flexDirection)) ;

          style.flexDirection = v[0];

          if (v.length > 1) {
            style.flexWrap = v[1];
          }
        }
      } else if (k === 'borderRadius') {
        // borderRadius缩写很特殊，/分隔x/y，然后上右下左4个
        v = v.toString().split('/');

        if (v.length === 1) {
          v[1] = v[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = v[i].toString().split(/\s+/);

          if (item.length === 0) {
            v[i] = [0, 0, 0, 0];
          } else if (item.length === 1) {
            v[i] = [item[0], item[0], item[0], item[0]];
          } else if (item.length === 2) {
            v[i] = [item[0], item[1], item[0], item[1]];
          } else if (item.length === 3) {
            v[i] = [item[0], item[1], item[2], item[1]];
          } else {
            v[i] = item.slice(0, 4);
          }
        }

        this[k].forEach(function (k, i) {
          if (isNil$f(style[k])) {
            style[k] = v[0][i] + ' ' + v[1][i];
          }
        });
      } else if (k === 'backgroundPosition') {
        if (!Array.isArray(v)) {
          v = [v];
        }

        var isEmpty = this[k].map(function (k2) {
          return isNil$f(style[k2]);
        });
        v.forEach(function (v2) {
          v2 = v2.toString().split(/\s+/);

          if (v2.length === 1) {
            v2[1] = '50%';
          }

          _this[k].forEach(function (k2, i) {
            if (isEmpty[i]) {
              style[k2] = style[k2] || [];
              style[k2].push(v2[i]);
            }
          });
        });
      } else if (['translate', 'scale', 'skew'].indexOf(k) > -1) {
        var _arr3 = v.toString().split(/\s*,\s*/);

        if (_arr3.length === 1) {
          _arr3[1] = _arr3[0];
        }

        this[k].forEach(function (k, i) {
          if (isNil$f(style[k])) {
            style[k] = _arr3[i];
          }
        });
      } else if (['translate3d', 'scale3d'].indexOf(k) > -1) {
        var _arr4 = v.toString().split(/\s*,\s*/);

        if (_arr4.length === 1) {
          _arr4[2] = _arr4[1] = _arr4[0];
        } else if (_arr4.length === 2) {
          _arr4[2] = k === 'scale3d' ? 1 : 0;
        }

        this[k].forEach(function (k, i) {
          if (isNil$f(style[k])) {
            style[k] = _arr4[i];
          }
        });
      } else if (k === 'margin' || k === 'padding') {
        parseMarginPadding(style, k, this[k]);
      } else if (/^border((Top)|(Right)|(Bottom)|(Left))$/.test(k)) {
        parseOneBorder(style, k);
      } else if (k === 'textStroke') {
        var w = /(?:^|\s)([-+]?[\d.]+[pxremvwhina%]*)/.exec(v);

        if (w) {
          style.textStrokeWidth = w[1];
        }

        var c = /(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

        if (c) {
          style.textStrokeColor = c[0];
        }

        if (/\bfill\b/i.test(v)) {
          style.textStrokeOver = 'fill';
        } else {
          style.textStrokeOver = 'none';
        }
      } else if (this[k]) {
        this[k].forEach(function (k) {
          if (isNil$f(style[k])) {
            style[k] = v;
          }
        });
      }

      return style;
    }
  };

  var STYLE_KEY$3 = enums.STYLE_KEY;
  var BACKGROUND_COLOR$4 = STYLE_KEY$3.BACKGROUND_COLOR,
      BORDER_BOTTOM_COLOR$3 = STYLE_KEY$3.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR$3 = STYLE_KEY$3.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR$3 = STYLE_KEY$3.BORDER_RIGHT_COLOR,
      BORDER_TOP_COLOR$3 = STYLE_KEY$3.BORDER_TOP_COLOR,
      COLOR$8 = STYLE_KEY$3.COLOR,
      TEXT_STROKE_COLOR$7 = STYLE_KEY$3.TEXT_STROKE_COLOR,
      FONT_SIZE$a = STYLE_KEY$3.FONT_SIZE,
      BORDER_BOTTOM_WIDTH$6 = STYLE_KEY$3.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$9 = STYLE_KEY$3.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$8 = STYLE_KEY$3.BORDER_RIGHT_WIDTH,
      BORDER_TOP_WIDTH$7 = STYLE_KEY$3.BORDER_TOP_WIDTH,
      LEFT$4 = STYLE_KEY$3.LEFT,
      TOP$5 = STYLE_KEY$3.TOP,
      RIGHT$4 = STYLE_KEY$3.RIGHT,
      BOTTOM$5 = STYLE_KEY$3.BOTTOM,
      FLEX_BASIS$5 = STYLE_KEY$3.FLEX_BASIS,
      WIDTH$9 = STYLE_KEY$3.WIDTH,
      HEIGHT$9 = STYLE_KEY$3.HEIGHT,
      LINE_HEIGHT$8 = STYLE_KEY$3.LINE_HEIGHT,
      MARGIN_BOTTOM$7 = STYLE_KEY$3.MARGIN_BOTTOM,
      MARGIN_LEFT$9 = STYLE_KEY$3.MARGIN_LEFT,
      MARGIN_TOP$7 = STYLE_KEY$3.MARGIN_TOP,
      MARGIN_RIGHT$8 = STYLE_KEY$3.MARGIN_RIGHT,
      PADDING_TOP$7 = STYLE_KEY$3.PADDING_TOP,
      PADDING_RIGHT$8 = STYLE_KEY$3.PADDING_RIGHT,
      PADDING_BOTTOM$6 = STYLE_KEY$3.PADDING_BOTTOM,
      PADDING_LEFT$9 = STYLE_KEY$3.PADDING_LEFT,
      STROKE_WIDTH$a = STYLE_KEY$3.STROKE_WIDTH,
      STROKE_MITERLIMIT$3 = STYLE_KEY$3.STROKE_MITERLIMIT,
      LETTER_SPACING$5 = STYLE_KEY$3.LETTER_SPACING,
      PERSPECTIVE$6 = STYLE_KEY$3.PERSPECTIVE,
      TEXT_STROKE_WIDTH$7 = STYLE_KEY$3.TEXT_STROKE_WIDTH,
      TRANSLATE_X$6 = STYLE_KEY$3.TRANSLATE_X,
      TRANSLATE_Y$6 = STYLE_KEY$3.TRANSLATE_Y,
      TRANSLATE_Z$6 = STYLE_KEY$3.TRANSLATE_Z,
      SKEW_X$6 = STYLE_KEY$3.SKEW_X,
      SKEW_Y$6 = STYLE_KEY$3.SKEW_Y,
      SCALE_X$7 = STYLE_KEY$3.SCALE_X,
      SCALE_Y$7 = STYLE_KEY$3.SCALE_Y,
      SCALE_Z$5 = STYLE_KEY$3.SCALE_Z,
      ROTATE_X$6 = STYLE_KEY$3.ROTATE_X,
      ROTATE_Y$6 = STYLE_KEY$3.ROTATE_Y,
      ROTATE_Z$8 = STYLE_KEY$3.ROTATE_Z,
      BACKGROUND_IMAGE$4 = STYLE_KEY$3.BACKGROUND_IMAGE,
      FILL$5 = STYLE_KEY$3.FILL,
      STROKE$4 = STYLE_KEY$3.STROKE,
      BORDER_TOP_LEFT_RADIUS$4 = STYLE_KEY$3.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$4 = STYLE_KEY$3.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$4 = STYLE_KEY$3.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$4 = STYLE_KEY$3.BORDER_BOTTOM_LEFT_RADIUS;

  function isColorKey$2(k) {
    return k === BACKGROUND_COLOR$4 || k === BORDER_BOTTOM_COLOR$3 || k === BORDER_LEFT_COLOR$3 || k === BORDER_RIGHT_COLOR$3 || k === BORDER_TOP_COLOR$3 || k === COLOR$8 || k === TEXT_STROKE_COLOR$7;
  }

  function isLengthKey$2(k) {
    return k === FONT_SIZE$a || k === TEXT_STROKE_WIDTH$7 || k === BORDER_BOTTOM_WIDTH$6 || k === BORDER_LEFT_WIDTH$9 || k === BORDER_RIGHT_WIDTH$8 || k === BORDER_TOP_WIDTH$7 || k === LEFT$4 || k === TOP$5 || k === RIGHT$4 || k === BOTTOM$5 || k === FLEX_BASIS$5 || k === WIDTH$9 || k === HEIGHT$9 || k === LINE_HEIGHT$8 || k === MARGIN_BOTTOM$7 || k === MARGIN_TOP$7 || k === MARGIN_LEFT$9 || k === MARGIN_RIGHT$8 || k === PADDING_TOP$7 || k === PADDING_RIGHT$8 || k === PADDING_LEFT$9 || k === PADDING_BOTTOM$6 || k === STROKE_WIDTH$a || k === STROKE_MITERLIMIT$3 || k === LETTER_SPACING$5 || k === PERSPECTIVE$6;
  }

  function isExpandKey$2(k) {
    return k === TRANSLATE_X$6 || k === TRANSLATE_Y$6 || k === TRANSLATE_Z$6 || k === SKEW_X$6 || k === SKEW_Y$6 || k === SCALE_X$7 || k === SCALE_Y$7 || k === SCALE_Z$5 || k === ROTATE_X$6 || k === ROTATE_Y$6 || k === ROTATE_Z$8;
  }

  function isGradientKey$2(k) {
    return k === BACKGROUND_IMAGE$4 || k === FILL$5 || k === STROKE$4;
  }

  function isRadiusKey$2(k) {
    return k === BORDER_BOTTOM_LEFT_RADIUS$4 || k === BORDER_TOP_LEFT_RADIUS$4 || k === BORDER_TOP_RIGHT_RADIUS$4 || k === BORDER_BOTTOM_RIGHT_RADIUS$4;
  }

  var key = {
    isColorKey: isColorKey$2,
    isLengthKey: isLengthKey$2,
    isExpandKey: isExpandKey$2,
    isGradientKey: isGradientKey$2,
    isRadiusKey: isRadiusKey$2
  };

  var RESET_DOM = reset.DOM,
      RESET_GEOM = reset.GEOM;
  var STYLE_KEY$2 = enums.STYLE_KEY;
  var POINTER_EVENTS$3 = STYLE_KEY$2.POINTER_EVENTS,
      COLOR$7 = STYLE_KEY$2.COLOR,
      STROKE_WIDTH$9 = STYLE_KEY$2.STROKE_WIDTH,
      FILL$4 = STYLE_KEY$2.FILL,
      STROKE_DASHARRAY$2 = STYLE_KEY$2.STROKE_DASHARRAY,
      STROKE_LINECAP$1 = STYLE_KEY$2.STROKE_LINECAP,
      STROKE_LINEJOIN$1 = STYLE_KEY$2.STROKE_LINEJOIN,
      STROKE_MITERLIMIT$2 = STYLE_KEY$2.STROKE_MITERLIMIT,
      BACKGROUND_COLOR$3 = STYLE_KEY$2.BACKGROUND_COLOR,
      BACKGROUND_IMAGE$3 = STYLE_KEY$2.BACKGROUND_IMAGE,
      BACKGROUND_POSITION_X$4 = STYLE_KEY$2.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$4 = STYLE_KEY$2.BACKGROUND_POSITION_Y,
      BACKGROUND_REPEAT$1 = STYLE_KEY$2.BACKGROUND_REPEAT,
      BACKGROUND_SIZE$3 = STYLE_KEY$2.BACKGROUND_SIZE,
      STROKE$3 = STYLE_KEY$2.STROKE,
      BORDER_BOTTOM_COLOR$2 = STYLE_KEY$2.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR$2 = STYLE_KEY$2.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR$2 = STYLE_KEY$2.BORDER_RIGHT_COLOR,
      BORDER_TOP_COLOR$2 = STYLE_KEY$2.BORDER_TOP_COLOR,
      BORDER_TOP_LEFT_RADIUS$3 = STYLE_KEY$2.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$3 = STYLE_KEY$2.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$3 = STYLE_KEY$2.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$3 = STYLE_KEY$2.BORDER_BOTTOM_LEFT_RADIUS,
      VISIBILITY$6 = STYLE_KEY$2.VISIBILITY,
      BOX_SHADOW$3 = STYLE_KEY$2.BOX_SHADOW,
      OVERFLOW$4 = STYLE_KEY$2.OVERFLOW,
      BACKGROUND_CLIP$2 = STYLE_KEY$2.BACKGROUND_CLIP,
      TEXT_STROKE_WIDTH$6 = STYLE_KEY$2.TEXT_STROKE_WIDTH,
      TEXT_STROKE_COLOR$6 = STYLE_KEY$2.TEXT_STROKE_COLOR,
      TEXT_STROKE_OVER$5 = STYLE_KEY$2.TEXT_STROKE_OVER,
      TRANSLATE_PATH$2 = STYLE_KEY$2.TRANSLATE_PATH,
      TRANSFORM_STYLE$2 = STYLE_KEY$2.TRANSFORM_STYLE;
  var GEOM$3 = {};
  var GEOM_KEY_SET$1 = [];
  var o$2 = {
    GEOM: GEOM$3,
    GEOM_KEY_SET: GEOM_KEY_SET$1,
    addGeom: function addGeom(tagName, ks, cb) {
      if (Array.isArray(ks)) {
        ks.forEach(function (k) {
          o$2.addGeom(tagName, k, cb);
        });
      } else if (ks) {
        if (!GEOM$3.hasOwnProperty(ks)) {
          GEOM_KEY_SET$1.push(ks);
        }

        var hash = GEOM$3[ks] = GEOM$3[ks] || {};
        hash[tagName] = cb || true;
      }
    },
    isIgnore: function isIgnore(k) {
      return k === POINTER_EVENTS$3 || k === TRANSLATE_PATH$2;
    },
    isGeom: function isGeom(tagName, k) {
      return tagName && k && GEOM$3.hasOwnProperty(k) && GEOM$3[k].hasOwnProperty(tagName);
    },
    isRepaint: function isRepaint(k, tagName) {
      return k === COLOR$7 || k === STROKE_WIDTH$9 || k === FILL$4 || k === STROKE_DASHARRAY$2 || k === STROKE_LINECAP$1 || k === STROKE_LINEJOIN$1 || k === STROKE_MITERLIMIT$2 || k === BACKGROUND_COLOR$3 || k === BACKGROUND_IMAGE$3 || k === BACKGROUND_POSITION_X$4 || k === BACKGROUND_POSITION_Y$4 || k === BACKGROUND_REPEAT$1 || k === BACKGROUND_SIZE$3 || k === STROKE$3 || k === BORDER_BOTTOM_COLOR$2 || k === BORDER_LEFT_COLOR$2 || k === BORDER_BOTTOM_COLOR$2 || k === BORDER_RIGHT_COLOR$2 || k === BORDER_TOP_COLOR$2 || k === BORDER_TOP_LEFT_RADIUS$3 || k === BORDER_TOP_RIGHT_RADIUS$3 || k === BORDER_BOTTOM_RIGHT_RADIUS$3 || k === BORDER_BOTTOM_LEFT_RADIUS$3 || k === VISIBILITY$6 || k === BOX_SHADOW$3 || k === OVERFLOW$4 || k === BACKGROUND_CLIP$2 || k === TEXT_STROKE_WIDTH$6 || k === TEXT_STROKE_COLOR$6 || k === TEXT_STROKE_OVER$5 || k === TRANSFORM_STYLE$2 || o$2.isGeom(tagName, k);
    },
    isValid: function isValid(tagName, k) {
      if (!k) {
        return false;
      }

      if (RESET_DOM.hasOwnProperty(k)) {
        return true;
      } // geom的fill等矢量才有的样式


      if (tagName && tagName.charAt(0) === '$' && RESET_GEOM.hasOwnProperty(k)) {
        return true;
      }

      if (GEOM$3.hasOwnProperty(k)) {
        return tagName && GEOM$3[k].hasOwnProperty(tagName);
      }

      if (k === 'translatePath') {
        return true;
      }

      return false;
    }
  };
  o$2.addGeom('$line', ['xa', 'ya', 'xb', 'yb', 'controlA', 'controlB', 'start', 'end']);
  o$2.addGeom('$circle', ['r']);
  o$2.addGeom('$ellipse', ['rx', 'ry']);
  o$2.addGeom('$rect', ['rx', 'ry']);
  o$2.addGeom('$sector', ['begin', 'end', 'edge', 'closure']);
  o$2.addGeom('$polyline', ['points', 'controls', 'start', 'end']);
  o$2.addGeom('$polygon', ['points', 'controls', 'start', 'end', 'booleanOperations']);

  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据模糊参数sigma求卷积核尺寸
   * @param sigma
   * @returns {number}
   */
  function kernelSize(sigma) {
    if (sigma <= 0) {
      return 0;
    }

    var d = Math.floor(sigma * 3 * Math.sqrt(2 * Math.PI) / 4 + 0.5);

    if (d < 2) {
      d = 2;
    }

    if (d % 2 === 0) {
      d++;
    }

    return d;
  }
  /**
   * 根据sigma求模糊扩展尺寸，卷积核求得后为d，再求半径/2，然后因为算法要执行3次，所以*3
   * 比如本来d为5，半径2.5算上自身像素点则各方向扩展2，*3则扩展6
   * @param sigma
   * @returns {number}
   */


  function outerSize(sigma) {
    var d = kernelSize(sigma);
    return outerSizeByD(d);
  }

  function outerSizeByD(d) {
    return Math.floor(d * 0.5) * 3;
  }
  /**
   * 一维高斯正态分布，根据标准差和卷积核尺寸返回一维权重数组
   * @param sigma
   * @param d
   */


  function gaussianWeight(sigma, d) {
    var list = [];
    var len = Math.floor(d * 0.5);
    var total = 0;

    for (var i = len; i >= 0; i--) {
      var n = Math.pow(Math.E, -Math.pow(i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));
      list.push(n);
      total += n;
    }

    for (var _i = 1; _i <= len; _i++) {
      var _n = list[len - _i];
      list.push(_n);
      total += _n;
    }

    if (total !== 1) {
      for (var _i2 = 0; _i2 < d; _i2++) {
        list[_i2] /= total;
      }
    }

    return list;
  }

  var blur = {
    kernelSize: kernelSize,
    outerSize: outerSize,
    outerSizeByD: outerSizeByD,
    gaussianWeight: gaussianWeight
  };

  var STYLE_KEY$1 = enums.STYLE_KEY,
      style2Upper$1 = enums.style2Upper,
      _enums$STYLE_KEY$j = enums.STYLE_KEY,
      POSITION$5 = _enums$STYLE_KEY$j.POSITION,
      WIDTH$8 = _enums$STYLE_KEY$j.WIDTH,
      HEIGHT$8 = _enums$STYLE_KEY$j.HEIGHT,
      TRANSLATE_X$5 = _enums$STYLE_KEY$j.TRANSLATE_X,
      TRANSLATE_Y$5 = _enums$STYLE_KEY$j.TRANSLATE_Y,
      TRANSLATE_Z$5 = _enums$STYLE_KEY$j.TRANSLATE_Z,
      SCALE_X$6 = _enums$STYLE_KEY$j.SCALE_X,
      SCALE_Y$6 = _enums$STYLE_KEY$j.SCALE_Y,
      SCALE_Z$4 = _enums$STYLE_KEY$j.SCALE_Z,
      SKEW_X$5 = _enums$STYLE_KEY$j.SKEW_X,
      SKEW_Y$5 = _enums$STYLE_KEY$j.SKEW_Y,
      ROTATE_X$5 = _enums$STYLE_KEY$j.ROTATE_X,
      ROTATE_Y$5 = _enums$STYLE_KEY$j.ROTATE_Y,
      ROTATE_Z$7 = _enums$STYLE_KEY$j.ROTATE_Z,
      ROTATE_3D$4 = _enums$STYLE_KEY$j.ROTATE_3D,
      PERSPECTIVE$5 = _enums$STYLE_KEY$j.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$4 = _enums$STYLE_KEY$j.PERSPECTIVE_ORIGIN,
      TRANSFORM$6 = _enums$STYLE_KEY$j.TRANSFORM,
      TRANSFORM_ORIGIN$6 = _enums$STYLE_KEY$j.TRANSFORM_ORIGIN,
      BACKGROUND_IMAGE$2 = _enums$STYLE_KEY$j.BACKGROUND_IMAGE,
      BACKGROUND_COLOR$2 = _enums$STYLE_KEY$j.BACKGROUND_COLOR,
      BACKGROUND_POSITION_X$3 = _enums$STYLE_KEY$j.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$3 = _enums$STYLE_KEY$j.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE$2 = _enums$STYLE_KEY$j.BACKGROUND_SIZE,
      OPACITY$7 = _enums$STYLE_KEY$j.OPACITY,
      Z_INDEX$5 = _enums$STYLE_KEY$j.Z_INDEX,
      COLOR$6 = _enums$STYLE_KEY$j.COLOR,
      FONT_SIZE$9 = _enums$STYLE_KEY$j.FONT_SIZE,
      FONT_FAMILY$6 = _enums$STYLE_KEY$j.FONT_FAMILY,
      FONT_WEIGHT$6 = _enums$STYLE_KEY$j.FONT_WEIGHT,
      FONT_STYLE$4 = _enums$STYLE_KEY$j.FONT_STYLE,
      LINE_HEIGHT$7 = _enums$STYLE_KEY$j.LINE_HEIGHT,
      TEXT_ALIGN$3 = _enums$STYLE_KEY$j.TEXT_ALIGN,
      FILTER$6 = _enums$STYLE_KEY$j.FILTER,
      VISIBILITY$5 = _enums$STYLE_KEY$j.VISIBILITY,
      BOX_SHADOW$2 = _enums$STYLE_KEY$j.BOX_SHADOW,
      POINTER_EVENTS$2 = _enums$STYLE_KEY$j.POINTER_EVENTS,
      FILL$3 = _enums$STYLE_KEY$j.FILL,
      STROKE$2 = _enums$STYLE_KEY$j.STROKE,
      STROKE_WIDTH$8 = _enums$STYLE_KEY$j.STROKE_WIDTH,
      STROKE_DASHARRAY$1 = _enums$STYLE_KEY$j.STROKE_DASHARRAY,
      FLEX_BASIS$4 = _enums$STYLE_KEY$j.FLEX_BASIS,
      MATRIX$4 = _enums$STYLE_KEY$j.MATRIX,
      LETTER_SPACING$4 = _enums$STYLE_KEY$j.LETTER_SPACING,
      WHITE_SPACE$3 = _enums$STYLE_KEY$j.WHITE_SPACE,
      LINE_CLAMP$2 = _enums$STYLE_KEY$j.LINE_CLAMP,
      ORDER$2 = _enums$STYLE_KEY$j.ORDER,
      TRANSLATE_PATH$1 = _enums$STYLE_KEY$j.TRANSLATE_PATH,
      TEXT_STROKE_COLOR$5 = _enums$STYLE_KEY$j.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$5 = _enums$STYLE_KEY$j.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$4 = _enums$STYLE_KEY$j.TEXT_STROKE_OVER,
      WRITING_MODE$3 = _enums$STYLE_KEY$j.WRITING_MODE,
      FONT_SIZE_SHRINK$2 = _enums$STYLE_KEY$j.FONT_SIZE_SHRINK;
  var AUTO$7 = o$4.AUTO,
      PX$8 = o$4.PX,
      PERCENT$7 = o$4.PERCENT,
      NUMBER$4 = o$4.NUMBER,
      INHERIT$3 = o$4.INHERIT,
      DEG$3 = o$4.DEG,
      RGBA$3 = o$4.RGBA,
      STRING$2 = o$4.STRING,
      EM = o$4.EM,
      REM$7 = o$4.REM,
      VW$7 = o$4.VW,
      VH$7 = o$4.VH,
      VMAX$7 = o$4.VMAX,
      VMIN$7 = o$4.VMIN,
      GRADIENT$3 = o$4.GRADIENT,
      calUnit$1 = o$4.calUnit;
  var isNil$e = util.isNil,
      rgba2int$1 = util.rgba2int,
      equalArr$1 = util.equalArr,
      equal = util.equal,
      replaceRgba2Hex = util.replaceRgba2Hex;
  var isGeom$1 = o$2.isGeom,
      GEOM$2 = o$2.GEOM,
      GEOM_KEY_SET = o$2.GEOM_KEY_SET;
  var VALID_STRING_VALUE = reset.VALID_STRING_VALUE;
  var isColorKey$1 = key.isColorKey,
      isExpandKey$1 = key.isExpandKey,
      isLengthKey$1 = key.isLengthKey,
      isGradientKey$1 = key.isGradientKey,
      isRadiusKey$1 = key.isRadiusKey;

  function isGradient(s) {
    if (reg.gradient.test(s)) {
      var _gradient = reg.gradient.exec(s);

      if (_gradient && ['linear', 'radial', 'conic'].indexOf(_gradient[1]) > -1) {
        return true;
      }
    }
  }

  var TRANSFORM_HASH = {
    translateX: TRANSLATE_X$5,
    translateY: TRANSLATE_Y$5,
    translateZ: TRANSLATE_Z$5,
    scaleX: SCALE_X$6,
    scaleY: SCALE_Y$6,
    scaleZ: SCALE_Z$4,
    skewX: SKEW_X$5,
    skewY: SKEW_Y$5,
    rotateX: ROTATE_X$5,
    rotateY: ROTATE_Y$5,
    rotateZ: ROTATE_Z$7,
    rotate: ROTATE_Z$7
  };

  function compatibleTransform(k, arr) {
    if (k === SCALE_X$6 || k === SCALE_Y$6 || k === SCALE_Z$4) {
      arr.u = NUMBER$4;
    } else if (k === TRANSLATE_X$5 || k === TRANSLATE_Y$5 || k === TRANSLATE_Z$5) {
      if (arr.u === NUMBER$4) {
        arr.u = PX$8;
      }
    } else if (k === PERSPECTIVE$5) {
      if ([NUMBER$4, PERCENT$7, DEG$3].indexOf(arr.u) > -1) {
        arr.u = PX$8;
      }
    } else {
      if (arr.u === NUMBER$4) {
        arr.u = DEG$3;
      }
    }
  }

  function camel(v) {
    if (isNil$e(v)) {
      v = '';
    }

    v = v.toString(); //有-才转换，否则可能是写好的驼峰

    if (v.indexOf('-') > -1) {
      return v.toString().toLowerCase().replace(/-([a-z])/ig, function ($0, $1) {
        return $1.toUpperCase();
      });
    }

    return v;
  }

  function convertStringValue(k, v) {
    v = camel(v);
    var list = VALID_STRING_VALUE[k];
    var i = list.indexOf(v);

    if (i > -1) {
      return list[i];
    } // 兜底默认


    return list[0];
  }
  /**
   * 将传入的手写style标准化，并且用resetList默认值覆盖其中为空的
   * @param style 手写的style样式
   * @param resetList 默认样式，可选
   * @returns Object 标准化的枚举数组结构样式
   */


  function normalize$1(style) {
    var resetList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!util.isObject(style)) {
      return {};
    }

    var res = {}; // style只有单层无需深度clone

    style = util.extend({}, style); // 缩写提前处理，因为reset里没有缩写

    var temp = style.border;

    if (temp) {
      abbr.toFull(style, 'border');
    }

    ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'].forEach(function (k) {
      abbr.toFull(style, k);
    });
    temp = style.borderWidth;

    if (temp) {
      abbr.toFull(style, 'borderWidth');
    }

    temp = style.borderColor;

    if (temp) {
      abbr.toFull(style, 'borderColor');
    }

    temp = style.borderStyle;

    if (temp) {
      abbr.toFull(style, 'borderStyle');
    }

    temp = style.borderRadius;

    if (temp) {
      abbr.toFull(style, 'borderRadius');
    }

    temp = style.background; // 处理渐变背景缩写

    if (temp) {
      abbr.toFull(style, 'background');
    } // 背景位置


    temp = style.backgroundPosition;

    if (!isNil$e(temp)) {
      abbr.toFull(style, 'backgroundPosition');
    } // flex


    temp = style.flex;

    if (temp) {
      abbr.toFull(style, 'flex');
    } // flex-flow


    temp = style.flexFlow;

    if (temp) {
      abbr.toFull(style, 'flexFlow');
    }

    temp = style.margin;

    if (!isNil$e(temp)) {
      abbr.toFull(style, 'margin');
    }

    temp = style.padding;

    if (!isNil$e(temp)) {
      abbr.toFull(style, 'padding');
    }

    temp = style.textStroke;

    if (temp) {
      abbr.toFull(style, 'textStroke');
    }

    temp = style.rotate3d;

    if (temp) {
      abbr.toFull(style, 'rotate3d');
    } // 扩展css，将transform几个值拆分为独立的css为动画准备，同时不能使用transform


    ['translate', 'scale', 'skew', 'translate3d', 'scale3d', 'rotate'].forEach(function (k) {
      temp = style[k];

      if (!isNil$e(temp)) {
        abbr.toFull(style, k);
      }
    }); // 扩展的不能和transform混用，给出警告

    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate3d'].forEach(function (k) {
      var v = style[k];

      if (v !== undefined && style.transform) {
        inject.warn("Can not use expand style \"".concat(k, "\" with transform"));
      }
    }); // 默认reset，根据传入不同，当style为空时覆盖

    resetList.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (isNil$e(style[k])) {
        style[k] = v;
      }
    }); // 背景图

    temp = style.backgroundImage;

    if (temp !== undefined) {
      if (!temp) {
        res[BACKGROUND_IMAGE$2] = [];
      } else if (Array.isArray(temp)) {
        res[BACKGROUND_IMAGE$2] = temp.map(function (item) {
          if (!item) {
            return null;
          }

          if (isGradient(item)) {
            return {
              v: gradient.parseGradient(item),
              u: GRADIENT$3
            };
          }

          if (reg.img.test(item)) {
            return {
              v: reg.img.exec(item)[2],
              u: STRING$2
            };
          }

          return null;
        });
      } // 区分是渐变色还是图
      else if (isGradient(temp)) {
        res[BACKGROUND_IMAGE$2] = [{
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        }];
      } else if (reg.img.test(temp)) {
        res[BACKGROUND_IMAGE$2] = [{
          v: reg.img.exec(temp)[2],
          u: STRING$2
        }];
      } else {
        res[BACKGROUND_IMAGE$2] = [];
      }
    }

    temp = style.backgroundColor;

    if (temp !== undefined) {
      temp = temp || 'transparent'; // 先赋值默认透明，后续操作有合法值覆盖

      var bgc = /^#[0-9a-f]{3,8}/i.exec(temp);

      if (bgc && [4, 7, 9].indexOf(bgc[0].length) > -1) {
        res[BACKGROUND_COLOR$2] = {
          v: rgba2int$1(bgc[0]),
          u: RGBA$3
        };
      } else {
        bgc = /rgba?\s*\(.+\)/i.exec(temp);
        res[BACKGROUND_COLOR$2] = {
          v: rgba2int$1(bgc ? bgc[0] : [0, 0, 0, 0]),
          u: RGBA$3
        };
      }
    }

    ['backgroundPositionX', 'backgroundPositionY'].forEach(function (k, i) {
      temp = style[k];

      if (temp !== undefined) {
        temp = temp || 0;
        k = i ? BACKGROUND_POSITION_Y$3 : BACKGROUND_POSITION_X$3;

        if (!Array.isArray(temp)) {
          temp = [temp];
        }

        res[k] = temp.map(function (item) {
          if (/^[-+]?[\d.]/.test(item)) {
            var v = calUnit$1(item);

            if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
              v.u = PX$8;
            }

            return v;
          } else {
            return {
              v: {
                top: 0,
                left: 0,
                center: 50,
                right: 100,
                bottom: 100
              }[item] || 0,
              u: PERCENT$7
            };
          }
        });
      }
    }); // 背景尺寸

    temp = style.backgroundSize;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[BACKGROUND_SIZE$2] = temp.map(function (item) {
        if (!item) {
          return [{
            u: AUTO$7
          }, {
            u: AUTO$7
          }];
        }

        var match = item.toString().match(/\b(?:([-+]?[\d.]+[pxremvwhina%]*)|(contain|cover|auto))/ig);

        if (match) {
          if (match.length === 1) {
            if (match[0].toLowerCase() === 'contain' || match[0].toLowerCase() === 'cover') {
              match[1] = match[0].toLowerCase();
            } else {
              match[1] = 'auto';
            }
          }

          var v = [];

          for (var i = 0; i < 2; i++) {
            var _item = match[i].toLowerCase();

            if (/^[-+]?[\d.]/.test(_item)) {
              var n = calUnit$1(_item);

              if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
                n.u = PX$8;
              }

              v.push(n);
            } else if (_item === 'contain' || _item === 'cover') {
              v.push({
                v: _item,
                u: STRING$2
              });
            } else {
              v.push({
                u: AUTO$7
              });
            }
          }

          return v;
        } else {
          return [{
            u: AUTO$7
          }, {
            u: AUTO$7
          }];
        }
      });
    } // border-color


    ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
      k = 'border' + k + 'Color';
      var v = style[k];

      if (v !== undefined) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = {
          v: rgba2int$1(v || 'transparent'),
          u: RGBA$3
        };
      }
    }); // border-radius

    ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].forEach(function (k) {
      k = 'border' + k + 'Radius';
      var v = style[k];

      if (v !== undefined) {
        v = v || 0;
        var arr = v.toString().split(/\s+/);

        if (arr.length === 1) {
          arr[1] = arr[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = arr[i];

          if (/^[-+]?[\d.]/.test(item)) {
            var n = calUnit$1(item);

            if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
              n.u = PX$8;
            }

            if (n.v < 0) {
              n.v = 0;
            }

            arr[i] = n;
          } else {
            arr[i] = {
              u: 0,
              v: PX$8
            };
          }
        }

        res[STYLE_KEY$1[style2Upper$1(k)]] = arr;
      }
    });
    temp = style.transform;

    if (temp !== undefined) {
      var transform = res[TRANSFORM$6] = [];
      var match = (temp || '').toString().match(/\w+\(.+?\)/g);

      if (match) {
        match.forEach(function (item) {
          var i = item.indexOf('(');
          var k = item.slice(0, i);
          var v = item.slice(i + 1, item.length - 1);

          if (k === 'matrix') {
            var arr = v.toString().split(/\s*,\s*/);
            arr = arr.map(function (item) {
              return parseFloat(item);
            });

            if (arr.length > 6) {
              arr = arr.slice(0, 6);
            }

            if (arr.length === 6) {
              transform.push({
                k: MATRIX$4,
                v: [arr[0], arr[1], 0, 0, arr[2], arr[3], 0, 0, 0, 0, 1, 0, arr[4], arr[5], 0, 1]
              });
            }
          } else if (k === 'matrix3d') {
            var _arr = v.toString().split(/\s*,\s*/);

            _arr = _arr.map(function (item) {
              return parseFloat(item);
            });

            if (_arr.length > 16) {
              _arr = _arr.slice(0, 16);
            }

            if (_arr.length === 16) {
              transform.push({
                k: MATRIX$4,
                v: _arr
              });
            }
          } else if (k === 'perspective') {
            var _arr2 = calUnit$1(v);

            if (_arr2.v < 0) {
              _arr2.v = 0;
            }

            compatibleTransform(PERSPECTIVE$5, _arr2);
            transform.push({
              k: PERSPECTIVE$5,
              v: _arr2
            });
          } else if (k === 'rotate3d') {
            var _arr3 = v.toString().split(/\s*,\s*/);

            if (_arr3.length === 4) {
              var deg = calUnit$1(_arr3[3]);
              compatibleTransform(ROTATE_3D$4, deg);
              _arr3[0] = parseFloat(_arr3[0].replace('(', ''));
              _arr3[1] = parseFloat(_arr3[1]);
              _arr3[2] = parseFloat(_arr3[2]);
              _arr3[3] = deg;
              transform.push({
                k: ROTATE_3D$4,
                v: _arr3
              });
            }
          } else if (TRANSFORM_HASH.hasOwnProperty(k)) {
            var k2 = TRANSFORM_HASH[k];

            var _arr4 = calUnit$1(v);

            compatibleTransform(k2, _arr4);
            transform.push({
              k: k2,
              v: _arr4
            });
          } else if ({
            translate: true,
            scale: true,
            skew: true
          }.hasOwnProperty(k)) {
            var _arr5 = v.toString().split(/\s*,\s*/);

            if (_arr5.length === 1) {
              _arr5[1] = k === 'scale' ? _arr5[0] : [0];
            }

            if (_arr5.length === 2) {
              var k1 = STYLE_KEY$1[style2Upper$1(k + 'X')];
              var _k = STYLE_KEY$1[style2Upper$1(k + 'Y')];
              var arr1 = calUnit$1(_arr5[0]);
              var arr2 = calUnit$1(_arr5[1]);
              compatibleTransform(k1, arr1);
              compatibleTransform(_k, arr2);
              transform.push({
                k: k1,
                v: arr1
              });
              transform.push({
                k: _k,
                v: arr2
              });
            }
          } else if ({
            translate3d: true,
            scale3d: true
          }.hasOwnProperty(k)) {
            var _arr6 = v.toString().split(/\s*,\s*/);

            if (_arr6.length === 1) {
              _arr6[1] = k === 'scale3d' ? [1] : [0];
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            } else if (_arr6.length === 2) {
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            }

            if (_arr6.length === 3) {
              var _k2 = STYLE_KEY$1[style2Upper$1(k + 'X')];
              var _k3 = STYLE_KEY$1[style2Upper$1(k + 'Y')];
              var k3 = STYLE_KEY$1[style2Upper$1(k + 'Z')];

              var _arr7 = calUnit$1(_arr6[0]);

              var _arr8 = calUnit$1(_arr6[1]);

              var arr3 = calUnit$1(_arr6[2]);
              compatibleTransform(_k2, _arr7);
              compatibleTransform(_k3, _arr8);
              compatibleTransform(k3, arr3);
              transform.push({
                k: _k2,
                v: _arr7
              });
              transform.push({
                k: _k3,
                v: _arr8
              });
              transform.push({
                k: k3,
                v: arr3
              });
            }
          }
        });
      }
    }

    temp = style.perspective;

    if (temp !== undefined) {
      var arr = calUnit$1(temp || 0);

      if (arr.v < 0) {
        arr.v = 0;
      }

      compatibleTransform(PERSPECTIVE$5, arr);
      res[PERSPECTIVE$5] = arr;
    }

    ['perspectiveOrigin', 'transformOrigin'].forEach(function (k) {
      temp = style[k];

      if (temp !== undefined) {
        if (temp === null) {
          temp = '';
        }

        var _arr9 = res[STYLE_KEY$1[style2Upper$1(k)]] = [];

        var _match = temp.toString().match(reg.position);

        if (_match) {
          if (_match.length === 1) {
            _match[1] = _match[0];
          }

          for (var i = 0; i < 2; i++) {
            var item = _match[i];

            if (/^[-+]?[\d.]/.test(item)) {
              var n = calUnit$1(item);

              if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
                n.u = PX$8;
              }

              _arr9.push(n);
            } else {
              _arr9.push({
                v: {
                  top: 0,
                  left: 0,
                  center: 50,
                  right: 100,
                  bottom: 100
                }[item],
                u: PERCENT$7
              }); // 不规范的写法变默认值50%


              if (isNil$e(_arr9[i].v)) {
                _arr9[i].v = 50;
              }
            }
          }
        } else {
          _arr9.push({
            v: 50,
            u: PERCENT$7
          });

          _arr9.push({
            v: 50,
            u: PERCENT$7
          });
        }
      }
    });
    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      if (v === null) {
        if (k.indexOf('scale') === 0) {
          v = 1;
        } else {
          v = 0;
        }
      }

      var k2 = TRANSFORM_HASH[k];
      var n = calUnit$1(v); // 没有单位或默认值处理单位

      compatibleTransform(k2, n);
      res[k2] = n;
    });
    temp = style.rotate3d;

    if (temp !== undefined) {
      var _arr10 = (temp || '').toString().split(/\s*,\s*/);

      if (_arr10.length === 4) {
        var deg = calUnit$1(_arr10[3]);
        compatibleTransform(ROTATE_3D$4, deg);
        _arr10[0] = parseFloat(_arr10[0].replace('(', ''));
        _arr10[1] = parseFloat(_arr10[1]);
        _arr10[2] = parseFloat(_arr10[2]);
        _arr10[3] = deg;
      }

      res[ROTATE_3D$4] = _arr10;
    }

    temp = style.opacity;

    if (temp !== undefined) {
      if (temp === null) {
        temp = 1;
      }

      temp = parseFloat(temp);

      if (!isNaN(temp)) {
        temp = Math.max(temp, 0);
        temp = Math.min(temp, 1);
        res[OPACITY$7] = temp;
      } else {
        res[OPACITY$7] = 1;
      }
    }

    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX$5] = parseInt(temp) || 0;
    } // 转化不同单位值为对象标准化，不写单位的变成number单位转化为px


    ['marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'top', 'right', 'bottom', 'left', 'width', 'height'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      v = calUnit$1(v || 0); // 无单位视为px

      if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
        v.u = PX$8;
      }

      var k2 = STYLE_KEY$1[style2Upper$1(k)];
      res[k2] = v; // 限制padding/border为正数

      if ({
        paddingTop: true,
        paddingRight: true,
        paddingBottom: true,
        paddingLeft: true,
        borderTopWidth: true,
        borderRightWidth: true,
        borderBottomWidth: true,
        borderLeftWidth: true,
        width: true,
        height: true
      }.hasOwnProperty(k) && v.v < 0) {
        v.v = 0;
      }
    });
    temp = style.flexBasis;

    if (temp !== undefined) {
      if (/content/i.test(temp)) {
        res[FLEX_BASIS$4] = {
          v: temp.toLowerCase(),
          u: STRING$2
        };
      } else if (/^[\d.]/.test(temp)) {
        var v = res[FLEX_BASIS$4] = calUnit$1(temp);
        v.v = Math.max(v.v, 0); // 无单位视为px

        if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
          v.u = PX$8;
        }
      } else {
        res[FLEX_BASIS$4] = {
          v: 0,
          u: AUTO$7
        };
      }
    }

    temp = style.order;

    if (temp !== undefined) {
      res[ORDER$2] = parseInt(temp) || 0;
    }

    temp = style.color;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[COLOR$6] = {
          u: INHERIT$3
        };
      } else if (isGradient(temp)) {
        res[COLOR$6] = {
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        };
      } else {
        res[COLOR$6] = {
          v: rgba2int$1(temp),
          u: RGBA$3
        };
      }
    }

    temp = style.textStrokeColor;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_COLOR$5] = {
          u: INHERIT$3
        };
      } else if (isGradient(temp)) {
        res[TEXT_STROKE_COLOR$5] = {
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        };
      } else {
        res[TEXT_STROKE_COLOR$5] = {
          v: rgba2int$1(temp),
          u: RGBA$3
        };
      }
    }

    temp = style.fontSize;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[FONT_SIZE$9] = {
          u: INHERIT$3
        };
      } else {
        var _v = calUnit$1(temp); // fontSize不能为非正数，否则为继承


        if (_v.v <= 0) {
          res[FONT_SIZE$9] = {
            u: INHERIT$3
          };
        } else {
          if ([NUMBER$4, DEG$3, EM].indexOf(_v.u) > -1) {
            // v.v = Math.floor(v.v); // 防止小数
            _v.u = PX$8;
          }

          res[FONT_SIZE$9] = _v;
        }
      }
    }

    temp = style.fontSizeShrink;

    if (temp !== undefined) {
      var _v2 = calUnit$1(temp); // 不能为非正数，否则为0


      if (_v2.v <= 0) {
        res[FONT_SIZE_SHRINK$2] = {
          v: 0,
          u: PX$8
        };
      } else {
        if ([NUMBER$4, DEG$3, EM].indexOf(_v2.u) > -1) {
          _v2.v = Math.floor(_v2.v); // 防止小数

          _v2.u = PX$8;
        }

        res[FONT_SIZE_SHRINK$2] = _v2;
      }
    }

    temp = style.textStrokeWidth;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_WIDTH$5] = {
          u: INHERIT$3
        };
      } else {
        var _v3 = calUnit$1(temp); // textStrokeWidth不能为负数，否则为继承


        if (_v3.v < 0) {
          res[TEXT_STROKE_WIDTH$5] = {
            u: INHERIT$3
          };
        } else {
          if ([NUMBER$4, DEG$3, PERCENT$7].indexOf(_v3.u) > -1) {
            _v3.u = PX$8;
          }

          res[TEXT_STROKE_WIDTH$5] = _v3;
        }
      }
    }

    temp = style.textStrokeOver;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_STROKE_OVER$4] = {
          u: INHERIT$3
        };
      } else {
        var _v4 = reset.INHERIT.textStrokeOver;

        if (/fill/i.test(temp)) {
          _v4 = 'fill';
        }

        res[TEXT_STROKE_OVER$4] = {
          v: _v4,
          u: STRING$2
        };
      }
    }

    temp = style.fontWeight;

    if (temp !== undefined) {
      if (/bold/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 700,
          u: NUMBER$4
        };
      } else if (/bolder/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 900,
          u: NUMBER$4
        };
      } else if (/normal/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 400,
          u: NUMBER$4
        };
      } else if (/lighter/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 300,
          u: NUMBER$4
        };
      } else if (/inherit/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          u: INHERIT$3
        };
      } else {
        res[FONT_WEIGHT$6] = {
          v: Math.min(900, Math.max(100, parseInt(temp)) || 400),
          u: NUMBER$4
        };
      }
    }

    temp = style.fontStyle;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_STYLE$4] = {
          u: INHERIT$3
        };
      } else {
        var _v5 = reset.INHERIT.fontStyle;

        if (/italic/i.test(temp)) {
          _v5 = 'italic';
        } else if (/oblique/i.test(temp)) {
          _v5 = 'oblique';
        }

        res[FONT_STYLE$4] = {
          v: _v5,
          u: STRING$2
        };
      }
    }

    temp = style.fontFamily;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_FAMILY$6] = {
          u: INHERIT$3
        };
      } else {
        // 统一文字声明格式
        res[FONT_FAMILY$6] = {
          v: temp.toString().trim().toLowerCase().replace(/['"]/g, '').replace(/\s*,\s*/g, ','),
          u: STRING$2
        };
      }
    }

    temp = style.writingMode;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WRITING_MODE$3] = {
          u: INHERIT$3
        };
      } else {
        var _v6 = reset.INHERIT.writingMode;

        if (/vertical-?rl/i.test(temp)) {
          _v6 = 'verticalRl';
        } else if (/vertical-?lr/i.test(temp)) {
          _v6 = 'verticalLr';
        }

        res[WRITING_MODE$3] = {
          v: _v6,
          u: STRING$2
        };
      }
    }

    temp = style.textAlign;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_ALIGN$3] = {
          u: INHERIT$3
        };
      } else {
        var _v7 = 'left';

        if (/center/i.test(temp)) {
          _v7 = 'center';
        } else if (/right/i.test(temp)) {
          _v7 = 'right';
        }

        res[TEXT_ALIGN$3] = {
          v: _v7,
          u: STRING$2
        };
      }
    }

    temp = style.lineHeight;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[LINE_HEIGHT$7] = {
          u: INHERIT$3
        };
      } else if (/normal/i.test(temp)) {
        res[LINE_HEIGHT$7] = {
          u: AUTO$7
        };
      } // lineHeight默认数字，想要px必须强制带单位
      else if (/^[\d.]+/i.test(temp)) {
        var _v8 = calUnit$1(temp);

        if ([DEG$3].indexOf(_v8.u) > -1) {
          _v8.u = NUMBER$4;
        }

        res[LINE_HEIGHT$7] = _v8;
      } else {
        var n = Math.max(0, parseFloat(temp)) || 'normal'; // 非法数字

        if (n === 'normal') {
          res[LINE_HEIGHT$7] = {
            u: AUTO$7
          };
        } else {
          res[LINE_HEIGHT$7] = {
            v: n,
            u: NUMBER$4
          };
        }
      }
    }

    temp = style.letterSpacing;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[LETTER_SPACING$4] = {
          u: INHERIT$3
        };
      } else if (/normal/i.test(temp)) {
        res[LETTER_SPACING$4] = {
          v: 0,
          u: PX$8
        };
      } else if (/^[-+]?[\d.]/.test(temp)) {
        var _v9 = calUnit$1(temp);

        if ([NUMBER$4, DEG$3].indexOf(_v9.u) > -1) {
          _v9.u = PX$8;
        }

        res[LETTER_SPACING$4] = _v9;
      } else {
        res[LETTER_SPACING$4] = {
          v: parseFloat(temp) || 0,
          u: PX$8
        };
      }
    }

    temp = style.whiteSpace;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WHITE_SPACE$3] = {
          u: INHERIT$3
        };
      } else {
        res[WHITE_SPACE$3] = {
          v: temp,
          u: STRING$2
        };
      }
    }

    temp = style.lineClamp;

    if (temp !== undefined) {
      temp = parseInt(temp) || 0;
      res[LINE_CLAMP$2] = Math.max(0, temp);
    } // fill和stroke为渐变时特殊处理，fillRule无需处理字符串


    ['fill', 'stroke'].forEach(function (k, i) {
      temp = style[k];

      if (temp !== undefined) {
        k = i ? STROKE$2 : FILL$3;

        if (!Array.isArray(temp)) {
          temp = [temp];
        }

        res[k] = temp.map(function (item) {
          if (!item) {
            return {
              v: 'none',
              u: STRING$2
            };
          } else if (isGradient(item)) {
            return {
              v: gradient.parseGradient(item),
              u: GRADIENT$3
            };
          } else {
            return {
              v: rgba2int$1(item),
              u: RGBA$3
            };
          }
        });
      }
    });
    temp = style.strokeWidth;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[STROKE_WIDTH$8] = temp.map(function (item) {
        var v = calUnit$1(item);

        if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
          v.u = PX$8;
        }

        v.v = Math.max(v.v, 0);
        return v;
      });
    }

    temp = style.strokeDasharray;

    if (temp !== undefined) {
      if (Array.isArray(temp)) {
        res[STROKE_DASHARRAY$1] = temp.map(function (item) {
          var match = (item || '').toString().match(/[\d.]+/g);

          if (match) {
            match = match.map(function (item) {
              return parseFloat(item);
            });

            if (match.length % 2 === 1) {
              match.push(match[match.length - 1]);
            }

            return match;
          }

          return [];
        });
      } else {
        var _match2 = (temp || '').toString().match(/[\d.]+/g);

        if (_match2) {
          _match2 = _match2.map(function (item) {
            return parseFloat(item);
          });

          if (_match2.length % 2 === 1) {
            _match2.push(_match2[_match2.length - 1]);
          }

          res[STROKE_DASHARRAY$1] = [_match2];
        } else {
          res[STROKE_DASHARRAY$1] = [[]];
        }
      }
    } // filter支持数组形式


    temp = style.filter;

    if (temp !== undefined) {
      var f = []; // 先替换掉rgba为#RGBA格式，然后分割

      var _arr11;

      if (Array.isArray(temp)) {
        _arr11 = temp.map(function (item) {
          return (replaceRgba2Hex(item) || '').match(/[\w-]+\s*\(.+?\)/ig);
        });
      } else {
        _arr11 = (replaceRgba2Hex(temp) || '').match(/[\w-]+\s*\(.+?\)/ig);
      }

      if (_arr11) {
        _arr11.forEach(function (item) {
          var match = /([\w-]+)\s*\((\s*.+\s*)\)/i.exec(item);

          if (match) {
            var k = match[1].toLowerCase(),
                _v10 = match[2];

            if (k === 'drop-shadow' || k === 'dropshadow') {
              var coords = /([-+]?[\d.]+[pxremvwhina%]*)[\s,]+([-+]?[\d.]+[pxremvwhina%]*)[\s,]+(?:([-+]?[\d.]+[pxremvwhina%]*)[\s,])?([-+]?[\d.]+[pxremvwhina%]*\s*)?/ig.exec(item);

              if (coords) {
                var _res = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

                for (var i = 1; i <= 4; i++) {
                  var item2 = coords[i];

                  if (item2) {
                    var _v11 = calUnit$1(item2);

                    if ([NUMBER$4, DEG$3].indexOf(_v11.u) > -1) {
                      _v11.u = PX$8;
                    } // x/y可以负，blur和spread不行


                    if (i > 2 && _v11.v < 0) {
                      _v11.v = 0;
                    }

                    _res.push(_v11);
                  } else {
                    _res.push({
                      v: 0,
                      u: PX$8
                    });
                  }
                }

                var color = /#[a-f\d]{3,8}/i.exec(item);

                if (color) {
                  _res.push(rgba2int$1(color[0]));
                } else {
                  _res.push([0, 0, 0, 1]);
                }

                f.push({
                  k: 'dropShadow',
                  v: _res
                });
              }
            } else {
              var m2 = /([-+]?[\d.]+\s*[pxremvwhdg%]*)/i.exec(_v10);

              if (m2) {
                var _v12 = calUnit$1(m2[0]);

                if (k === 'blur') {
                  if ([DEG$3, PERCENT$7].indexOf(_v12.u) > -1) {
                    return;
                  }

                  if (_v12.u === NUMBER$4) {
                    _v12.u = PX$8;
                  }

                  _v12.v = Math.max(_v12.v, 0);
                  f.push({
                    k: k,
                    v: _v12
                  });
                } else if (k === 'hue-rotate' || k === 'huerotate') {
                  if ([NUMBER$4, DEG$3].indexOf(_v12.u) === -1) {
                    return;
                  }

                  _v12.u = DEG$3;
                  f.push({
                    k: 'hueRotate',
                    v: _v12
                  });
                } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
                  if ([NUMBER$4, PERCENT$7].indexOf(_v12.u) === -1) {
                    return;
                  }

                  _v12.v = Math.max(_v12.v, 0);
                  _v12.u = PERCENT$7;
                  f.push({
                    k: k,
                    v: _v12
                  });
                }
              }
            }
          }
        });
      }

      res[FILTER$6] = f;
    }

    temp = style.visibility;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[VISIBILITY$5] = {
          u: INHERIT$3
        };
      } else {
        var _v13 = reset.INHERIT.visibility;

        if (/hidden/i.test(temp)) {
          _v13 = 'hidden';
        }

        res[VISIBILITY$5] = {
          v: _v13,
          u: STRING$2
        };
      }
    }

    temp = style.pointerEvents;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp) || /auto/i.test(temp)) {
        res[POINTER_EVENTS$2] = {
          u: INHERIT$3
        };
      } else {
        var _v14 = reset.INHERIT.pointerEvents;

        if (/none/i.test(temp)) {
          _v14 = 'none';
        }

        res[POINTER_EVENTS$2] = {
          v: _v14,
          u: STRING$2
        };
      }
    }

    temp = style.boxShadow;

    if (temp !== undefined) {
      var bs = []; // 先替换掉rgba为#RGBA格式，然后按逗号分割

      var _arr12 = (replaceRgba2Hex(temp) || '').split(',');

      if (_arr12) {
        _arr12.forEach(function (item) {
          var coords = /([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*\s*)?([-+]?[\d.]+[pxremvwhina%]*\s*)?/i.exec(item);

          if (coords) {
            var _res2 = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

            for (var i = 1; i <= 4; i++) {
              var item2 = coords[i];

              if (item2) {
                var _v15 = calUnit$1(item2);

                if ([NUMBER$4, DEG$3].indexOf(_v15.u) > -1) {
                  _v15.u = PX$8;
                } // x/y可以负，blur和spread不行


                if (i > 2 && _v15.v < 0) {
                  _v15.v = 0;
                }

                _res2.push(_v15);
              } else {
                _res2.push({
                  v: 0,
                  u: PX$8
                });
              }
            }

            var color = /#[a-f\d]{3,8}/i.exec(item);

            if (color) {
              _res2.push(rgba2int$1(color[0]));
            } else {
              _res2.push([0, 0, 0, 1]);
            }

            _res2.push(/inset/i.test(item) ? 'inset' : 'outset');

            bs.push(_res2);
          }
        });
      }

      res[BOX_SHADOW$2] = bs;
    } // 直接赋值的string类型


    ['position', 'display', 'boxSizing', 'flexDirection', 'flexWrap', 'justifyContent', 'alignItems', 'alignSelf', 'alignContent', 'overflow', 'mixBlendMode', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'backgroundClip', 'textOverflow', 'transformStyle', 'backfaceVisibility'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = convertStringValue(k, style[k]);
      }
    }); // 直接赋值的number类型

    ['flexGrow', 'flexShrink'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = Math.max(parseFloat(style[k]) || 0, 0);
      }
    });
    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX$5] = parseFloat(temp) || 0;
    } // 这些支持多个的用数组表示


    ['backgroundRepeat', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'fillRule'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        var _v16 = style[k];

        if (!Array.isArray(_v16)) {
          _v16 = [_v16];
        }

        if (k === 'backgroundRepeat') {
          _v16.forEach(function (item, i) {
            if (item) {
              _v16[i] = camel(item);
            }
          });
        }

        res[STYLE_KEY$1[style2Upper$1(k)]] = _v16;
      }
    });
    GEOM_KEY_SET.forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[k] = style[k];
      }
    });
    return res;
  }

  function setFontStyle(style, specialFontSize) {
    var fontSize = specialFontSize || style[FONT_SIZE$9] || 0;
    var fontFamily = style[FONT_FAMILY$6] || inject.defaultFontFamily || 'arial';

    if (/\s/.test(fontFamily)) {
      fontFamily = '"' + fontFamily.replace(/"/g, '\\"') + '"';
    }

    return (style[FONT_STYLE$4] || 'normal') + ' ' + (style[FONT_WEIGHT$6] || '400') + ' ' + fontSize + 'px/' + fontSize + 'px ' + fontFamily;
  }
  /**
   * https://zhuanlan.zhihu.com/p/25808995
   * 根据字形信息计算baseline的正确值，差值上下均分
   * @param style computedStyle
   * @returns {number}
   */


  function getBaseline$1(style) {
    var fontSize = style[FONT_SIZE$9];
    var ff = calFontFamily$1(style[FONT_FAMILY$6]);
    var normal = calNormalLineHeight$1(style, ff);
    return (style[LINE_HEIGHT$7] - normal) * 0.5 + fontSize * (o$3.info[ff] || o$3.info[inject.defaultFontFamily] || o$3.info.arial).blr;
  } // 垂直排版的baseline和水平类似，只是原点坐标系不同，删除加本身高度变为加gap高度


  function getVerticalBaseline$1(style) {
    return style[LINE_HEIGHT$7] - getBaseline$1(style);
  }

  function calNormalLineHeight$1(style, ff) {
    if (!ff) {
      ff = calFontFamily$1(style[FONT_FAMILY$6]);
    }

    return style[FONT_SIZE$9] * (o$3.info[ff] || o$3.info[inject.defaultFontFamily] || o$3.info.arial).lhr;
  }

  function calFontFamily$1(fontFamily) {
    var ff = fontFamily.split(/\s*,\s*/);

    for (var i = 0, len = ff.length; i < len; i++) {
      var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

      if (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item)) {
        return item;
      }
    }

    return inject.defaultFontFamily;
  }

  function calRelativePercent(n, parent, k) {
    n *= 0.01;

    while (parent) {
      var style = parent.currentStyle[k];

      if (style.u === AUTO$7) {
        if (k === WIDTH$8) {
          parent = parent.domParent;
        } else {
          break;
        }
      } else if (style.u === PX$8) {
        return n * style.v;
      } else if (style.u === PERCENT$7) {
        n *= style.v * 0.01;
        parent = parent.domParent;
      } else if (style.u === REM$7) {
        return n * style.v * parent.root.computedStyle[FONT_SIZE$9];
      } else if (style.u === VW$7) {
        return n * style.v * parent.root.width * 0.01;
      } else if (style.u === VH$7) {
        return n * style.v * parent.root.height * 0.01;
      } else if (style.u === VMAX$7) {
        return n * style.v * Math.max(parent.root.width, parent.root.height) * 0.01;
      } else if (style.u === VMIN$7) {
        return n * style.v * Math.min(parent.root.width, parent.root.height) * 0.01;
      }
    }

    return n;
  }

  function calRelative$1(currentStyle, k, v, parent, isWidth) {
    if (v.u === AUTO$7) {
      v = 0;
    } else if ([PX$8, NUMBER$4].indexOf(v.u) > -1) {
      v = v.v;
    } else if (v.u === PERCENT$7) {
      if (isWidth) {
        v = calRelativePercent(v.v, parent, WIDTH$8);
      } else {
        v = calRelativePercent(v.v, parent, HEIGHT$8);
      }
    } else if (v.u === REM$7) {
      v = v.v * parent.root.computedStyle[FONT_SIZE$9];
    } else if (v.u === VW$7) {
      v = v.v * parent.root.width * 0.01;
    } else if (v.u === VH$7) {
      v = v.v * parent.root.height * 0.01;
    } else if (v.u === VMAX$7) {
      v = v.v * Math.max(parent.root.width, parent.root.height) * 0.01;
    } else if (v.u === VMIN$7) {
      v = v.v * Math.min(parent.root.width, parent.root.height) * 0.01;
    }

    return v;
  }

  function isRelativeOrAbsolute$2(node) {
    var position = node.currentStyle[POSITION$5];
    return position === 'relative' || position === 'absolute';
  }

  function equalStyle$2(k, a, b, target) {
    if (!a || !b) {
      return a === b;
    }

    if (k === TRANSFORM$6) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0, len = a.length; i < len; i++) {
        var oa = a[i];
        var ob = b[i];

        if (oa.k !== ob.k) {
          return false;
        }

        var av = oa.v,
            bv = ob.v;

        if (oa.k === MATRIX$4) {
          if (!equalArr$1(av, bv)) {
            return false;
          }
        } else if (av.u !== bv.u || av.v !== bv.v) {
          return false;
        }
      }

      return true;
    }

    if (k === ROTATE_3D$4) {
      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3].v === b[3].v && a[3].u === b[3].u;
    }

    if (k === FILTER$6) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i = 0, _len = a.length; _i < _len; _i++) {
        var _oa = a[_i];
        var _ob = b[_i];

        if (_oa.k !== _ob.k) {
          return false;
        }

        var _av = _oa.v,
            _bv = _ob.v;

        if (_oa.k === 'dropShadow' || _oa.k === 'drop-shadow') {
          if (_av.length !== _bv.length) {
            return false;
          }

          for (var j = 0; j < 4; j++) {
            var avj = _av[j],
                bvj = _bv[j];

            if (avj.u !== bvj.u || avj.v !== bvj.v) {
              return false;
            }
          }
        } else if (_av.u !== _bv.u || _av.v !== _bv.v) {
          return false;
        }
      }

      return true;
    }

    if (k === TRANSFORM_ORIGIN$6 || k === PERSPECTIVE_ORIGIN$4 || isRadiusKey$1(k)) {
      return a[0].v === b[0].v && a[0].u === b[0].u && a[1].v === b[1].v && a[1].u === b[1].u;
    }

    if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3 || k === STROKE_WIDTH$8) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        var aa = a[_i2],
            bb = b[_i2];

        if (aa.v !== bb.v || aa.u !== bb.u || aa.v !== bb.v || aa.u !== bb.u) {
          return false;
        }
      }

      return true;
    }

    if (k === BOX_SHADOW$2) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i3 = 0, _len3 = a.length; _i3 < _len3; _i3++) {
        var _aa = a[_i3],
            _bb = b[_i3];

        if ((!_aa || !_bb) && _aa !== _bb) {
          return false;
        }

        for (var _j = 0; _j < 4; _j++) {
          if (_aa[_j].v !== _bb[_j].v || _aa[_j].u !== _bb[_j].u) {
            return false;
          }
        }

        for (var _j2 = 0; _j2 < 4; _j2++) {
          if (_aa[4][_j2] !== _bb[4][_j2]) {
            return false;
          }
        }

        if (_aa[5] !== _bb[5]) {
          return false;
        }
      }

      return true;
    }

    if (k === BACKGROUND_SIZE$2 || k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i4 = 0, _len4 = a.length; _i4 < _len4; _i4++) {
        var _aa2 = a[_i4],
            _bb2 = b[_i4];

        if (_aa2[0].v !== _bb2[0].v || _aa2[0].u !== _bb2[0].u || _aa2[1].v !== _bb2[1].v || _aa2[1].u !== _bb2[1].u) {
          return false;
        }
      }

      return true;
    } // if(k === OPACITY || k === Z_INDEX) {} 原始数字无需判断


    if (isLengthKey$1(k) || isExpandKey$1(k)) {
      return a.v === b.v && a.u === b.u;
    }

    if (isGradientKey$1(k)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i5 = 0, _len5 = a.length; _i5 < _len5; _i5++) {
        var ai = a[_i5],
            bi = b[_i5];

        if (ai.u !== bi.u) {
          return false;
        }

        var _av2 = ai.v,
            _bv2 = bi.v;

        if (ai.u === GRADIENT$3) {
          if (_av2.k !== _bv2.k || _av2.d !== _bv2.d || _av2.s !== _bv2.s || _av2.z !== _bv2.z) {
            return false;
          }

          if (_av2.k === 'linear') {
            var ad = _av2.d,
                bd = _bv2.d;
            var isArrayD1 = Array.isArray(ad);
            var isArrayD2 = Array.isArray(bd);

            if (isArrayD1 !== isArrayD2) {
              return false;
            }

            if (isArrayD1) {
              if (ad[0] !== bd[0] || ad[1] !== bd[1] || ad[2] !== bd[2] || ad[3] !== bd[3]) {
                return false;
              }
            } else if (ad !== bd) {
              return false;
            }
          } else if (_av2.k === 'conic' && _av2.d !== _bv2.d) {
            return false;
          }

          if (_av2.k === 'radial' || _av2.k === 'conic') {
            var ap = _av2.p,
                bp = _bv2.p;

            if (ap[0].u !== bp[0].u || ap[0].v !== bp[0].v || ap[1].u !== bp[1].u || ap[1].v !== bp[1].v) {
              return false;
            }
          }

          for (var _j3 = 0; _j3 < 2; _j3++) {
            var aj = _av2.v[_j3],
                bj = _bv2.v[_j3];
            var ac = aj[0],
                bc = bj[0];

            if (ac[0] !== bc[0] || ac[1] !== bc[1] || ac[2] !== bc[2] || ac[3] !== bc[3]) {
              return false;
            }

            if (aj[1] && bj[1]) {
              if (aj[1].u !== bj[1].u || aj[1].v !== bj[1].v) {
                return false;
              }
            } else if (aj[1] || bj[1]) {
              return false;
            }
          }
        } else if (ai.u === RGBA$3) {
          if (!equalArr$1(_av2, _bv2)) {
            return false;
          }
        } else if (_av2 !== _bv2) {
          return false;
        }
      }

      return true;
    }

    if (isColorKey$1(k)) {
      if (a.u !== b.u) {
        return false;
      }

      if (a.u === GRADIENT$3) {
        return equal(a.v, b.v);
      } else if (a.u === INHERIT$3) {
        return true;
      } else if (a.u === RGBA$3) {
        return equalArr$1(a.v, b.v);
      }
    } // multi都是纯值数组，equalArr本身即递归，非multi根据类型判断


    if (isGeom$1(target.tagName, k) && (target.isMulti || Array.isArray(a) && Array.isArray(b))) {
      return equal(a, b);
    }

    return a === b;
  }

  function cloneStyle$1(style, keys) {
    if (!keys) {
      keys = Object.keys(style).map(function (i) {
        if (!GEOM$2.hasOwnProperty(i)) {
          i = parseInt(i);
        }

        return i;
      });
    }

    var res = {};

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      var v = style[k];

      if (k === TRANSFORM$6) {
        if (v) {
          var _len6 = v.length;
          var n = new Array(_len6);

          for (var _i6 = 0; _i6 < _len6; _i6++) {
            var o = v[_i6];

            if (o.k === MATRIX$4) {
              n[_i6] = {
                k: o.k,
                v: o.v.slice(0)
              };
            } else {
              n[_i6] = {
                k: o.k,
                v: {
                  v: o.v.v,
                  u: o.v.u
                }
              };
            }
          }

          res[k] = n;
        }
      } else if (k === ROTATE_3D$4) {
        res[k] = [v[0], v[1], v[2], {
          v: v[3].v,
          u: v[3].u
        }];
      } else if (k === FILTER$6) {
        if (v) {
          var _len7 = v.length;

          var _n = new Array(_len7);

          for (var _i7 = 0; _i7 < _len7; _i7++) {
            var _o = v[_i7];
            var _k4 = _o.k,
                vv = _o.v;

            if (_k4 === 'dropShadow') {
              var arr = new Array(5);
              _n[_i7] = {
                k: _k4,
                v: arr
              };

              for (var j = 0; j < 4; j++) {
                var temp = vv[j];
                arr[j] = {
                  v: temp.v,
                  u: temp.u
                };
              }

              arr[4] = vv[4].slice(0);
            } else {
              _n[_i7] = {
                k: _k4,
                v: {
                  v: vv.v,
                  u: vv.u
                }
              };
            }
          }

          res[k] = _n;
        }
      } else if (k === TRANSFORM_ORIGIN$6 || k === PERSPECTIVE_ORIGIN$4 || isRadiusKey$1(k)) {
        if (v) {
          var _n2 = new Array(2);

          for (var _i8 = 0; _i8 < 2; _i8++) {
            var _o2 = v[_i8];
            _n2[_i8] = {
              v: _o2.v,
              u: _o2.u
            };
          }

          res[k] = _n2;
        }
      } else if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3 || k === STROKE_WIDTH$8) {
        res[k] = v.map(function (item) {
          return {
            v: item.v,
            u: item.u
          };
        });
      } else if (k === BOX_SHADOW$2) {
        if (v) {
          v = v.map(function (item) {
            var n = new Array(6);

            for (var _i9 = 0; _i9 < 4; _i9++) {
              var _o3 = item[_i9];
              n[_i9] = {
                v: _o3.v,
                u: _o3.u
              }; // x/y/blur/spread
            }

            n[4] = item[4].slice(0); //rgba

            n[5] = item[5]; // outset/inset

            return n;
          });
          res[k] = v;
        }
      } else if (k === BACKGROUND_SIZE$2) {
        if (v) {
          res[k] = v.map(function (item) {
            return [{
              v: item[0].v,
              u: item[0].u
            }, {
              v: item[1].v,
              u: item[1].u
            }];
          });
        }
      } else if (k === OPACITY$7 || k === Z_INDEX$5) {
        res[k] = v;
      } else if (k === TRANSLATE_PATH$1) {
        if (v) {
          res[k] = v.map(function (item) {
            return {
              v: item.v,
              u: item.u
            };
          });
        }
      } else if (isLengthKey$1(k) || isExpandKey$1(k)) {
        res[k] = {
          v: v.v,
          u: v.u
        };
      } // 渐变特殊处理
      else if (isGradientKey$1(k)) {
        res[k] = v.map(function (item) {
          if (!item) {
            return null;
          }

          if (item.u === GRADIENT$3) {
            return {
              v: util.clone(item.v),
              u: GRADIENT$3
            };
          } // 颜色
          else if (item.u === RGBA$3) {
            return {
              v: item.v.slice(0),
              u: RGBA$3
            };
          } // string和none
          else {
            return {
              v: item.v,
              u: item.u
            };
          }
        });
      } else if (isColorKey$1(k)) {
        // 特殊增加支持有gradient的先判断，仅color和textStrokeColor支持
        if (v.u === GRADIENT$3) {
          res[k] = {
            v: util.clone(v.v),
            u: GRADIENT$3
          };
        } else if (v.u === RGBA$3) {
          res[k] = {
            v: v.v.slice(0),
            u: RGBA$3
          };
        } // inherit
        else {
          res[k] = {
            u: INHERIT$3
          };
        }
      } // geom自定义属性
      else if (GEOM$2.hasOwnProperty(k)) {
        res[k] = util.clone(v);
      } // position等直接值类型赋值
      else {
        res[k] = v;
      }
    }

    return res;
  }

  function spreadBoxShadow$1(bbox, boxShadow) {
    var _bbox = _slicedToArray(bbox, 4),
        x1 = _bbox[0],
        y1 = _bbox[1],
        x2 = _bbox[2],
        y2 = _bbox[3];

    if (Array.isArray(boxShadow)) {
      var xl = 0,
          yt = 0,
          xr = 0,
          yb = 0;
      boxShadow.forEach(function (item) {
        var _item2 = _slicedToArray(item, 6),
            x = _item2[0],
            y = _item2[1],
            sigma = _item2[2],
            spread = _item2[3],
            color = _item2[4],
            inset = _item2[5];

        if (inset !== 'inset' && color[3] > 0) {
          var d = blur.outerSize(sigma);
          d += spread;
          xl = Math.min(xl, x - d);
          yt = Math.min(yt, x - d);
          xr = Math.max(xr, x + d);
          yb = Math.max(yb, y + d);
        }
      });
      x1 += xl;
      y1 += yt;
      x2 += xr;
      y2 += yb;
    }

    return [x1, y1, x2, y2];
  }

  function spreadFilter$2(bbox, filter) {
    var _bbox2 = _slicedToArray(bbox, 4),
        x1 = _bbox2[0],
        y1 = _bbox2[1],
        x2 = _bbox2[2],
        y2 = _bbox2[3]; // filter对整体有影响，且filter子项可以先后多次重复出现，上面计算完后，依次处理


    if (Array.isArray(filter)) {
      filter.forEach(function (item) {
        var k = item.k,
            v = item.v;

        if (k === 'blur' && v > 0) {
          var d = blur.kernelSize(v);
          var spread = blur.outerSizeByD(d);

          if (spread) {
            x1 -= spread;
            y1 -= spread;
            x2 += spread;
            y2 += spread;
          }
        } else if (k === 'dropShadow') {
          var _d = blur.kernelSize(v[2]);

          var _spread = blur.outerSizeByD(_d); // x/y/blur，3个一起影响，要考虑正负号，spread一定为非负


          if (v[0] || v[1] || _spread) {
            if (v[0] <= 0 || v[0] > 0 && v[0] < _spread) {
              x1 += v[0] - _spread;
            }

            if (v[1] <= 0 || v[1] > 0 && v[1] < _spread) {
              y1 += v[1] - _spread;
            }

            if (v[0] < 0 && -v[0] < _spread || v[0] >= 0) {
              x2 += v[0] + _spread;
            }

            if (v[1] < 0 && -v[1] < _spread || v[1] >= 0) {
              y2 += v[1] + _spread;
            }
          }
        }
      });
    }

    return [x1, y1, x2, y2];
  }

  var css = {
    normalize: normalize$1,
    setFontStyle: setFontStyle,
    getBaseline: getBaseline$1,
    getVerticalBaseline: getVerticalBaseline$1,
    calRelative: calRelative$1,
    equalStyle: equalStyle$2,
    isRelativeOrAbsolute: isRelativeOrAbsolute$2,
    cloneStyle: cloneStyle$1,
    calNormalLineHeight: calNormalLineHeight$1,
    calFontFamily: calFontFamily$1,
    spreadBoxShadow: spreadBoxShadow$1,
    spreadFilter: spreadFilter$2
  };

  var _enums$STYLE_KEY$i = enums.STYLE_KEY,
      TRANSLATE_X$4 = _enums$STYLE_KEY$i.TRANSLATE_X,
      TRANSLATE_Y$4 = _enums$STYLE_KEY$i.TRANSLATE_Y,
      TRANSLATE_Z$4 = _enums$STYLE_KEY$i.TRANSLATE_Z,
      SCALE_X$5 = _enums$STYLE_KEY$i.SCALE_X,
      SCALE_Y$5 = _enums$STYLE_KEY$i.SCALE_Y,
      SCALE_Z$3 = _enums$STYLE_KEY$i.SCALE_Z,
      SKEW_X$4 = _enums$STYLE_KEY$i.SKEW_X,
      SKEW_Y$4 = _enums$STYLE_KEY$i.SKEW_Y,
      ROTATE_X$4 = _enums$STYLE_KEY$i.ROTATE_X,
      ROTATE_Y$4 = _enums$STYLE_KEY$i.ROTATE_Y,
      ROTATE_Z$6 = _enums$STYLE_KEY$i.ROTATE_Z,
      ROTATE_3D$3 = _enums$STYLE_KEY$i.ROTATE_3D,
      PERSPECTIVE$4 = _enums$STYLE_KEY$i.PERSPECTIVE,
      MATRIX$3 = _enums$STYLE_KEY$i.MATRIX,
      FONT_SIZE$8 = _enums$STYLE_KEY$i.FONT_SIZE;
  var PX$7 = o$4.PX,
      PERCENT$6 = o$4.PERCENT,
      REM$6 = o$4.REM,
      VW$6 = o$4.VW,
      VH$6 = o$4.VH,
      VMAX$6 = o$4.VMAX,
      VMIN$6 = o$4.VMIN;
  var identity$1 = matrix.identity,
      multiply$3 = matrix.multiply,
      multiplyTfo = matrix.multiplyTfo,
      tfoMultiply = matrix.tfoMultiply,
      isE$3 = matrix.isE,
      multiplyTranslateX = matrix.multiplyTranslateX,
      multiplyTranslateY = matrix.multiplyTranslateY,
      multiplyTranslateZ = matrix.multiplyTranslateZ,
      multiplyRotateX$1 = matrix.multiplyRotateX,
      multiplyRotateY$1 = matrix.multiplyRotateY,
      multiplyRotateZ$1 = matrix.multiplyRotateZ,
      multiplySkewX$1 = matrix.multiplySkewX,
      multiplySkewY$1 = matrix.multiplySkewY,
      multiplyPerspective = matrix.multiplyPerspective,
      multiplyScaleX$1 = matrix.multiplyScaleX,
      multiplyScaleY$1 = matrix.multiplyScaleY,
      multiplyScaleZ$1 = matrix.multiplyScaleZ;
  var d2r$1 = geom.d2r;

  function calRotateX$1(t, v) {
    v = d2r$1(v);
    var sin = Math.sin(v);
    var cos = Math.cos(v);
    t[5] = t[10] = cos;
    t[6] = sin;
    t[9] = -sin;
    return t;
  }

  function calRotateY$1(t, v) {
    v = d2r$1(v);
    var sin = Math.sin(v);
    var cos = Math.cos(v);
    t[0] = t[10] = cos;
    t[8] = sin;
    t[2] = -sin;
    return t;
  }

  function calRotateZ$1(t, v) {
    v = d2r$1(v);
    var sin = Math.sin(v);
    var cos = Math.cos(v);
    t[0] = t[5] = cos;
    t[1] = sin;
    t[4] = -sin;
    return t;
  }

  function calRotate3d$2(t, v) {
    var _v = _slicedToArray(v, 4),
        x = _v[0],
        y = _v[1],
        z = _v[2],
        r = _v[3];

    r = d2r$1(r);
    var s = Math.sin(r);
    var c = Math.cos(r);

    if (x && !y && !z) {
      if (x < 0) {
        s = -s;
      }

      t[5] = c;
      t[9] = -s;
      t[6] = s;
      t[10] = c;
    } else if (y && !x && !z) {
      if (y < 0) {
        s = -s;
      }

      t[0] = c;
      t[8] = s;
      t[2] = -s;
      t[10] = c;
    } else if (z && !x && !y) {
      if (z < 0) {
        s = -s;
      }

      t[0] = c;
      t[4] = -s;
      t[1] = s;
      t[5] = c;
    } else {
      var len = Math.sqrt(x * x + y * y + z * z);

      if (len !== 1) {
        var rlen = 1 / len;
        x *= rlen;
        y *= rlen;
        z *= rlen;
      }

      var nc = 1 - c;
      var xy = x * y;
      var yz = y * z;
      var zx = z * x;
      var xs = x * s;
      var ys = y * s;
      var zs = z * s;
      t[0] = x * x * nc + c;
      t[1] = xy * nc + zs;
      t[2] = zx * nc - ys;
      t[3] = 0;
      t[4] = xy * nc - zs;
      t[5] = y * y * nc + c;
      t[6] = yz * nc + xs;
      t[7] = 0;
      t[8] = zx * nc + ys;
      t[9] = yz * nc - xs;
      t[10] = z * z * nc + c;
      t[11] = 0;
      t[12] = 0;
      t[13] = 0;
      t[14] = 0;
      t[15] = 1;
    }

    return t;
  }

  function calMatrix(transform, ow, oh, root) {
    var m = identity$1();

    for (var i = 0, len = transform.length; i < len; i++) {
      var item = transform[i];
      var k = item.k;
      var v = calSingleValue(k, item.v, ow, oh, root);

      if (k === TRANSLATE_X$4) {
        m = multiplyTranslateX(m, v);
      } else if (k === TRANSLATE_Y$4) {
        m = multiplyTranslateY(m, v);
      } else if (k === TRANSLATE_Z$4) {
        m = multiplyTranslateZ(m, v);
      } else if (k === ROTATE_X$4) {
        m = multiplyRotateX$1(m, d2r$1(v));
      } else if (k === ROTATE_Y$4) {
        m = multiplyRotateY$1(m, d2r$1(v));
      } else if (k === ROTATE_Z$6) {
        m = multiplyRotateZ$1(m, d2r$1(v));
      } else if (k === SKEW_X$4) {
        m = multiplySkewX$1(m, d2r$1(v));
      } else if (k === SKEW_Y$4) {
        m = multiplySkewY$1(m, d2r$1(v));
      } else if (k === SCALE_X$5) {
        m = multiplyScaleX$1(m, v);
      } else if (k === SCALE_Y$5) {
        m = multiplyScaleY$1(m, v);
      } else if (k === SCALE_Z$3) {
        m = multiplyScaleZ$1(m, v);
      } // 这种写法要求ppt必须在开头
      else if (k === PERSPECTIVE$4 && !i) {
        m = multiplyPerspective(m, v);
      } else if (k === ROTATE_3D$3) {
        var t = identity$1();
        calRotate3d$2(t, [v[0], v[1], v[2], v[3].v]);
        m = multiply$3(m, t);
      } else if (k === MATRIX$3) {
        m = multiply$3(m, v);
      }
    }

    return m;
  } // 已有计算好的变换矩阵，根据tfo原点计算最终的matrix


  function calMatrixByOrigin(m, ox, oy) {
    var res = m.slice(0);

    if (ox === 0 && oy === 0 || isE$3(m)) {
      return res;
    }

    res = tfoMultiply(ox, oy, res);
    res = multiplyTfo(res, -ox, -oy);
    return res;
  } // img缩放svg下专用，无rem


  function calMatrixWithOrigin(transform, ox, oy, ow, oh) {
    var m = calMatrix(transform, ow, oh);
    return calMatrixByOrigin(m, ox, oy);
  }

  function calSingleValue(k, v, ow, oh, root) {
    if (k === TRANSLATE_X$4 || k === TRANSLATE_Y$4 || k === TRANSLATE_Z$4) {
      if (v.u === PX$7) {
        return v.v;
      } else if (v.u === PERCENT$6) {
        return v.v * (k === TRANSLATE_Y$4 ? oh : ow) * 0.01;
      } else if (v.u === REM$6) {
        return v.v * root.__computedStyle[FONT_SIZE$8];
      } else if (v.u === VW$6) {
        return v.v * root.width * 0.01;
      } else if (v.u === VH$6) {
        return v.v * root.height * 0.01;
      } else if (v.u === VMAX$6) {
        return v.v * Math.max(root.width, root.height) * 0.01;
      } else if (v.u === VMIN$6) {
        return v.v * Math.min(root.width, root.height) * 0.01;
      }
    } else if (k === MATRIX$3) {
      return v;
    } else if (k === ROTATE_3D$3) {
      return v;
    }

    return v.v;
  }

  function calPerspectiveMatrix(ppt, ox, oy) {
    if (ppt && ppt > 0) {
      var res = identity$1();
      ppt = Math.max(ppt, 1);
      res[11] = -1 / ppt;

      if (ox || oy) {
        res = tfoMultiply(ox, oy, res);
        res = multiplyTfo(res, -ox, -oy);
      }

      return res;
    }
  } // 是否有透视矩阵应用


  function isPerspectiveMatrix(m) {
    if (!m) {
      return;
    }

    return !!m[11];
  }

  var transform$1 = {
    calSingleValue: calSingleValue,
    calMatrix: calMatrix,
    calRotateX: calRotateX$1,
    calRotateY: calRotateY$1,
    calRotateZ: calRotateZ$1,
    calRotate3d: calRotate3d$2,
    calPerspectiveMatrix: calPerspectiveMatrix,
    calMatrixByOrigin: calMatrixByOrigin,
    calMatrixWithOrigin: calMatrixWithOrigin,
    isPerspectiveMatrix: isPerspectiveMatrix
  };

  var _enums$STYLE_KEY$h = enums.STYLE_KEY,
      COLOR$5 = _enums$STYLE_KEY$h.COLOR,
      FONT_WEIGHT$5 = _enums$STYLE_KEY$h.FONT_WEIGHT,
      FONT_FAMILY$5 = _enums$STYLE_KEY$h.FONT_FAMILY,
      FONT_SIZE$7 = _enums$STYLE_KEY$h.FONT_SIZE,
      FONT_STYLE$3 = _enums$STYLE_KEY$h.FONT_STYLE,
      LETTER_SPACING$3 = _enums$STYLE_KEY$h.LETTER_SPACING,
      TEXT_STROKE_COLOR$4 = _enums$STYLE_KEY$h.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$4 = _enums$STYLE_KEY$h.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$3 = _enums$STYLE_KEY$h.TEXT_STROKE_OVER,
      ROTATE_Z$5 = _enums$STYLE_KEY$h.ROTATE_Z,
      LINE_HEIGHT$6 = _enums$STYLE_KEY$h.LINE_HEIGHT;
  var DEG$2 = o$4.DEG;
  var CANVAS$4 = mode.CANVAS,
      SVG$4 = mode.SVG;
  var TuOrU = /(?:[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u02EA\u02EB\u1100-\u11FF\u1401-\u167F\u18B0-\u18FF\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2065\u20DD-\u20E0\u20E2-\u20E4\u2100\u2101\u2103-\u2109\u210F\u2113\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u2135-\u213F\u2145-\u214A\u214C\u214D\u214F-\u2189\u218C-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2B97\u2BB8-\u2BD1\u2BD3-\u2BEB\u2BF0-\u2BFF\u2E50\u2E51\u2E80-\u3000\u3003-\u3007\u3012\u3013\u3020-\u302F\u3031-\u3040\u3042\u3044\u3046\u3048\u304A-\u3062\u3064-\u3082\u3084\u3086\u3088-\u308D\u308F-\u3094\u3097-\u309A\u309D-\u309F\u30A2\u30A4\u30A6\u30A8\u30AA-\u30C2\u30C4-\u30E2\u30E4\u30E6\u30E8-\u30ED\u30EF-\u30F4\u30F7-\u30FB\u30FD-\u3126\u3128-\u31EF\u3200-\u32FE\u3358-\u337A\u3380-\uA4CF\uA960-\uA97F\uAC00-\uD7FF\uE000-\uFAFF\uFE10-\uFE1F\uFE30-\uFE48\uFE53-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF02-\uFF07\uFF0A\uFF0B\uFF0F-\uFF19\uFF20-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7\uFFF0-\uFFF8\uFFFC\uFFFD]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|[\uD80C\uD81C-\uD822\uD83D\uD840-\uD87E\uD880-\uD8BE][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC5F]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFFF]|\uD823[\uDC00-\uDD7F]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFF]|\uD833[\uDF00-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83C[\uDC00-\uDDFF\uDE02-\uDFFF]|\uD83E[\uDD00-\uDEFF]|[\uD87F\uD8BF][\uDC00-\uDFFD])/;
  /**
   * 表示一行文本的类，保存它的位置、内容、从属信息，在布局阶段生成，并在渲染阶段被Text调用render()
   * 关系上直属于Text类，一个Text类可能因为换行原因导致有多个TextBox，一行内容中也可能有不同Text从而不同TextBox
   * 另外本类还会被LineBoxManager添加到LineBox里，LineBox为一行中的inline/文本组合，之间需要进行垂直对齐
   * 在textOverflow为ellipsis时，可能会收到后面节点的向前回退（后面不足放下…），使得省略号发生在本节点
   */

  var TextBox = /*#__PURE__*/function () {
    function TextBox(parent, index, x, y, w, h, content) {
      var isUpright = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      this.__parent = parent;
      this.__index = index;
      this.__x = x;
      this.__y = y;

      if (isUpright) {
        this.__width = h;
        this.__height = w;
      } else {
        this.__width = w;
        this.__height = h;
      }

      this.__content = content;
      this.__virtualDom = {};
      this.__parentLineBox = null;
      this.__isVertical = isUpright;
    }
    /**
     * 渲染阶段被Text类调用，多行Text会有多个TextBox，内容被分拆开
     * @param renderMode
     * @param ctx
     * @param computedStyle
     * @param cacheStyle Text父节点Dom的缓存样式，相比computedStyle可以直接用，比如color被缓存为style字符串
     * @param dx
     * @param dy
     */


    _createClass(TextBox, [{
      key: "render",
      value: function render(renderMode, ctx, computedStyle, cacheStyle, dx, dy) {
        var content = this.content,
            x = this.x,
            y = this.y,
            parent = this.parent,
            width = this.width,
            height = this.height,
            isUpright = this.isUpright;
        var dom = parent.__domParent;
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle); // 垂直文本x/y互换，渲染时使用rotate模拟，因为是基于baseline绘制，顺时针90deg时tfo是文字左下角，
        // 它等同于lineHeight（现在的w）减去b

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += dx;
        y += dy;

        if (isUpright) {
          this.__endX = x;
          this.__endY = y + height;
        } else {
          this.__endX = x + width;
          this.__endY = y;
        }

        var letterSpacing = computedStyle[LETTER_SPACING$3],
            textStrokeWidth = computedStyle[TEXT_STROKE_WIDTH$4],
            textStrokeColor = computedStyle[TEXT_STROKE_COLOR$4],
            fontSize = computedStyle[FONT_SIZE$7],
            lineHeight = computedStyle[LINE_HEIGHT$6];
        var i = 0,
            length = content.length;

        if (renderMode === CANVAS$4) {
          var me = dom.matrixEvent,
              list;
          var dev1 = 0,
              dev2 = 0;

          if (isUpright) {
            list = [{
              k: ROTATE_Z$5,
              v: {
                v: 90,
                u: DEG$2
              }
            }];
            dev1 = bv * 0.6;
            dev2 = bv * 0.2;
          }

          var overFill = computedStyle[TEXT_STROKE_OVER$3] === 'fill';

          if (letterSpacing) {
            for (; i < length; i++) {
              var c = content.charAt(i);

              if (isUpright) {
                var cjk = TuOrU.test(c);

                if (cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x - dev1, y - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }
                } else {
                  var m = transform$1.calMatrixWithOrigin(list, x, y, 0, 0);
                  m = matrix.multiply(me, m);
                  ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

                  if (overFill) {
                    ctx.fillText(c, x, y);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x, y);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x, y);
                  }
                }

                y += ctx.measureText(c).width + letterSpacing;
              } else {
                if (overFill) {
                  ctx.fillText(c, x, y);
                }

                if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                  ctx.strokeText(c, x, y);
                }

                if (!overFill) {
                  ctx.fillText(c, x, y);
                }

                x += ctx.measureText(c).width + letterSpacing;
              }
            }
          } else {
            if (isUpright) {
              var _cjk = TuOrU.test(content.charAt(0)),
                  last = 0,
                  count = 0,
                  len = content.length;

              for (var _i = 1; _i < len; _i++) {
                var nowCjk = TuOrU.test(content.charAt(_i)); // 不相等时cjk发生变化，输出之前的内容，记录当下的所有

                if (nowCjk !== _cjk) {
                  if (_cjk) {
                    ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);
                    var s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(s, x - dev1, y + count + b - dev2);
                    }

                    if (!overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    count += fontSize;
                  } else {
                    var _m = transform$1.calMatrixWithOrigin(list, x, y + count, 0, 0);

                    _m = matrix.multiply(me, _m);
                    ctx.setTransform(_m[0], _m[1], _m[4], _m[5], _m[12], _m[13]);

                    var _s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(_s, x, y + count);
                    }

                    if (!overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    count += ctx.measureText(_s).width;
                  }

                  last = _i;
                  _cjk = !_cjk;
                } // cjk单字符输出
                else if (nowCjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  var _s2 = content.slice(last, _i);

                  if (overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  count += fontSize;
                  last = _i;
                }
              }

              if (last < len) {
                var _s3 = content.slice(last, len); // 最后的cjk只可能是一个字符


                if (_cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }
                } else {
                  var _m2 = transform$1.calMatrixWithOrigin(list, x, y + count, 0, 0);

                  _m2 = matrix.multiply(me, _m2);
                  ctx.setTransform(_m2[0], _m2[1], _m2[4], _m2[5], _m2[12], _m2[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x, y + count);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }
                }
              }
            } else {
              if (overFill) {
                ctx.fillText(content, x, y);
              }

              if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                ctx.strokeText(content, x, y);
              }

              if (!overFill) {
                ctx.fillText(content, x, y);
              }
            }
          }
        } else if (renderMode === SVG$4) {
          var color = cacheStyle[COLOR$5];

          if (color.k) {
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          } // 垂直的svg以中线为基线，需偏移baseline和中线的差值


          if (isUpright) {
            x += lineHeight * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$5]], ['font-weight', computedStyle[FONT_WEIGHT$5]], ['font-style', computedStyle[FONT_STYLE$3]], ['font-size', computedStyle[FONT_SIZE$7] + 'px']]; // svg无法定义stroke的over

          if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
            var _textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$4]; // 渐变

            if (_textStrokeColor.k) {
              _textStrokeColor = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, _textStrokeColor, dx, dy).v;
            }

            props.push(['stroke', _textStrokeColor]);
            props.push(['stroke-width', computedStyle[TEXT_STROKE_WIDTH$4]]);
          }

          if (letterSpacing) {
            props.push(['letter-spacing', letterSpacing]);
          }

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          this.__virtualDom = {
            type: 'item',
            tagName: 'text',
            props: props,
            content: util.encodeHtml(content)
          };
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.__x += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.__y += diff;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.__endX;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.__endY;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.parent.baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.parent.verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }]);

    return TextBox;
  }();

  var _enums$STYLE_KEY$g = enums.STYLE_KEY,
      FONT_SIZE$6 = _enums$STYLE_KEY$g.FONT_SIZE,
      FONT_FAMILY$4 = _enums$STYLE_KEY$g.FONT_FAMILY,
      FONT_WEIGHT$4 = _enums$STYLE_KEY$g.FONT_WEIGHT,
      FONT_STYLE$2 = _enums$STYLE_KEY$g.FONT_STYLE,
      COLOR$4 = _enums$STYLE_KEY$g.COLOR,
      LINE_HEIGHT$5 = _enums$STYLE_KEY$g.LINE_HEIGHT,
      ROTATE_Z$4 = _enums$STYLE_KEY$g.ROTATE_Z;
  var DEG$1 = o$4.DEG;
  var CANVAS$3 = mode.CANVAS,
      SVG$3 = mode.SVG,
      WEBGL$3 = mode.WEBGL;
  var CHAR = '…';

  var Ellipsis = /*#__PURE__*/function (_Node) {
    _inherits(Ellipsis, _Node);

    function Ellipsis(x, y, width, parent, text, isUpright) {
      var _this;

      _this = _Node.call(this) || this;
      _this.__x = _this.__x1 = x;
      _this.__y = _this.__y1 = y;
      _this.__width = width;
      _this.__parent = _this.__domParent = parent;
      _this.__text = text;
      parent.__ellipsis = _assertThisInitialized(_this);
      _this.__parentLineBox = null;
      _this.__baseline = css.getBaseline(parent.computedStyle);
      _this.__isVertical = isUpright;
      return _this;
    }

    _createClass(Ellipsis, [{
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var x = this.x,
            y = this.y,
            parent = this.parent,
            isUpright = this.isUpright;
        var computedStyle = parent.computedStyle,
            color = parent.cacheStyle[COLOR$4];
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle);

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += dx;
        y += dy;

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          var font = css.setFontStyle(computedStyle, this.__text.__fitFontSize);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          if (isUpright) {
            var me = parent.matrixEvent,
                list = [{
              k: ROTATE_Z$4,
              v: {
                v: 90,
                u: DEG$1
              }
            }];
            var m = transform$1.calMatrixWithOrigin(list, x, y, 0, 0);
            m = matrix.multiply(me, m);
            ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
          }

          ctx.fillText(CHAR, x, y);
        } else if (renderMode === SVG$3) {
          // 垂直的svg以中线为基线，需偏移baseline和中线的差值
          if (isUpright) {
            x += computedStyle[LINE_HEIGHT$5] * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$4]], ['font-weight', computedStyle[FONT_WEIGHT$4]], ['font-style', computedStyle[FONT_STYLE$2]], ['font-size', computedStyle[FONT_SIZE$6] + 'px']];

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          var vd = this.__virtualDom = {
            type: 'text',
            children: [{
              type: 'item',
              tagName: 'text',
              props: props,
              content: CHAR
            }]
          };
          parent.virtualDom.children.push(vd);
        }
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "isEllipsis",
      get: function get() {
        return true;
      }
    }]);

    return Ellipsis;
  }(Node$1);

  var _enums$STYLE_KEY$f = enums.STYLE_KEY,
      TX$1 = _enums$STYLE_KEY$f.TRANSLATE_X,
      TY$1 = _enums$STYLE_KEY$f.TRANSLATE_Y,
      TZ$1 = _enums$STYLE_KEY$f.TRANSLATE_Z,
      OP$2 = _enums$STYLE_KEY$f.OPACITY,
      FT$2 = _enums$STYLE_KEY$f.FILTER,
      PPT$2 = _enums$STYLE_KEY$f.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$3 = _enums$STYLE_KEY$f.PERSPECTIVE_ORIGIN,
      Z_INDEX$4 = _enums$STYLE_KEY$f.Z_INDEX,
      SX$1 = _enums$STYLE_KEY$f.SCALE_X,
      SY$1 = _enums$STYLE_KEY$f.SCALE_Y,
      SZ$1 = _enums$STYLE_KEY$f.SCALE_Z,
      ROTATE_X$3 = _enums$STYLE_KEY$f.ROTATE_X,
      ROTATE_Y$3 = _enums$STYLE_KEY$f.ROTATE_Y,
      RZ$1 = _enums$STYLE_KEY$f.ROTATE_Z,
      ROTATE_3D$2 = _enums$STYLE_KEY$f.ROTATE_3D,
      SKEW_X$3 = _enums$STYLE_KEY$f.SKEW_X,
      SKEW_Y$3 = _enums$STYLE_KEY$f.SKEW_Y,
      TF$2 = _enums$STYLE_KEY$f.TRANSFORM,
      TRANSFORM_ORIGIN$5 = _enums$STYLE_KEY$f.TRANSFORM_ORIGIN;
  var isIgnore = o$2.isIgnore,
      isRepaint = o$2.isRepaint; // 低位表示<repaint级别

  var NONE$4 = 0; //                                          0
  // cacheTotal变化需重新生成的时候

  var CACHE$4 = 1; //                                         1

  var TRANSLATE_X$3 = 2; //                                  10

  var TRANSLATE_Y$3 = 4; //                                 100

  var TRANSLATE_Z$3 = 8; //                                1000

  var TRANSLATE = 14; //                                 1110

  var ROTATE_Z$3 = 16; //                                 10000

  var SCALE_X$4 = 32; //                                 100000

  var SCALE_Y$4 = 64; //                                1000000

  var SCALE_Z$2 = 128; //                              10000000

  var SCALE$1 = 224; //                                11100000

  var TRANSFORM$5 = 256; //                           100000000

  var TRANSFORM_ALL$4 = 510; //                       111111110

  var OPACITY$6 = 512; //                            1000000000

  var FILTER$5 = 1024; //                           10000000000

  var MIX_BLEND_MODE$4 = 2048; //                  100000000000

  var PERSPECTIVE$3 = 4096; //                    1000000000000

  var MASK$3 = 8192; //                          10000000000000

  var REPAINT$4 = 16384; //                     100000000000000
  // 高位表示reflow

  var REFLOW$4 = 32768; //                     1000000000000000
  // 特殊高位表示rebuild，节点发生增删变化

  var REBUILD$1 = 65536; //                   10000000000000000

  var ENUM = {
    NONE: NONE$4,
    CACHE: CACHE$4,
    TRANSLATE_X: TRANSLATE_X$3,
    TRANSLATE_Y: TRANSLATE_Y$3,
    TRANSLATE_Z: TRANSLATE_Z$3,
    TRANSLATE: TRANSLATE,
    ROTATE_Z: ROTATE_Z$3,
    SCALE_X: SCALE_X$4,
    SCALE_Y: SCALE_Y$4,
    SCALE_Z: SCALE_Z$2,
    SCALE: SCALE$1,
    TRANSFORM: TRANSFORM$5,
    TRANSFORM_ALL: TRANSFORM_ALL$4,
    OPACITY: OPACITY$6,
    FILTER: FILTER$5,
    MIX_BLEND_MODE: MIX_BLEND_MODE$4,
    PERSPECTIVE: PERSPECTIVE$3,
    MASK: MASK$3,
    REPAINT: REPAINT$4,
    REFLOW: REFLOW$4,
    REBUILD: REBUILD$1
  };

  function isTransforms(k) {
    return k === ROTATE_X$3 || k === ROTATE_Y$3 || k === ROTATE_3D$2 || k === SKEW_X$3 || k === SKEW_Y$3 || k === TF$2 || k === TRANSFORM_ORIGIN$5;
  }

  var o$1 = Object.assign({
    // 是否包含value之内的
    contain: function contain(lv, value) {
      return (lv & value) > 0;
    },
    // 是否不包含value之外的
    exclude: function exclude(lv, value) {
      return (lv | value) === value;
    },

    /**
     * 得出等级
     * @param k
     * @returns {number|*}
     */
    getLevel: function getLevel(k) {
      if (isIgnore(k)) {
        return NONE$4;
      }

      if (k === Z_INDEX$4) {
        return CACHE$4;
      }

      if (k === TX$1) {
        return TRANSLATE_X$3;
      }

      if (k === TY$1) {
        return TRANSLATE_Y$3;
      }

      if (k === TZ$1) {
        return TRANSLATE_Z$3;
      }

      if (k === RZ$1) {
        return ROTATE_Z$3;
      }

      if (k === SX$1) {
        return SCALE_X$4;
      }

      if (k === SY$1) {
        return SCALE_Y$4;
      }

      if (k === SZ$1) {
        return SCALE_Z$2;
      }

      if (k === OP$2) {
        return OPACITY$6;
      }

      if (k === FT$2) {
        return FILTER$5;
      }

      if (k === PPT$2 || k === PERSPECTIVE_ORIGIN$3) {
        return PERSPECTIVE$3;
      }

      if (isTransforms(k)) {
        return TRANSFORM$5;
      }

      if (isRepaint(k)) {
        return REPAINT$4;
      }

      return REFLOW$4;
    },
    isReflow: function isReflow(lv) {
      return lv >= REFLOW$4;
    },
    isRepaint: function isRepaint(lv) {
      return lv < REFLOW$4;
    }
  }, ENUM);

  var _enums$STYLE_KEY$e = enums.STYLE_KEY,
      DISPLAY$7 = _enums$STYLE_KEY$e.DISPLAY,
      POSITION$4 = _enums$STYLE_KEY$e.POSITION,
      LINE_HEIGHT$4 = _enums$STYLE_KEY$e.LINE_HEIGHT,
      FONT_SIZE$5 = _enums$STYLE_KEY$e.FONT_SIZE,
      FONT_FAMILY$3 = _enums$STYLE_KEY$e.FONT_FAMILY,
      FONT_WEIGHT$3 = _enums$STYLE_KEY$e.FONT_WEIGHT,
      COLOR$3 = _enums$STYLE_KEY$e.COLOR,
      VISIBILITY$4 = _enums$STYLE_KEY$e.VISIBILITY,
      LETTER_SPACING$2 = _enums$STYLE_KEY$e.LETTER_SPACING,
      OVERFLOW$3 = _enums$STYLE_KEY$e.OVERFLOW,
      WHITE_SPACE$2 = _enums$STYLE_KEY$e.WHITE_SPACE,
      TEXT_OVERFLOW$1 = _enums$STYLE_KEY$e.TEXT_OVERFLOW,
      WIDTH$7 = _enums$STYLE_KEY$e.WIDTH,
      HEIGHT$7 = _enums$STYLE_KEY$e.HEIGHT,
      TEXT_STROKE_COLOR$3 = _enums$STYLE_KEY$e.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$3 = _enums$STYLE_KEY$e.TEXT_STROKE_WIDTH,
      MARGIN_TOP$6 = _enums$STYLE_KEY$e.MARGIN_TOP,
      MARGIN_BOTTOM$6 = _enums$STYLE_KEY$e.MARGIN_BOTTOM,
      MARGIN_LEFT$8 = _enums$STYLE_KEY$e.MARGIN_LEFT,
      MARGIN_RIGHT$7 = _enums$STYLE_KEY$e.MARGIN_RIGHT,
      PADDING_TOP$6 = _enums$STYLE_KEY$e.PADDING_TOP,
      PADDING_BOTTOM$5 = _enums$STYLE_KEY$e.PADDING_BOTTOM,
      PADDING_LEFT$8 = _enums$STYLE_KEY$e.PADDING_LEFT,
      PADDING_RIGHT$7 = _enums$STYLE_KEY$e.PADDING_RIGHT,
      BORDER_TOP_WIDTH$6 = _enums$STYLE_KEY$e.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$5 = _enums$STYLE_KEY$e.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$8 = _enums$STYLE_KEY$e.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$7 = _enums$STYLE_KEY$e.BORDER_RIGHT_WIDTH,
      FILTER$4 = _enums$STYLE_KEY$e.FILTER,
      FONT_SIZE_SHRINK$1 = _enums$STYLE_KEY$e.FONT_SIZE_SHRINK,
      ELLIPSIS$1 = enums.ELLIPSIS;
  var AUTO$6 = o$4.AUTO;
  var CANVAS$2 = mode.CANVAS,
      SVG$2 = mode.SVG,
      WEBGL$2 = mode.WEBGL;
  var isFunction$a = util.isFunction;
  /**
   * 测量的封装，主要是增加了shrinkFontSize声明时，不断尝试fontSize--，直到限制或者满足一行展示要求
   */

  function measureLineWidth(ctx, renderMode, start, length, content, w, ew, perW, computedStyle, fontFamily, fontSize, fontWeight, fontSizeShrink, letterSpacing) {
    if (start >= length) {
      // 特殊情况不应该走进这里
      return {
        hypotheticalNum: 0,
        rw: 0,
        newLine: false
      };
    }

    var res = measure(ctx, renderMode, start, length, content, w - ew, perW, fontFamily, fontSize, fontWeight, letterSpacing);

    if (res.newLine && fontSizeShrink > 0 && fontSizeShrink < fontSize) {
      while (res.newLine && fontSize > fontSizeShrink) {
        // 文字和ellipsis同时设置测量
        ctx.font = css.setFontStyle(computedStyle, --fontSize);

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          ew = ctx.measureText(ELLIPSIS$1).width;
        } else {
          ew = inject.measureTextSync(ELLIPSIS$1, fontFamily, fontSize, fontWeight, false);
        }

        res = measure(ctx, renderMode, start, length, content, w - ew, perW, fontFamily, fontSize, fontWeight, letterSpacing);
        res.fitFontSize = fontSize;
        res.ew = ew; // 有ew的时候还要尝试没有是否放得下

        if (ew) {
          var t = measure(ctx, renderMode, start, length, content, w, perW, fontFamily, fontSize, fontWeight, letterSpacing);

          if (!t.newLine) {
            t.fitFontSize = fontSize;
            res = t;
          }
        }
      }
    }

    return res;
  }
  /**
   * 在给定宽度w的情况下，测量文字content多少个满足塞下，只支持水平书写，从start的索引开始，content长length
   * 尽可能地少的次数调用canvas的measureText或svg的html节点的width，因为比较消耗性能
   * 这就需要一种算法，不能逐字遍历看总长度是否超过，也不能单字宽度相加因为有文本整形某些字体多个字宽度不等于每个之和
   * 简单的2分法实现简单，但是次数稍多，对于性能不是最佳，因为内容的slice裁剪和传递给canvas测量都随尺寸增加而加大
   * 由于知道w和fontSize，因此能推测出平均值为fontSize/w，即字的个数，
   * 进行测量后得出w2，和真实w对比，产生误差d，再看d和fontSize推测差距个数，如此反复
   * 返回内容和end索引和长度，最少也要1个字符
   */


  function measure(ctx, renderMode, start, length, content, w, perW, fontFamily, fontSize, fontWeight, letterSpacing) {
    var i = start,
        j = length,
        rw = 0,
        newLine = false; // 特殊降级，有letterSpacing时，canvas无法完全兼容，只能采取单字测量的方式完成

    if (letterSpacing && [CANVAS$2, WEBGL$2].indexOf(renderMode) > -1) {
      var count = 0;

      for (; i < j; i++) {
        var mw = ctx.measureText(content.charAt(i)).width + letterSpacing;

        if (count + mw > w + 1e-10) {
          newLine = true;
          break;
        }

        count += mw;
      }

      return {
        hypotheticalNum: i - start,
        rw: count,
        newLine: newLine || count > w + 1e-10
      };
    } // 没有letterSpacing或者是svg模式可以完美获取TextMetrics


    var hypotheticalNum = Math.round(w / perW); // 不能增长0个字符，至少也要1个

    if (hypotheticalNum <= 0) {
      hypotheticalNum = 1;
    } // 超过内容长度范围也不行
    else if (hypotheticalNum > length - start) {
      hypotheticalNum = length - start;
    } // 类似2分的一个循环


    while (i < j) {
      var _mw = void 0,
          str = content.slice(start, start + hypotheticalNum);

      if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
        _mw = ctx.measureText(str).width;
      } else if (renderMode === SVG$2) {
        _mw = inject.measureTextSync(str, fontFamily, fontSize, fontWeight, false);
      }

      if (letterSpacing) {
        _mw += hypotheticalNum * letterSpacing;
      }

      if (_mw === w) {
        rw = w;
        newLine = true;
        break;
      } // 超出，设置右边界，并根据余量推测减少个数，
      // 因为精度问题，固定宽度或者累加的剩余空间，不用相等判断，而是为原本w宽度加一点点冗余1e-10


      if (_mw > w + 1e-10) {
        newLine = true; // 限制至少1个

        if (hypotheticalNum === 1) {
          rw = _mw;
          break;
        } // 注意特殊判断i和j就差1个可直接得出结果，因为现在超了而-1不超肯定是-1的结果


        if (i === j - 1 || i - start === hypotheticalNum - 1) {
          hypotheticalNum = i - start;
          break;
        }

        j = hypotheticalNum + start - 1;
        var reduce = Math.round((_mw - w) / perW);

        if (reduce <= 0) {
          reduce = 1;
        }

        hypotheticalNum -= reduce;

        if (hypotheticalNum < i - start) {
          hypotheticalNum = i - start;
        }
      } // 还有空余，设置左边界，并根据余量推测增加的个数
      else {
        rw = _mw;

        if (hypotheticalNum === length - start) {
          break;
        }

        i = hypotheticalNum + start;
        var add = Math.round((w - _mw) / perW);

        if (add <= 0) {
          add = 1;
        }

        hypotheticalNum += add;

        if (hypotheticalNum > j - start) {
          hypotheticalNum = j - start;
        }
      }
    }

    return {
      hypotheticalNum: hypotheticalNum,
      rw: rw,
      newLine: newLine
    };
  }

  function getFontKey(ff, fs, fw, ls) {
    return ff + '_' + fs + '_' + fw + '_' + ls;
  }

  var Text = /*#__PURE__*/function (_Node) {
    _inherits(Text, _Node);

    function Text(content) {
      var _this;

      _this = _Node.call(this) || this;
      _this.__content = util.isNil(content) ? '' : content.toString();
      _this.__textBoxes = [];
      _this.__charWidth = 0; // 最小字符宽度（单个）

      _this.__textWidth = 0; // 整体宽度

      _this.__bp = null; // block父节点

      _this.__widthHash = {}; // 存储当前字体样式key下的charWidth/textWidth

      _this.__limitCache = false;
      _this.__hasContent = false;
      _this.__fitFontSize = 0; // 自动缩小时的字体大小N

      return _this;
    }
    /**
     * text在virtual时和普通一样，无需特殊处理
     * endSpace由外界inline布局控制，末尾最后一行的空白mpb，包含递归情况，递归为多个嵌套末尾节点的空白mpb之和
     * 即便宽度不足，每行还是强制渲染一个字符，换行依据lx开始，因为x可能是从中间开始的，非inline则两个相等
     * 最后一个字符排版时要考虑末尾mpb，排不下的话回退删掉这个字符，如果最后一个字符另起开头，排不下也强制排，每行至少1个字符
     * 在textOverflow时很特殊，多个inline同行，回退可能到前一个inline节点，这个通过x和lx判断是否行首，决定至少1个字符规则
     * @param data
     * @private
     */


    _createClass(Text, [{
      key: "__layoutFlow",
      value: function __layoutFlow(data) {
        var __cache = this.__cache;

        if (__cache) {
          __cache.release();
        }

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            _data$lx = data.lx,
            lx = _data$lx === void 0 ? x : _data$lx,
            _data$ly = data.ly,
            ly = _data$ly === void 0 ? y : _data$ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            _data$lineClamp = data.lineClamp,
            lineClamp = _data$lineClamp === void 0 ? 0 : _data$lineClamp,
            _data$lineClampCount = data.lineClampCount,
            lineClampCount = _data$lineClampCount === void 0 ? 0 : _data$lineClampCount,
            _data$isUpright = data.isUpright,
            isUpright = _data$isUpright === void 0 ? false : _data$isUpright;
        this.__x = this.__x1 = x;
        this.__y = this.__y1 = y;
        var __isDestroyed = this.__isDestroyed,
            content = this.content,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            root = this.root;
        textBoxes.splice(0); // 空内容w/h都为0可以提前跳出，lineClamp超出一般不会进这，但有特例flex文本垂直预计算时，所以也要跳出

        if (__isDestroyed || computedStyle[DISPLAY$7] === 'none' || !content || lineClamp && lineClampCount >= lineClamp) {
          return lineClampCount;
        } // 顺序尝试分割字符串为TextBox，形成多行，begin为每行起始索引，i是当前字符索引


        var i = 0;
        var length = content.length;
        var maxW = 0;
        var lineHeight = computedStyle[LINE_HEIGHT$4],
            letterSpacing = computedStyle[LETTER_SPACING$2],
            whiteSpace = computedStyle[WHITE_SPACE$2],
            fontSize = computedStyle[FONT_SIZE$5],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            fontFamily = computedStyle[FONT_FAMILY$3];
        var size = isUpright ? h : w;
        var beginSpace = isUpright ? y - ly : x - lx; // x>=lx，当第一行非起始处时前面被prev节点占据，这个差值可认为是count宽度
        // 基于最近block父节点的样式

        var bp = this.domParent;

        while (bp.computedStyle[DISPLAY$7] === 'inline') {
          bp = bp.domParent;
        }

        this.__bp = bp;
        var textOverflow = bp.computedStyle[TEXT_OVERFLOW$1]; // 布局测量前置，根据renderMode不同提供不同的测量方法

        var renderMode = root.renderMode;
        var ctx;

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          ctx = renderMode === WEBGL$2 ? inject.getFontCanvas().ctx : root.ctx;
          ctx.font = css.setFontStyle(computedStyle, 0);
        } // fontSize在中文是正好1个字宽度，英文不一定，等宽为2个，不等宽可能1~2个，特殊字符甚至>2个，取预估均值然后倒数得每个均宽0.8


        var perW = fontSize * 0.8 + letterSpacing;
        var lineCount = 0;
        var mainCoords; // 根据书写模式指向不同x/y
        // 不换行特殊对待，同时考虑overflow和textOverflow

        if (whiteSpace === 'nowrap') {
          var isTextOverflow,
              textWidth = this.textWidth,
              _w = size - endSpace - beginSpace;

          var _bp$computedStyle = bp.computedStyle,
              position = _bp$computedStyle[POSITION$4],
              overflow = _bp$computedStyle[OVERFLOW$3],
              fontSizeShrink = _bp$computedStyle[FONT_SIZE_SHRINK$1];
          var containerSize = bp.currentStyle[isUpright ? HEIGHT$7 : WIDTH$7]; // 只要是overflow隐藏，不管textOverflow如何（默认是clip等同于overflow:hidden的功能）都截取

          if (overflow === 'hidden') {
            // abs自适应宽度时不裁剪
            if (position === 'absolute' && containerSize.u === AUTO$6) {
              isTextOverflow = false;
            } else {
              isTextOverflow = textWidth > size + 1e-10 - beginSpace - endSpace;
            }
          } // ellipsis生效情况，本节点开始向前回退查找，尝试放下一部分字符


          if (isTextOverflow && textOverflow === 'ellipsis') {
            var _this$__lineBack = this.__lineBack(ctx, renderMode, i, length, content, _w, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, fontSizeShrink, letterSpacing, isUpright);

            var _this$__lineBack2 = _slicedToArray(_this$__lineBack, 1);

            mainCoords = _this$__lineBack2[0];
            lineCount++;

            if (isUpright) {
              x = mainCoords;
            } else {
              y = mainCoords;
            }
          } // 默认是否clip跟随overflow:hidden，无需感知，裁剪由dom做，这里不裁剪
          else {
            // 但还是要判断缩小字体适应
            if (fontSizeShrink > 0 && fontSizeShrink < fontSize) {
              var fs = fontSize;
              this.__fitFontSize = 0;

              while (fs > fontSizeShrink && textWidth > _w) {
                if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
                  ctx.font = css.setFontStyle(computedStyle, --fs);
                  textWidth = ctx.measureText(content).width + letterSpacing * content.length;
                } else if (renderMode === SVG$2) {
                  textWidth = inject.measureTextSync(content, fontFamily, fs, fontWeight, false) + letterSpacing * content.length;
                }
              }

              this.__fitFontSize = fs;
            }

            var textBox = new TextBox(this, textBoxes.length, x, y, textWidth, lineHeight, content, isUpright);
            textBoxes.push(textBox);
            lineBoxManager.addItem(textBox, false);

            if (isUpright) {
              x += lineHeight;
            } else {
              y += lineHeight;
            }

            if (isTextOverflow) {
              lineCount++;
            }
          } // 和html一样，maxW此时在html是满格


          maxW = textWidth;
        } // 普通换行，注意x和lx的区别，可能相同（block起始处）可能不同（非起始处），第1行从x开始，第2行及以后都从lx开始
        // 然后第一次换行还有特殊之处，可能同一行前半部行高很大，此时y增加并非自身的lineHeight，而是整体LineBox的
        else {
          while (i < length) {
            var limit = i ? size : size - beginSpace;

            if (lineClamp && lineCount + lineClampCount >= lineClamp - 1) {
              limit -= endSpace;
            }

            var _measureLineWidth = measureLineWidth(ctx, renderMode, i, length, content, limit, 0, perW, computedStyle, fontFamily, fontSize, fontWeight, 0, letterSpacing),
                num = _measureLineWidth.hypotheticalNum,
                rw = _measureLineWidth.rw,
                newLine = _measureLineWidth.newLine; // 多行文本截断，这里肯定需要回退，注意防止恰好是最后一个字符，此时无需截取


            if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1 && i + num < length) {
              var _this$__lineBack3 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, 0, letterSpacing, isUpright);

              var _this$__lineBack4 = _slicedToArray(_this$__lineBack3, 2);

              mainCoords = _this$__lineBack4[0];
              maxW = _this$__lineBack4[1];
              lineCount++;

              if (isUpright) {
                x = mainCoords;
              } else {
                y = mainCoords;
              }

              break;
            } // 最后一行考虑endSpace，可能不够需要回退，但不能是1个字符


            if (i + num === length && endSpace && rw + endSpace > limit + 1e-10 && num > 1) {
              var res = measureLineWidth(ctx, renderMode, i, length, content, limit - endSpace, 0, perW, computedStyle, fontFamily, fontSize, fontWeight, 0, letterSpacing);
              num = res.hypotheticalNum;
              rw = res.rw;
              newLine = res.newLine; // 可能加上endSpace后超过了，还得再判断一次

              if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1) {
                var _this$__lineBack5 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, 0, letterSpacing, isUpright);

                var _this$__lineBack6 = _slicedToArray(_this$__lineBack5, 2);

                mainCoords = _this$__lineBack6[0];
                maxW = _this$__lineBack6[1];
                lineCount++;

                if (isUpright) {
                  x = mainCoords;
                } else {
                  y = mainCoords;
                }

                break;
              }
            }

            maxW = Math.max(maxW, rw); // 根据是否第一行分开处理行首空白

            var _textBox = new TextBox(this, textBoxes.length, lineCount && !isUpright ? lx : x, lineCount && isUpright ? ly : y, rw, lineHeight, content.slice(i, i + num), isUpright);

            textBoxes.push(_textBox);
            lineBoxManager.addItem(_textBox, newLine); // 竖排横排换行不一样

            if (isUpright) {
              x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
            } else {
              y += Math.max(lineHeight, lineBoxManager.lineHeight);
            } // 至少也要1个字符形成1行，哪怕是首行，因为是否放得下逻辑在dom中做过了


            i += num;

            if (newLine) {
              lineCount++;
            }
          } // 换行后Text的x重设为lx


          if (lineCount) {
            if (isUpright) {
              this.__y = this.__y1 = ly;
            } else {
              this.__x = this.__x1 = lx;
            }
          }
        }

        if (isUpright) {
          this.__width = x - data.x;
          this.__height = maxW;
          this.__verticalBaseline = css.getVerticalBaseline(computedStyle);
        } else {
          this.__width = maxW;
          this.__height = y - data.y;
          this.__baseline = css.getBaseline(computedStyle);
        }

        return lineClampCount + lineCount;
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        this.__width = this.__height = this.__baseline = this.__verticalBaseline = 0;

        this.__textBoxes.splice(0);
      } // 末尾行因ellipsis的缘故向前回退字符生成textBox，可能会因不满足宽度导致无法生成，此时向前继续回退TextBox

    }, {
      key: "__lineBack",
      value: function __lineBack(ctx, renderMode, i, length, content, limit, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, fontSizeShrink, letterSpacing, isUpright) {
        var ew,
            bp = this.__bp,
            computedStyle = bp.computedStyle; // 临时测量ELLIPSIS的尺寸

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          var font = css.setFontStyle(computedStyle, 0);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          ew = ctx.measureText(ELLIPSIS$1).width;
        } else {
          ew = inject.measureTextSync(ELLIPSIS$1, fontFamily, fontSize, fontWeight, false);
        }

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          var _font = css.setFontStyle(this.computedStyle, 0);

          if (ctx.font !== _font) {
            ctx.font = _font;
          }
        }

        this.__fitFontSize = 0;

        var _measureLineWidth2 = measureLineWidth(ctx, renderMode, i, length, content, limit - endSpace, ew, perW, computedStyle, fontFamily, fontSize, fontWeight, fontSizeShrink, letterSpacing),
            num = _measureLineWidth2.hypotheticalNum,
            rw = _measureLineWidth2.rw,
            newLine = _measureLineWidth2.newLine,
            fitFontSize = _measureLineWidth2.fitFontSize,
            ew2 = _measureLineWidth2.ew; // 缩小的fontSize


        if (fitFontSize) {
          this.__fitFontSize = fitFontSize;
        }

        if (ew2) {
          ew = ew2;
        } // 缩小后可能不再换行，下面的逻辑都要预先判断newLine
        // 还是不够，需要回溯查找前一个inline节点继续回退，同时防止空行首，要至少一个textBox且一个字符


        if (newLine && rw + ew > limit + 1e-10 - endSpace) {
          // 向前回溯已有的tb，需注意可能是新行开头这时还没生成新的lineBox，而旧行则至少1个内容
          // 新行的话进不来，会添加上面num的内容，旧行不添加只修改之前的tb内容也有可能删除一些
          var lineBox = lineBoxManager.lineBox;

          if (!lineBoxManager.isNewLine && lineBox && lineBox.size) {
            var list = lineBox.list;

            for (var j = list.length - 1; j >= 0; j--) {
              var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

              if (!(tb instanceof TextBox)) {
                if (!j) {
                  break;
                }

                var _item = list.pop();

                if (isUpright) {
                  y -= _item.outerHeight;
                } else {
                  x -= _item.outerWidth;
                }

                limit += isUpright ? _item.outerHeight : _item.outerWidth;

                _item.__layoutNone();

                continue;
              } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


              var _content = tb.content,
                  width = tb.width,
                  height = tb.height,
                  parent = tb.parent;

              if (!j || limit >= width + ew + 1e-10 + endSpace) {
                var _length = _content.length;
                var _parent$computedStyle = parent.computedStyle,
                    _lineHeight = _parent$computedStyle[LINE_HEIGHT$4],
                    _letterSpacing = _parent$computedStyle[LETTER_SPACING$2],
                    _fontSize = _parent$computedStyle[FONT_SIZE$5],
                    _fontWeight = _parent$computedStyle[FONT_WEIGHT$3],
                    _fontFamily = _parent$computedStyle[FONT_FAMILY$3];

                if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
                  ctx.font = css.setFontStyle(parent.computedStyle, 0);
                } // 再进行查找，这里也会有至少一个字符不用担心


                var _measureLineWidth3 = measureLineWidth(ctx, renderMode, 0, _length, _content, limit + width - endSpace, ew, perW, computedStyle, _fontFamily, _fontSize, _fontWeight, 0, _letterSpacing),
                    _num = _measureLineWidth3.hypotheticalNum,
                    _rw = _measureLineWidth3.rw; // 可能发生x回退，当tb的内容产生减少时


                if (_num !== _content.length) {
                  tb.__content = _content.slice(0, _num);

                  if (isUpright) {
                    y -= height - _rw;
                    tb.__height = _rw;
                  } else {
                    x -= width - _rw;
                    tb.__width = _rw;
                  }
                } // 重新设置lineHeight和baseline，因为可能删除了东西


                lineBox.__resetLb(computedStyle[LINE_HEIGHT$4], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

                var ep = isUpright ? new Ellipsis(x, y + _rw + endSpace, ew, bp, this, isUpright) : new Ellipsis(x + _rw + endSpace, y, ew, bp, this, isUpright);
                lineBoxManager.addItem(ep, true);

                if (isUpright) {
                  x += Math.max(_lineHeight, lineBoxManager.verticalLineHeight);
                } else {
                  y += Math.max(_lineHeight, lineBoxManager.lineHeight);
                }

                maxW = Math.max(maxW, _rw + ew);
                return [y, maxW];
              } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


              var item = list.pop();

              if (isUpright) {
                limit += height;
                y -= height;
              } else {
                limit += width;
                x -= width;
              }

              var tbs = item.parent.textBoxes;
              var k = tbs.indexOf(item);

              if (k > -1) {
                tbs.splice(k, 1);
              } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


              var dom = item.parent.parent;
              var prev = list[list.length - 1];

              if (prev instanceof TextBox) {
                prev = prev.parent.parent;
              }

              while (dom !== bp && dom !== prev) {
                var _contentBoxList = dom.contentBoxList || [];

                var _i2 = _contentBoxList.indexOf(item);

                if (_i2 > -1) {
                  _contentBoxList.splice(_i2, 1);
                }

                var _computedStyle = dom.computedStyle;

                if (isUpright) {
                  var mbp = _computedStyle[MARGIN_TOP$6] + _computedStyle[MARGIN_BOTTOM$6] + _computedStyle[PADDING_TOP$6] + _computedStyle[PADDING_BOTTOM$5] + _computedStyle[BORDER_TOP_WIDTH$6] + _computedStyle[BORDER_BOTTOM_WIDTH$5];
                  y -= mbp;
                  limit += mbp;
                } else {
                  var _mbp = _computedStyle[MARGIN_LEFT$8] + _computedStyle[MARGIN_RIGHT$7] + _computedStyle[PADDING_LEFT$8] + _computedStyle[PADDING_RIGHT$7] + _computedStyle[BORDER_LEFT_WIDTH$8] + _computedStyle[BORDER_RIGHT_WIDTH$7];

                  x -= _mbp;
                  limit += _mbp;
                }

                dom.__layoutNone();

                dom = dom.domParent;
              }

              var contentBoxList = prev.contentBoxList || [];

              var _i = contentBoxList.indexOf(item);

              if (_i > -1) {
                contentBoxList.splice(_i, 1);
              }
            }
          }
        } // 本次回退不用向前追溯删除textBox会进这里，最少一个字符兜底


        var textBox = new TextBox(this, textBoxes.length, x, y, rw, lineHeight, content.slice(i, i + num), isUpright);
        textBoxes.push(textBox);
        lineBoxManager.addItem(textBox, false); // ELLIPSIS也作为内容加入，但特殊的是指向最近block使用其样式渲染

        if (newLine) {
          var _ep = isUpright ? new Ellipsis(x, y + rw + endSpace, ew, bp, this, isUpright) : new Ellipsis(x + rw + endSpace, y, ew, bp, this, isUpright);

          lineBoxManager.addItem(_ep, true);
        }

        if (isUpright) {
          x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
        } else {
          y += Math.max(lineHeight, lineBoxManager.lineHeight);
        }

        maxW = Math.max(maxW, rw + newLine ? ew : 0);
        return [isUpright ? x : y, maxW];
      } // 外部dom换行发现超行，且一定是ellipsis时，会进这里让上一行text回退，lineBox一定有值且最后一个一定是本text的最后的textBox

    }, {
      key: "__backtrack",
      value: function __backtrack(bp, lineBoxManager, lineBox, textBox, limit, endSpace, ew, computedStyle, ctx, renderMode, isUpright) {
        var list = lineBox.list;

        for (var j = list.length - 1; j >= 0; j--) {
          var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

          if (!(tb instanceof TextBox)) {
            if (!j) {
              break;
            }

            var _item2 = list.pop();

            limit += isUpright ? _item2.outerHeight : _item2.outerWidth;

            _item2.__layoutNone();

            continue;
          } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


          var content = tb.content,
              width = tb.width,
              height = tb.height,
              parent = tb.parent;

          if (!j || limit >= width + ew + 1e-10 + endSpace) {
            var length = content.length;
            var _parent$computedStyle2 = parent.computedStyle,
                letterSpacing = _parent$computedStyle2[LETTER_SPACING$2],
                fontSize = _parent$computedStyle2[FONT_SIZE$5],
                fontWeight = _parent$computedStyle2[FONT_WEIGHT$3],
                fontFamily = _parent$computedStyle2[FONT_FAMILY$3];

            if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
              ctx.font = css.setFontStyle(parent.computedStyle, 0);
            }

            var perW = fontSize * 0.8 + letterSpacing; // 再进行查找，这里也会有至少一个字符不用担心

            var _measureLineWidth4 = measureLineWidth(ctx, renderMode, 0, length, content, limit - endSpace + width, ew, perW, computedStyle, fontFamily, fontSize, fontWeight, 0, letterSpacing),
                num = _measureLineWidth4.hypotheticalNum,
                rw = _measureLineWidth4.rw; // 可能发生x回退，当tb的内容产生减少时


            if (num !== content.length) {
              tb.__content = content.slice(0, num);

              if (isUpright) {
                tb.__height = rw;
              } else {
                tb.__width = rw;
              }
            } // 重新设置lineHeight和baseline，因为可能删除了东西


            lineBox.__resetLb(computedStyle[LINE_HEIGHT$4], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

            var ep = isUpright ? new Ellipsis(tb.x, tb.y + rw + endSpace, ew, bp, this, isUpright) : new Ellipsis(tb.x + rw + endSpace, tb.y, ew, bp, this, isUpright);
            lineBoxManager.addItem(ep, true);
            return;
          } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


          var item = list.pop();
          limit += isUpright ? height : width;
          var tbs = item.parent.textBoxes;
          var k = tbs.indexOf(item);

          if (k > -1) {
            tbs.splice(k, 1);
          } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


          var dom = item.parent.parent;
          var prev = list[list.length - 1];

          if (prev instanceof TextBox) {
            prev = prev.parent.parent;
          }

          while (dom !== bp && dom !== prev) {
            var _contentBoxList2 = dom.contentBoxList || [];

            var _i3 = _contentBoxList2.indexOf(item);

            if (_i3 > -1) {
              _contentBoxList2.splice(_i3, 1);
            }

            var _computedStyle2 = dom.computedStyle;

            if (isUpright) {
              var mbp = _computedStyle2[MARGIN_TOP$6] + _computedStyle2[MARGIN_BOTTOM$6] + _computedStyle2[PADDING_TOP$6] + _computedStyle2[PADDING_BOTTOM$5] + _computedStyle2[BORDER_TOP_WIDTH$6] + _computedStyle2[BORDER_BOTTOM_WIDTH$5];
              limit += mbp;
            } else {
              var _mbp2 = _computedStyle2[MARGIN_LEFT$8] + _computedStyle2[MARGIN_RIGHT$7] + _computedStyle2[PADDING_LEFT$8] + _computedStyle2[PADDING_RIGHT$7] + _computedStyle2[BORDER_LEFT_WIDTH$8] + _computedStyle2[BORDER_RIGHT_WIDTH$7];

              limit += _mbp2;
            }

            dom.__layoutNone();

            dom = dom.domParent;
          }

          var contentBoxList = prev.contentBoxList || [];
          var i = contentBoxList.indexOf(item);

          if (i > -1) {
            contentBoxList.splice(i, 1);
          }
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetX", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetX(diff);
          });
        }

        this.__x1 += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetY", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetY(diff);
          });
        }

        this.__y1 += diff;
      }
    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(total) {
        return total - this.firstCharWidth;
      }
    }, {
      key: "__inlineSize",
      value: function __inlineSize(isUpright) {
        var min, max;
        this.textBoxes.forEach(function (item, i) {
          if (i) {
            min = Math.min(min, isUpright ? item.y : item.x);
            max = Math.max(max, (isUpright ? item.y : item.x) + item.width);
          } else {
            min = isUpright ? item.y : item.x;
            max = (isUpright ? item.y : item.x) + item.width;
          }
        });

        if (isUpright) {
          this.__y = this.__y1 = min;
          this.__x = this.__x1;
          this.__height = max - min;
        } else {
          this.__x = this.__x1 = min;
          this.__y = this.__y1;
          this.__width = max - min;
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            cacheStyle = this.cacheStyle;

        if (renderMode === SVG$2) {
          this.__virtualDom = {
            type: 'text',
            children: []
          };
        } // >=REPAINT清空bbox


        this.__bbox = null;
        this.__filterBbox = null;

        if (__isDestroyed || computedStyle[DISPLAY$7] === 'none' || computedStyle[VISIBILITY$4] === 'hidden' || !textBoxes.length) {
          this.__hasContent = false;
          return;
        }

        this.__hasContent = true;

        if (renderMode === WEBGL$2) {
          return;
        }

        if (renderMode === CANVAS$2) {
          var font = css.setFontStyle(computedStyle, this.__fitFontSize);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          var color = cacheStyle[COLOR$3]; // 渐变

          if (color.k) {
            var dom = this.parent;
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          var strokeWidth = computedStyle[TEXT_STROKE_WIDTH$3];

          if (ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          var textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$3]; // 渐变

          if (textStrokeColor.k) {
            var _dom = this.parent;
            textStrokeColor = _dom.__gradient(renderMode, ctx, _dom.__bx1, _dom.__by1, _dom.__bx2, _dom.__by2, textStrokeColor, dx, dy).v;
          }

          if (ctx.strokeStyle !== textStrokeColor) {
            ctx.strokeStyle = textStrokeColor;
          }
        } // 可能为空，整个是个ellipsis


        textBoxes.forEach(function (item) {
          item.render(renderMode, ctx, computedStyle, cacheStyle, dx, dy);
        });

        if (renderMode === SVG$2) {
          this.__virtualDom.children = textBoxes.map(function (textBox) {
            return textBox.virtualDom;
          });
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        _get(_getPrototypeOf(Text.prototype), "__destroy", this).call(this);

        var __cache = this.__cache;

        if (__cache) {
          __cache.release();
        }
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        return this.__domParent.getComputedStyle(key);
      }
    }, {
      key: "updateContent",
      value: function updateContent(s, cb) {
        if (s === this.__content || this.__isDestroyed) {
          this.__content = s;

          if (isFunction$a(cb)) {
            cb(true);
          }

          return;
        }

        this.__widthHash = {};

        if (util.isNil(s)) {
          s = '';
        } else {
          s = s.toString();
        }

        this.__content = s;

        this.__root.__addUpdate(this.__domParent, null, o$1.REFLOW, false, false, false, false, cb);
      }
    }, {
      key: "remove",
      value: function remove(cb) {
        var root = this.__root;
        var parent = this.isShadowRoot ? this.hostRoot.__parent : this.__parent;
        var i;

        if (parent) {
          var target = this.isShadowRoot ? this.hostRoot : this;
          i = parent.__children.indexOf(target);

          parent.__children.splice(i, 1);

          i = parent.__zIndexChildren.indexOf(target);

          parent.__zIndexChildren.splice(i, 1);

          var __prev = this.__prev,
              __next = this.__next;

          if (__prev) {
            __prev.__next = __next;
          }

          if (__next) {
            __next.__prev = __prev;
          }
        }

        if (this.__isDestroyed) {
          if (isFunction$a(cb)) {
            cb(true);
          }

          return;
        }

        parent.__deleteStruct(this, i); // 不可见仅改变数据结构


        if (this.computedStyle[DISPLAY$7] === 'none') {
          this.__destroy();

          if (isFunction$a(cb)) {
            cb(true);
          }

          return;
        } // 可见在reflow逻辑做结构关系等，text视为父变更


        root.__addUpdate(this, null, o$1.REFLOW, false, true, false, false, cb);
      }
    }, {
      key: "__structure",
      value: function __structure(lv, j) {
        var o = _get(_getPrototypeOf(Text.prototype), "__structure", this).call(this, lv, j);

        o.isText = true;
        return o;
      }
    }, {
      key: "__layoutStyle",
      value: function __layoutStyle() {
        var wn = this.__wasmNode;

        if (wn) {
          wn.set_txt(this.__x1, this.__y1, this.__width, this.__height);
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      },
      set: function set(v) {
        this.updateContent(v, null);
      }
    }, {
      key: "textBoxes",
      get: function get() {
        return this.__textBoxes;
      }
    }, {
      key: "charWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root = this.root,
            ctx = _this$root.ctx,
            renderMode = _this$root.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$5],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('charWidth')) {
          var max = 0;

          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle, 0);

            for (var i = 0, len = content.length; i < len; i++) {
              max = Math.max(max, ctx.measureText(content.charAt([i])).width);
            }
          } else if (renderMode === SVG$2) {
            max = inject.measureTextListMax(content, fontFamily, fontSize, fontWeight);
          }

          o.charWidth = max + letterSpacing;
        }

        return o.charWidth;
      }
    }, {
      key: "firstCharWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root2 = this.root,
            ctx = _this$root2.ctx,
            renderMode = _this$root2.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$5],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('firstCharWidth')) {
          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle, 0);
            o.firstCharWidth = ctx.measureText(content.charAt(0)).width + letterSpacing;
          } else if (renderMode === SVG$2) {
            o.firstCharWidth = inject.measureTextSync(content.charAt(0), fontFamily, fontSize, fontWeight, false) + letterSpacing;
          }
        }

        return o.firstCharWidth;
      }
    }, {
      key: "textWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root3 = this.root,
            ctx = _this$root3.ctx,
            renderMode = _this$root3.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$5],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$2];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('textWidth')) {
          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle, 0);
            o.textWidth = ctx.measureText(content).width + letterSpacing * content.length;
          } else if (renderMode === SVG$2) {
            o.textWidth = inject.measureTextSync(content, fontFamily, fontSize, fontWeight, false) + letterSpacing * content.length;
          }
        }

        return o.textWidth;
      }
    }, {
      key: "clientWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "clientHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__domParent.__root;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.__domParent.__currentStyle;
      }
    }, {
      key: "__currentStyle",
      get: function get() {
        return this.__domParent.__currentStyle;
      }
    }, {
      key: "style",
      get: function get() {
        return this.__domParent.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.__domParent.__computedStyle;
      }
    }, {
      key: "__computedStyle",
      get: function get() {
        return this.__domParent.__computedStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.__domParent.__cacheStyle;
      }
    }, {
      key: "__cacheStyle",
      get: function get() {
        return this.__domParent.__cacheStyle;
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var __x1 = this.__x1,
              __y1 = this.__y1,
              width = this.width,
              height = this.height,
              textStrokeWidth = this.computedStyle[TEXT_STROKE_WIDTH$3]; // 文字描边暂时不清楚最大值是多少，影响不确定，先按描边宽算，因为会出现>>0.5宽的情况

          var half = textStrokeWidth;
          this.__bbox = [__x1 - half, __y1 - half, __x1 + width + half, __y1 + height + half];
        }

        return this.__bbox;
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.__bbox || this.bbox;
          var filter = this.computedStyle[FILTER$4];
          this.__filterBbox = css.spreadFilter(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.__parent && this.__host && this.__host !== this.root;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.__domParent.__matrix;
      }
    }, {
      key: "matrixEvent",
      get: function get() {
        return this.__domParent.__matrixEvent;
      }
    }, {
      key: "perspectiveMatrix",
      get: function get() {
        return this.__domParent.__perspectiveMatrix;
      }
    }, {
      key: "fitFontSize",
      get: function get() {
        return this.__fitFontSize;
      }
    }]);

    return Text;
  }(Node$1);

  var isFunction$9 = util.isFunction;

  var Event = /*#__PURE__*/function () {
    function Event() {
      this.__eHash = {};
    }

    _createClass(Event, [{
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$9(handle)) {
          return;
        }

        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.on(id[i], handle);
          }
        } else {
          if (!self.__eHash.hasOwnProperty(id)) {
            self.__eHash[id] = [];
          } // 遍历防止此handle被侦听过了


          for (var _i = 0, item = self.__eHash[id], _len = item.length; _i < _len; _i++) {
            if (item[_i] === handle) {
              return self;
            }
          }

          self.__eHash[id].push(handle);
        }

        return self;
      }
    }, {
      key: "once",
      value: function once(id, handle) {
        if (!isFunction$9(handle)) {
          return;
        }

        var self = this; // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比

        function cb() {
          for (var _len2 = arguments.length, data = new Array(_len2), _key = 0; _key < _len2; _key++) {
            data[_key] = arguments[_key];
          }

          handle.apply(self, data);
          self.off(id, cb);
        }

        cb.__karasEventCb = handle;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.once(id[i], handle);
          }
        } else if (handle) {
          self.on(id, cb);
        }

        return this;
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.off(id[i], handle);
          }
        } else if (self.__eHash.hasOwnProperty(id)) {
          if (handle) {
            for (var _i2 = 0, item = self.__eHash[id], _len3 = item.length; _i2 < _len3; _i2++) {
              // 需考虑once包裹的引用对比
              if (item[_i2] === handle || item[_i2].__karasEventCb === handle) {
                item.splice(_i2, 1);
                break;
              }
            }
          } // 未定义为全部清除
          else {
            delete self.__eHash[id];
          }
        }

        return this;
      }
    }, {
      key: "emit",
      value: function emit(id) {
        var self = this;

        for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key2 = 1; _key2 < _len4; _key2++) {
          data[_key2 - 1] = arguments[_key2];
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.emit(id[i], data);
          }
        } else {
          if (self.__eHash.hasOwnProperty(id)) {
            var list = self.__eHash[id];

            if (list.length) {
              list = list.slice();

              for (var _i3 = 0, _len5 = list.length; _i3 < _len5; _i3++) {
                var cb = list[_i3];

                if (isFunction$9(cb)) {
                  cb.apply(self, data);
                }
              }
            }
          }
        }

        return this;
      }
    }], [{
      key: "mix",
      value: function mix() {
        for (var i = arguments.length - 1; i >= 0; i--) {
          var o = i < 0 || arguments.length <= i ? undefined : arguments[i];
          var event = new Event();
          o.__eHash = {};
          var fns = ['on', 'once', 'off', 'emit'];

          for (var j = fns.length - 1; j >= 0; j--) {
            var fn = fns[j];
            o[fn] = event[fn];
          }
        }
      }
    }]);

    return Event;
  }();

  _defineProperty(Event, "REFRESH", 'refresh');

  _defineProperty(Event, "PAUSE", 'pause');

  _defineProperty(Event, "PLAY", 'play');

  _defineProperty(Event, "FRAME", 'frame');

  _defineProperty(Event, "FINISH", 'finish');

  _defineProperty(Event, "CANCEL", 'cancel');

  _defineProperty(Event, "BEGIN", 'begin');

  _defineProperty(Event, "END", 'end');

  _defineProperty(Event, "FREEZE", 'freeze');

  _defineProperty(Event, "UN_FREEZE", 'unFreeze');

  var isNil$d = util.isNil,
      isFunction$8 = util.isFunction,
      extend$2 = util.extend;
  var REGISTER$1 = {};

  var Component = /*#__PURE__*/function (_Event) {
    _inherits(Component, _Event);

    function Component() {
      var _this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _this = _Event.call(this) || this;
      _this.__tagName = props.tagName || /(?:function|class)\s+([\w$]+)/.exec(_this.constructor.toString())[1]; // 构建工具中都是{}，手写可能出现[]情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__parent = null;
      _this.__host = null;
      _this.__ref = {};
      _this.__isMounted = false;
      _this.__taskList = [];
      return _this;
    }
    /**
     * build中调用初始化，处理过flatten
     */


    _createClass(Component, [{
      key: "__init",
      value: function __init() {
        var _this2 = this;

        this.__ref = {};
        var sr = this.__shadowRoot;

        if (sr instanceof Text) ; else if (sr instanceof Node$1) {
          // 组件的json的动画得放到sr上
          var ar = this.__animateRecords;

          if (ar) {
            sr.__animateRecords = ar;
          }

          var style = css.normalize(this.props.style);
          var keys = Object.keys(style);
          extend$2(sr.style, style, keys);
          extend$2(sr.currentStyle, style, keys); // 事件添加到sr

          Object.keys(this.props).forEach(function (k) {
            var v = _this2.props[k];

            if (/^on[a-zA-Z]/.test(k)) {
              k = k.slice(2).toLowerCase();
              sr.listener[k] = v;
            }
          });
        } // 自定义事件无视返回强制添加


        Object.keys(this.props).forEach(function (k) {
          var v = _this2.props[k];

          if (/^on-[a-zA-Z\d_$]/.test(k)) {
            k = k.slice(3);

            _this2.on(k, v);
          }
        });

        if (isFunction$8(this.componentDidMount)) {
          // 可能已经销毁
          var cb = this.__cb = function () {
            if (!_this2.__root.__isDestroyed && !_this2.__isDestroyed) {
              _this2.componentDidMount();

              _this2.__root.off(Event.REFRESH, cb);

              _this2.__cb = null;
            }
          };

          this.__root.once(Event.REFRESH, cb);
        }
      }
    }, {
      key: "render",
      value: function render() {
        inject.warn('Component should implement render()');
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        this.__isDestroyed = true;
        this.__isMounted = false;
        var ref = this.props.ref;

        if (!isNil$d(ref) && !isFunction$8(ref)) {
          delete this.__root.__ref[ref];
        } // 极限情况尚未触发需清除


        if (this.__cb) {
          this.__root.off(Event.REFRESH, this.__cb);

          this.__cb = null;
        }

        if (isFunction$8(this.componentWillUnmount)) {
          this.componentWillUnmount();
        }

        if (this.__shadow) {
          this.__shadow.__destroy();
        }

        this.__host = this.__hostRoot = this.__shadow = this.__shadowRoot = this.__prev = this.__next = this.__root = this.__parent = this.__domParent = null;
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var sr = this.shadowRoot;

        if (sr instanceof Text) {
          return;
        }

        var res = sr.__emitEvent(e, force);

        if (res) {
          e.target = this;
          return true;
        }
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "shadow",
      get: function get() {
        return this.__shadow;
      }
    }, {
      key: "shadowRoot",
      get: function get() {
        return this.__shadowRoot;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__root;
      }
    }, {
      key: "host",
      get: function get() {
        return this.__host;
      }
    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER$1;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (name && !util.isString(name) && name.prototype && name.prototype instanceof Component) {
          return name;
        }

        if (!name || !util.isString(name) || !/^[A-Z]/.test(name)) {
          throw new Error('Invalid param');
        }

        if (!REGISTER$1.hasOwnProperty(name)) {
          throw new Error("Component has not register: ".concat(name));
        }

        return REGISTER$1[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || !/^[A-Z]/.test(name) || !obj.prototype || !(obj.prototype instanceof Component)) {
          throw new Error('Invalid param: Component register');
        }

        if (Component.hasRegister(name)) {
          throw new Error("Component has already register: ".concat(name));
        }

        REGISTER$1[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER$1.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Component.hasRegister(name)) {
          delete REGISTER$1[name];
        }
      }
    }]);

    return Component;
  }(Event);

  Object.keys(o$2.GEOM).concat(['x', 'y', 'width', 'height', 'outerWidth', 'outerHeight', 'clientWidth', 'clientHeight', 'offsetWidth', 'offsetHeight', 'style', 'children', 'animationList', 'currentStyle', 'computedStyle', 'cacheStyle', '__currentStyle', '__computedStyle', '__cacheStyle', 'currentProps', '__currentProps', 'cacheProps', '__cacheProps', 'baseline', 'virtualDom', 'mask', 'maskId', 'textWidth', 'content', 'lineBoxes', 'charWidthList', 'charWidth', '__layoutData', '__struct', 'bbox', 'contentBoxList', 'listener', 'matrix', 'matrixEvent']).forEach(function (fn) {
    Object.defineProperty(Component.prototype, fn, {
      get: function get() {
        var sr = this.shadowRoot;

        if (sr) {
          return sr[fn];
        }
      }
    });
  });
  ['__layout', '__layoutFlow', '__layoutStyle', '__layoutAbs', '__layoutNone', '__tryLayInline', '__offsetX', '__offsetY', '__calAutoBasis', '__computeReflow', '__mp', 'animate', 'removeAnimate', 'clearAnimate', 'frameAnimate', 'updateStyle', 'getBoundingClientRect', 'getComputedStyle', 'getStyle', 'clearCache', '__structure', '__updateStruct', 'flowChildren', 'absChildren', '__isRealInline', '__calBasis', '__calMinMax', '__computeMeasure', 'appendChild', 'prependChild', 'insertBefore', 'insertAfter', 'removeChild', 'remove', 'addEventListener', 'removeEventListener'].forEach(function (fn) {
    Component.prototype[fn] = function () {
      var sr = this.shadowRoot;

      if (sr && isFunction$8(sr[fn])) {
        return sr[fn].apply(sr, arguments);
      }
    };
  });

  var _enums$STYLE_KEY$d = enums.STYLE_KEY,
      MARGIN_TOP$5 = _enums$STYLE_KEY$d.MARGIN_TOP,
      MARGIN_LEFT$7 = _enums$STYLE_KEY$d.MARGIN_LEFT,
      MARGIN_RIGHT$6 = _enums$STYLE_KEY$d.MARGIN_RIGHT,
      MARGIN_BOTTOM$5 = _enums$STYLE_KEY$d.MARGIN_BOTTOM,
      PADDING_TOP$5 = _enums$STYLE_KEY$d.PADDING_TOP,
      PADDING_LEFT$7 = _enums$STYLE_KEY$d.PADDING_LEFT,
      PADDING_RIGHT$6 = _enums$STYLE_KEY$d.PADDING_RIGHT,
      PADDING_BOTTOM$4 = _enums$STYLE_KEY$d.PADDING_BOTTOM,
      BORDER_TOP_WIDTH$5 = _enums$STYLE_KEY$d.BORDER_TOP_WIDTH,
      BORDER_LEFT_WIDTH$7 = _enums$STYLE_KEY$d.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$6 = _enums$STYLE_KEY$d.BORDER_RIGHT_WIDTH,
      BORDER_BOTTOM_WIDTH$4 = _enums$STYLE_KEY$d.BORDER_BOTTOM_WIDTH;
  /**
   * 获取inline的每一行内容的矩形坐标4个点，同时附带上border的矩形，比前面4个点尺寸大或相等（有无border/padding）
   * @param xom
   * @param isUpright
   * @param contentBoxList
   * @param start
   * @param end
   * @param lineBox
   * @param baseline
   * @param lineHeight
   * @param leading
   * @param isStart
   * @param isEnd
   * @param backgroundClip
   * @param paddingTop
   * @param paddingRight
   * @param paddingBottom
   * @param paddingLeft
   * @param borderTopWidth
   * @param borderRightWidth
   * @param borderBottomWidth
   * @param borderLeftWidth
   * @returns {(*|number)[]}
   */

  function getInlineBox(xom, isUpright, contentBoxList, start, end, lineBox, baseline, lineHeight, leading, isStart, isEnd, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth) {
    // 根据bgClip确定y伸展范围，inline渲染bg扩展到pb的位置不影响布局
    var bcStart = 0,
        bcEnd = 0;
    var pbStart = isUpright ? paddingLeft + borderLeftWidth : paddingTop + borderTopWidth;
    var pbEnd = isUpright ? paddingRight + borderRightWidth : paddingBottom + borderBottomWidth;

    if (backgroundClip === 'paddingBox') {
      bcStart = isUpright ? paddingLeft : paddingTop;
      bcEnd = isUpright ? paddingRight : paddingBottom;
    } else if (backgroundClip === 'borderBox') {
      bcStart = pbStart;
      bcEnd = pbEnd;
    } // inline的baseline和lineBox的差值，不同lh时造成的偏移，一般为多个textBox时比较小的那个发生
    // 垂直排版不能简单算baseline差值，因为原点坐标系不一样


    var diff;

    if (isUpright) {
      diff = lineBox.verticalBaseline - baseline;
    } else {
      diff = lineBox.baseline - baseline;
    }

    var x1, y1, x2, y2, bx1, by1, bx2, by2; // x坐标取首尾contentBox的左右2侧，clip布局时已算好；y是根据lineHeight和lineBox的高度以及baseline对齐后计算的
    // 垂直排版则互换x/y逻辑

    if (isUpright) {
      x1 = lineBox.x + diff - bcStart + leading;
      y1 = start.y;
      bx1 = lineBox.x + diff - pbStart + leading;
    } else {
      x1 = start.x;
      y1 = lineBox.y + lineBox.oy + diff - bcStart + leading;
      by1 = lineBox.y + lineBox.oy + diff - pbStart + leading;
    } // 容器内包含的inline节点，需考虑行首水平mbp（垂直排版为垂直头mbp）


    var dom = start instanceof TextBox ? start.parent.domParent : start.domParent;

    while (dom !== xom) {
      var list = dom.contentBoxList;

      if (start === list[0]) {
        if (isUpright) {
          var _dom$computedStyle = dom.computedStyle,
              marginTop = _dom$computedStyle[MARGIN_TOP$5],
              _paddingTop = _dom$computedStyle[PADDING_TOP$5],
              _borderTopWidth = _dom$computedStyle[BORDER_TOP_WIDTH$5];
          y1 -= marginTop + _paddingTop + _borderTopWidth;
        } else {
          var _dom$computedStyle2 = dom.computedStyle,
              marginLeft = _dom$computedStyle2[MARGIN_LEFT$7],
              _paddingLeft = _dom$computedStyle2[PADDING_LEFT$7],
              _borderLeftWidth = _dom$computedStyle2[BORDER_LEFT_WIDTH$7];
          x1 -= marginLeft + _paddingLeft + _borderLeftWidth;
        }
      }

      dom = dom.domParent;
    } // 第一个需考虑容器本身的padding/border


    if (isUpright) {
      by1 = y1;

      if (isStart) {
        by1 -= paddingTop + borderTopWidth;

        if (backgroundClip === 'paddingBox') {
          y1 -= paddingTop;
        } else if (backgroundClip === 'borderBox') {
          y1 -= paddingTop + borderTopWidth;
        }
      }

      x2 = lineBox.x + diff + lineHeight + bcEnd - leading;
      bx2 = lineBox.x + diff + lineHeight + pbEnd - leading;
      y2 = end.y + end.outerHeight;
    } else {
      bx1 = x1;

      if (isStart) {
        bx1 -= paddingLeft + borderLeftWidth;

        if (backgroundClip === 'paddingBox') {
          x1 -= paddingLeft;
        } else if (backgroundClip === 'borderBox') {
          x1 -= paddingLeft + borderLeftWidth;
        }
      }

      x2 = end.x + end.outerWidth;
      y2 = lineBox.y + lineBox.oy + diff + lineHeight + bcEnd - leading;
      by2 = lineBox.y + lineBox.oy + diff + lineHeight + pbEnd - leading;
    } // TextBox的parent是Text，再是Dom，这里一定是inline，无嵌套就是xom本身，有则包含若干层最上层还是xom


    dom = end instanceof TextBox ? end.parent.domParent : end.domParent; // 从end开始，向上获取dom节点的尾部mpb进行累加，直到xom跳出

    while (dom !== xom) {
      var _list = dom.contentBoxList;

      if (end === _list[_list.length - 1]) {
        if (isUpright) {
          var _dom$computedStyle3 = dom.computedStyle,
              marginBottom = _dom$computedStyle3[MARGIN_BOTTOM$5],
              _paddingBottom = _dom$computedStyle3[PADDING_BOTTOM$4],
              _borderBottomWidth = _dom$computedStyle3[BORDER_BOTTOM_WIDTH$4];
          y2 += marginBottom + _paddingBottom + _borderBottomWidth;
        } else {
          var _dom$computedStyle4 = dom.computedStyle,
              marginRight = _dom$computedStyle4[MARGIN_RIGHT$6],
              _paddingRight = _dom$computedStyle4[PADDING_RIGHT$6],
              _borderRightWidth = _dom$computedStyle4[BORDER_RIGHT_WIDTH$6];
          x2 += marginRight + _paddingRight + _borderRightWidth;
        }
      }

      dom = dom.domParent;
    }

    if (isUpright) {
      by2 = y2;

      if (isEnd) {
        by2 += paddingBottom + borderBottomWidth;

        if (backgroundClip === 'paddingBox') {
          y2 += paddingBottom;
        } else if (backgroundClip === 'borderBox') {
          y2 += paddingBottom + borderBottomWidth;
        }
      }
    } else {
      bx2 = x2;

      if (isEnd) {
        bx2 += paddingRight + borderRightWidth;

        if (backgroundClip === 'paddingBox') {
          x2 += paddingRight;
        } else if (backgroundClip === 'borderBox') {
          x2 += paddingRight + borderRightWidth;
        }
      }
    }

    return [x1, y1, x2, y2, bx1, by1, bx2, by2];
  }
  /**
   * 统计inline的所有contentBox排成一行时的总宽度，考虑嵌套的mpb
   * @param xom
   * @param contentBoxList
   * @param isUpright
   * @returns {number}
   */


  function getInlineWidth(xom, contentBoxList, isUpright) {
    var sum = 0;
    var length = contentBoxList.length;

    if (contentBoxList[length - 1] instanceof Ellipsis) {
      length--;
    }

    for (var i = 0; i < length; i++) {
      var contentBox = contentBoxList[i];

      if (isUpright) {
        sum += contentBox.height;
      } else {
        sum += contentBox.width;
      } // 嵌套时，首尾box考虑mpb


      var dom = contentBox instanceof TextBox ? contentBox.parent.domParent : contentBox.domParent;

      while (dom !== xom) {
        var list = dom.contentBoxList;

        if (contentBox === list[0]) {
          if (isUpright) {
            var _dom$computedStyle5 = dom.computedStyle,
                marginTop = _dom$computedStyle5[MARGIN_TOP$5],
                paddingTop = _dom$computedStyle5[PADDING_TOP$5],
                borderTopWidth = _dom$computedStyle5[BORDER_TOP_WIDTH$5];
            sum += marginTop + paddingTop + borderTopWidth;
          } else {
            var _dom$computedStyle6 = dom.computedStyle,
                marginLeft = _dom$computedStyle6[MARGIN_LEFT$7],
                paddingLeft = _dom$computedStyle6[PADDING_LEFT$7],
                borderLeftWidth = _dom$computedStyle6[BORDER_LEFT_WIDTH$7];
            sum += marginLeft + paddingLeft + borderLeftWidth;
          }
        }

        if (contentBox === list[list.length - 1]) {
          if (isUpright) {
            var _dom$computedStyle7 = dom.computedStyle,
                marginBottom = _dom$computedStyle7[MARGIN_BOTTOM$5],
                paddingBottom = _dom$computedStyle7[PADDING_BOTTOM$4],
                borderBottomWidth = _dom$computedStyle7[BORDER_BOTTOM_WIDTH$4];
            sum += marginBottom + paddingBottom + borderBottomWidth;
          } else {
            var _dom$computedStyle8 = dom.computedStyle,
                marginRight = _dom$computedStyle8[MARGIN_RIGHT$6],
                paddingRight = _dom$computedStyle8[PADDING_RIGHT$6],
                borderRightWidth = _dom$computedStyle8[BORDER_RIGHT_WIDTH$6];
            sum += marginRight + paddingRight + borderRightWidth;
          }
        }

        dom = dom.domParent;
      }
    }

    return sum;
  }

  var inline = {
    getInlineBox: getInlineBox,
    getInlineWidth: getInlineWidth
  };

  var _enums$STYLE_KEY$c = enums.STYLE_KEY,
      SCALE_X$3 = _enums$STYLE_KEY$c.SCALE_X,
      SCALE_Y$3 = _enums$STYLE_KEY$c.SCALE_Y;
  var NUMBER$3 = o$4.NUMBER;

  function matrixResize(imgWidth, imgHeight, targetWidth, targetHeight, x, y, w, h) {
    if (imgWidth === targetWidth && imgHeight === targetHeight) {
      return;
    }

    var list = [{
      k: SCALE_X$3,
      v: {
        v: targetWidth / imgWidth,
        u: NUMBER$3
      }
    }, {
      k: SCALE_Y$3,
      v: {
        v: targetHeight / imgHeight,
        u: NUMBER$3
      }
    }];
    return transform$1.calMatrixWithOrigin(list, x, y, w, h);
  }

  var image = {
    matrixResize: matrixResize
  };

  var _enums$STYLE_KEY$b = enums.STYLE_KEY,
      BACKGROUND_POSITION_X$2 = _enums$STYLE_KEY$b.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$2 = _enums$STYLE_KEY$b.BACKGROUND_POSITION_Y;
  var clone$2 = util.clone,
      joinArr$2 = util.joinArr;
  var canvasPolygon$4 = painter.canvasPolygon,
      svgPolygon$4 = painter.svgPolygon;

  function renderBgc(xom, renderMode, ctx, color, list, x, y, w, h, btlr, btrr, bbrr, bblr) {
    var method = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 'fill';
    var isInline = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : false;
    var dx = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0;
    var dy = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0;
    // radial渐变ellipse形状会有matrix，用以从圆缩放到椭圆
    var matrix$1, cx, cy;

    if (Array.isArray(color)) {
      matrix$1 = color[1];
      cx = color[2];
      cy = color[3];
      color = color[0];
    } // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间


    list = list || border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    } // 椭圆有matrix，用逆矩阵变化点来完成


    if (matrix$1) {
      matrix$1 = transform$1.calMatrixByOrigin(matrix$1, cx, cy);
      var t = matrix.inverse(matrix$1);
      list = list.map(function (item) {
        if (!item || !item.length) {
          return null;
        }

        var arr = [];

        for (var i = 0, len = item.length; i < len; i += 2) {
          var p = matrix.calPoint({
            x: item[i],
            y: item[i + 1]
          }, t);
          arr.push(p.x);
          arr.push(p.y);
        }

        return arr;
      });
    }

    if (renderMode === mode.CANVAS) {
      if (matrix$1) {
        ctx.save();
        var me = xom.matrixEvent;
        matrix$1 = matrix.multiply(me, matrix$1);
        ctx.setTransform(matrix$1[0], matrix$1[1], matrix$1[4], matrix$1[5], matrix$1[12], matrix$1[13]);
      }

      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      canvasPolygon$4(ctx, list, dx, dy, true);
      ctx[method]();

      if (matrix$1) {
        ctx.restore();
      }
    } else if (renderMode === mode.SVG) {
      var d = svgPolygon$4(list);

      if (isInline) {
        var v = {
          tagName: 'symbol',
          props: [],
          children: [{
            type: 'item',
            tagName: 'path',
            props: [['d', d], ['fill', color]]
          }]
        };

        xom.__cacheDefs.push(v);

        return ctx.add(v);
      } else {
        xom.virtualDom.bb.push({
          type: 'item',
          tagName: 'path',
          props: [['d', d], ['fill', color]]
        }); // 椭圆渐变独有

        if (matrix$1) {
          var bb = xom.virtualDom.bb;
          bb[bb.length - 1].props.push(['transform', "matrix(".concat(joinArr$2(matrix.m2m6(matrix$1), ','), ")")]);
        }
      }
    }
  }

  function renderImage(xom, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, isInline) {
    var dx = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : 0;
    var dy = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : 0;
    var source = loadBgi.source; // 无source不绘制，可能错误或加载中

    if (source) {
      bx1 += dx;
      by1 += dy;
      bx2 += dx;
      by2 += dy;
      var bgW = bx2 - bx1;
      var bgH = by2 - by1;
      var width = loadBgi.width,
          height = loadBgi.height;

      var _ref = backgroundSize[i] || [],
          _ref2 = _slicedToArray(_ref, 2),
          w = _ref2[0],
          h = _ref2[1]; // -1为auto，-2为contain，-3为cover


      if (w === -1 && h === -1) {
        w = width;
        h = height;
      } else if (w === -2) {
        if (width > bgW && height > bgH) {
          w = width / bgW;
          h = height / bgH;

          if (w >= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (width > bgW) {
          w = bgW;
          h = w * height / width;
        } else if (height > bgH) {
          h = bgH;
          w = h * width / height;
        } else {
          w = width / bgW;
          h = height / bgH;

          if (w >= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        }
      } else if (w === -3) {
        if (width > bgW && height > bgH) {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (width > bgW) {
          h = bgH;
          w = h * width / height;
        } else if (height > bgH) {
          w = bgW;
          h = w * height / width;
        } else {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        }
      } else if (w === -1) {
        w = h * width / height;
      } else if (h === -1) {
        h = w * height / width;
      }

      var bgX = computedStyle[BACKGROUND_POSITION_X$2][i] || 0;

      if (/%/.test(bgX)) {
        bgX = (bgW - w) * parseFloat(bgX) * 0.01;
      }

      bgX += bx1;
      var bgY = computedStyle[BACKGROUND_POSITION_Y$2][i] || 0;

      if (/%/.test(bgY)) {
        bgY = (bgH - h) * parseFloat(bgY) * 0.01;
      }

      bgY += by1; // 超出尺寸模拟mask截取

      var needMask = bgX < bx1 || bgY < by1 || bgX + w > bx1 + bgW || bgY + h > by1 + bgH; // 计算因为repeat，需要向4个方向扩展渲染几个数量图片

      var xnl = 0;
      var xnr = 0;
      var ynt = 0;
      var ynb = 0; // repeat-x

      if (['repeatX', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var diff = bgX - bx1;

        if (diff > 0) {
          xnl = Math.ceil(diff / w);
        }

        diff = bx1 + bgW - bgX - w;

        if (diff > 0) {
          xnr = Math.ceil(diff / w);
        }
      } // repeat-y


      if (['repeatY', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var _diff = bgY - by1;

        if (_diff > 0) {
          ynt = Math.ceil(_diff / h);
        }

        _diff = by1 + bgH - bgY - h;

        if (_diff > 0) {
          ynb = Math.ceil(_diff / h);
        }
      } // 分同行列和4个角分别判断，先看同行同列，再看4个角的象限


      var repeat = [];

      if (xnl > 0) {
        for (var _i = 0; _i < xnl; _i++) {
          var x = bgX - (_i + 1) * w;
          repeat.push([x, bgY]); // 看最左边超过没有

          if (!needMask && _i === 0 && x < bx1) {
            needMask = true;
          }
        }
      }

      if (xnr > 0) {
        for (var _i2 = 0; _i2 < xnr; _i2++) {
          var _x = bgX + (_i2 + 1) * w;

          repeat.push([_x, bgY]); // 看最右边超过没有

          if (!needMask && _i2 === xnr - 1 && _x + w > bx1 + bgW) {
            needMask = true;
          }
        }
      }

      if (ynt > 0) {
        for (var _i3 = 0; _i3 < ynt; _i3++) {
          var y = bgY - (_i3 + 1) * h;
          repeat.push([bgX, y]); // 看最上边超过没有

          if (!needMask && _i3 === 0 && y < by1) {
            needMask = true;
          }
        }
      }

      if (ynb > 0) {
        for (var _i4 = 0; _i4 < ynb; _i4++) {
          var _y = bgY + (_i4 + 1) * h;

          repeat.push([bgX, _y]); // 看最下边超过没有

          if (!needMask && _i4 === ynb - 1 && _y + w > by1 + bgH) {
            needMask = true;
          }
        }
      } // 原点和同行列十字画完，看4个角的情况


      if (xnl > 0 && ynt > 0) {
        for (var _i5 = 0; _i5 < xnl; _i5++) {
          for (var j = 0; j < ynt; j++) {
            repeat.push([bgX - (_i5 + 1) * w, bgY - (j + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynt > 0) {
        for (var _i6 = 0; _i6 < xnr; _i6++) {
          for (var _j = 0; _j < ynt; _j++) {
            repeat.push([bgX + (_i6 + 1) * w, bgY - (_j + 1) * h]);
          }
        }
      }

      if (xnl > 0 && ynb > 0) {
        for (var _i7 = 0; _i7 < xnl; _i7++) {
          for (var _j2 = 0; _j2 < ynb; _j2++) {
            repeat.push([bgX - (_i7 + 1) * w, bgY + (_j2 + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynb > 0) {
        for (var _i8 = 0; _i8 < xnr; _i8++) {
          for (var _j3 = 0; _j3 < ynb; _j3++) {
            repeat.push([bgX + (_i8 + 1) * w, bgY + (_j3 + 1) * h]);
          }
        }
      }

      if (renderMode === mode.CANVAS) {
        if (needMask) {
          ctx.save();
          renderBgc(this, renderMode, ctx, '#FFF', null, bx1, by1, bgW, bgH, btlr, btrr, bbrr, bblr, 'clip');
        } // 先画不考虑repeat的中心声明的


        ctx.drawImage(source, bgX, bgY, w, h); // 再画重复的十字和4角象限

        repeat.forEach(function (item) {
          ctx.drawImage(source, item[0], item[1], w, h);
        });

        if (needMask) {
          ctx.restore();
        }
      } else if (renderMode === mode.SVG) {
        var matrix$1 = image.matrixResize(width, height, w, h, bgX, bgY, bgW, bgH);
        var props = [['xlink:href', loadBgi.url], ['x', bgX], ['y', bgY], ['width', width], ['height', height]];
        var needResize;

        if (matrix$1 && !matrix.isE(matrix$1)) {
          needResize = true;
          props.push(['transform', 'matrix(' + joinArr$2(matrix.m2m6(matrix$1), ',') + ')']);
        }

        if (needMask) {
          var p1 = {
            x: bx1,
            y: by1
          };
          var p2 = {
            x: bx2,
            y: by2
          };

          if (needResize) {
            var inverse = matrix.inverse(matrix$1);
            p1 = matrix.calPoint(p1, inverse);
            p2 = matrix.calPoint(p2, inverse);
          }

          var v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', "M".concat(p1.x, ",").concat(p1.y, "L").concat(p2.x, ",").concat(p1.y, "L").concat(p2.x, ",").concat(p2.y, "L").concat(p1.x, ",").concat(p2.y, "L").concat(p1.x, ",").concat(p1.y)], ['fill', '#FFF']]
            }]
          };
          var id = ctx.add(v);

          xom.__cacheDefs.push(v);

          props.push(['clip-path', 'url(#' + id + ')']);
        }

        if (isInline) {
          var _v = {
            tagName: 'symbol',
            props: [],
            children: [{
              type: 'img',
              tagName: 'image',
              props: props
            }]
          };

          xom.__cacheDefs.push(_v);

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix && !matrix.isE(_matrix)) {
                copy[5][1] = 'matrix(' + joinArr$2(matrix.m2m6(_matrix), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];

            _v.children.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
          return ctx.add(_v);
        } else {
          // 先画不考虑repeat的中心声明的
          xom.virtualDom.bb.push({
            type: 'img',
            tagName: 'image',
            props: props
          }); // 再画重复的十字和4角象限

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix2 = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix2 && !matrix.isE(_matrix2)) {
                copy[5][1] = 'matrix(' + joinArr$2(matrix.m2m6(_matrix2), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];
            xom.virtualDom.bb.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
        }
      }
    }
  }

  var bg = {
    renderBgc: renderBgc,
    renderImage: renderImage
  };

  var isFunction$7 = util.isFunction;

  function traversalBefore(list, length, diff) {
    for (var i = 0; i < length; i++) {
      var item = list[i];
      item.__before && item.__before(diff);
    }
  }

  function traversalAfter(list, length, diff) {
    for (var i = 0; i < length; i++) {
      var item = list[i];
      item.__after && item.__after(diff);
    }
  }

  var isPause;

  var Frame = /*#__PURE__*/function () {
    function Frame() {
      this.__rootTask = []; // 每帧先执行Root的刷新操作，之前动画或其他异步更新引发的

      this.__roots = []; // wasm情况下每个Root实例留个钩子引用，每帧检查动画任务行

      this.__task = []; // 普通比如飞wasm动画的任务执行

      this.__now = inject.now();
    }

    _createClass(Frame, [{
      key: "__init",
      value: function __init() {
        var self = this;
        var task = self.task;
        inject.cancelAnimationFrame(self.id);
        var last = self.__now = inject.now();

        function cb() {
          // 必须清除，可能会发生重复，当动画finish回调中gotoAndPlay(0)，下方结束判断发现aTask还有值会继续，新的init也会进入再次执行
          inject.cancelAnimationFrame(self.id);
          self.id = inject.requestAnimationFrame(function () {
            // console.log('frame', task.length, task.slice(0))
            var now = self.__now = inject.now();

            if (isPause || !task.length) {
              return;
            }

            var diff = now - last;
            diff = Math.max(diff, 0); // let delta = diff * 0.06; // 比例是除以1/60s，等同于*0.06

            last = now; // 优先动画计算

            var clone = task.slice(0);
            var len1 = clone.length; // 普通的before/after，动画计算在before，所有回调在after

            traversalBefore(clone, len1, diff); // 刷新成功后调用after，确保图像生成

            traversalAfter(clone, len1, diff); // 还有则继续，没有则停止节省性能

            if (task.length) {
              cb();
            }
          });
        }

        cb();
      }
    }, {
      key: "onFrame",
      value: function onFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        if (!task.length) {
          this.__init();
        }

        if (isFunction$7(handle)) {
          handle = {
            __after: handle,
            __karasFrameCb: handle
          };
        }

        task.push(handle);
      }
    }, {
      key: "offFrame",
      value: function offFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        for (var i = 0, len = task.length; i < len; i++) {
          var item = task[i]; // 需考虑nextFrame包裹的引用对比

          if (item === handle || item.__karasFrameCb === handle) {
            task.splice(i, 1);
            break;
          }
        }

        if (!task.length) {
          inject.cancelAnimationFrame(this.id);
          this.__now = null;
        }
      }
    }, {
      key: "nextFrame",
      value: function nextFrame(handle) {
        var _this = this;

        if (!handle) {
          return;
        } // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比


        var cb = isFunction$7(handle) ? {
          __after: function __after(diff) {
            handle(diff);

            _this.offFrame(cb);
          }
        } : {
          __before: handle.__before,
          __after: function __after(diff) {
            handle.__after && handle.__after(diff);

            _this.offFrame(cb);
          }
        };
        cb.__karasFrameCb = handle;
        this.onFrame(cb);
      }
    }, {
      key: "pause",
      value: function pause() {
        isPause = true;
      }
    }, {
      key: "resume",
      value: function resume() {
        if (isPause) {
          this.__init();

          isPause = false;
        }
      }
    }, {
      key: "addRoot",
      value: function addRoot(root) {
        this.__roots.push(root);
      }
    }, {
      key: "removeRoot",
      value: function removeRoot(root) {
        var i = this.__roots.indexOf(root);

        if (i > -1) {
          this.__roots.splice(i, 1);
        }
      }
    }, {
      key: "task",
      get: function get() {
        return this.__task;
      }
    }, {
      key: "roots",
      get: function get() {
        return this.__roots;
      }
    }]);

    return Frame;
  }();

  var frame = new Frame();

  /**
   * https://github.com/gre/bezier-easing
   * BezierEasing - use bezier curve for transition easing function
   * by Gaëtan Renaudeau 2014 - 2015 – MIT License
   */
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function LinearEasing(x) {
    return x;
  }

  function bezier$1(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return LinearEasing;
    } // Precompute samples table


    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample; // Interpolate to provide an initial guess for t

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  var easing = {
    linear: bezier$1(1, 1, 0, 0),
    easeIn: bezier$1(0.42, 0, 1, 1),
    easeOut: bezier$1(0, 0, 0.58, 1),
    ease: bezier$1(0.25, 0.1, 0.25, 1),
    easeInOut: bezier$1(0.42, 0, 0.58, 1),
    cubicBezier: bezier$1,
    getEasing: function getEasing(v, v1, v2, v3) {
      if (arguments.length === 4) {
        return bezier$1(v, v1, v2, v3);
      } else if (Array.isArray(v) && v.length === 4) {
        return bezier$1(v[0], v[1], v[2], v[3]);
      } else if (v) {
        v = v.toString();
        var timingFunction;

        if (/^\s*(?:cubic-bezier\s*)?\(\s*[\d.]+\s*,\s*[-\d.]+\s*,\s*[\d.]+\s*,\s*[-\d.]+\s*\)\s*$/i.test(v)) {
          v = v.match(/[\d.]+/g);
          timingFunction = bezier$1(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3]));
        } // 防御一下
        else if (v !== 'getEasing' && v !== 'cubicBezier') {
          timingFunction = this[v];
        }

        return timingFunction;
      }
    }
  };
  easing['ease-in'] = easing.easeIn;
  easing['ease-out'] = easing.easeOut;
  easing['ease-in-out'] = easing.easeInOut;

  var isFunction$6 = util.isFunction,
      isNil$c = util.isNil;

  var Controller = /*#__PURE__*/function () {
    function Controller() {
      this.__records = []; // 默认记录和自动记录

      this.__records2 = []; // 非自动播放的动画记录

      this.__list = []; // 默认初始化播放列表，自动播放也存这里

      this.__list2 = []; // json中autoPlay为false的初始化存入这里

      this.__onList = []; // list中已存在的侦听事件，list2初始化时也需要增加上

      this.__lastTime = {}; // 每个类型的上次触发时间，防止重复emit
    }

    _createClass(Controller, [{
      key: "add",
      value: function add(v) {
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.__list;

        if (list.indexOf(v) === -1) {
          list.push(v);
        }
      }
    }, {
      key: "remove",
      value: function remove(v) {
        var i = this.__list.indexOf(v);

        if (i > -1) {
          this.__list.splice(i, 1);
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__records = [];
        this.__records2 = [];
        this.__list = [];
        this.__list2 = [];
      }
    }, {
      key: "__action",
      value: function __action(k, args) {
        this.__list.forEach(function (item) {
          item[k].apply(item, args);
        });
      }
    }, {
      key: "init",
      value: function init() {
        var _this = this;

        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__records;
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.__list;

        // 检查尚未初始化的record，并初始化，后面才能调用各种控制方法
        if (records.length) {
          // 清除防止重复调用，并且新的json还会进入整体逻辑
          records.splice(0).forEach(function (item) {
            var target = item.target,
                animate = item.animate,
                areaStart = item.areaStart,
                areaDuration = item.areaDuration;

            if (target.isDestroyed || !animate) {
              return;
            }

            if (!Array.isArray(animate)) {
              animate = [animate];
            }

            animate.forEach(function (animate) {
              var value = animate.value,
                  options = animate.options;

              if (areaStart || !isNil$c(areaDuration)) {
                options = Object.assign({}, options); // clone防止多个使用相同的干扰

                options.areaStart = areaStart;
                options.areaDuration = areaDuration;
              }

              options.autoPlay = false;
              var o = target.animate(value, options);
              o.__isControlled = true;

              _this.add(o, list);
            });
          });
        } // 非自动播放后初始化需检测事件，给非自动播放添加上，并清空本次


        if (records === this.__records2) {
          var onList = this.__onList;
          var list2 = this.list2;

          if (list2.length && onList.length) {
            list2.forEach(function (item) {
              onList.forEach(function (arr) {
                var cb = function cb() {
                  var time = frame.__now;

                  if (time !== _this.__lastTime[arr[0]]) {
                    _this.__lastTime[arr[0]] = time;
                    arr[1] && arr[1]();
                  }
                };

                cb.__karasEventCb = arr[1];
                item.off(arr[0], arr[1]);
                item.on(arr[0], cb);
              });
            });
          }
        }
      }
    }, {
      key: "__playAuto",
      value: function __playAuto() {
        this.init();

        this.__action('play');
      }
    }, {
      key: "play",
      value: function play(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('play', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "pause",
      value: function pause() {
        this.__action('pause');
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var once = true;

        this.__action('resume', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "__mergeAuto",
      value: function __mergeAuto() {
        this.init();
        this.init(this.__records2);

        if (this.__list2.length) {
          this.__list = this.__list.concat(this.__list2);
          this.__list2 = [];
        }
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('cancel', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('finish', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$6(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndStop', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$6(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndPlay', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$6(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$6(handle)) {
          return;
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.__on(id[i], handle);
          }

          this.__onList.push([id, handle]);
        } else {
          this.__on(id, handle);

          this.__onList.push([id, handle]);
        }
      }
    }, {
      key: "__on",
      value: function __on(id, handle) {
        var _this2 = this;

        this.__list.forEach(function (item) {
          var cb = function cb() {
            var time = frame.__now;

            if (time !== _this2.__lastTime[id]) {
              _this2.__lastTime[id] = time;
              handle && handle();
            }
          };

          cb.__karasEventCb = handle;
          item.on(id, cb);
        });
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.off(id[i], handle);
          }
        } else {
          this.list.forEach(function (item) {
            item.off(id, handle);
          });
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "list2",
      get: function get() {
        return this.__list2;
      }
    }, {
      key: "__set",
      value: function __set(key, value) {
        this.__list.forEach(function (item) {
          item[key] = value;
        });

        this.__list2.forEach(function (item) {
          item[key] = value;
        });
      }
    }, {
      key: "playbackRate",
      set: function set(v) {
        this.__set('playbackRate', v);
      }
    }, {
      key: "iterations",
      set: function set(v) {
        this.__set('iterations', v);
      }
    }, {
      key: "playCount",
      set: function set(v) {
        this.__set('playCount', v);
      }
    }, {
      key: "fps",
      set: function set(v) {
        this.__set('fps', v);
      }
    }, {
      key: "currentTime",
      set: function set(v) {
        this.__set('currentTime', v);
      }
    }, {
      key: "spfLimit",
      set: function set(v) {
        this.__set('spfLimit', v);
      }
    }, {
      key: "delay",
      set: function set(v) {
        this.__set('delay', v);
      }
    }, {
      key: "endDelay",
      set: function set(v) {
        this.__set('endDelay', v);
      }
    }, {
      key: "fill",
      set: function set(v) {
        this.__set('fill', v);
      }
    }, {
      key: "direction",
      set: function set(v) {
        this.__set('direction', v);
      }
    }]);

    return Controller;
  }();

  var _enums$STYLE_KEY$a = enums.STYLE_KEY,
      TRANSLATE_X$2 = _enums$STYLE_KEY$a.TRANSLATE_X,
      TRANSLATE_Y$2 = _enums$STYLE_KEY$a.TRANSLATE_Y,
      TRANSLATE_Z$2 = _enums$STYLE_KEY$a.TRANSLATE_Z,
      SCALE_X$2 = _enums$STYLE_KEY$a.SCALE_X,
      SCALE_Y$2 = _enums$STYLE_KEY$a.SCALE_Y,
      ROTATE_X$2 = _enums$STYLE_KEY$a.ROTATE_X,
      ROTATE_Y$2 = _enums$STYLE_KEY$a.ROTATE_Y,
      ROTATE_Z$2 = _enums$STYLE_KEY$a.ROTATE_Z,
      SKEW_X$2 = _enums$STYLE_KEY$a.SKEW_X,
      SKEW_Y$2 = _enums$STYLE_KEY$a.SKEW_Y,
      TRANSFORM_ORIGIN$4 = _enums$STYLE_KEY$a.TRANSFORM_ORIGIN,
      OPACITY$5 = _enums$STYLE_KEY$a.OPACITY;
  var wasm;
  var cachedTextDecoder = new TextDecoder('utf-8', {
    ignoreBOM: true,
    fatal: true
  });
  cachedTextDecoder.decode();
  var cachedUint8Memory0 = new Uint8Array();

  function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
      cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }

    return cachedUint8Memory0;
  }

  function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
  }
  /**
   */


  var Animation$1 = /*#__PURE__*/function () {
    function Animation() {}

    _createClass(Animation, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg_animation_free(ptr);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "duration",
      get: function get() {
        var ret = wasm.__wbg_get_animation_duration(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_duration(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "fps",
      get: function get() {
        var ret = wasm.__wbg_get_animation_fps(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_fps(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "delay",
      get: function get() {
        var ret = wasm.__wbg_get_animation_delay(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_delay(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "end_delay",
      get: function get() {
        var ret = wasm.__wbg_get_animation_end_delay(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_end_delay(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "fill",
      get: function get() {
        var ret = wasm.__wbg_get_animation_fill(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_fill(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "playback_rate",
      get: function get() {
        var ret = wasm.__wbg_get_animation_playback_rate(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_playback_rate(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "iterations",
      get: function get() {
        var ret = wasm.__wbg_get_animation_iterations(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_iterations(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "area_start",
      get: function get() {
        var ret = wasm.__wbg_get_animation_area_start(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_area_start(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "area_duration",
      get: function get() {
        var ret = wasm.__wbg_get_animation_area_duration(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_area_duration(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "easing",
      get: function get() {
        var ret = wasm.__wbg_get_animation_easing(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_easing(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "current_time",
      get: function get() {
        var ret = wasm.__wbg_get_animation_current_time(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_current_time(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "play_count",
      get: function get() {
        var ret = wasm.__wbg_get_animation_play_count(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_play_count(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "play_state",
      get: function get() {
        var ret = wasm.__wbg_get_animation_play_state(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_play_state(this.ptr, arg0);
      }
      /**
       * @returns {boolean}
       */

    }, {
      key: "first_play",
      get: function get() {
        var ret = wasm.__wbg_get_animation_first_play(this.ptr);

        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_first_play(this.ptr, arg0);
      }
      /**
       * @returns {boolean}
       */

    }, {
      key: "finished",
      get: function get() {
        var ret = wasm.__wbg_get_animation_finished(this.ptr);

        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_finished(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "index",
      get: function get() {
        var ret = wasm.__wbg_get_animation_index(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_index(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "percent",
      get: function get() {
        var ret = wasm.__wbg_get_animation_percent(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_animation_percent(this.ptr, arg0);
      }
      /**
       * @param {number} node
       * @param {number} direction
       * @param {number} duration
       * @param {number} fps
       * @param {number} delay
       * @param {number} end_delay
       * @param {number} fill
       * @param {number} playback_rate
       * @param {number} iterations
       * @param {number} area_start
       * @param {number} area_duration
       * @param {number} easing
       * @returns {Animation}
       */

    }, {
      key: "set_bezier",
      value:
      /**
       * @param {number} c1
       * @param {number} c2
       * @param {number} c3
       * @param {number} c4
       */
      function set_bezier(c1, c2, c3, c4) {
        wasm.animation_set_bezier(this.ptr, c1, c2, c3, c4);
      }
      /**
       * @param {boolean} is_reverse
       * @param {number} time
       * @param {number} easing
       * @param {number} x1
       * @param {number} y1
       * @param {number} x2
       * @param {number} y2
       */

    }, {
      key: "add_frame",
      value: function add_frame(is_reverse, time, easing, x1, y1, x2, y2) {
        wasm.animation_add_frame(this.ptr, is_reverse, time, easing, x1, y1, x2, y2);
      }
      /**
       * @param {boolean} is_reverse
       * @param {number} k
       * @param {number} v
       * @param {number} u
       * @param {number} d
       */

    }, {
      key: "add_item",
      value: function add_item(is_reverse, k, v, u, d) {
        wasm.animation_add_item(this.ptr, is_reverse, k, v, u, d);
      }
      /**
       * @param {number} k
       * @param {number} v
       * @param {number} u
       */

    }, {
      key: "add_origin",
      value: function add_origin(k, v, u) {
        wasm.animation_add_origin(this.ptr, k, v, u);
      }
      /**
       */

    }, {
      key: "play",
      value: function play() {
        wasm.animation_play(this.ptr);
      }
      /**
       * @param {number} play_count
       */

    }, {
      key: "init_current_frames",
      value: function init_current_frames(play_count) {
        wasm.animation_init_current_frames(this.ptr, play_count);
      }
      /**
       * @param {number} dur
       * @returns {boolean}
       */

    }, {
      key: "cal_current",
      value: function cal_current(dur) {
        var ret = wasm.animation_cal_current(this.ptr, dur);
        return ret !== 0;
      }
      /**
       * @param {number} diff
       * @returns {boolean}
       */

    }, {
      key: "before",
      value: function before(diff) {
        var ret = wasm.animation_before(this.ptr, diff);
        return ret !== 0;
      }
      /**
       * @returns {boolean}
       */

    }, {
      key: "after",
      value: function after() {
        var ret = wasm.animation_after(this.ptr);
        return ret !== 0;
      }
      /**
       * @param {number} v
       * @param {number} dur
       * @returns {boolean}
       */

    }, {
      key: "goto_stop",
      value: function goto_stop(v, dur) {
        var ret = wasm.animation_goto_stop(this.ptr, v, dur);
        return ret !== 0;
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(Animation.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "new",
      value: function _new(node, direction, duration, fps, delay, end_delay, fill, playback_rate, iterations, area_start, area_duration, easing) {
        var ret = wasm.animation_new(node, direction, duration, fps, delay, end_delay, fill, playback_rate, iterations, area_start, area_duration, easing);
        return Animation.__wrap(ret);
      }
    }]);

    return Animation;
  }();
  /**
   */

  var Node = /*#__PURE__*/function () {
    function Node() {}

    _createClass(Node, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg_node_free(ptr);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "root",
      get: function get() {
        var ret = wasm.__wbg_get_node_root(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_root(this.ptr, arg0);
      }
      /**
       * @returns {boolean}
       */

    }, {
      key: "is_text",
      get: function get() {
        var ret = wasm.__wbg_get_node_is_text(this.ptr);

        return ret !== 0;
      }
      /**
       * @param {boolean} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_is_text(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "x",
      get: function get() {
        var ret = wasm.__wbg_get_node_x(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_x(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "y",
      get: function get() {
        var ret = wasm.__wbg_get_node_y(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_y(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "offset_width",
      get: function get() {
        var ret = wasm.__wbg_get_node_offset_width(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_offset_width(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "offset_height",
      get: function get() {
        var ret = wasm.__wbg_get_node_offset_height(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_offset_height(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "xa",
      get: function get() {
        var ret = wasm.__wbg_get_node_xa(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_xa(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "ya",
      get: function get() {
        var ret = wasm.__wbg_get_node_ya(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_ya(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "xb",
      get: function get() {
        var ret = wasm.__wbg_get_node_xb(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_xb(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "yb",
      get: function get() {
        var ret = wasm.__wbg_get_node_yb(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_yb(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "lv",
      get: function get() {
        var ret = wasm.__wbg_get_node_lv(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_lv(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "refresh_level",
      get: function get() {
        var ret = wasm.__wbg_get_node_refresh_level(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_refresh_level(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "opacity",
      get: function get() {
        var ret = wasm.__wbg_get_node_opacity(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_node_opacity(this.ptr, arg0);
      }
      /**
       * @param {boolean} is_text
       * @returns {Node}
       */

    }, {
      key: "set_root",
      value:
      /**
       * @param {number} root
       */
      function set_root(root) {
        wasm.__wbg_set_node_root(this.ptr, root);
      }
      /**
       * @param {number} animation
       */

    }, {
      key: "add_ani",
      value: function add_ani(animation) {
        wasm.node_add_ani(this.ptr, animation);
      }
      /**
       * @param {number} animation
       */

    }, {
      key: "remove_ani",
      value: function remove_ani(animation) {
        wasm.node_remove_ani(this.ptr, animation);
      }
      /**
       */

    }, {
      key: "clear",
      value: function clear() {
        wasm.node_clear(this.ptr);
      }
      /**
       * @param {number} x
       * @param {number} y
       * @param {number} offset_width
       * @param {number} offset_height
       * @param {number} cs0
       * @param {number} cs1
       * @param {number} cs2
       * @param {number} cs3
       * @param {number} cs4
       * @param {number} cs5
       * @param {number} cs6
       * @param {number} cs7
       * @param {number} cs8
       * @param {number} cs9
       * @param {number} cs10
       * @param {number} cs11
       * @param {number} cs12
       * @param {number} cs13
       * @param {number} cs14
       * @param {number} cs15
       * @param {number} cs16
       * @param {number} cs17
       * @param {number} cu0
       * @param {number} cu1
       * @param {number} cu2
       * @param {number} cu16
       * @param {number} cu17
       */

    }, {
      key: "set_style",
      value: function set_style(x, y, offset_width, offset_height, cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, cs8, cs9, cs10, cs11, cs12, cs13, cs14, cs15, cs16, cs17, cu0, cu1, cu2, cu16, cu17) {
        wasm.node_set_style(this.ptr, x, y, offset_width, offset_height, cs0, cs1, cs2, cs3, cs4, cs5, cs6, cs7, cs8, cs9, cs10, cs11, cs12, cs13, cs14, cs15, cs16, cs17, cu0, cu1, cu2, cu16, cu17);
      }
      /**
       * @param {number} x
       * @param {number} y
       * @param {number} offset_width
       * @param {number} offset_height
       */

    }, {
      key: "set_xywh",
      value: function set_xywh(x, y, offset_width, offset_height) {
        wasm.node_set_xywh(this.ptr, x, y, offset_width, offset_height);
      }
      /**
       * @param {number} x
       * @param {number} y
       * @param {number} offset_width
       * @param {number} offset_height
       */

    }, {
      key: "set_txt",
      value: function set_txt(x, y, offset_width, offset_height) {
        wasm.node_set_txt(this.ptr, x, y, offset_width, offset_height);
      }
      /**
       * @param {number} a
       * @param {number} b
       * @param {number} c
       * @param {number} d
       * @param {number} e
       * @param {number} f
       * @param {number} g
       * @param {number} h
       * @param {number} i
       * @param {number} j
       * @param {number} k
       * @param {number} l
       * @param {number} m
       * @param {number} n
       * @param {number} o
       * @param {number} p
       */

    }, {
      key: "set_transform",
      value: function set_transform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        wasm.node_set_transform(this.ptr, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "computed_style_ptr",
      value: function computed_style_ptr() {
        var ret = wasm.node_computed_style_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "transform_ptr",
      value: function transform_ptr() {
        var ret = wasm.node_transform_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "m_ptr",
      value: function m_ptr() {
        var ret = wasm.node_m_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "me_ptr",
      value: function me_ptr() {
        var ret = wasm.node_me_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "get_op",
      value: function get_op() {
        var ret = wasm.__wbg_get_node_opacity(this.ptr);

        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "get_rl",
      value: function get_rl() {
        var ret = wasm.__wbg_get_node_refresh_level(this.ptr);

        return ret >>> 0;
      }
      /**
       * @param {number} diff
       * @returns {number}
       */

    }, {
      key: "before",
      value: function before(diff) {
        var ret = wasm.node_before(this.ptr, diff);
        return ret >>> 0;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "after",
      value: function after() {
        var ret = wasm.node_after(this.ptr);
        return ret >>> 0;
      }
      /**
       * @param {Animation} ani
       */

    }, {
      key: "cal_trans",
      value: function cal_trans(ani) {
        _assertClass(ani, Animation$1);

        wasm.node_cal_trans(this.ptr, ani.ptr);
      }
      /**
       * @param {number} rl
       */

    }, {
      key: "cal_matrix",
      value: function cal_matrix(rl) {
        wasm.node_cal_matrix(this.ptr, rl);
      }
      /**
       * @param {number} v
       * @param {number} u
       * @param {number} parent
       * @returns {number}
       */

    }, {
      key: "cal_size",
      value: function cal_size(v, u, parent) {
        var ret = wasm.node_cal_size(this.ptr, v, u, parent);
        return ret;
      }
      /**
       * @param {number} k
       * @param {number} v
       * @param {number} u
       * @returns {boolean}
       */

    }, {
      key: "equal_style",
      value: function equal_style(k, v, u) {
        var ret = wasm.node_equal_style(this.ptr, k, v, u);
        return ret !== 0;
      }
      /**
       * @param {number} k
       * @param {number} v
       * @param {number} u
       * @returns {boolean}
       */

    }, {
      key: "equal_set_style",
      value: function equal_set_style(k, v, u) {
        var ret = wasm.node_equal_set_style(this.ptr, k, v, u);
        return ret !== 0;
      }
      /**
       * @param {number} k
       * @param {number} v
       * @param {number} u
       */

    }, {
      key: "update_style",
      value: function update_style(k, v, u) {
        wasm.node_update_style(this.ptr, k, v, u);
      }
      /**
       * @param {number} v
       */

    }, {
      key: "offset_x",
      value: function offset_x(v) {
        wasm.node_offset_x(this.ptr, v);
      }
      /**
       * @param {number} v
       */

    }, {
      key: "offset_y",
      value: function offset_y(v) {
        wasm.node_offset_y(this.ptr, v);
      }
      /**
       * @param {number} v
       */

    }, {
      key: "resize_x",
      value: function resize_x(v) {
        wasm.node_resize_x(this.ptr, v);
      }
      /**
       * @param {number} v
       */

    }, {
      key: "resize_y",
      value: function resize_y(v) {
        wasm.node_resize_y(this.ptr, v);
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(Node.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "new",
      value: function _new(is_text) {
        var ret = wasm.node_new(is_text);
        return Node.__wrap(ret);
      }
    }]);

    return Node;
  }();
  /**
   */

  var Root$1 = /*#__PURE__*/function () {
    function Root() {}

    _createClass(Root, [{
      key: "__destroy_into_raw",
      value: function __destroy_into_raw() {
        var ptr = this.ptr;
        this.ptr = 0;
        return ptr;
      }
    }, {
      key: "free",
      value: function free() {
        var ptr = this.__destroy_into_raw();

        wasm.__wbg_root_free(ptr);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "mode",
      get: function get() {
        var ret = wasm.__wbg_get_root_mode(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_root_mode(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "width",
      get: function get() {
        var ret = wasm.__wbg_get_root_width(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_root_width(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "height",
      get: function get() {
        var ret = wasm.__wbg_get_root_height(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_root_height(this.ptr, arg0);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "font_size",
      get: function get() {
        var ret = wasm.__wbg_get_root_font_size(this.ptr);

        return ret;
      }
      /**
       * @param {number} arg0
       */
      ,
      set: function set(arg0) {
        wasm.__wbg_set_root_font_size(this.ptr, arg0);
      }
      /**
       * @returns {Root}
       */

    }, {
      key: "add_node",
      value:
      /**
       * @param {number} node
       */
      function add_node(node) {
        wasm.root_add_node(this.ptr, node);
      }
      /**
       * @param {number} i
       */

    }, {
      key: "remove_node",
      value: function remove_node(i) {
        wasm.root_remove_node(this.ptr, i);
      }
      /**
       * @param {number} i
       * @param {number} node
       */

    }, {
      key: "set_node",
      value: function set_node(i, node) {
        wasm.root_set_node(this.ptr, i, node);
      }
      /**
       * @param {number} i
       * @param {number} node
       */

    }, {
      key: "insert_node",
      value: function insert_node(i, node) {
        wasm.root_insert_node(this.ptr, i, node);
      }
      /**
       */

    }, {
      key: "clear",
      value: function clear() {
        wasm.root_clear(this.ptr);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "size",
      value: function size() {
        var ret = wasm.root_size(this.ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} width
       * @param {number} height
       */

    }, {
      key: "resize",
      value: function resize(width, height) {
        wasm.root_resize(this.ptr, width, height);
      }
      /**
       * @param {number} diff
       * @returns {number}
       */

    }, {
      key: "before",
      value: function before(diff) {
        var ret = wasm.root_before(this.ptr, diff);
        return ret >>> 0;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "after",
      value: function after() {
        var ret = wasm.root_after(this.ptr);
        return ret >>> 0;
      }
      /**
       * @param {number} n
       */

    }, {
      key: "add_am_state",
      value: function add_am_state(n) {
        wasm.root_add_am_state(this.ptr, n);
      }
      /**
       */

    }, {
      key: "refresh",
      value: function refresh() {
        wasm.root_refresh(this.ptr);
      }
      /**
       * @returns {number}
       */

    }, {
      key: "rl_ptr",
      value: function rl_ptr() {
        var ret = wasm.root_rl_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "me_ptr",
      value: function me_ptr() {
        var ret = wasm.root_me_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "op_ptr",
      value: function op_ptr() {
        var ret = wasm.root_op_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "vt_ptr",
      value: function vt_ptr() {
        var ret = wasm.root_vt_ptr(this.ptr);
        return ret;
      }
      /**
       * @returns {number}
       */

    }, {
      key: "am_states_ptr",
      value: function am_states_ptr() {
        var ret = wasm.root_am_states_ptr(this.ptr);
        return ret;
      }
    }], [{
      key: "__wrap",
      value: function __wrap(ptr) {
        var obj = Object.create(Root.prototype);
        obj.ptr = ptr;
        return obj;
      }
    }, {
      key: "new",
      value: function _new() {
        var ret = wasm.root_new();
        return Root.__wrap(ret);
      }
    }]);

    return Root;
  }();

  function load(_x, _x2) {
    return _load.apply(this, arguments);
  }

  function _load() {
    _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(module, imports) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return WebAssembly.instantiateStreaming(module, imports);

            case 3:
              return _context2.abrupt("return", _context2.sent);

            case 6:
              _context2.prev = 6;
              _context2.t0 = _context2["catch"](0);

              if (module.headers.get('Content-Type') !== 'application/wasm') {
                inject.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", _context2.t0);
              } else {
                inject.error(_context2.t0.toString());
              }

            case 9:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 6]]);
    }));
    return _load.apply(this, arguments);
  }

  var wasm$1 = {
    init: function init(url, cb) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var req, input, imports, res;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!((typeof fetch === "undefined" ? "undefined" : _typeof(fetch)) !== undefined && util.isFunction(fetch))) {
                  _context.next = 13;
                  break;
                }

                req = typeof location !== 'undefined' ? new URL(url, location.href) : new URL(url);
                input = fetch(req);
                imports = {
                  wbg: {
                    __wbg_log_7bf8a72f8beaaabe: function __wbg_log_7bf8a72f8beaaabe(arg0, arg1) {
                      inject.log(getStringFromWasm0(arg0, arg1));
                    },
                    __wbindgen_throw: function __wbindgen_throw(arg0, arg1) {
                      throw new Error(getStringFromWasm0(arg0, arg1));
                    }
                  }
                };
                _context.t0 = load;
                _context.next = 7;
                return input;

              case 7:
                _context.t1 = _context.sent;
                _context.t2 = imports;
                _context.next = 11;
                return (0, _context.t0)(_context.t1, _context.t2);

              case 11:
                res = _context.sent;

                if (res) {
                  wasm = res.instance.exports;
                }

              case 13:
                if (cb) {
                  cb(wasm);
                }

                return _context.abrupt("return", wasm);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    get instance() {
      return wasm;
    },

    Node: Node,
    Root: Root$1,
    Animation: Animation$1,
    isWasmStyle: function isWasmStyle(k) {
      return k === TRANSLATE_X$2 || k === TRANSLATE_Y$2 || k === TRANSLATE_Z$2 || k === ROTATE_X$2 || k === ROTATE_Y$2 || k === ROTATE_Z$2 || k === SCALE_X$2 || k === SCALE_Y$2 || k === SKEW_X$2 || k === SKEW_Y$2 || k === OPACITY$5 || k === TRANSFORM_ORIGIN$4;
    }
  };

  var _enums$STYLE_KEY$9 = enums.STYLE_KEY,
      FILTER$3 = _enums$STYLE_KEY$9.FILTER,
      TRANSFORM_ORIGIN$3 = _enums$STYLE_KEY$9.TRANSFORM_ORIGIN,
      PERSPECTIVE_ORIGIN$2 = _enums$STYLE_KEY$9.PERSPECTIVE_ORIGIN,
      BACKGROUND_CLIP$1 = _enums$STYLE_KEY$9.BACKGROUND_CLIP,
      BACKGROUND_POSITION_X$1 = _enums$STYLE_KEY$9.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$1 = _enums$STYLE_KEY$9.BACKGROUND_POSITION_Y,
      BOX_SHADOW$1 = _enums$STYLE_KEY$9.BOX_SHADOW,
      TRANSLATE_X$1 = _enums$STYLE_KEY$9.TRANSLATE_X,
      TRANSLATE_Y$1 = _enums$STYLE_KEY$9.TRANSLATE_Y,
      TRANSLATE_Z$1 = _enums$STYLE_KEY$9.TRANSLATE_Z,
      BACKGROUND_SIZE$1 = _enums$STYLE_KEY$9.BACKGROUND_SIZE,
      FONT_SIZE$4 = _enums$STYLE_KEY$9.FONT_SIZE,
      FLEX_BASIS$3 = _enums$STYLE_KEY$9.FLEX_BASIS,
      FLEX_DIRECTION$2 = _enums$STYLE_KEY$9.FLEX_DIRECTION,
      WIDTH$6 = _enums$STYLE_KEY$9.WIDTH,
      HEIGHT$6 = _enums$STYLE_KEY$9.HEIGHT,
      TOP$4 = _enums$STYLE_KEY$9.TOP,
      BOTTOM$4 = _enums$STYLE_KEY$9.BOTTOM,
      LINE_HEIGHT$3 = _enums$STYLE_KEY$9.LINE_HEIGHT,
      OPACITY$4 = _enums$STYLE_KEY$9.OPACITY,
      Z_INDEX$3 = _enums$STYLE_KEY$9.Z_INDEX,
      TRANSFORM$4 = _enums$STYLE_KEY$9.TRANSFORM,
      COLOR$2 = _enums$STYLE_KEY$9.COLOR,
      FONT_WEIGHT$2 = _enums$STYLE_KEY$9.FONT_WEIGHT,
      FONT_STYLE$1 = _enums$STYLE_KEY$9.FONT_STYLE,
      FONT_FAMILY$2 = _enums$STYLE_KEY$9.FONT_FAMILY,
      TEXT_ALIGN$2 = _enums$STYLE_KEY$9.TEXT_ALIGN,
      MATRIX$2 = _enums$STYLE_KEY$9.MATRIX,
      ROTATE_3D$1 = _enums$STYLE_KEY$9.ROTATE_3D,
      TRANSLATE_PATH = _enums$STYLE_KEY$9.TRANSLATE_PATH,
      TEXT_STROKE_COLOR$2 = _enums$STYLE_KEY$9.TEXT_STROKE_COLOR,
      TEXT_STROKE_OVER$2 = _enums$STYLE_KEY$9.TEXT_STROKE_OVER,
      STROKE_WIDTH$7 = _enums$STYLE_KEY$9.STROKE_WIDTH,
      BORDER_TOP_LEFT_RADIUS$2 = _enums$STYLE_KEY$9.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$2 = _enums$STYLE_KEY$9.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$2 = _enums$STYLE_KEY$9.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$2 = _enums$STYLE_KEY$9.BORDER_BOTTOM_LEFT_RADIUS,
      TEXT_STROKE_WIDTH$2 = _enums$STYLE_KEY$9.TEXT_STROKE_WIDTH,
      BORDER_BOTTOM_WIDTH$3 = _enums$STYLE_KEY$9.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$6 = _enums$STYLE_KEY$9.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$5 = _enums$STYLE_KEY$9.BORDER_RIGHT_WIDTH,
      BORDER_TOP_WIDTH$4 = _enums$STYLE_KEY$9.BORDER_TOP_WIDTH,
      LEFT$3 = _enums$STYLE_KEY$9.LEFT,
      RIGHT$3 = _enums$STYLE_KEY$9.RIGHT,
      MARGIN_BOTTOM$4 = _enums$STYLE_KEY$9.MARGIN_BOTTOM,
      MARGIN_TOP$4 = _enums$STYLE_KEY$9.MARGIN_TOP,
      MARGIN_LEFT$6 = _enums$STYLE_KEY$9.MARGIN_LEFT,
      MARGIN_RIGHT$5 = _enums$STYLE_KEY$9.MARGIN_RIGHT,
      PADDING_TOP$4 = _enums$STYLE_KEY$9.PADDING_TOP,
      PADDING_RIGHT$5 = _enums$STYLE_KEY$9.PADDING_RIGHT,
      PADDING_LEFT$6 = _enums$STYLE_KEY$9.PADDING_LEFT,
      PADDING_BOTTOM$3 = _enums$STYLE_KEY$9.PADDING_BOTTOM,
      STROKE_MITERLIMIT$1 = _enums$STYLE_KEY$9.STROKE_MITERLIMIT,
      LETTER_SPACING$1 = _enums$STYLE_KEY$9.LETTER_SPACING,
      PERSPECTIVE$2 = _enums$STYLE_KEY$9.PERSPECTIVE,
      SKEW_X$1 = _enums$STYLE_KEY$9.SKEW_X,
      SKEW_Y$1 = _enums$STYLE_KEY$9.SKEW_Y,
      SCALE_X$1 = _enums$STYLE_KEY$9.SCALE_X,
      SCALE_Y$1 = _enums$STYLE_KEY$9.SCALE_Y,
      SCALE_Z$1 = _enums$STYLE_KEY$9.SCALE_Z,
      ROTATE_X$1 = _enums$STYLE_KEY$9.ROTATE_X,
      ROTATE_Y$1 = _enums$STYLE_KEY$9.ROTATE_Y,
      ROTATE_Z$1 = _enums$STYLE_KEY$9.ROTATE_Z,
      BACKGROUND_IMAGE$1 = _enums$STYLE_KEY$9.BACKGROUND_IMAGE,
      FILL$2 = _enums$STYLE_KEY$9.FILL,
      STROKE$1 = _enums$STYLE_KEY$9.STROKE,
      BACKGROUND_COLOR$1 = _enums$STYLE_KEY$9.BACKGROUND_COLOR,
      BORDER_BOTTOM_COLOR$1 = _enums$STYLE_KEY$9.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR$1 = _enums$STYLE_KEY$9.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR$1 = _enums$STYLE_KEY$9.BORDER_RIGHT_COLOR,
      BORDER_TOP_COLOR$1 = _enums$STYLE_KEY$9.BORDER_TOP_COLOR,
      WASM_STYLE_KEY$1 = enums.WASM_STYLE_KEY,
      DIRECTION = enums.DIRECTION,
      FILLS = enums.FILLS,
      EASING = enums.EASING,
      PLAY_STATE = enums.PLAY_STATE;
  var AUTO$5 = o$4.AUTO,
      PX$6 = o$4.PX,
      PERCENT$5 = o$4.PERCENT,
      INHERIT$2 = o$4.INHERIT,
      RGBA$2 = o$4.RGBA,
      STRING$1 = o$4.STRING,
      NUMBER$2 = o$4.NUMBER,
      REM$5 = o$4.REM,
      VW$5 = o$4.VW,
      VH$5 = o$4.VH,
      VMAX$5 = o$4.VMAX,
      VMIN$5 = o$4.VMIN,
      GRADIENT$2 = o$4.GRADIENT,
      calUnit = o$4.calUnit;
  var isNil$b = util.isNil,
      isFunction$5 = util.isFunction,
      isNumber$1 = util.isNumber,
      isObject = util.isObject,
      clone$1 = util.clone,
      equalArr = util.equalArr;
  var linear = easing.linear;
  var cloneStyle = css.cloneStyle,
      equalStyle$1 = css.equalStyle;
  var GEOM$1 = o$2.GEOM;
  var getLevel$1 = o$1.getLevel,
      NONE$3 = o$1.NONE;
  var isColorKey = key.isColorKey,
      isExpandKey = key.isExpandKey,
      isLengthKey = key.isLengthKey,
      isGradientKey = key.isGradientKey,
      isRadiusKey = key.isRadiusKey;
  /**
   * 将每帧的样式格式化，提取出offset属性并转化为时间，提取出缓动曲线easing
   * 加好空数组transition/keys，后续计算两帧之间变化时存入
   * 加好空数组fixed，后续计算无帧变化时存入
   * @param style 关键帧样式
   * @param duration 动画时间长度
   * @param es options的easing曲线控制，frame没有自定义则使用全局的
   */

  function framing(style, duration, es) {
    var _style = style,
        offset = _style.offset,
        easing = _style.easing; // 这两个特殊值提出来存储不干扰style

    delete style.offset;
    delete style.easing; // translatePath特殊对待，ae的曲线运动动画，普通css不包含，特殊处理并添加到style最后

    var translatePath = style.translatePath;
    style = css.normalize(style);

    if (Array.isArray(translatePath) && [6, 8].indexOf(translatePath.length) > -1) {
      style[TRANSLATE_PATH] = translatePath.map(function (item) {
        var v = calUnit(item);

        if (v.u === NUMBER$2) {
          v.u = PX$6;
        }

        return v;
      });
    }

    return {
      style: style,
      time: offset * duration,
      easing: easing || es,
      timingFunction: getEasing(easing || es),
      transition: [],
      // 变化的属性
      trans: [],
      // 变化的k
      fixed: [],
      // 不变的k
      lastPercent: -1
    };
  }

  function calByUnit(p, n, container, root) {
    if (p.u === PX$6) {
      if (n.u === PERCENT$5) {
        return n.v * 0.01 * container - p.v;
      } else if (n.u === REM$5) {
        return n.v * root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width * 0.01 - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height * 0.01 - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) * 0.01 - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) * 0.01 - p.v;
      }
    } else if (p.u === PERCENT$5) {
      if (n.u === PX$6) {
        return n.v * 100 / container - p.v;
      } else if (n.u === REM$5) {
        return n.v * root.computedStyle[FONT_SIZE$4] * 100 / container - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width / container - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height / container - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) / container - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) / container - p.v;
      }
    } else if (p.u === REM$5) {
      if (n.u === PX$6) {
        return n.v / root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * 0.01 * container / root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width * 0.01 / root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height * 0.01 / root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) * 0.01 / root.computedStyle[FONT_SIZE$4] - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) * 0.01 / root.computedStyle[FONT_SIZE$4] - p.v;
      }
    } else if (p.u === VW$5) {
      if (n.u === PX$6) {
        return n.v * 100 / root.__width - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$4] / root.__width - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / root.__width - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height / root.__width - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) / root.__width - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) / root.__width - p.v;
      }
    } else if (p.u === VH$5) {
      if (n.u === PX$6) {
        return n.v * 100 / root.__height - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$4] / root.__height - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width / root.__height - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / root.__height - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) / root.__height - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) / root.__height - p.v;
      }
    } else if (p.u === VMAX$5) {
      if (n.u === PX$6) {
        return n.v * 100 / Math.max(root.__width, root.__height) - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$4] / Math.max(root.__width, root.__height) - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / Math.max(root.__width, root.__height) - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width / Math.max(root.__width, root.__height) - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height / Math.max(root.__width, root.__height) - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.__width, root.__height) / Math.max(root.__width, root.__height) - p.v;
      }
    } else if (p.u === VMIN$5) {
      if (n.u === PX$6) {
        return n.v * 100 / Math.min(root.__width, root.__height) - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$4] / Math.min(root.__width, root.__height) - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / Math.min(root.__width, root.__height) - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.__width / Math.min(root.__width, root.__height) - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.__height / Math.min(root.__width, root.__height) - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.__width, root.__height) / Math.min(root.__width, root.__height) - p.v;
      }
    }

    return 0;
  }
  /**
   * 计算两帧之间的差，单位不同的以后面为准，返回的v表示差值
   * 没有变化返回空
   * auto等无法比较的不参与计算
   * @param prev 上一帧样式
   * @param next 下一帧样式
   * @param k 比较的样式名
   * @param target dom对象
   */


  function calDiff(prev, next, k, target) {
    var p = prev.style[k];
    var n = next.style[k]; // 提前设置好引用，无需每帧计算时取引用，由于单位一定相同，可以简化直接引用到值v上无需单位u，有些直接量没有单位

    var cl = prev.clone[k]; // translatePath可能不存在

    if (cl && cl.hasOwnProperty('v')) {
      cl = cl.v;
    }

    var res = {
      k: k,
      st: p,
      cl: cl
    };

    if (k === TRANSFORM$4) {
      // transform不存在时需给默认矩阵，他只有1个matrix3d的值做动画
      if (!p && !n || !p.length && !n.length) {
        return;
      }

      var pm, nm;

      if (p && p[0]) {
        pm = p[0].v;
      } else {
        pm = matrix.identity();
      }

      if (n && n[0]) {
        nm = n[0].v;
      } else {
        nm = matrix.identity();
      } // transform特殊被初始化转成matrix矩阵，直接计算差值


      if (equalArr(pm, nm)) {
        return;
      }

      res.v = [nm[0] - pm[0], nm[1] - pm[1], nm[2] - pm[2], nm[3] - pm[3], nm[4] - pm[4], nm[5] - pm[5], nm[6] - pm[6], nm[7] - pm[7], nm[8] - pm[8], nm[9] - pm[9], nm[10] - pm[10], nm[11] - pm[11], nm[12] - pm[12], nm[13] - pm[13], nm[14] - pm[14], nm[15] - pm[15]];
    } else if (k === ROTATE_3D$1) {
      if (p[0] === n[0] && p[1] === n[1] && p[2] === n[2] && p[3].v === n[3].v && p[3].u === n[3].u) {
        return;
      }

      res.v = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3].v - p[3].v];
    } else if (k === FILTER$3) {
      // filter很特殊，里面有多个滤镜，按顺序计算，为空视为默认值，如blur默认0，brightness默认1
      var len = Math.max(p ? p.length : 0, n ? n.length : 0);
      var v = [],
          has;

      for (var i = 0; i < len; i++) {
        var pv = p ? p[i] : null,
            nv = n ? n[i] : null; // 空或key不等都无变化

        if (isNil$b(pv) || isNil$b(nv) || pv.k !== nv.k) {
          v.push(null);
        } else {
          has = true;
          var _k = pv.k,
              pvv = pv.v,
              nvv = nv.v;

          if (_k === 'blur') {
            if (pvv.u === nvv.u) {
              v.push(nvv.v - pvv.v);
            } else {
              var v2 = calByUnit(pvv, nvv, 0, target.__root);
              v.push(v2);
            }
          } else if (_k === 'hueRotate' || _k === 'saturate' || _k === 'brightness' || _k === 'contrast' || _k === 'sepia' || _k === 'invert' || _k === 'grayscale') {
            v.push(nvv.v - pvv.v);
          } else if (_k === 'dropShadow') {
            var _v = [];

            for (var _i = 0; _i < 4; _i++) {
              var a = pvv[_i],
                  b = nvv[_i];

              if (a.u === b.u) {
                _v.push(b.v - a.v);
              } else {
                _v.push(calByUnit(a, b, _i === 1 ? target.__clientHeight : target.__clientWidth, target.__root));
              }
            }

            _v.push([nvv[4][0] - pvv[4][0], nvv[4][1] - pvv[4][1], nvv[4][2] - pvv[4][2], nvv[4][3] - pvv[4][3]]);

            v.push(_v);
          }
        }
      }

      if (!has) {
        return;
      }

      res.v = v;
    } else if (k === TRANSFORM_ORIGIN$3 || k === PERSPECTIVE_ORIGIN$2 || isRadiusKey(k)) {
      // x/y都相等无需
      if (n[0].v === p[0].v && n[0].u === p[0].u && n[1].v === p[1].v && n[1].u === p[1].u) {
        return;
      }

      res.v = [];

      for (var _i2 = 0; _i2 < 2; _i2++) {
        var pi = p[_i2];
        var ni = n[_i2];

        if (pi.u === ni.u) {
          res.v.push(ni.v - pi.v);
        } else {
          var _v2 = calByUnit(pi, ni, target[_i2 ? '__outerHeight' : '__outerWidth'], target.__root);

          res.v.push(_v2);
        }
      }
    } else if (k === BACKGROUND_POSITION_X$1 || k === BACKGROUND_POSITION_Y$1) {
      res.v = [];
      var length = Math.min(p.length, n.length);

      for (var _i3 = 0; _i3 < length; _i3++) {
        var _pi = p[_i3],
            _ni = n[_i3];

        if (_pi.u === _ni.u) {
          var _v3 = _ni.v - _pi.v;

          res.v.push(_v3);
        } else {
          var k2 = void 0;

          if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$1 ? '__clientWidth' : '__clientHeight';
          } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$1 ? '__width' : '__height';
          } else {
            k2 = k === BACKGROUND_POSITION_X$1 ? '__offsetWidth' : '__offsetHeight';
          }

          var _v4 = calByUnit(_pi, _ni, target[k2], target.__root);

          res.v.push(_v4);
        }
      }
    } else if (k === BOX_SHADOW$1) {
      res.v = [];

      for (var _i4 = 0, _len = Math.min(p.length, n.length); _i4 < _len; _i4++) {
        var _a = p[_i4];
        var _b = n[_i4]; // 不能为空，outset/inset必须相等

        if (!_a || !_b || _a[5] !== _b[5]) {
          res.v.push(null);
          continue;
        }

        var _v5 = []; // x/y/blur/spread

        for (var j = 0; j < 4; j++) {
          if (_a[j].u === _b[j].u) {
            _v5.push(_b[j].v - _a[j].v);
          } else {
            var _v6 = calByUnit(_a[j], _b[j], _i4 === 1 ? target.__offsetHeight : target.__offsetWidth, target.__root);

            _v5.push(_v6);
          }
        } // rgba


        var c = [];

        for (var _j = 0; _j < 4; _j++) {
          c.push(_b[4][_j] - _a[4][_j]);
        }

        _v5.push(c);

        res.v.push(_v5);
      }
    } else if (k === BACKGROUND_SIZE$1) {
      res.v = [];

      var _length = Math.min(p.length, n.length);

      var _has;

      for (var _i5 = 0; _i5 < _length; _i5++) {
        var _pi2 = p[_i5],
            _ni2 = n[_i5];

        if (!_pi2 || !_ni2) {
          res.v.push(null);
          continue;
        }

        var temp = [];

        for (var _j2 = 0; _j2 < 2; _j2++) {
          var pp = _pi2[_j2],
              nn = _ni2[_j2];

          if (pp.u === nn.u) {
            temp.push(nn.v - pp.v);
          } else {
            var _k2 = void 0;

            if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? '__clientWidth' : '__clientHeight';
            } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? '__width' : '__height';
            } else {
              _k2 = _i5 ? '__offsetWidth' : '__offsetHeight';
            }

            var _v7 = calByUnit(pp, nn, target[_k2], target.__root);

            temp.push(_v7);
          }
        }

        if (equalArr(temp, [0, 0])) {
          res.v.push(null);
        } else {
          res.v.push(temp);
          _has = true;
        }
      }

      if (!_has) {
        return;
      }
    } else if (k === OPACITY$4 || k === Z_INDEX$3) {
      if (n === p) {
        return;
      }

      res.v = n - p;
    } else if (k === STROKE_WIDTH$7) {
      res.v = [];

      var _length2 = Math.min(p.length, n.length);

      for (var _i6 = 0; _i6 < _length2; _i6++) {
        var _pi3 = p[_i6],
            _ni3 = n[_i6];

        if (_pi3.u === _ni3.u) {
          var _v9 = _ni3.v - _pi3.v;

          res.v.push(_v9);
        }

        var _v8 = calByUnit(_pi3, _ni3, target.__offsetWidth, target.__root);

        res.v.push(_v8);
      }
    } // 特殊的path，不存在style中但在动画某帧中，不会统一化所以可能反向计算frameR时后一帧没有
    else if (k === TRANSLATE_PATH && p) {
      var k1 = '__offsetWidth',
          _k3 = '__offsetHeight';
      var computedStyle = target && target.__computedStyle;

      if (computedStyle) {
        if (['padding-box', 'paddingBox'].indexOf(computedStyle[BACKGROUND_CLIP$1]) > -1) {
          k1 = '__clientWidth';
          _k3 = '__clientHeight';
        } else if (['content-box', 'contentBox'].indexOf(computedStyle[BACKGROUND_CLIP$1]) > -1) {
          k1 = '__width';
          _k3 = '__height';
        }
      }

      res.v = p.map(function (item, i) {
        var v = item.v,
            u = item.u;

        if (u === PERCENT$5) {
          if (i % 2 === 0) {
            return {
              v: (parseFloat(v) || 0) * 0.01 * target[k1],
              u: PX$6
            };
          } else {
            return {
              v: (parseFloat(v) || 0) * 0.01 * target[_k3],
              u: PX$6
            };
          }
        } else if (u === REM$5) {
          return {
            v: (parseFloat(v) || 0) * target.__root.computedStyle[FONT_SIZE$4] * 100,
            u: PX$6
          };
        } else if (u === VW$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * target.__root.__width,
            u: PX$6
          };
        } else if (u === VH$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * target.__root.__height,
            u: PX$6
          };
        } else if (u === VMAX$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * Math.max(target.__root.__width, target.__root.__height),
            u: PX$6
          };
        } else if (u === VMIN$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * Math.min(target.__root.__width, target.__root.__height),
            u: PX$6
          };
        } else {
          return {
            v: parseFloat(v) || 0,
            u: PX$6
          };
        }
      });
    } else if (isExpandKey(k)) {
      if (p.u === n.u) {
        var _v10 = n.v - p.v;

        if (_v10 === 0) {
          return;
        }

        res.v = _v10;
      } else {
        var _v11 = calByUnit(p, n, target[k === TRANSLATE_X$1 || k === TRANSLATE_Z$1 ? '__outerWidth' : '__outerHeight'], target.__root);

        if (!_v11) {
          return;
        }

        res.v = _v11;
      }
    } else if (isLengthKey(k)) {
      // auto不做动画
      if (p.u === AUTO$5 || n.u === AUTO$5) {
        return;
      }

      var _computedStyle = target.__computedStyle;
      var parentComputedStyle = (target.__domParent || target).__computedStyle;
      var diff = 0;

      if (p.u === n.u) {
        diff = n.v - p.v;
      } // lineHeight奇怪的单位变化，%相对于fontSize
      else if (k === LINE_HEIGHT$3) {
        diff = calByUnit(p, n, _computedStyle[FONT_SIZE$4], target.__root);
      } // fontSize的%相对于parent的
      else if (k === FONT_SIZE$4) {
        diff = calByUnit(p, n, parentComputedStyle[FONT_SIZE$4], target.__root);
      } // 相对于父height的特殊属性
      else if (k === FLEX_BASIS$3 && ['column', 'column-reverse', 'columnReverse'].indexOf(_computedStyle[FLEX_DIRECTION$2]) > -1 || [HEIGHT$6, TOP$4, BOTTOM$4].indexOf(k) > -1) {
        if (p.u !== AUTO$5 && n.u !== AUTO$5) {
          diff = calByUnit(p, n, parentComputedStyle[HEIGHT$6], target.__root);
        }
      } // 其余都是相对于父width的
      else {
        if (p.u !== AUTO$5 && n.u !== AUTO$5) {
          diff = calByUnit(p, n, parentComputedStyle[WIDTH$6], target.__root);
        }
      } // 兜底NaN非法


      if (diff === 0 || isNaN(diff)) {
        return;
      }

      res.v = diff;
    } else if (isGradientKey(k)) {
      // backgroundImage发生了渐变色和图片的变化，fill发生渐变色和纯色的变化等
      res.v = [];

      var _length3 = Math.min(p.length, n.length);

      for (var _i7 = 0; _i7 < _length3; _i7++) {
        var _pi4 = p[_i7],
            _ni4 = n[_i7];

        if (!_pi4 || !_ni4 || _pi4.u !== _ni4.u || _pi4.u === STRING$1) {
          res.v.push(null);
          continue;
        }

        var u = _pi4.u;
        _pi4 = _pi4.v;
        _ni4 = _ni4.v;

        var _temp = void 0; // 渐变


        if (u === GRADIENT$2) {
          var r = calDiffGradient(_pi4, _ni4, target);

          if (!r) {
            res.v.push(null);
            continue;
          }

          _temp = r;
        } // 纯色
        else {
          if (equalArr(_ni4, _pi4)) {
            res.v.push(null);
            continue;
          }

          _temp = [_ni4[0] - _pi4[0], _ni4[1] - _pi4[1], _ni4[2] - _pi4[2], _ni4[3] - _pi4[3]];
        }

        res.v.push(_temp);
      }
    } else if (isColorKey(k)) {
      if (n.u !== p.u) {
        return;
      } // 特殊增加支持有gradient的先判断，仅color和textStrokeColor支持


      n = n.v;
      p = p.v;

      if (n.u === GRADIENT$2) {
        var _r = calDiffGradient(p, n, target);

        if (!_r) {
          return;
        }

        res.v = _r;
      } else {
        if (equalArr(n, p)) {
          return;
        }

        res.v = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3] - p[3]];
      }
    } else if (GEOM$1.hasOwnProperty(k)) {
      var tagName = target.tagName;

      if (isNil$b(p)) {
        return;
      } else if (GEOM$1[k][tagName] && isFunction$5(GEOM$1[k][tagName].calDiff)) {
        var fn = GEOM$1[k][tagName].calDiff;

        if (target.isMulti) {
          var arr = [];

          for (var _i8 = 0, _len2 = Math.min(p.length, n.length); _i8 < _len2; _i8++) {
            arr.push(fn(p[_i8], n[_i8]));
          }

          return arr;
        } else {
          res.v = fn(p, n);
        }
      } // 特殊处理multi
      else if (target.isMulti) {
        if (k === 'points' || k === 'controls') {
          if (isNil$b(n) || !n.length || isNil$b(p) || !p.length || equalArr(p, n)) {
            return;
          }

          res.v = [];

          for (var _i9 = 0, _len3 = Math.min(p.length, n.length); _i9 < _len3; _i9++) {
            var _pv = p[_i9];
            var _nv = n[_i9];

            if (isNil$b(_pv) || !_pv.length || isNil$b(_nv) || !_nv.length) {
              res.v.push(null);
            } else {
              var _v12 = [];

              for (var _j3 = 0, len2 = Math.min(_pv.length, _nv.length); _j3 < len2; _j3++) {
                var pv2 = _pv[_j3];
                var nv2 = _nv[_j3];

                if (isNil$b(pv2) || isNil$b(nv2)) {
                  _v12.push(null);
                } else {
                  var v3 = [];

                  for (var _k4 = 0, len3 = Math.max(pv2.length, nv2.length); _k4 < len3; _k4++) {
                    var pv3 = pv2[_k4];
                    var nv3 = nv2[_k4]; // control由4点变2点

                    if (isNil$b(pv3) || isNil$b(nv3)) {
                      v3.push(0);
                    } else {
                      v3.push(nv3 - pv3);
                    }
                  }

                  _v12.push(v3);
                }
              }

              res.v.push(_v12);
            }
          }
        } else if (k === 'controlA' || k === 'controlB') {
          if (isNil$b(n) || !n.length || isNil$b(p) || !p.length || equalArr(p, n)) {
            return;
          }

          res.v = [];

          for (var _i10 = 0, _len4 = Math.min(p.length, n.length); _i10 < _len4; _i10++) {
            var _pv2 = p[_i10];
            var _nv2 = n[_i10];

            if (isNil$b(_pv2) || !_pv2.length || isNil$b(_nv2) || !_nv2.length) {
              res.v.push(null);
            } else {
              res.v.push([_nv2[0] - _pv2[0], _nv2[1] - _pv2[1]]);
            }
          }
        } else {
          if (n === p || equalArr(n, p) || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
            return;
          }

          var _v13 = [];

          for (var _i11 = 0, _len5 = Math.min(p.length, n.length); _i11 < _len5; _i11++) {
            var _pv3 = p[_i11];
            var _nv3 = n[_i11];

            if (isNil$b(_pv3) || isNil$b(_nv3)) {
              _v13.push(0);
            }

            _v13.push(_nv3 - _pv3);
          }

          res.v = _v13;
        }
      } // 非multi特殊处理这几类数组类型数据
      else if (k === 'points' || k === 'controls') {
        if (isNil$b(n) || !n.length || isNil$b(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res.v = [];

        for (var _i12 = 0, _len6 = Math.min(p.length, n.length); _i12 < _len6; _i12++) {
          var _pv4 = p[_i12];
          var _nv4 = n[_i12];

          if (isNil$b(_pv4) || !_pv4.length || isNil$b(_nv4) || !_nv4.length) {
            res.v.push(null);
          } else {
            var _v14 = [];

            for (var _j4 = 0, _len7 = Math.max(_pv4.length, _nv4.length); _j4 < _len7; _j4++) {
              var _pv5 = _pv4[_j4];
              var _nv5 = _nv4[_j4]; // control由4点变2点

              if (isNil$b(_pv5) || isNil$b(_nv5)) {
                _v14.push(0);
              } else {
                _v14.push(_nv5 - _pv5);
              }
            }

            res.v.push(_v14);
          }
        }
      } else if (k === 'controlA' || k === 'controlB') {
        if (isNil$b(n) || !n.length || isNil$b(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res.v = [n[0] - p[0], n[1] - p[1]];
      } // 其它简单数据，除了edge/closure/booleanOperations没有增量
      else {
        if (n === p || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
          return;
        } else {
          res.v = n - p;
        }
      }
    } // display等不能有增量过程的
    else {
      return;
    }

    return res;
  } // 渐变的差异计算


  function calDiffGradient(p, n, target) {
    if (p.k !== n.k) {
      return;
    }

    var pv = p.v;
    var nv = n.v;
    var temp = [[]];
    var eq = equalArr(pv, nv); // 渐变值部分是通用的

    for (var i = 0, len = Math.min(pv.length, nv.length); i < len; i++) {
      var a = pv[i];
      var b = nv[i];
      var t = [];
      t.push([b[0][0] - a[0][0], b[0][1] - a[0][1], b[0][2] - a[0][2], b[0][3] - a[0][3]]);

      if (a[1] && b[1]) {
        if (a[1].u === b[1].u) {
          t.push(b[1].v - a[1].v);
        } else {
          var v = calByUnit(a[1], b[1], target.__clientWidth, target.__root);
          t.push(v || 0);
        }
      }

      temp[0].push(t);
    }

    if (p.k === 'linear') {
      var isArrP = Array.isArray(p.d);
      var isArrN = Array.isArray(n.d);

      if (isArrN !== isArrP) {
        return;
      }

      if (isArrP) {
        var _v15 = [n.d[0] - p.d[0], n.d[1] - p.d[1], n.d[2] - p.d[2], n.d[3] - p.d[3]];

        if (eq && equalArr(_v15, [0, 0, 0, 0])) {
          return;
        }

        temp[1] = _v15;
      } else {
        var _v16 = n.d - p.d; // 颜色角度都没变化


        if (eq && _v16 === 0) {
          return;
        }

        temp[1] = _v16;
      }
    } else if (p.k === 'radial') {
      var _isArrP = Array.isArray(p.z);

      var _isArrN = Array.isArray(n.z);

      if (_isArrN !== _isArrP) {
        return;
      }

      temp[2] = []; // sketch中a点到b点特殊格式表达，z是数组忽略p和s

      if (_isArrP) {
        // 距离中心外形全等
        if (eq && equalArr(p.z, n.z)) {
          return;
        }

        for (var _i13 = 0; _i13 < 5; _i13++) {
          var pz = p.z[_i13]; // 半径比例省略为1

          if (pz === undefined) {
            pz = 1;
          }

          var nz = n.z[_i13];

          if (nz === undefined) {
            nz = 1;
          }

          temp[2].push(nz - pz);
        }
      } else {
        if (eq && p.z === n.z && p.s === n.s && equalArr(p.p, n.p)) {
          return;
        }

        for (var _i14 = 0; _i14 < 2; _i14++) {
          var pp = p.p[_i14];
          var np = n.p[_i14];

          if (pp.u === np.u) {
            temp[2].push(np.v - pp.v);
          } else {
            var _v17 = calByUnit(pp, np, target[_i14 ? '__clientWidth' : '__clientHeight'], target.__root);

            temp[2].push(_v17 || 0);
          }
        }
      }
    } else if (p.k === 'conic') {
      if (eq && p.d === n.d && equalArr(p.p, n.p)) {
        return;
      }

      temp[1] = n.d - p.d;
      temp[2] = [];

      for (var _i15 = 0; _i15 < 2; _i15++) {
        var _pp = p.p[_i15];
        var _np = n.p[_i15];

        if (_pp[1] === _np[1]) {
          temp[2].push(_np[0] - _pp[0]);
        } else {
          var _v18 = calByUnit(_pp, _np, target[_i15 ? '__clientWidth' : '__clientHeight'], target.__root);

          temp[2].push(_v18 || 0);
        }
      }
    }

    return temp;
  }
  /**
   * 计算两帧之间不相同的变化，存入transition，相同的忽略
   * 同时不变化的key也得存入fixed
   */


  function calFrame(prev, next, keys, target, isGeom) {
    var hasTp,
        allInFn = true;

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      var ts = calDiff(prev, next, k, target); // 可以形成过渡的才会产生结果返回

      if (ts) {
        if (k === TRANSLATE_PATH) {
          hasTp = true;
        }

        var fn = CAL_HASH[k]; // Geom特殊属性没有fn

        if (fn) {
          ts.fn = fn;
        } else {
          allInFn = false;
        }

        prev.transition.push(ts);
        prev.trans.push(k);
      } // 无法形成连续计算的或者不变的记录下来
      else if (k !== TRANSLATE_PATH) {
        prev.fixed.push(k);
        allInFn = false;
      }
    } // translatePath需特殊处理translate，防止被覆盖


    if (hasTp) {
      var _i16 = prev.trans.indexOf(TRANSLATE_X$1);

      if (_i16 === -1) {
        prev.trans.push(TRANSLATE_X$1);
      }

      _i16 = prev.trans.indexOf(TRANSLATE_Y$1);

      if (_i16 === -1) {
        prev.trans.push(TRANSLATE_Y$1);
      }

      _i16 = prev.fixed.indexOf(TRANSLATE_X$1);

      if (_i16 > -1) {
        prev.fixed.splice(_i16, 1);
      }

      _i16 = prev.fixed.indexOf(TRANSLATE_Y$1);

      if (_i16 > -1) {
        prev.fixed.splice(_i16, 1);
      }
    } // 特殊优化，加速通知Root的更新


    var lv = NONE$3;
    var trans = prev.trans; // 此帧过程中一定变化的，预先计算lv加速，一些影响继承的标识后续特殊处理

    for (var _i17 = 0, _len8 = trans.length; _i17 < _len8; _i17++) {
      var _k5 = trans[_i17];
      lv |= getLevel$1(_k5);

      if (_k5 === COLOR$2) {
        prev.hasColor = true;
      } else if (_k5 === TEXT_STROKE_COLOR$2) {
        prev.hasTsColor = true;
      } else if (_k5 === TEXT_STROKE_WIDTH$2) {
        prev.hasTsWidth = true;
      } else if (_k5 === TEXT_STROKE_OVER$2) {
        prev.hasTsOver = true;
      } // display和visibility固定在fixed里这里不出现，zIndex需要考虑abs等这里也不处理

    } // 提前计算，不包含fixed的


    prev.lv = lv;
    prev.allInFn = allInFn;
    prev.isGeom = isGeom;
    return next;
  }

  function getEasing(ea) {
    var timingFunction;

    if (ea) {
      if (timingFunction = /^\s*steps\s*\(\s*(\d+)(?:\s*,\s*(\w+))?\s*\)/i.exec(ea)) {
        var steps = parseInt(timingFunction[1]);
        var stepsD = timingFunction[2];

        timingFunction = function timingFunction(percent) {
          // steps有效定义正整数
          if (steps && steps > 0) {
            var per = 1 / steps;
            var res = Math.floor(percent / per); // 默认end

            if (stepsD === 'start') {
              res++;
            }

            return res / steps;
          }

          return percent;
        };
      } else {
        timingFunction = easing.getEasing(ea);
      }
    }

    return timingFunction;
  }
  /**
   * calIntermediateStyle计算优化，不能类型的style动画计算方式不同，也有可以复用的，
   * 全部if分支判断太长且浪费，相同计算的用hash存储，k为样式，v为方法，一次hash获取即可
   */


  var CAL_HASH = [];
  CAL_HASH[TRANSFORM$4] = calTransform;
  CAL_HASH[ROTATE_3D$1] = calRotate3d$1;
  CAL_HASH[FILTER$3] = calFilter;
  CAL_HASH[TRANSFORM_ORIGIN$3] = CAL_HASH[PERSPECTIVE_ORIGIN$2] = CAL_HASH[BORDER_TOP_LEFT_RADIUS$2] = CAL_HASH[BORDER_TOP_RIGHT_RADIUS$2] = CAL_HASH[BORDER_BOTTOM_RIGHT_RADIUS$2] = CAL_HASH[BORDER_BOTTOM_LEFT_RADIUS$2] = calOrigin;
  CAL_HASH[STROKE_WIDTH$7] = CAL_HASH[BACKGROUND_POSITION_X$1] = CAL_HASH[BACKGROUND_POSITION_Y$1] = calPosition;
  CAL_HASH[BOX_SHADOW$1] = calBoxShadow;
  CAL_HASH[BACKGROUND_SIZE$1] = calBgSize;
  CAL_HASH[OPACITY$4] = CAL_HASH[Z_INDEX$3] = calNumber;
  CAL_HASH[TRANSLATE_PATH] = calPath;
  CAL_HASH[FONT_SIZE$4] = CAL_HASH[TEXT_STROKE_WIDTH$2] = CAL_HASH[BORDER_BOTTOM_WIDTH$3] = CAL_HASH[BORDER_LEFT_WIDTH$6] = CAL_HASH[BORDER_RIGHT_WIDTH$5] = CAL_HASH[BORDER_TOP_WIDTH$4] = CAL_HASH[LEFT$3] = CAL_HASH[TOP$4] = CAL_HASH[RIGHT$3] = CAL_HASH[BOTTOM$4] = CAL_HASH[FLEX_BASIS$3] = CAL_HASH[WIDTH$6] = CAL_HASH[HEIGHT$6] = CAL_HASH[LINE_HEIGHT$3] = CAL_HASH[MARGIN_BOTTOM$4] = CAL_HASH[MARGIN_TOP$4] = CAL_HASH[MARGIN_LEFT$6] = CAL_HASH[MARGIN_RIGHT$5] = CAL_HASH[PADDING_TOP$4] = CAL_HASH[PADDING_RIGHT$5] = CAL_HASH[PADDING_LEFT$6] = CAL_HASH[PADDING_BOTTOM$3] = CAL_HASH[STROKE_WIDTH$7] = CAL_HASH[STROKE_MITERLIMIT$1] = CAL_HASH[LETTER_SPACING$1] = CAL_HASH[PERSPECTIVE$2] = CAL_HASH[TRANSLATE_X$1] = CAL_HASH[TRANSLATE_Y$1] = CAL_HASH[TRANSLATE_Z$1] = CAL_HASH[SKEW_X$1] = CAL_HASH[SKEW_Y$1] = CAL_HASH[SCALE_X$1] = CAL_HASH[SCALE_Y$1] = CAL_HASH[SCALE_Z$1] = CAL_HASH[ROTATE_X$1] = CAL_HASH[ROTATE_Y$1] = CAL_HASH[ROTATE_Z$1] = calLength;
  CAL_HASH[BACKGROUND_IMAGE$1] = CAL_HASH[FILL$2] = CAL_HASH[STROKE$1] = calGradient;
  CAL_HASH[BACKGROUND_COLOR$1] = CAL_HASH[BORDER_BOTTOM_COLOR$1] = CAL_HASH[BORDER_LEFT_COLOR$1] = CAL_HASH[BORDER_RIGHT_COLOR$1] = CAL_HASH[BORDER_TOP_COLOR$1] = CAL_HASH[COLOR$2] = CAL_HASH[TEXT_STROKE_COLOR$2] = calColor; // transform特殊处理，只有1个matrix，有可能不存在，需给默认矩阵

  function calTransform(k, v, percent, st, cl, frame, currentStyle) {
    if (!st || !st.length) {
      st = frame.style[k] = [{
        k: MATRIX$2,
        v: matrix.identity()
      }];
    }

    if (!cl || !cl.length) {
      cl = frame.clone[k] = [{
        k: MATRIX$2,
        v: matrix.identity()
      }];
    }

    for (var i = 0; i < 16; i++) {
      st[0].v[i] = cl[0].v[i] + v[i] * percent;
    }
  }

  function calRotate3d$1(k, v, percent, st, cl, frame, currentStyle) {
    st[0] = cl[0] + v[0] * percent;
    st[1] = cl[1] + v[1] * percent;
    st[2] = cl[2] + v[2] * percent;
    st[3].v = cl[3].v + v[3] * percent;
  }

  function calFilter(k, v, percent, st, cl, frame, currentStyle) {
    for (var i = 0, len = v.length; i < len; i++) {
      var item = v[i];

      if (item) {
        var k2 = st[i].k,
            v2 = st[i].v,
            clv = cl[i].v; // 只有dropShadow是多个数组，存放x/y/blur/spread/color

        if (k2 === 'dropShadow') {
          v2[0].v = clv[0].v + item[0] * percent;
          v2[1].v = clv[1].v + item[1] * percent;
          v2[2].v = clv[2].v + item[2] * percent;
          v2[3].v = clv[3].v + item[3] * percent;
          var c1 = v2[4],
              cv = clv[4],
              c2 = item[4];
          c1[0] = cv[0] + c2[0] * percent;
          c1[1] = cv[1] + c2[1] * percent;
          c1[2] = cv[2] + c2[2] * percent;
          c1[3] = cv[3] + c2[3] * percent;
        } // 其它都是带单位单值
        else {
          v2.v = clv.v + item * percent;
        }
      }
    }
  }

  function calOrigin(k, v, percent, st, cl, frame, currentStyle) {
    if (v[0] !== 0) {
      st[0].v = cl[0].v + v[0] * percent;
    }

    if (v[1] !== 0) {
      st[1].v = cl[1].v + v[1] * percent;
    }
  }

  function calPosition(k, v, percent, st, cl, frame, currentStyle) {
    st.forEach(function (item, i) {
      if (v[i]) {
        item.v = cl[i].v + v[i] * percent;
      }
    });
  }

  function calBoxShadow(k, v, percent, st, cl, frame, currentStyle) {
    for (var i = 0, len = Math.min(st.length, v.length); i < len; i++) {
      if (!v[i]) {
        continue;
      } // x/y/blur/spread


      for (var j = 0; j < 4; j++) {
        st[i][j].v = cl[i][j].v + v[i][j] * percent;
      } // rgba


      for (var _j5 = 0; _j5 < 4; _j5++) {
        st[i][4][_j5] = cl[i][4][_j5] + v[i][4][_j5] * percent;
      }
    }
  }

  function calBgSize(k, v, percent, st, cl, frame, currentStyle) {
    st.forEach(function (item, i) {
      var o = v[i];

      if (o) {
        item[0].v = cl[i][0].v + o[0] * percent;
        item[1].v = cl[i][1].v + o[1] * percent;
      }
    });
  }

  function calNumber(k, v, percent, st, cl, frame, currentStyle) {
    st = cl + v * percent; // 精度问题可能会超过[0,1]区间

    if (k === OPACITY$4) {
      if (st < 0) {
        st = 0;
      } else if (st > 1) {
        st = 1;
      }
    }

    currentStyle[k] = st;
  } // 特殊的曲线运动计算，转换为translateXY，出现在最后一定会覆盖原本的translate防重


  function calPath(k, v, percent, st, cl, frame, currentStyle) {
    var t = 1 - percent;

    if (v.length === 8) {
      currentStyle[TRANSLATE_X$1] = {
        v: v[0].v * t * t * t + 3 * v[2].v * percent * t * t + 3 * v[4].v * percent * percent * t + v[6].v * percent * percent * percent,
        u: PX$6
      };
      currentStyle[TRANSLATE_Y$1] = {
        v: v[1].v * t * t * t + 3 * v[3].v * percent * t * t + 3 * v[5].v * percent * percent * t + v[7].v * percent * percent * percent,
        u: PX$6
      };
    } else if (v.length === 6) {
      currentStyle[TRANSLATE_X$1] = {
        v: v[0].v * t * t + 2 * v[2].v * percent * t + v[4].v * percent * percent,
        u: PX$6
      };
      currentStyle[TRANSLATE_Y$1] = {
        v: v[1].v * t * t + 3 * v[3].v * percent * t + v[5].v * percent * percent,
        u: PX$6
      };
    }
  }

  function calLength(k, v, percent, st, cl, frame, currentStyle) {
    st.v = cl + v * percent;
  }

  function calGradient(k, v, percent, st, cl, frame, currentStyle) {
    st.forEach(function (st2, i) {
      var v2 = v[i];

      if (!v2) {
        return;
      }

      var cli = cl[i].v;

      if (st2.u === GRADIENT$2) {
        st2 = st2.v;

        var _v19 = _slicedToArray(v2, 4),
            c = _v19[0],
            d = _v19[1],
            p = _v19[2],
            z = _v19[3];

        for (var j = 0, len = Math.min(st2.v.length, c.length); j < len; j++) {
          var a = st2.v[j];
          var b = c[j];
          a[0][0] = cli.v[j][0][0] + b[0][0] * percent;
          a[0][1] = cli.v[j][0][1] + b[0][1] * percent;
          a[0][2] = cli.v[j][0][2] + b[0][2] * percent;
          a[0][3] = cli.v[j][0][3] + b[0][3] * percent;

          if (a[1] && b[1]) {
            a[1].v = cli.v[j][1].v + b[1] * percent;
          }
        }

        if (st2.k === 'linear' && st2.d !== undefined && d !== undefined) {
          if (Array.isArray(d)) {
            st2.d[0] = cli.d[0] + d[0] * percent;
            st2.d[1] = cli.d[1] + d[1] * percent;
            st2.d[2] = cli.d[2] + d[2] * percent;
            st2.d[3] = cli.d[3] + d[3] * percent;
          } else {
            st2.d = cli.d + d * percent;
          }
        } else if (st2.k === 'radial') {
          if (st2.z !== undefined && z !== undefined) {
            st2.z[0] = cli.z[0] + z[0] * percent;
            st2.z[1] = cli.z[1] + z[1] * percent;
            st2.z[2] = cli.z[2] + z[2] * percent;
            st2.z[3] = cli.z[3] + z[3] * percent;
            st2.z[4] = cli.z[4] + z[4] * percent;
          } else if (st2.p !== undefined && p !== undefined) {
            st2.p[0].v = cli.p[0].v + p[0] * percent;
            st2.p[1].v = cli.p[1].v + p[1] * percent;
          }
        } else if (st2.k === 'conic' && st2.d !== undefined && d !== undefined) {
          st2.d = cli.d + d * percent;
          st2.p[0][0] = cli.p[0] + p[0] * percent;
          st2.p[1][0] = cli.p[1] + p[1] * percent;
        }
      } // fill纯色
      else {
        st2 = st2.v;
        st2[0] = cli[0] + v2[0] * percent;
        st2[1] = cli[1] + v2[1] * percent;
        st2[2] = cli[2] + v2[2] * percent;
        st2[3] = cli[3] + v2[3] * percent;
      }
    });
  } // color可能超限[0,255]，但浏览器已经做了限制，无需关心


  function calColor(k, v, percent, st, cl, frame, currentStyle) {
    var t = st.v;
    t[0] = cl[0] + v[0] * percent;
    t[1] = cl[1] + v[1] * percent;
    t[2] = cl[2] + v[2] * percent;
    t[3] = cl[3] + v[3] * percent;
  }
  /**
   * 最后一帧无法计算transition，对整体keys的style进行对比
   */


  function calLastStyle(style, target, keys) {
    var currentStyle = target.__currentStyle,
        currentProps = target.__currentProps,
        res = [];
    var wn = target.__wasmNode;

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i],
          v = style[k];
      var isGeom = GEOM$1.hasOwnProperty(k);

      if (isGeom) {
        if (!equalStyle$1(k, v, currentProps[k], target)) {
          currentProps[k] = v;
          res.push(k);
        }
      } // wasm的情况transform和opacity都是在wasm上计算存储
      else if (wn && wasm$1.isWasmStyle(k)) {
        var n = WASM_STYLE_KEY$1[k];

        if (k === TRANSFORM_ORIGIN$3) {
          if (!wn.equal_set_style(n, v[0].v, v[0].u) || !wn.equal_set_style(n, v[1].v, v[1].u)) {
            res.push(k);
          }
        } else if (k === ROTATE_3D$1) {
          if (!wn.equal_set_style(n, v[0].v, v[0].u) || !wn.equal_set_style(n, v[1].v, v[1].u) || !wn.equal_set_style(n, v[2].v, v[2].u)) {
            res.push(k);
          }
        } else {
          if (!wn.equal_set_style(n, v.v, v.u)) {
            res.push(k);
          }
        }
      } else {
        if (!equalStyle$1(k, v, currentStyle[k], target)) {
          currentStyle[k] = v;
          res.push(k);
        }
      }
    }

    return res;
  }

  function gotoOverload(animation, options, cb) {
    if (isFunction$5(options)) {
      cb = options;
      options = {};
    }

    options = options || {};

    if (!isNil$b(options.areaStart)) {
      animation.areaStart = options.areaStart;
    }

    if (!isNil$b(options.areaDuration)) {
      animation.areaDuration = options.areaDuration;
    }

    return {
      options: options,
      cb: cb
    };
  }

  function frameCb(self) {
    self.emit(Event.FRAME, self.__isDelay);

    if (self.__firstPlay) {
      self.__firstPlay = false;
      self.emit(Event.PLAY);
    }

    var cb = self.__playCb;

    if (cb) {
      self.__playCb = null;
      cb(true); // 标明异步回调
    }
  }

  function wasmFrame(wa, wList, wHash, frames, isReverse) {
    for (var i = 0, len = frames.length; i < len; i++) {
      var _frames$i = frames[i],
          style = _frames$i.style,
          transition = _frames$i.transition,
          trans = _frames$i.trans,
          time = _frames$i.time,
          _easing = _frames$i.easing;
      var eType = EASING.DEFAULT,
          x1 = 0,
          y1 = 0,
          x2 = 1,
          y2 = 1;

      if (Array.isArray(_easing)) {
        if (_easing.length === 4) {
          eType = EASING.EASE_CUSTOM;
          x1 = parseFloat(_easing[0]) || 0;
          y1 = parseFloat(_easing[1]) || 0;
          x2 = parseFloat(_easing[2]) || 0;
          y2 = parseFloat(_easing[3]) || 0;
        }
      } else if (_easing) {
        _easing = _easing.toString();

        if (/^\s*(?:cubic-bezier\s*)?\(\s*[\d.]+\s*,\s*[-\d.]+\s*,\s*[\d.]+\s*,\s*[-\d.]+\s*\)\s*$/i.test(_easing)) {
          _easing = _easing.match(/[\d.]+/g);
          eType = EASING.EASE_CUSTOM;
          x1 = parseFloat(_easing[0]) || 0;
          y1 = parseFloat(_easing[1]) || 0;
          x2 = parseFloat(_easing[2]) || 0;
          y2 = parseFloat(_easing[3]) || 0;
        } else if (_easing === 'easeIn' || _easing === 'ease-in') {
          eType = EASING.EASE_IN;
        } else if (_easing === 'easeOut' || _easing === 'ease-out') {
          eType = EASING.EASE_OUT;
        } else if (_easing === 'ease') {
          eType = EASING.EASE;
        } else if (_easing === 'easeInOut' || _easing === 'ease-in-out') {
          eType = EASING.EASE_IN_OUT;
        } else if (_easing === 'linear') {
          eType = EASING.LINEAR;
        }
      }

      wa.add_frame(isReverse, time, eType, x1, y1, x2, y2); // 除了最后一帧，都有transition

      if (i < len - 1) {
        for (var j = 0, _len9 = transition.length; j < _len9; j++) {
          var item = transition[j],
              k = item.k;

          if (wHash.hasOwnProperty(k)) {
            var o = style[k];
            var n = WASM_STYLE_KEY$1[k];
            var diff = item.v; // 相关记录提取出来存到wasm记录上标识

            transition.splice(j, 1);
            trans.splice(j, 1); // transformOrigin和rotate3d是复合型对应多条，其它简单型

            if (k === TRANSFORM_ORIGIN$3) {
              wa.add_item(isReverse, n, o[0].v, o[0].u, diff[0]);
              wa.add_item(isReverse, n + 1, o[1].v, o[1].u, diff[1]);
            } else if (k === ROTATE_3D$1) {
              wa.add_item(isReverse, n, o[0].v, o[0].u, diff[0]);
              wa.add_item(isReverse, n + 1, o[1].v, o[1].u, diff[1]);
              wa.add_item(isReverse, n + 1, o[2].v, o[2].u, diff[2]);
            } else {
              wa.add_item(isReverse, n, o.v, o.u, diff);
            }

            j--;
            _len9--;
          }
        }
      } // 最后一帧特殊处理，将样式存入，diff都设置0即可
      else {
        for (var _j6 = 0, _len10 = wList.length; _j6 < _len10; _j6++) {
          var _k6 = wList[_j6];

          if (style.hasOwnProperty(_k6)) {
            var _o = style[_k6];
            var _n = WASM_STYLE_KEY$1[_k6];

            if (_k6 === TRANSFORM_ORIGIN$3) {
              wa.add_item(isReverse, _n, _o[0].v, _o[0].u, 0);
              wa.add_item(isReverse, _n + 1, _o[1].v, _o[1].u, 0);
            } else if (_k6 === ROTATE_3D$1) {
              wa.add_item(isReverse, _n, _o[0].v, _o[0].u, 0);
              wa.add_item(isReverse, _n + 1, _o[1].v, _o[1].u, 0);
              wa.add_item(isReverse, _n + 1, _o[2].v, _o[2].u, 0);
            } else {
              wa.add_item(isReverse, _n, _o.v, _o.u, 0);
            }
          }
        }
      }
    }
  }

  var uuid$3 = 0;

  var Animation = /*#__PURE__*/function (_Event) {
    _inherits(Animation, _Event);

    function Animation(target, list, options) {
      var _this;

      _this = _Event.call(this) || this;
      _this.__id = uuid$3++;
      _this.__wasmAnimation = null;
      _this.__ignore = false; // wasm全部接管无需运行before/after

      _this.__fromGoto = false; // play()和gotoAndPlay()区分来源

      list = clone$1(list || []);

      if (Array.isArray(list)) {
        list = list.filter(function (item) {
          return item && isObject(item);
        });
      } // 动画过程另外一种形式，object描述k-v形式
      else if (list && isObject(list)) {
        var nl = [];
        Object.keys(list).forEach(function (k) {
          var v = list[k];

          if (Array.isArray(v)) {
            for (var i = 0, len = v.length; i < len; i++) {
              var o = nl[i] = nl[i] || {
                offset: i / (len - 1)
              };
              o[k] = v[i];
            }
          }
        });
        list = nl;
      } else {
        list = [];
      }

      if (isNumber$1(options)) {
        _this.__options = {
          duration: options,
          fill: 'forwards'
        };
        options = _this.__options;
      }

      var op = _this.__options = options || {
        duration: 0
      };
      _this.__playState = 'idle';
      _this.__target = target;
      _this.__root = target.__root;
      var duration = _this.duration = op.duration;
      var ea = _this.easing = op.easing;
      var fps = parseInt(op.fps) || 0;

      if (fps <= 0) {
        fps = 60;
      }

      _this.fps = fps;
      _this.delay = op.delay;
      _this.endDelay = op.endDelay;
      _this.playbackRate = op.playbackRate;
      _this.fill = op.fill;
      _this.iterations = op.iterations;
      _this.direction = op.direction;
      _this.areaStart = op.areaStart; // ae中的功能，播放中间一段动画，为0忽略

      _this.areaDuration = op.areaDuration;

      var _this$__init = _this.__init(list, duration, ea, target, op.isGeom),
          frames = _this$__init.frames,
          framesR = _this$__init.framesR,
          keys = _this$__init.keys,
          originStyle = _this$__init.originStyle;

      _this.__frames = frames;
      _this.__framesR = framesR;
      _this.__fps = fps;
      _this.__keys = keys;
      _this.__originStyle = originStyle;
      _this.__firstPlay = true;
      _this.__begin = true;
      _this.__end = false;
      _this.__isDelay = false;
      _this.__isEndDelay = false;
      _this.__playCount = 0;
      _this.__currentFrames = {
        reverse: true,
        'alternate-reverse': true,
        alternateReverse: true
      }.hasOwnProperty(_this.__direction) ? framesR : frames;
      var controller = op.controller;

      if (controller && controller instanceof Controller) {
        controller.add(_assertThisInitialized(_this));
      } else if (controller) {
        _this.addControl();
      } // 时间戳


      _this.__startTime = 0;
      return _this;
    }

    _createClass(Animation, [{
      key: "__init",
      value: function __init(list, duration, ea, target, isGeom) {
        if (list.length < 1) {
          return {
            frames: [],
            framesR: [],
            keys: [],
            originStyle: {}
          };
        } // 标准化帧


        var frames = Animation.parse(list, duration, ea, target); // 为方便两帧之间计算变化，强制统一所有帧的css属性相同，没有写的为节点的当前样式currentStyle

        var keys = Animation.unify(frames, target);
        Animation.inherit(frames, keys, target); // 反向的帧复制出来

        var framesR = clone$1(frames).reverse(); // 存储原本样式以便恢复用

        var __currentStyle = target.__currentStyle,
            __currentProps = target.__currentProps;
        var originStyle = {};
        keys.forEach(function (k) {
          if (isGeom && o$2.isGeom(target.tagName, k)) {
            originStyle[k] = __currentProps[k];
          }

          originStyle[k] = __currentStyle[k];
        });
        originStyle = cloneStyle(originStyle, keys); // 再计算两帧之间的变化，存入transition/fixed属性

        Animation.calTransition(frames, keys, target, isGeom); // 反向存储帧的倒排结果

        framesR.forEach(function (item, i) {
          item.time = duration - item.time;
          item.index = i;
        });
        Animation.calTransition(framesR, keys, target, isGeom); // wasm优化和matrix有关的，提取出来交给rust处理

        var wn = target.__wasmNode,
            wList = [],
            wHash = {};

        if (wn) {
          for (var i = 0, len = keys.length; i < len; i++) {
            var k = keys[i];

            if (wasm$1.isWasmStyle(k)) {
              wList.push(k);
              wHash[k] = true;
            }
          } // 有相关的才交给wasm，并移除js中transition计算


          if (wList.length) {
            var iter = this.__iterations === Infinity ? 0 : this.__iterations;
            var easeType = getEaseType(ea);
            var wa = this.__wasmAnimation = wasm$1.Animation["new"](target.__wasmNode.ptr, DIRECTION[this.__direction] || 0, this.__duration, this.__fps, this.__delay, this.__endDelay, FILLS[this.__fill] || 0, this.__playbackRate, iter, this.__areaStart, this.__areaDuration, easeType);

            if (easeType === EASING.EASE_CUSTOM) {
              var v = ea.match(/[\d.]+/g);

              if (v.length === 4) {
                wa.set_bezier(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3]));
              }
            }

            wasmFrame(wa, wList, wHash, frames, false);
            wasmFrame(wa, wList, wHash, framesR, true); // originStyle也需要wasm保存下来等结束还原用

            for (var _i18 = 0, _len11 = wList.length; _i18 < _len11; _i18++) {
              var _k7 = wList[_i18],
                  n = WASM_STYLE_KEY$1[_k7],
                  _v20 = __currentStyle[_k7];

              if (_k7 === TRANSFORM_ORIGIN$3) {
                wa.add_origin(n, _v20[0].v, _v20[0].u);
                wa.add_origin(n + 1, _v20[1].v, _v20[1].u);
              } else if (_k7 === ROTATE_3D$1) {
                wa.add_origin(n, _v20[0].v, _v20[0].u);
                wa.add_origin(n + 1, _v20[1].v, _v20[1].u);
                wa.add_origin(n + 2, _v20[2].v, _v20[2].u);
              } else {
                wa.add_origin(n, _v20.v, _v20.u);
              }
            } // 没有其他的则全部交由wasm


            if (wList.length === keys.length) {
              this.__ignore = true;
            }
          }
        }

        return {
          frames: frames,
          framesR: framesR,
          keys: keys,
          originStyle: originStyle
        };
      }
    }, {
      key: "__clean",
      value: function __clean(isFinish) {
        this.__cancelTask();

        if (isFinish) {
          // gotoAndStop到一个很大的时间的话，也需要防止超过
          this.__currentTime = this.__delay + this.__duration * this.__iterations + this.__endDelay;
          this.__playState = 'finished';
        } else {
          this.__playCount = this.__currentTime = 0;
          this.__playState = 'idle';
        }

        var currentFrame = this.__currentFrame;

        if (currentFrame) {
          currentFrame.lastPercent = -1;
          this.__currentFrame = null;
        }
      }
    }, {
      key: "play",
      value: function play(cb) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'running') {
          if (isFunction$5(cb)) {
            cb(true); // 同步回调
          }

          return this;
        }

        this.__playCb = cb;
        this.__playState = 'running'; // 每次play调用标识第一次运行，需响应play事件和回调

        this.__firstPlay = true; // gotoAndPlay时间已经计算好

        var fromGoto = this.__fromGoto;

        if (fromGoto) {
          this.__fromGoto = false;
        } else {
          this.__currentTime = 0;
          this.__playCount = 0;
        }

        var currentTime = this.__currentTime;
        this.__fpsTime = 0;

        var currentFrames = this.__initCurrentFrames(this.__playCount); // fill停留在开始同步更新首帧样式，gotoPlay若不足delay亦是


        if (!fromGoto && this.__stayBegin || fromGoto && currentTime < this.__delay) {
          var currentFrame = this.__currentFrame = currentFrames[0];
          var target = this.__target,
              _root = this.__root;
          var keys = calLastStyle(currentFrame.style, target, this.__keys);
          var isChange = !!keys.length;

          if (this.__stopCb) {
            _root.__cancelAsyncDraw(this.__stopCb);
          } // 有变化的backwards才更新，否则无需理会，不需要回调，极端情况立刻pause()回造成一次无用刷新


          if (isChange) {
            _root.__addUpdate(target, keys, false, false, false, false, false, null);
          }
        } // 非首帧，gotoPlay要同步执行更新样式
        else if (fromGoto) {
          var areaDuration = this.__areaDuration;
          var dur = areaDuration ? Math.min(duration, areaDuration) : duration; // 只有2帧可优化，否则2分查找当前帧

          var i,
              length = currentFrames.length;

          if (length === 2) {
            i = currentTime < dur ? 0 : 1;
          } else {
            i = Animation.binarySearch(0, length - 1, currentTime, currentFrames);
          }

          var _currentFrame = currentFrames[i]; // 一定不会是最后一帧

          var percent;

          if (length === 2) {
            percent = currentTime / duration; // 不能是dur，按照原本计算
          } else {
            var time = _currentFrame.time;
            var total = currentFrames[i + 1].time - time;
            percent = (currentTime - time) / total;
          } // 强制认为不是同一帧防止不执行


          Animation.calIntermediateStyle(_currentFrame, percent, this.__target, true);
        } // 开始时间为调用play时的帧时间


        this.__startTime = frame.__now || (frame.__now = inject.now());
        this.__begin = true;
        this.__end = false;
        this.__isDelay = false;
        this.__isEndDelay = false;
        var wa = this.__wasmAnimation;

        if (wa && !fromGoto) {
          wa.play();
        } // 由root统一控制，防止重复play


        var root = this.__root;

        root.__onAniFrame(this);

        return this;
      }
    }, {
      key: "__before",
      value: function __before(diff) {
        // 有wasm且完全被包含情况忽略js计算，返回true标识，即便不完全包含，其它的引发的刷新逻辑也包含matrix+opacity
        if (this.__ignore) {
          return true;
        }

        var fps = this.__fps;
        var currentFrames = this.__currentFrames;
        var iterations = this.__iterations;
        var delay = this.__delay;
        var areaStart = this.__areaStart;
        var areaDuration = this.__areaDuration;
        var duration = this.__duration;
        var playbackRate = this.__playbackRate;
        var dur = areaDuration ? Math.min(duration, areaDuration) : duration; // 播放时间累加，并且考虑播放速度加成

        if (playbackRate !== 1) {
          diff *= playbackRate;
        } // 用本帧和上帧时间差，计算累加运行时间currentTime，以便定位当前应该处于哪个时刻


        var currentTime = this.__currentTime += diff; // 增加的fps功能，当<60时计算跳帧，每帧运行依旧累加时间，达到fps时重置，第一帧强制不跳

        if (!this.__firstPlay && fps > 0 && fps !== 60 && fps !== 120) {
          diff = this.__fpsTime += diff;

          if (diff < 1000 / fps) {
            this.__inFps = true;
            return;
          }

          this.__fpsTime = 0;
        } // delay仅第一次生效等待


        if (currentTime < delay - areaStart) {
          this.__begin = false; // 默认是true，delay置false防触发
          // 即便不刷新，依旧执行帧回调，同时标明让后续第一帧响应begin

          this.__isDelay = true;
          return;
        } // 减去delay，计算在哪一帧


        currentTime -= delay - areaStart;

        if (this.__isDelay) {
          this.__isDelay = false;
          this.__begin = true;
        } // 超过duration非尾轮需处理回到开头，触发新一轮动画事件，这里可能时间间隔非常大直接跳过几轮


        var playCount = Math.min(iterations - 1, Math.floor(currentTime / dur));
        currentTime -= dur * playCount; // 如果发生轮换，需重新确定正反向

        if (this.__playCount < playCount) {
          this.__begin = true;
          this.__playCount = playCount;
          currentFrames = this.__initCurrentFrames(playCount);
        }

        this.__calCurrent(currentFrames, this.__currentFrame, currentTime, dur, duration, null);
      }
    }, {
      key: "__after",
      value: function __after() {
        if (this.__inFps) {
          this.__inFps = false;
          return;
        }

        frameCb(this);

        if (this.__begin) {
          this.__begin = false;
          this.emit(Event.BEGIN, this.__playCount);
        } // end事件只触发一次，末轮进入endDelay或直接结束时


        if (this.__end) {
          this.__end = false;
          this.emit(Event.END, this.__playCount - 1);
        }

        if (this.__finished) {
          this.__begin = this.__end = this.__isDelay = this.__isEndDelay = this.__finished = false;
          this.__playState = 'finished';
          this.emit(Event.FINISH, true);

          this.__clean(true);
        }
      }
    }, {
      key: "pause",
      value: function pause() {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var pending = this.pending;

        if (isDestroyed || duration <= 0 || pending) {
          return this;
        } // 不能清空stopCb


        if (this.__playState === 'running') {
          this.__root.__offAniFrame(this);
        }

        this.__playCb = null;
        this.__playState = 'paused';
        var wa = this.__wasmAnimation;

        if (wa) {
          wa.play_state = PLAY_STATE.PAUSED;
        }

        this.emit(Event.PAUSE);
        return this;
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;

        if (isDestroyed || duration <= 0 || playState !== 'paused') {
          return this;
        }

        return this.play(cb);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        var _this2 = this;

        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'finished') {
          if (isFunction$5(cb)) {
            cb(true);
          }

          return this;
        } // 先清除所有回调任务，多次调用finish也会清除只留最后一次


        this.__clean(true);

        this.__begin = this.__end = this.__isDelay = this.__isEndDelay = this.__finished = this.__inFps = false;
        this.__playState = 'finished';
        var wa = this.__wasmAnimation;

        if (wa) {
          wa.play_state = PLAY_STATE.FINISHED;
        }

        var root = this.__root;

        if (root) {
          var target = this.__target;
          var style; // 是否停留在最后一帧

          if (this.__stayEnd) {
            var currentFrames = this.__initCurrentFrames(this.__playCount);

            var currentFrame = this.__currentFrame = currentFrames[currentFrames.length - 1];
            style = currentFrame.style;
          } else {
            style = this.__originStyle;
          }

          var keys = calLastStyle(style, target, this.__keys);
          var isChange = !!keys.length;

          if (this.__stopCb) {
            root.__cancelAsyncDraw(this.__stopCb);
          }

          this.__stopCb = function () {
            if (isChange) {
              frameCb(_this2);
            }

            _this2.emit(Event.FINISH, isChange);

            if (isFunction$5(cb)) {
              cb(isChange);
            }
          };

          if (isChange) {
            root.__addUpdate(target, keys, false, false, false, false, false, this.__stopCb);
          } else {
            this.__stopCb();
          }
        }

        return this;
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        var _this3 = this;

        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'idle') {
          if (isFunction$5(cb)) {
            cb(true);
          }

          return this;
        }

        this.__clean(false);

        this.__begin = this.__end = this.__isDelay = this.__isEndDelay = this.__finished = this.__inFps = false;
        this.__playState = 'idle';
        var wa = this.__wasmAnimation;

        if (wa) {
          wa.play_state = PLAY_STATE.IDLE;
        }

        this.__currentFrame = null;
        var root = this.__root;

        if (root) {
          var target = this.__target;
          var keys = calLastStyle(this.__originStyle, target, this.__keys);
          var isChange = !!keys.length;

          if (this.__stopCb) {
            root.__offFrame(this.__stopCb);
          }

          this.__stopCb = function () {
            if (isChange) {
              frameCb(_this3);
            }

            _this3.emit(Event.CANCEL, isChange);

            if (isFunction$5(cb)) {
              cb(isChange);
            }
          };

          if (isChange) {
            root.__addUpdate(target, keys, false, false, false, false, false, this.__stopCb);
          } else {
            this.__stopCb();
          }
        }

        return this;
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        var t = gotoOverload(this, options, cb);
        options = t.options;
        cb = t.cb;
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var frames = this.__frames;
        var areaDuration = this.__areaDuration;
        var endDelay = this.__endDelay;
        var currentTime = this.__currentTime;
        var dur = areaDuration ? Math.min(duration, areaDuration) : duration;

        if (isDestroyed || dur <= 0 || frames.length < 1) {
          return this;
        } // 重复相同时间，且正在播放中，且


        if (v === currentTime && this.__playState === 'running') {
          if (isFunction$5(cb)) {
            cb(true);
          }

          return;
        } // 计算出时间点直接累加播放


        v = this.__goto(v, options.isFrame, options.excludeDelay); // 已经结束提前跳出

        if (v >= dur + endDelay) {
          if (this.__stayEnd) {
            this.finish(cb);
          } else {
            this.cancel(cb);
          }

          return;
        }

        if (this.__playState === 'running') {
          this.__cancelTask();
        }

        this.__playState = 'idle';
        this.__fromGoto = true;
        var wa = this.__wasmAnimation;
        var wasmChange = false;

        if (wa) {
          wasmChange = wa.goto_stop(this.__currentTime, dur);
        }

        this.__calCurrent(this.__currentFrames, this.__currentFrame, v, dur, duration, {
          wasmChange: wasmChange,
          cb: cb
        });

        return this.play(cb);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        var t = gotoOverload(this, options, cb);
        options = t.options;
        cb = t.cb;
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var frames = this.__frames;
        var areaDuration = this.__areaDuration;
        var endDelay = this.__endDelay;
        var currentTime = this.__currentTime;
        var dur = areaDuration ? Math.min(duration, areaDuration) : duration;

        if (isDestroyed || dur <= 0 || frames.length < 1) {
          return this;
        } // 重复相同时间忽略


        if (v === currentTime) {
          if (isFunction$5(cb)) {
            cb(true);
          }

          return;
        }

        v = this.__goto(v, options.isFrame, options.excludeDelay); // 已经结束提前跳出

        if (v >= dur + endDelay) {
          if (this.__stayEnd) {
            this.finish(cb);
          } else {
            this.cancel(cb);
          }

          return;
        }

        if (this.__playState === 'running') {
          this.__cancelTask();
        }

        this.__startTime = frame.__now = frame.__now || inject.now();
        this.__playState = 'paused';
        var wa = this.__wasmAnimation;
        var wasmChange = false;

        if (wa) {
          wasmChange = wa.goto_stop(this.__currentTime, dur);
        }

        this.__calCurrent(this.__currentFrames, this.__currentFrame, v, dur, duration, {
          wasmChange: wasmChange,
          cb: cb
        });
      } // 返回不包含delay且去除多轮的时间

    }, {
      key: "__goto",
      value: function __goto(v, isFrame, excludeDelay) {
        var iterations = this.__iterations;
        var duration = this.__duration;
        var areaDuration = this.__areaDuration;
        var dur = areaDuration ? Math.min(duration, areaDuration) : duration;

        if (isNaN(v) || v < 0) {
          throw new Error('Param of gotoAnd(Play/Stop) is illegal: ' + v);
        }

        if (isFrame) {
          v = (v - 1) / this.spf;
        }

        if (excludeDelay) {
          v += this.__delay;
        } // 在时间范围内设置好时间，复用play直接跳到播放点


        this.__currentTime = v;
        v -= this.__delay - this.__areaStart;

        if (v < 0) {
          v = 0;
        } // 超过时间长度需要累加次数，这里可以超过iterations，因为设定也许会非常大


        var playCount = Math.min(iterations - 1, Math.floor(v / dur));
        v -= dur * playCount;
        this.__playCount = playCount;

        this.__initCurrentFrames(playCount);

        return v;
      }
    }, {
      key: "__initCurrentFrames",
      value: function __initCurrentFrames(playCount) {
        var frames = this.__frames;
        var framesR = this.__framesR;
        var direction = this.__direction; // 初始化根据方向确定帧序列

        if ({
          alternate: true,
          'alternate-reverse': true,
          alternateReverse: true
        }.hasOwnProperty(direction)) {
          var isEven = playCount % 2 === 0;

          if (direction === 'alternate') {
            return this.__currentFrames = isEven ? frames : framesR;
          } else {
            return this.__currentFrames = isEven ? framesR : frames;
          }
        }

        return this.__currentFrames = direction === 'reverse' ? framesR : frames;
      } // 有gotoCb时是来自gotoAndStop，gotoAndPlay则复用play

    }, {
      key: "__calCurrent",
      value: function __calCurrent(currentFrames, lastFrame, currentTime, dur, duration, gotoParams) {
        var isLastCount = this.__playCount >= this.__iterations - 1,
            length = currentFrames.length; // 只有2帧可优化，否则2分查找当前帧

        var i;

        if (length === 2) {
          i = currentTime < dur ? 0 : 1;
        } else {
          i = Animation.binarySearch(0, length - 1, currentTime, currentFrames);
        }

        var currentFrame = currentFrames[i]; // 最后一帧结束动画，仅最后一轮才会进入

        var isLastFrame = isLastCount && i === length - 1;
        var percent = 0;

        if (isLastFrame) ; // 否则根据目前到下一帧的时间差，计算百分比，再反馈到变化数值上
        else if (length === 2) {
          percent = currentTime / duration; // 不能是dur，按照原本计算
        } else {
          var time = currentFrame.time;
          var total = currentFrames[i + 1].time - time;
          percent = (currentTime - time) / total;
        }

        var notSameFrame = lastFrame !== currentFrame; // 对比前后两帧是否为同一关键帧，不是则清除之前关键帧上的percent标识为-1，这样可以识别跳帧和本轮第一次进入此帧

        if (notSameFrame) {
          lastFrame && (lastFrame.lastPercent = -1);
          this.__currentFrame = currentFrame;
        }
        /** 这里要考虑全几种场景：
         * 1. 单次播放无endDelay且fill不停留（有/无差异，下同）
         * 2. 单次播放无endDelay且fill停留
         * 3. 单次播放有endDelay且fill不停留
         * 4. 单次播放有endDelay且fill停留
         * 5. 多次播放无endDelay且fill不停留（尾次/非尾次，下同）
         * 6. 多次播放无endDelay且fill停留
         * 7. 多次播放有endDelay且fill不停留
         * 8. 多次播放有endDelay且fill停留
         */


        var root = this.__root,
            target = this.__target; // 最后结束特殊处理

        if (isLastFrame) {
          var keys; // 是否停留在最后一帧

          if (this.__stayEnd) {
            // 第一次进入endDelay触发后续不再，并且设置__end标识在after触发END事件
            if (!this.__isEndDelay) {
              this.__isEndDelay = true;
              this.__end = true;
              keys = calLastStyle(currentFrame.style, target, this.__keys);
            } else {
              keys = [];
            } // 有可能刚进endDelay（只有1ms很短）就超过直接finish了，所以只用时间对比


            if (currentTime >= dur + this.__endDelay) {
              this.__playCount++;
              this.__finished = true;
            }
          } else {
            keys = calLastStyle(this.__originStyle, target, this.__keys);
            currentFrame = this.__currentFrame = null;
            this.__end = true;
            this.__playCount++;
            this.__finished = true;
          } // gotoAndStop有参数回调特殊对待


          if (gotoParams) {
            this.__gotoStopCb(root, target, keys, currentFrame, gotoParams);
          } // 普通动画有样式变更才触发真实刷新，且sync标识同步应用，和动画节奏一样，
          // wasmChange无需，因为即便wasm接管，这块逻辑也在wasm中，这是动画更新没有gotoStop
          else if (keys.length) {
            root.__addUpdate(target, keys, false, false, false, true, false, null);
          }
        } // 动画内部除非同帧内且本帧没有任何变化，否则会一直触发，哪怕diff时间为0
        else {
          var _Animation$calInterme = Animation.calIntermediateStyle(currentFrame, percent, target, notSameFrame),
              trans = _Animation$calInterme.trans,
              fixed = _Animation$calInterme.fixed; // gotoAndStop有参数回调特殊对待


          if (gotoParams) {
            var _keys = trans.concat(fixed);

            this.__gotoStopCb(root, target, _keys, currentFrame, gotoParams);
          } // 普通动画同步更新sync
          else if (trans.length || fixed.length) {
            root.__addAniUpdate(target, trans, fixed, currentFrame);
          }
        }
      }
    }, {
      key: "__gotoStopCb",
      value: function __gotoStopCb(root, target, keys, currentFrame, gotoParams) {
        var _this4 = this;

        if (this.__stopCb) {
          root.__cancelAsyncDraw(this.__stopCb);
        }

        var isChange = gotoParams.wasmChange || !!keys.length;

        this.__stopCb = function () {
          if (isChange) {
            frameCb(_this4);
          }

          if (isFunction$5(gotoParams.cb)) {
            gotoParams.cb(isChange);
          }
        };

        if (isChange) {
          // 因为wasm情况会导致js不计算可能没有keys（缺少wasm计算的那些），需传参标识
          root.__addUpdate(target, keys, false, false, false, false, gotoParams.wasmChange, this.__stopCb);
        } else {
          this.__stopCb(isChange); // 无变化同步执行

        }
      }
    }, {
      key: "addControl",
      value: function addControl() {
        var root = this.__root;

        if (!root) {
          return;
        }

        var ac = root.__animateController;

        if (ac) {
          this.__isControlled = true;
          ac.add(this);
        }
      }
    }, {
      key: "removeControl",
      value: function removeControl() {
        var root = this.__root;

        if (!root || !this.__isControlled) {
          return;
        }

        var ac = root.__animateController;

        if (ac) {
          ac.remove(this);
        }
      }
    }, {
      key: "__cancelTask",
      value: function __cancelTask() {
        var root = this.__root;

        if (!root) {
          return;
        }

        root.__offAniFrame(this);

        if (this.__stopCb) {
          root.__cancelAsyncDraw(this.__stopCb);
        }

        this.__playCb = this.__stopCb = null;
      }
    }, {
      key: "remove",
      value: function remove() {
        if (this.__target) {
          this.cancel();

          this.__target.removeAnimate(this);

          this.__destroy();
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        this.removeControl();

        this.__cancelTask();

        this.__target = this.__root = null;
        this.__startTime = 0;
        this.__isDestroyed = true;
        var wa = this.__wasmAnimation;

        if (wa) {
          wa.free();
          this.__wasmAnimation = null;
        }
      }
    }, {
      key: "__checkModify",
      value: function __checkModify() {
        if (this.__playState !== 'idle' && this.__playState !== 'finished') {
          inject.warn('Modification will not come into effect when animation is running');
        }
      }
    }, {
      key: "id",
      get: function get() {
        return this.__id;
      }
    }, {
      key: "target",
      get: function get() {
        return this.__target;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__root;
      }
    }, {
      key: "keys",
      get: function get() {
        return this.__keys;
      }
    }, {
      key: "options",
      get: function get() {
        return this.__options;
      }
    }, {
      key: "duration",
      get: function get() {
        return this.__duration;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__duration !== v) {
          this.__duration = v;

          this.__checkModify();
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.duration = v;
        }

        return v;
      }
    }, {
      key: "delay",
      get: function get() {
        return this.__delay;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__delay !== v) {
          this.__delay = v;

          this.__checkModify();
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.delay = v;
        }

        return v;
      }
    }, {
      key: "endDelay",
      get: function get() {
        return this.__endDelay;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__endDelay !== v) {
          this.__endDelay = v;

          this.__checkModify();
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.end_delay = v;
        }

        return v;
      }
    }, {
      key: "fps",
      get: function get() {
        return this.__fps;
      },
      set: function set(v) {
        v = parseInt(v) || 60;

        if (this.__fps !== v) {
          if (v <= 0) {
            v = 60;
          }

          this.__fps = v;
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.fps = v;
        }

        return v;
      }
    }, {
      key: "spf",
      get: function get() {
        return 1 / this.fps;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this.__iterations;
      },
      set: function set(v) {
        if (v === Infinity || util.isString(v) && v.toLowerCase() === 'infinity') {
          v = Infinity;
        } else {
          v = parseInt(v);

          if (isNaN(v) || v < 0) {
            v = 1;
          }
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.iterations = v === Infinity ? 0 : v;
        }

        if (this.__iterations !== v) {
          this.__iterations = v;
        }

        return v;
      }
    }, {
      key: "fill",
      get: function get() {
        return this.__fill;
      },
      set: function set(v) {
        v = v || 'none';

        if (this.__fill !== v) {
          this.__fill = v;

          this.__checkModify();
        }

        this.__stayBegin = {
          backwards: true,
          both: true
        }.hasOwnProperty(v);
        this.__stayEnd = {
          forwards: true,
          both: true
        }.hasOwnProperty(v);
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.fill = FILLS[v] || 0;
        }

        return v;
      }
    }, {
      key: "direction",
      get: function get() {
        return this.__direction;
      },
      set: function set(v) {
        v = v || 'normal';
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.direction = DIRECTION[v] || 0;
        }

        if (this.__direction !== v) {
          this.__direction = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "frames",
      get: function get() {
        return this.__frames;
      }
    }, {
      key: "framesR",
      get: function get() {
        return this.__framesR;
      }
    }, {
      key: "playbackRate",
      get: function get() {
        return this.__playbackRate;
      },
      set: function set(v) {
        v = parseFloat(v) || 1;

        if (v <= 0) {
          v = 1;
        }

        var wn = this.__wasmAnimation;

        if (wn) {
          wn.playback_rate = v;
        }

        if (this.__playbackRate !== v) {
          this.__playbackRate = v;
        }

        return v;
      }
    }, {
      key: "easing",
      get: function get() {
        return this.__easing;
      },
      set: function set(v) {
        var wa = this.__wasmAnimation;

        if (wa) {
          var easeType = getEaseType(v);

          if (easeType === EASING.EASE_CUSTOM) {
            v = v.match(/[\d.]+/g);

            if (v.length === 4) {
              wa.set_bezier(parseFloat(v[0]), parseFloat(v[1]), parseFloat(v[2]), parseFloat(v[3]));
            }
          }
        }

        this.__easing = v;
      }
    }, {
      key: "startTime",
      get: function get() {
        return this.__startTime;
      }
    }, {
      key: "currentTime",
      get: function get() {
        if (this.__ignore) {
          return this.__wasmAnimation.current_time;
        }

        return this.__currentTime;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.current_time = v;
        }

        if (this.__currentTime !== v) {
          this.__currentTime = v;
        }

        return v;
      }
    }, {
      key: "pending",
      get: function get() {
        if (this.__ignore) {
          return this.__wasmAnimation.play_state !== 1; // 硬编码，wasm对应状态
        }

        return this.__playState !== 'running';
      }
    }, {
      key: "finished",
      get: function get() {
        if (this.__ignore) {
          return this.__wasmAnimation.play_state === 3; // 硬编码，wasm对应状态
        }

        return this.__playState === 'finished';
      }
    }, {
      key: "playState",
      get: function get() {
        return this.__playState;
      }
    }, {
      key: "playCount",
      get: function get() {
        if (this.__ignore) {
          return this.__wasmAnimation.play_count;
        }

        return this.__playCount;
      },
      set: function set(v) {
        v = Math.max(0, parseInt(v) || 0);
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.play_count = v;
        }

        if (this.__playCount !== v) {
          this.__playCount = v;
        }

        return v;
      }
    }, {
      key: "areaStart",
      get: function get() {
        return this.__areaStart;
      },
      set: function set(v) {
        v = Math.max(0, parseInt(v) || 0);
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.area_start = v;
        }

        if (this.__areaStart !== v) {
          this.__areaStart = v;
        }

        return v;
      }
    }, {
      key: "areaDuration",
      get: function get() {
        return this.__areaDuration;
      },
      set: function set(v) {
        v = Math.max(0, parseInt(v) || 0);
        var wn = this.__wasmAnimation;

        if (wn) {
          wn.area_duration = v;
        }

        if (this.__areaDuration !== v) {
          this.__areaDuration = v;
        }

        return v;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }, {
      key: "animating",
      get: function get() {
        var playState = this.__playState;

        if (playState === 'idle') {
          return false;
        }

        return playState !== 'finished' || this.__stayEnd || this.__stayBegin;
      }
    }], [{
      key: "parse",
      value: function parse(list, duration, easing, target) {
        // 过滤时间非法的，过滤后续offset<=前面的
        var offset = -1;

        var _loop = function _loop(_i19, _len12) {
          var current = list[_i19];

          if (current.hasOwnProperty('offset')) {
            current.offset = parseFloat(current.offset) || 0;
            current.offset = Math.max(0, current.offset);
            current.offset = Math.min(1, current.offset); // 超过区间[0,1]

            if (isNaN(current.offset) || current.offset < 0 || current.offset > 1) {
              list.splice(_i19, 1);
              _i19--;
              _len12--;
              i = _i19;
              len = _len12;
              return "continue";
            } // <=前面的
            else if (current.offset <= offset) {
              list.splice(_i19, 1);
              _i19--;
              _len12--;
              i = _i19;
              len = _len12;
              return "continue";
            }
          } // 缩写处理


          Object.keys(current).forEach(function (k) {
            if (abbr.hasOwnProperty(k)) {
              abbr.toFull(current, k);
            }
          }); // 检查key合法性

          Object.keys(current).forEach(function (k) {
            if (k !== 'easing' && k !== 'offset' && !o$2.isValid(target && target.tagName, k)) {
              delete current[k];
            }
          });
          i = _i19;
          len = _len12;
        };

        for (var i = 0, len = list.length; i < len; i++) {
          var _ret = _loop(i, len);

          if (_ret === "continue") continue;
        } // 只有1帧复制出来变成2帧方便运行


        if (list.length === 1) {
          list[0] = clone$1(list[0]);

          if (list[0].offset === 1) {
            list.unshift({
              offset: 0
            });
          } else {
            var copy = clone$1(list[0]);
            copy.offset = 1;
            list.push(copy);
          }
        } // 强制clone防止同引用
        else {
          list.forEach(function (item, i) {
            list[i] = clone$1(item);
          });
        } // 首尾时间偏移强制为[0, 1]，不是的话前后加空帧


        var first = list[0];

        if (first.hasOwnProperty('offset') && first.offset > 0) {
          first = {
            offset: 0
          };
          list.unshift(first);
        } else {
          first.offset = 0;
        }

        var last = list[list.length - 1];

        if (last.hasOwnProperty('offset') && last.offset < 1) {
          last = {
            offset: 1
          };
          list.push(last);
        } else {
          last.offset = 1;
        } // 计算没有设置offset的帧


        for (var _i20 = 1, _len13 = list.length; _i20 < _len13; _i20++) {
          var start = list[_i20]; // 从i=1开始offset一定>0，找到下一个有offset的，均分中间无声明的

          if (!start.hasOwnProperty('offset')) {
            var end = void 0;
            var j = _i20 + 1;

            for (; j < _len13; j++) {
              end = list[j];

              if (end.hasOwnProperty('offset')) {
                break;
              }
            }

            var num = j - _i20 + 1;
            start = list[_i20 - 1];
            var per = (end.offset - start.offset) / num;

            for (var k = _i20; k < j; k++) {
              var item = list[k];
              item.offset = start.offset + per * (k + 1 - _i20);
            }

            _i20 = j;
          }
        }

        var frames = [];

        for (var _i21 = 0, _len14 = list.length; _i21 < _len14; _i21++) {
          var o = framing(list[_i21], duration, easing);
          o.index = _i21;
          frames[_i21] = o;
        }

        return frames;
      }
    }, {
      key: "unify",
      value: function unify(frames, target) {
        var hash = {};
        var keys = []; // 获取所有关键帧的属性

        frames.forEach(function (item) {
          var style = item.style;
          Object.keys(style).forEach(function (k) {
            var v = style[k]; // 未定义的过滤掉，null空有意义

            if (v !== undefined && !hash.hasOwnProperty(k)) {
              hash[k] = true; // geom为属性字符串，style都为枚举int

              if (!GEOM$1.hasOwnProperty(k)) {
                k = parseInt(k);
              } // path动画要转为translateXY，所以手动添加，使2帧之间存在过渡，有可能之前已存在这个动画，可忽视


              if (k === TRANSLATE_PATH) {
                if (!hash.hasOwnProperty(TRANSLATE_X$1)) {
                  keys.push(TRANSLATE_X$1);
                }

                if (!hash.hasOwnProperty(TRANSLATE_Y$1)) {
                  keys.push(TRANSLATE_Y$1);
                }

                hash[TRANSLATE_X$1] = hash[TRANSLATE_Y$1] = true;
              }

              keys.push(k);
            }
          });
        }); // 添补没有声明完全的关键帧属性为节点当前值

        frames.forEach(function (item) {
          var style = item.style;
          keys.forEach(function (k) {
            if (!style.hasOwnProperty(k) || isNil$b(style[k])) {
              if (GEOM$1.hasOwnProperty(k)) {
                if (target) {
                  style[k] = clone$1(target.getProps(k));
                }
              } else {
                if (k === TRANSLATE_X$1 && style.hasOwnProperty(TRANSLATE_PATH)) {
                  style[k] = clone$1(style[TRANSLATE_PATH][0]);
                } else if (k === TRANSLATE_Y$1 && style.hasOwnProperty(TRANSLATE_PATH)) {
                  style[k] = clone$1(style[TRANSLATE_PATH][1]);
                } else if (target) {
                  style[k] = cloneStyle(target.__currentStyle, [k])[k];
                }
              }
            }
          });
        });
        return keys;
      }
    }, {
      key: "inherit",
      value: function inherit(frames, keys, target) {
        var computedStyle = target && target.__computedStyle;
        frames.forEach(function (item) {
          var style = item.style;
          keys.forEach(function (k) {
            var v = style[k]; // geom的属性可能在帧中没有

            if (isNil$b(v)) {
              return;
            }

            if (k === TRANSFORM$4) {
              if (target) {
                var ow = target.__outerWidth;
                var oh = target.__outerHeight;
                var m = transform$1.calMatrix(v, ow, oh, target.__root);
                style[k] = [{
                  k: MATRIX$2,
                  v: m
                }];
              }
            } else if (v.u === INHERIT$2 && computedStyle) {
              if (k === COLOR$2 || k === TEXT_STROKE_COLOR$2) {
                style[k] = {
                  v: util.rgba2int(computedStyle[k]),
                  u: RGBA$2
                };
              } else if (isLengthKey(k)) {
                style[k] = {
                  v: computedStyle[k],
                  u: PX$6
                };
              } else if (k === FONT_WEIGHT$2) {
                style[k] = {
                  v: computedStyle[k],
                  u: NUMBER$2
                };
              } else if (k === FONT_STYLE$1 || k === FONT_FAMILY$2 || k === TEXT_ALIGN$2 || k === TEXT_STROKE_OVER$2) {
                style[k] = {
                  v: computedStyle[k],
                  u: STRING$1
                };
              }
            }
          });
        });
      }
    }, {
      key: "calTransition",
      value: function calTransition(frames, keys, target) {
        var isGeom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var prev = frames[0];
        prev.clone = cloneStyle(prev.style, keys);

        for (var _i22 = 1, _len15 = frames.length; _i22 < _len15; _i22++) {
          var next = frames[_i22];
          next.clone = cloneStyle(next.style, keys);
          prev = calFrame(prev, next, keys, target, isGeom);
        }
      }
    }, {
      key: "binarySearch",
      value: function binarySearch(i, j, time, frames) {
        while (i < j) {
          if (i === j - 1) {
            if (frames[j].time <= time) {
              return j;
            }

            return i;
          }

          var middle = i + (j - i >> 1);
          var _frame = frames[middle];

          if (_frame.time === time) {
            return middle;
          }

          if (_frame.time > time) {
            j = Math.max(middle - 1, i);
          } else {
            i = Math.min(middle, j);
          }
        }

        return i;
      }
      /**
       * 计算真变化，对于有连续变化补间的，即有trans的，优化认为一定触发了重绘，哪怕和原始style相等或者diff为0
       * 对于无补间的如display这种，在不同帧之间才认为可能触发重绘，因为性能开销小可以再次比对真实情况判断是否需要真实重绘
       */

    }, {
      key: "calIntermediateStyle",
      value: function calIntermediateStyle(frame, percent, target, notSameFrame) {
        var style = frame.style;
        var transition = frame.transition;
        var timingFunction = frame.timingFunction;
        var allInFn = frame.allInFn;

        if (timingFunction && timingFunction !== linear) {
          percent = timingFunction(percent);
        } // 同一关键帧同一percent可以不刷新，比如diff为0时，或者steps情况，离开会清空，notSameFrame判断防止pause更新在0的情况


        if (!notSameFrame && frame.lastPercent === percent) {
          return {
            trans: [],
            fixed: []
          };
        }

        frame.lastPercent = percent;
        var currentStyle = target.__currentStyle,
            trans = frame.trans,
            fixed = []; // 特殊性能优化，for拆开v8会提升不少

        if (allInFn) {
          for (var _i23 = 0, _len16 = transition.length; _i23 < _len16; _i23++) {
            var item = transition[_i23];
            var k = item.k,
                v = item.v,
                st = item.st,
                cl = item.cl,
                fn = item.fn; // 可能updateStyle()甚至手动修改了currentStyle，需要重新赋值

            if (currentStyle[k] !== st) {
              currentStyle[k] = st;
            }

            fn(k, v, percent, st, cl, frame, currentStyle);
          }
        } else {
          var currentProps = target.__currentProps;

          var _loop2 = function _loop2(_i24, _len17) {
            var item = transition[_i24];
            var k = item.k,
                v = item.v,
                st = item.st,
                cl = item.cl,
                fn = item.fn;

            if (fn) {
              if (currentStyle[k] !== st) {
                currentStyle[k] = st;
              }

              fn(k, v, percent, st, cl, frame, currentStyle);
            } else if (GEOM$1.hasOwnProperty(k)) {
              var tagName = target.tagName;

              if (GEOM$1[k][tagName] && isFunction$5(GEOM$1[k][tagName].calIncrease)) {
                var _fn = GEOM$1[k][tagName].calIncrease;

                if (target.isMulti) {
                  st = st.map(function (item, i) {
                    return _fn(item, v[i], percent);
                  });
                } else {
                  st = _fn(st, v, percent);
                }
              } else if (target.isMulti) {
                if (k === 'points' || k === 'controls') {
                  for (var _i26 = 0, _len19 = Math.min(st.length, v.length); _i26 < _len19; _i26++) {
                    var o = st[_i26];
                    var n = v[_i26];
                    var cli = cl[_i26];

                    if (!isNil$b(o) && !isNil$b(n)) {
                      for (var j = 0, len2 = Math.min(o.length, n.length); j < len2; j++) {
                        var o2 = o[j];
                        var n2 = n[j];

                        if (!isNil$b(o2) && !isNil$b(n2)) {
                          for (var _k9 = 0, len3 = Math.min(o2.length, n2.length); _k9 < len3; _k9++) {
                            if (!isNil$b(o2[_k9]) && !isNil$b(n2[_k9])) {
                              o2[_k9] = cli[j][_k9] + n2[_k9] * percent;
                            }
                          }
                        }
                      }
                    }
                  }
                } else if (k === 'controlA' || k === 'controlB') {
                  v.forEach(function (item, i) {
                    var st2 = st[i];

                    if (!isNil$b(item[0]) && !isNil$b(st2[0])) {
                      st2[0] = cl[i][0] + item[0] * percent;
                    }

                    if (!isNil$b(item[1]) && !isNil$b(st2[1])) {
                      st2[1] = cl[i][1] + item[1] * percent;
                    }
                  });
                } else {
                  v.forEach(function (item, i) {
                    if (!isNil$b(item) && !isNil$b(st[i])) {
                      st[i] = cl[i] + item * percent;
                    }
                  });
                }
              } else {
                if (k === 'points' || k === 'controls') {
                  for (var _i27 = 0, _len20 = Math.min(st.length, v.length); _i27 < _len20; _i27++) {
                    var _o2 = st[_i27];
                    var _n2 = v[_i27];

                    if (!isNil$b(_o2) && !isNil$b(_n2)) {
                      for (var _j7 = 0, _len21 = Math.min(_o2.length, _n2.length); _j7 < _len21; _j7++) {
                        if (!isNil$b(_o2[_j7]) && !isNil$b(_n2[_j7])) {
                          _o2[_j7] = cl[_i27][_j7] + _n2[_j7] * percent;
                        }
                      }
                    }
                  }
                } else if (k === 'controlA' || k === 'controlB') {
                  if (!isNil$b(st[0]) && !isNil$b(v[0])) {
                    st[0] = cl[0] + v[0] * percent;
                  }

                  if (!isNil$b(st[1]) && !isNil$b(v[1])) {
                    st[1] = cl[1] + v[1] * percent;
                  }
                } else {
                  if (!isNil$b(st) && !isNil$b(v)) {
                    st = cl + v * percent;
                  }
                }
              }

              currentProps[k] = st;
            }
          };

          for (var _i24 = 0, _len17 = transition.length; _i24 < _len17; _i24++) {
            _loop2(_i24, _len17);
          } // string等的直接量，在不同帧之间可能存在变化，同帧变化后不再改变引用，因此前提是发生帧变化
          // 再检查是否和当前相等，防止跳到一个不变化的帧上，而前一帧有变化的情况，大部分都是无变化


          if (notSameFrame) {
            var f = frame.fixed;

            for (var _i25 = 0, _len18 = f.length; _i25 < _len18; _i25++) {
              var _k8 = f[_i25];
              var isGeom = frame.isGeom && GEOM$1.hasOwnProperty(_k8);

              if (!equalStyle$1(_k8, style[_k8], isGeom ? currentProps[_k8] : currentStyle[_k8], target)) {
                if (GEOM$1.hasOwnProperty(_k8)) {
                  currentProps[_k8] = style[_k8];
                } else {
                  currentStyle[_k8] = style[_k8];
                }

                fixed.push(_k8);
              }
            }
          }
        }

        return {
          trans: trans,
          fixed: fixed
        };
      }
    }]);

    return Animation;
  }(Event);

  function getEaseType(ea) {
    var tf = getEasing(ea),
        easeType = EASING.LINEAR;

    if (tf && tf !== easing.linear) {
      if (tf === easing.easeIn) {
        easeType = EASING.EASE_IN;
      } else if (tf === easing.easeOut) {
        easeType = EASING.EASE_OUT;
      } else if (tf === easing.ease) {
        easeType = EASING.EASE;
      } else if (tf === easing.easeInOut) {
        easeType = EASING.EASE_IN_OUT;
      } else {
        easeType = EASING.EASE_CUSTOM;
      }
    }

    return easeType;
  }

  var int2rgba$2 = util.int2rgba;
  var canvasPolygon$3 = painter.canvasPolygon,
      svgPolygon$3 = painter.svgPolygon;

  function renderBoxShadow(xom, renderMode, ctx, data, x1, y1, x2, y2, w, h) {
    var dx = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var dy = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _data = _slicedToArray(data, 6),
        x = _data[0],
        y = _data[1],
        sigma = _data[2],
        spread = _data[3],
        color = _data[4],
        inset = _data[5];

    var c = int2rgba$2(color);
    var n = Math.abs(sigma) * 2 + Math.abs(spread) * 2 + Math.abs(x) * 2 + Math.abs(y) * 2; // box本身坐标顺时针

    var box = [[x1, y1], [x2, y1], [x2, y2], [x1, y2], [x1, y1]]; // 算上各种偏移/扩散的最外层坐标，且逆时针

    var outer = [[x1 - n, y1 - n], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n]];

    if (color[3] > 0) {
      if (renderMode === mode.CANVAS) {
        ctx.save();
        ctx.beginPath(); // inset裁剪box外面

        if (inset === 'inset') {
          var xa = x1 + x + spread;
          var ya = y1 + y + spread;
          var xb = x2 + x - spread;
          var yb = y2 + y - spread;
          var spreadBox = [[xa, ya], [xb, ya], [xb, yb], [xa, yb]]; // 是否相交判断需要绘制

          var cross = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [spreadBox[0][0], spreadBox[0][1], spreadBox[2][0], spreadBox[2][1]]);

          if (!cross) {
            return;
          }

          cross = [[cross[0], cross[1]], [cross[2], cross[1]], [cross[2], cross[3]], [cross[0], cross[3]], [cross[0], cross[1]]]; // 扩散区域类似边框填充

          if (spread) {
            canvasPolygon$3(ctx, cross);
            canvasPolygon$3(ctx, box.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$3(ctx, box);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath();
            canvasPolygon$3(ctx, cross);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma; // 画在外围的空心矩形，宽度要比blur大，n考虑了这一情况取了最大值

            canvasPolygon$3(ctx, [[xa, ya], [xb, ya], [xb, yb], [x1 - n, yb], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, yb], [xa, yb], [xa, ya]]);
          } else {
            canvasPolygon$3(ctx, box);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, [[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]]);
          }
        } // outset需裁减掉box本身的内容，clip()非零环绕显示box外的阴影内容，fill()绘制在内无效
        else {
          var _xa = x1 + x - spread;

          var _ya = y1 + y - spread;

          var _xb = x2 + x + spread;

          var _yb = y2 + y + spread;

          var blurBox = [[_xa, _ya], [_xb, _ya], [_xb, _yb], [_xa, _yb]];

          var _cross = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [blurBox[0][0], blurBox[0][1], blurBox[2][0], blurBox[2][1]]); // 分为是否有spread，因模糊成本spread区域将没有模糊


          if (spread) {
            // 扩散区域类似边框填充
            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, blurBox.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$3(ctx, blurBox);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath(); // 阴影部分看相交情况裁剪，有相交时逆时针绘制相交区域即可排除之

            if (_cross) {
              canvasPolygon$3(ctx, [[_cross[0], _cross[1]], [_cross[2], _cross[1]], [_cross[2], _cross[3]], [_cross[0], _cross[3]], [_cross[0], _cross[1]]].reverse());
            }

            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, blurBox);
            canvasPolygon$3(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, blurBox);
          } else {
            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, box);
          }
        }

        ctx.fill();
        ctx.closePath();
        ctx.restore();
      } else if (renderMode === mode.SVG) {
        var d = blur.outerSize(sigma);

        if (inset === 'inset') {
          var _xa2 = x1 + x + spread;

          var _ya2 = y1 + y + spread;

          var _xb2 = x2 + x - spread;

          var _yb2 = y2 + y - spread;

          var _spreadBox = [[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [_xa2, _yb2]];

          var _cross2 = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_spreadBox[0][0], _spreadBox[0][1], _spreadBox[2][0], _spreadBox[2][1]]);

          if (!_cross2) {
            return;
          }

          _cross2 = [[_cross2[0], _cross2[1]], [_cross2[2], _cross2[1]], [_cross2[2], _cross2[3]], [_cross2[0], _cross2[3]], [_cross2[0], _cross2[1]]];

          if (spread) {
            var v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            xom.__cacheDefs.push(v);

            var filter = ctx.add(v);
            var v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2) + svgPolygon$3(box.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };
            var clip = ctx.add(v2);

            xom.__cacheDefs.push(v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', c], ['clip-path', 'url(#' + clip + ')']]
            });
            v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2)], ['fill', '#FFF']]
              }]
            };
            clip = ctx.add(v);

            xom.__cacheDefs.push(v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [x1 - n, _yb2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, _yb2], [_xa2, _yb2], [_xa2, _ya2]])], ['fill', '#FFF'], ['filter', 'url(#' + filter + ')'], ['clip-path', 'url(#' + clip + ')']]
            });
          } else {
            var _v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter = ctx.add(_v);

            xom.__cacheDefs.push(_v);

            _v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box)], ['fill', '#FFF']]
              }]
            };

            var _clip = ctx.add(_v);

            xom.__cacheDefs.push(_v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]])], ['fill', '#FFF'], ['filter', 'url(#' + _filter + ')'], ['clip-path', 'url(#' + _clip + ')']]
            });
          }
        } else {
          var _xa3 = x1 + x - spread;

          var _ya3 = y1 + y - spread;

          var _xb3 = x2 + x + spread;

          var _yb3 = y2 + y + spread;

          var _blurBox = [[_xa3, _ya3], [_xb3, _ya3], [_xb3, _yb3], [_xa3, _yb3]];

          var _cross3 = geom.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_blurBox[0][0], _blurBox[0][1], _blurBox[2][0], _blurBox[2][1]]);

          if (spread) {
            var _v2 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(_blurBox.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };

            var _clip2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', c], ['clip-path', 'url(#' + _clip2 + ')']]
            });
            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', (_cross3 ? svgPolygon$3([[_cross3[0], _cross3[1]], [_cross3[2], _cross3[1]], [_cross3[2], _cross3[3]], [_cross3[0], _cross3[3]], [_cross3[0], _cross3[1]]].reverse()) : '') + svgPolygon$3(box) + svgPolygon$3(_blurBox) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };
            _clip2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', '#FFF'], ['filter', 'url(#' + _filter2 + ')'], ['clip-path', 'url(#' + _clip2 + ')']]
            });
          } else {
            var _v3 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter3 = ctx.add(_v3);

            xom.__cacheDefs.push(_v3);

            _v3 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };

            var _clip3 = ctx.add(_v3);

            xom.__cacheDefs.push(_v3);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', '#FFF'], ['filter', 'url(#' + _filter3 + ')'], ['clip-path', 'url(#' + _clip3 + ')']]
            });
          }
        }
      }
    }
  }

  var bs = {
    renderBoxShadow: renderBoxShadow
  };

  var hash = {};

  function mbmName$2(v) {
    if (v) {
      if (hash.hasOwnProperty(v)) {
        return hash[v];
      }

      return hash[v] = v.replace(/[A-Z]/, function ($0) {
        return '-' + $0.toLowerCase();
      });
    }
  }

  function isValidMbm$1(v) {
    if (v === 'normal') {
      return false;
    }

    return v === 'multiply' || v === 'screen' || v === 'overlay' || v === 'darken' || v === 'lighten' || v === 'colorDodge' || v === 'color-dodge' || v === 'colorBurn' || v === 'color-burn' || v === 'hardLight' || v === 'hard-light' || v === 'softLight' || v === 'soft-light' || v === 'difference' || v === 'exclusion' || v === 'hue' || v === 'saturation' || v === 'color' || v === 'luminosity';
  }

  var mbm = {
    mbmName: mbmName$2,
    isValidMbm: isValidMbm$1
  };

  var svgPolygon$2 = painter.svgPolygon;
  var CANVAS$1 = mode.CANVAS,
      SVG$1 = mode.SVG,
      WEBGL$1 = mode.WEBGL;
  var normalize = css.normalize,
      equalStyle = css.equalStyle;
  var STYLE_KEY = enums.STYLE_KEY,
      STYLE_RV_KEY = enums.STYLE_RV_KEY,
      style2Upper = enums.style2Upper,
      _enums$STYLE_KEY$8 = enums.STYLE_KEY,
      BORDER_TOP_LEFT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_RIGHT_RADIUS,
      PADDING_LEFT$5 = _enums$STYLE_KEY$8.PADDING_LEFT,
      PADDING_RIGHT$4 = _enums$STYLE_KEY$8.PADDING_RIGHT,
      PADDING_TOP$3 = _enums$STYLE_KEY$8.PADDING_TOP,
      PADDING_BOTTOM$2 = _enums$STYLE_KEY$8.PADDING_BOTTOM,
      MARGIN_LEFT$5 = _enums$STYLE_KEY$8.MARGIN_LEFT,
      MARGIN_TOP$3 = _enums$STYLE_KEY$8.MARGIN_TOP,
      MARGIN_BOTTOM$3 = _enums$STYLE_KEY$8.MARGIN_BOTTOM,
      MARGIN_RIGHT$4 = _enums$STYLE_KEY$8.MARGIN_RIGHT,
      BORDER_LEFT_WIDTH$5 = _enums$STYLE_KEY$8.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH$3 = _enums$STYLE_KEY$8.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$2 = _enums$STYLE_KEY$8.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$4 = _enums$STYLE_KEY$8.BORDER_RIGHT_WIDTH,
      TOP$3 = _enums$STYLE_KEY$8.TOP,
      RIGHT$2 = _enums$STYLE_KEY$8.RIGHT,
      BOTTOM$3 = _enums$STYLE_KEY$8.BOTTOM,
      LEFT$2 = _enums$STYLE_KEY$8.LEFT,
      POSITION$3 = _enums$STYLE_KEY$8.POSITION,
      DISPLAY$6 = _enums$STYLE_KEY$8.DISPLAY,
      WIDTH$5 = _enums$STYLE_KEY$8.WIDTH,
      HEIGHT$5 = _enums$STYLE_KEY$8.HEIGHT,
      MATRIX$1 = _enums$STYLE_KEY$8.MATRIX,
      TRANSLATE_X = _enums$STYLE_KEY$8.TRANSLATE_X,
      TRANSLATE_Y = _enums$STYLE_KEY$8.TRANSLATE_Y,
      TRANSLATE_Z = _enums$STYLE_KEY$8.TRANSLATE_Z,
      TRANSFORM$3 = _enums$STYLE_KEY$8.TRANSFORM,
      SCALE_X = _enums$STYLE_KEY$8.SCALE_X,
      SCALE_Y = _enums$STYLE_KEY$8.SCALE_Y,
      SCALE_Z = _enums$STYLE_KEY$8.SCALE_Z,
      ROTATE_X = _enums$STYLE_KEY$8.ROTATE_X,
      ROTATE_Y = _enums$STYLE_KEY$8.ROTATE_Y,
      ROTATE_Z = _enums$STYLE_KEY$8.ROTATE_Z,
      SKEW_X = _enums$STYLE_KEY$8.SKEW_X,
      SKEW_Y = _enums$STYLE_KEY$8.SKEW_Y,
      PERSPECTIVE$1 = _enums$STYLE_KEY$8.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$1 = _enums$STYLE_KEY$8.PERSPECTIVE_ORIGIN,
      ROTATE_3D = _enums$STYLE_KEY$8.ROTATE_3D,
      TRANSFORM_ORIGIN$2 = _enums$STYLE_KEY$8.TRANSFORM_ORIGIN,
      BACKGROUND_POSITION_X = _enums$STYLE_KEY$8.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y = _enums$STYLE_KEY$8.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE = _enums$STYLE_KEY$8.BACKGROUND_SIZE,
      BACKGROUND_COLOR = _enums$STYLE_KEY$8.BACKGROUND_COLOR,
      BACKGROUND_IMAGE = _enums$STYLE_KEY$8.BACKGROUND_IMAGE,
      BACKGROUND_REPEAT = _enums$STYLE_KEY$8.BACKGROUND_REPEAT,
      BOX_SHADOW = _enums$STYLE_KEY$8.BOX_SHADOW,
      OPACITY$3 = _enums$STYLE_KEY$8.OPACITY,
      Z_INDEX$2 = _enums$STYLE_KEY$8.Z_INDEX,
      BORDER_TOP_STYLE = _enums$STYLE_KEY$8.BORDER_TOP_STYLE,
      BORDER_RIGHT_STYLE = _enums$STYLE_KEY$8.BORDER_RIGHT_STYLE,
      BORDER_BOTTOM_STYLE = _enums$STYLE_KEY$8.BORDER_BOTTOM_STYLE,
      BORDER_LEFT_STYLE = _enums$STYLE_KEY$8.BORDER_LEFT_STYLE,
      FILTER$2 = _enums$STYLE_KEY$8.FILTER,
      OVERFLOW$2 = _enums$STYLE_KEY$8.OVERFLOW,
      MIX_BLEND_MODE$3 = _enums$STYLE_KEY$8.MIX_BLEND_MODE,
      TEXT_OVERFLOW = _enums$STYLE_KEY$8.TEXT_OVERFLOW,
      BORDER_TOP_COLOR = _enums$STYLE_KEY$8.BORDER_TOP_COLOR,
      BORDER_BOTTOM_COLOR = _enums$STYLE_KEY$8.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR = _enums$STYLE_KEY$8.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR = _enums$STYLE_KEY$8.BORDER_RIGHT_COLOR,
      FONT_STYLE = _enums$STYLE_KEY$8.FONT_STYLE,
      COLOR$1 = _enums$STYLE_KEY$8.COLOR,
      VISIBILITY$3 = _enums$STYLE_KEY$8.VISIBILITY,
      POINTER_EVENTS$1 = _enums$STYLE_KEY$8.POINTER_EVENTS,
      BORDER_TOP = _enums$STYLE_KEY$8.BORDER_TOP,
      BORDER_RIGHT = _enums$STYLE_KEY$8.BORDER_RIGHT,
      BORDER_BOTTOM = _enums$STYLE_KEY$8.BORDER_BOTTOM,
      BORDER_LEFT = _enums$STYLE_KEY$8.BORDER_LEFT,
      BACKGROUND_CLIP = _enums$STYLE_KEY$8.BACKGROUND_CLIP,
      FONT_SIZE$3 = _enums$STYLE_KEY$8.FONT_SIZE,
      FONT_FAMILY$1 = _enums$STYLE_KEY$8.FONT_FAMILY,
      LINE_HEIGHT$2 = _enums$STYLE_KEY$8.LINE_HEIGHT,
      TEXT_STROKE_COLOR$1 = _enums$STYLE_KEY$8.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$1 = _enums$STYLE_KEY$8.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$1 = _enums$STYLE_KEY$8.TEXT_STROKE_OVER,
      FONT_WEIGHT$1 = _enums$STYLE_KEY$8.FONT_WEIGHT,
      FLEX_DIRECTION$1 = _enums$STYLE_KEY$8.FLEX_DIRECTION,
      JUSTIFY_CONTENT$1 = _enums$STYLE_KEY$8.JUSTIFY_CONTENT,
      ALIGN_ITEMS$1 = _enums$STYLE_KEY$8.ALIGN_ITEMS,
      ALIGN_SELF$1 = _enums$STYLE_KEY$8.ALIGN_SELF,
      FLEX_GROW$1 = _enums$STYLE_KEY$8.FLEX_GROW,
      FLEX_SHRINK$1 = _enums$STYLE_KEY$8.FLEX_SHRINK,
      LINE_CLAMP$1 = _enums$STYLE_KEY$8.LINE_CLAMP,
      ORDER$1 = _enums$STYLE_KEY$8.ORDER,
      FLEX_WRAP$1 = _enums$STYLE_KEY$8.FLEX_WRAP,
      ALIGN_CONTENT$1 = _enums$STYLE_KEY$8.ALIGN_CONTENT,
      TEXT_ALIGN$1 = _enums$STYLE_KEY$8.TEXT_ALIGN,
      LETTER_SPACING = _enums$STYLE_KEY$8.LETTER_SPACING,
      WHITE_SPACE$1 = _enums$STYLE_KEY$8.WHITE_SPACE,
      WRITING_MODE$2 = _enums$STYLE_KEY$8.WRITING_MODE,
      TRANSFORM_STYLE$1 = _enums$STYLE_KEY$8.TRANSFORM_STYLE,
      BACKFACE_VISIBILITY$1 = _enums$STYLE_KEY$8.BACKFACE_VISIBILITY,
      BOX_SIZING = _enums$STYLE_KEY$8.BOX_SIZING,
      FONT_SIZE_SHRINK = _enums$STYLE_KEY$8.FONT_SIZE_SHRINK,
      WASM_STYLE_KEY = enums.WASM_STYLE_KEY;
  var AUTO$4 = o$4.AUTO,
      PX$5 = o$4.PX,
      PERCENT$4 = o$4.PERCENT,
      INHERIT$1 = o$4.INHERIT,
      NUMBER$1 = o$4.NUMBER,
      RGBA$1 = o$4.RGBA,
      STRING = o$4.STRING,
      REM$4 = o$4.REM,
      VW$4 = o$4.VW,
      VH$4 = o$4.VH,
      VMAX$4 = o$4.VMAX,
      VMIN$4 = o$4.VMIN,
      DEG = o$4.DEG,
      GRADIENT$1 = o$4.GRADIENT;
  var int2rgba$1 = util.int2rgba,
      rgba2int = util.rgba2int,
      joinArr$1 = util.joinArr,
      isNil$a = util.isNil,
      isFunction$4 = util.isFunction;
  var calRelative = css.calRelative,
      calNormalLineHeight = css.calNormalLineHeight,
      calFontFamily = css.calFontFamily,
      spreadBoxShadow = css.spreadBoxShadow,
      spreadFilter$1 = css.spreadFilter;
  var GEOM = o$2.GEOM;
  var mbmName$1 = mbm.mbmName,
      isValidMbm = mbm.isValidMbm;
  var point2d = matrix.point2d,
      toE = matrix.toE,
      identity = matrix.identity,
      assignMatrix$2 = matrix.assignMatrix,
      multiply$2 = matrix.multiply,
      multiplyRotateX = matrix.multiplyRotateX,
      multiplyRotateY = matrix.multiplyRotateY,
      multiplyRotateZ = matrix.multiplyRotateZ,
      multiplySkewX = matrix.multiplySkewX,
      multiplySkewY = matrix.multiplySkewY,
      multiplyScaleX = matrix.multiplyScaleX,
      multiplyScaleY = matrix.multiplyScaleY,
      multiplyScaleZ = matrix.multiplyScaleZ;
  var TF$1 = o$1.TRANSFORM,
      REFLOW$3 = o$1.REFLOW,
      REPAINT$3 = o$1.REPAINT,
      TX = o$1.TRANSLATE_X,
      TY = o$1.TRANSLATE_Y,
      TZ = o$1.TRANSLATE_Z,
      RZ = o$1.ROTATE_Z,
      SX = o$1.SCALE_X,
      SY = o$1.SCALE_Y,
      SZ = o$1.SCALE_Z,
      SCALE = o$1.SCALE,
      TRANSFORM_ALL$3 = o$1.TRANSFORM_ALL,
      CACHE$3 = o$1.CACHE,
      MASK$2 = o$1.MASK;
  var d2r = geom.d2r;
  var calRotateX = transform$1.calRotateX,
      calRotateY = transform$1.calRotateY,
      calRotateZ = transform$1.calRotateZ,
      calRotate3d = transform$1.calRotate3d;

  function getFirstEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = 0; i < length; i++) {
      var child = flowChildren[i];

      if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getFirstEmptyInlineWidth(child);
          break;
        } else if (child.__isInline) {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  function getLastEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = length - 1; i >= 0; i--) {
      var child = flowChildren[i];

      if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getLastEmptyInlineWidth(child);
          break;
        } else {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  var Xom = /*#__PURE__*/function (_Node) {
    _inherits(Xom, _Node);

    function Xom(tagName) {
      var _this;

      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _this = _Node.call(this) || this; // 构建工具中都是arr，手写可能出现hash情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__tagName = tagName;
      _this.__style = _this.props.style || {}; // style被解析后的k-v形式

      _this.__currentStyle = []; // 动画过程中绘制一开始会merge动画样式

      _this.__computedStyle = []; // 类似getComputedStyle()将currentStyle计算好数值赋给

      _this.__listener = {};
      Object.keys(_this.props).forEach(function (k) {
        var v = _this.props[k];

        if (/^on[a-zA-Z]/.test(k)) {
          k = k.slice(2).toLowerCase();

          _this.addEventListener(k, v);
        }
      });
      _this.__animationList = [];
      _this.__loadBgi = {
        // 刷新回调函数，用以destroy取消用
        cb: function cb() {}
      };
      _this.__cacheStyle = []; // 是否缓存重新计算computedStyle的样式key

      _this.__cacheDefs = []; // svg专用，缓存渲染时使用已有的defs，diff过程用，否则会defs被清空

      var isClip = _this.__clip = !!_this.props.clip;
      _this.__mask = isClip || !!_this.props.mask;
      _this.__refreshLevel = REFLOW$3;
      _this.__limitCache = false;
      _this.__isInline = false;
      _this.__hasContent = false;
      _this.__opacity = 1;
      _this.__matrix = identity();
      _this.__matrixEvent = identity();
      _this.__perspectiveMatrix = identity();
      _this.__selfPerspectiveMatrix = identity();
      _this.__frameAnimateList = [];
      _this.__contentBoxList = []; // inline存储内容用

      _this.__cacheAsBitmap = !!_this.props.cacheAsBitmap;
      _this.__cacheTotal = _this.__cacheFilter = _this.__cacheMask = null;
      _this.__layoutData = null; // 缓存上次布局x/y/w/h数据

      _this.__hasComputeReflow = false; // 每次布局计算缓存标，使得每次开始只computeReflow一次

      _this.__parentLineBox = null; // inline时指向

      _this.__fontRegister = {}; // 优先级字体尚未加载时记录回调hash，销毁时删除回调

      _this.__firstInit = true; // 标识是否第一次创建，布局后置false

      return _this;
    }

    _createClass(Xom, [{
      key: "__structure",
      value: function __structure(lv, j) {
        var res = _get(_getPrototypeOf(Xom.prototype), "__structure", this).call(this, lv, j);

        if (this.__hasMask) {
          res.hasMask = this.__hasMask;
        }

        return res;
      } // 设置margin/padding的实际值，layout时执行，inline的垂直方向仍然计算值，但在布局时被忽略

    }, {
      key: "__mp",
      value: function __mp(currentStyle, computedStyle, w) {
        var _this2 = this;

        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          var a = STYLE_KEY[style2Upper('margin' + k)];
          var b = STYLE_KEY[style2Upper('padding' + k)];
          computedStyle[a] = _this2.__calSize(currentStyle[a], w, true);
          computedStyle[b] = _this2.__calSize(currentStyle[b], w, true);
        });
      }
    }, {
      key: "__calSize",
      value: function __calSize(v, w, includePercent) {
        if (v.u === PX$5) {
          return v.v;
        } else if (v.u === PERCENT$4) {
          if (includePercent) {
            return v.v * w * 0.01;
          }
        } else if (v.u === REM$4) {
          return v.v * this.__root.computedStyle[FONT_SIZE$3];
        } else if (v.u === VW$4) {
          return v.v * this.__root.width * 0.01;
        } else if (v.u === VH$4) {
          return v.v * this.__root.height * 0.01;
        } else if (v.u === VMAX$4) {
          return v.v * Math.max(this.__root.width, this.__root.height) * 0.01;
        } else if (v.u === VMIN$4) {
          return v.v * Math.min(this.__root.width, this.__root.height) * 0.01;
        }

        return 0;
      }
    }, {
      key: "__computeReflow",
      value: function __computeReflow() {
        var _this3 = this;

        if (this.__hasComputeReflow) {
          return;
        }

        this.__hasComputeReflow = true;
        var currentStyle = this.__currentStyle,
            computedStyle = this.__computedStyle,
            parent = this.__domParent;
        var isRoot = !parent;
        var parentComputedStyle = parent && parent.__computedStyle; // 继承的特殊处理，根节点用默认值

        [FONT_SIZE$3, FONT_FAMILY$1, FONT_WEIGHT$1, WRITING_MODE$2, FONT_SIZE_SHRINK].forEach(function (k) {
          var v = currentStyle[k]; // ff特殊处理

          if (k === FONT_FAMILY$1) {
            if (v.u === INHERIT$1) {
              computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : parentComputedStyle[k];
            } else {
              computedStyle[k] = v.v;
              var ff = v.v.split(/\s*,\s*/); // 从左到右即声明的字体优先级

              for (var i = 0, len = ff.length; i < len; i++) {
                var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

                if (o$3.hasRegister(item)) {
                  // 如果已经注册加载了，或者注册且本地支持的，说明可用
                  if (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item)) {
                    break;
                  }
                } // 不可用的都特殊记住等待注册回调__loadFontCallback


                _this3.__fontRegister[item] = true;
                o$3.onRegister(item, _this3);
              }
            }
          } else if (v.u === INHERIT$1) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : parentComputedStyle[k];
          } // fontSize和shrinkFontSize会有%
          else if (v.u === PERCENT$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.computedStyle[FONT_SIZE$3] * v.v * 0.01;
          } else if (v.u === REM$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.computedStyle[FONT_SIZE$3] * v.v;
          } else if (v.u === VW$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.width * 0.01 * v.v;
          } else if (v.u === VH$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.height * 0.01 * v.v;
          } else if (v.u === VMAX$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : Math.max(_this3.root.width, _this3.root.height) * 0.01 * v.v;
          } else if (v.u === VMIN$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : Math.min(_this3.root.width, _this3.root.height) * 0.01 * v.v;
          } else {
            computedStyle[k] = v.v;
          }
        });
        [BORDER_TOP_WIDTH$3, BORDER_RIGHT_WIDTH$4, BORDER_BOTTOM_WIDTH$2, BORDER_LEFT_WIDTH$5].forEach(function (k) {
          // border-width不支持百分比
          var item = currentStyle[k];
          computedStyle[k] = _this3.__calSize(item, 0, false);
        });
        [POSITION$3, DISPLAY$6, BOX_SIZING, FLEX_DIRECTION$1, JUSTIFY_CONTENT$1, ALIGN_ITEMS$1, ALIGN_SELF$1, FLEX_GROW$1, FLEX_SHRINK$1, LINE_CLAMP$1, ORDER$1, FLEX_WRAP$1, ALIGN_CONTENT$1, OVERFLOW$2, TEXT_OVERFLOW].forEach(function (k) {
          computedStyle[k] = currentStyle[k];
        }); // writingMode特殊判断inline

        if (parentComputedStyle && computedStyle[WRITING_MODE$2] !== parentComputedStyle[WRITING_MODE$2] && computedStyle[DISPLAY$6] === 'inline') {
          computedStyle[DISPLAY$6] = 'inlineBlock';
        } // 匿名块对象


        if (computedStyle[POSITION$3] === 'absolute' || parentComputedStyle && parentComputedStyle[DISPLAY$6] === 'flex') {
          if (['block', 'flex'].indexOf(computedStyle[DISPLAY$6]) === -1) {
            computedStyle[DISPLAY$6] = 'block';
          }
        }

        var textAlign = currentStyle[TEXT_ALIGN$1];

        if (textAlign.u === INHERIT$1) {
          computedStyle[TEXT_ALIGN$1] = isRoot ? 'left' : parentComputedStyle[TEXT_ALIGN$1];
        } else {
          computedStyle[TEXT_ALIGN$1] = textAlign.v;
        }

        var fontSize = computedStyle[FONT_SIZE$3];
        var lineHeight = currentStyle[LINE_HEIGHT$2]; // lineHeight继承很特殊，数字和normal不同于普通单位

        if (lineHeight.u === INHERIT$1) {
          if (isRoot) {
            computedStyle[LINE_HEIGHT$2] = calNormalLineHeight(computedStyle);
          } else {
            var p = parent;
            var ph;

            while (p) {
              ph = p.currentStyle[LINE_HEIGHT$2];

              if (ph.u !== INHERIT$1) {
                break;
              }

              p = p.domParent;
            } // 到root还是inherit或normal，或者中途遇到了normal，使用normal


            if ([AUTO$4, INHERIT$1].indexOf(ph.u) > -1) {
              computedStyle[LINE_HEIGHT$2] = calNormalLineHeight(computedStyle);
            } // 数字继承
            else if (ph.u === NUMBER$1) {
              computedStyle[LINE_HEIGHT$2] = Math.max(ph.v, 0) * fontSize;
            } // 单位继承
            else {
              computedStyle[LINE_HEIGHT$2] = parentComputedStyle[LINE_HEIGHT$2];
            }
          }
        } else if (lineHeight.u === NUMBER$1) {
          computedStyle[LINE_HEIGHT$2] = Math.max(lineHeight.v, 0) * fontSize || calNormalLineHeight(computedStyle);
        } // 防止为0
        else {
          var v = Math.max(this.__calSize(lineHeight, fontSize, true), 0);
          computedStyle[LINE_HEIGHT$2] = v || calNormalLineHeight(computedStyle);
        }

        var letterSpacing = currentStyle[LETTER_SPACING];

        if (letterSpacing.u === INHERIT$1) {
          computedStyle[LETTER_SPACING] = isRoot ? 0 : parentComputedStyle[LETTER_SPACING];
        } else {
          computedStyle[LETTER_SPACING] = this.__calSize(letterSpacing, fontSize, true);
        } //whiteSpace


        var whiteSpace = currentStyle[WHITE_SPACE$1];

        if (whiteSpace.u === INHERIT$1) {
          computedStyle[WHITE_SPACE$1] = isRoot ? 'normal' : parentComputedStyle[WHITE_SPACE$1];
        } else {
          computedStyle[WHITE_SPACE$1] = whiteSpace.v;
        }

        var width = currentStyle[WIDTH$5],
            height = currentStyle[HEIGHT$5];
        this.__width = this.__height = 0; // 布局前固定尺寸的先设置好，子元素percent尺寸要用到，flex的子元素侧轴stretch也要特殊提前处理，认为定高

        if (width.u !== AUTO$4) {
          this.__width = computedStyle[WIDTH$5] = this.__calSize(width, isRoot ? this.__width : parent.__width, true);
        }

        if (height.u !== AUTO$4) {
          this.__height = computedStyle[HEIGHT$5] = this.__calSize(height, isRoot ? this.__height : parent.__height, true);
        } else {
          var p = this.__domParent;

          if (p) {
            var crs = p.__currentStyle;
            var alignSelf = currentStyle[ALIGN_SELF$1]; // flex的子元素stretch提前处理认为有高度，以便其子元素%高度计算

            if (crs[DISPLAY$6] === 'flex' && p.__height) {
              if (crs[FLEX_DIRECTION$1].indexOf('row') > -1 && (alignSelf === 'stretch' || crs[ALIGN_ITEMS$1] === 'stretch' && alignSelf === 'auto')) {
                this.__height = p.__height;
              }
            }
          }
        }
      }
    }, {
      key: "__emitFontRegister",
      value: function __emitFontRegister(fontFamily) {
        var node = this,
            fontRegister = node.__fontRegister;

        if (node.__isDestroyed) {
          return;
        }

        delete fontRegister[fontFamily];
        var root = node.root,
            currentStyle = node.currentStyle;

        if (!root) {
          return;
        }

        var v = currentStyle[FONT_FAMILY$1];

        if (v.u === INHERIT$1) {
          return;
        }

        var ff = v.v.split(/\s*,\s*/);

        for (var i = 0, len = ff.length; i < len; i++) {
          var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

          if (item === fontFamily) {
            // 加载成功回调可能没注册信息，需要多判断一下
            if (o$3.hasRegister(item)) {
              root.__addUpdate(node, null, REFLOW$3, false, false, false, false, null);
            } // 后面低优先级的无需再看


            return;
          } // 有更高优先级的已经支持了，回调刷新无效
          else if (o$3.hasRegister(item) && (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item))) {
            return;
          }
        }
      } // dom常用的几种尺寸赋值

    }, {
      key: "__ioSize",
      value: function __ioSize(w, h) {
        var computedStyle = this.__computedStyle; // 可能不传，在虚拟布局时用不到

        if (!isNil$a(w)) {
          this.__width = computedStyle[WIDTH$5] = w;
          this.__clientWidth = w += computedStyle[PADDING_LEFT$5] + computedStyle[PADDING_RIGHT$4];
          this.__offsetWidth = w += computedStyle[BORDER_LEFT_WIDTH$5] + computedStyle[BORDER_RIGHT_WIDTH$4];
          this.__outerWidth = w + computedStyle[MARGIN_LEFT$5] + computedStyle[MARGIN_RIGHT$4];
        }

        if (!isNil$a(h)) {
          this.__height = computedStyle[HEIGHT$5] = h;
          this.__clientHeight = h += computedStyle[PADDING_TOP$3] + computedStyle[PADDING_BOTTOM$2];
          this.__offsetHeight = h += computedStyle[BORDER_TOP_WIDTH$3] + computedStyle[BORDER_BOTTOM_WIDTH$2];
          this.__outerHeight = h + computedStyle[MARGIN_TOP$3] + computedStyle[MARGIN_BOTTOM$3];
        }
      } // 为basis的b/min/max添加mpb，只有当b未显示指定等于w/content时才加，同时返回mpb值

    }, {
      key: "__addMBP",
      value: function __addMBP(isDirectionRow, w, currentStyle, computedStyle, res, isDirectItem) {
        var marginLeft = currentStyle[MARGIN_LEFT$5],
            marginTop = currentStyle[MARGIN_TOP$3],
            marginRight = currentStyle[MARGIN_RIGHT$4],
            marginBottom = currentStyle[MARGIN_BOTTOM$3],
            paddingLeft = currentStyle[PADDING_LEFT$5],
            paddingTop = currentStyle[PADDING_TOP$3],
            paddingRight = currentStyle[PADDING_RIGHT$4],
            paddingBottom = currentStyle[PADDING_BOTTOM$2],
            boxSizing = currentStyle[BOX_SIZING];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5];

        if (isDirectionRow) {
          var m = this.__calSize(marginLeft, w, isDirectItem) + this.__calSize(marginRight, w, isDirectItem);

          var bp = 0;

          if (isDirectItem || boxSizing === 'contentBox') {
            bp = this.__calSize(paddingLeft, w, isDirectItem) + this.__calSize(paddingRight, w, isDirectItem) + borderLeftWidth + borderRightWidth;
          }

          res = res.map(function (item) {
            return item + m + bp;
          });
        } else {
          var _m = this.__calSize(marginTop, w, isDirectItem) + this.__calSize(marginBottom, w, isDirectItem);

          var _bp = 0;

          if (isDirectItem || boxSizing === 'contentBox') {
            _bp = this.__calSize(paddingTop, w, isDirectItem) + this.__calSize(paddingBottom, w, isDirectItem) + borderTopWidth + borderBottomWidth;
          }

          res = res.map(function (item) {
            return item + _m + _bp;
          });
        }

        return res;
      }
    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        this.__layoutFlow(data, isAbs, isColumn, isRow);
      } // absolute且无尺寸时，isAbs标明先假布局一次计算尺寸，还有flex列计算时isColumn假布局，flex横计算时writingMode垂直假布局

    }, {
      key: "__layoutFlow",
      value: function __layoutFlow(data, isAbs, isColumn, isRow) {
        this.__computeReflow();

        var __isDestroyed = this.__isDestroyed,
            __currentStyle = this.__currentStyle,
            __computedStyle = this.__computedStyle,
            __ellipsis = this.__ellipsis; // 虚拟省略号每次清除

        if (__ellipsis) {
          this.__ellipsis = null;
        }

        this.__parentLineBox = null;
        this.__isIbFull = this.__isUprightIbFull = false;
        var display = __computedStyle[DISPLAY$6],
            position = __computedStyle[POSITION$3];
        this.__layoutData = {
          x: data.x,
          y: data.y,
          w: data.w,
          h: data.h,
          lx: data.lx,
          ly: data.ly,
          isUpright: data.isUpright,
          // 从Root开始，父级的书写模式需每层传递
          container: data.container
        }; // 防止display:none不统计mask，isVirtual忽略，abs/flex布局后续会真正来走一遍

        if (!isAbs && !isColumn && !isRow) {
          this.clearCache();
          this.__cacheStyle = [];
          this.__refreshLevel = REFLOW$3;
          this.__limitCache = false;
          this.__isInline = false;
          var next = this.next; // mask关系只有布局才会变更，普通渲染关系不会改变，clip也是mask的一种

          if (!this.__mask && next && next.__mask) {
            var count = 0;

            while (next) {
              if (next.__mask) {
                count++;
              } else {
                break;
              }

              next = next.next;
            }

            this.__hasMask = count; // appendChild一个parse好的节点引用对象，会先生成struct，此时遗漏hasMask

            if (this.__struct) {
              this.__struct.hasMask = count;
            }
          }
        }

        if (__isDestroyed || display === 'none') {
          this.__x = data.x;
          this.__y = data.y;

          this.__layoutNone();

          this.__hasComputeReflow = false;
          return;
        } // absolute特殊，在自己布局时已计算相对于容器的mbp


        if (position !== 'absolute') {
          this.__mp(__currentStyle, __computedStyle, data.w);
        } // 只有inline会继承计算行数，其它都是原样返回


        var lineClampCount = data.lineClampCount || 0; // 4种布局，默认block，inlineBlock基本可以复用inline逻辑，除了尺寸

        if (display === 'flex') {
          data.lineClampCount = 0;

          this.__layoutFlex(data, isAbs, isColumn, isRow);
        } else if (display === 'inlineBlock') {
          data.lineClampCount = 0;

          this.__layoutInline(data, isAbs, isColumn, isRow);
        } else if (display === 'inline') {
          lineClampCount = this.__layoutInline(data, isAbs, isColumn, isRow, true);
        } else {
          data.lineClampCount = 0;

          this.__layoutBlock(data, isAbs, isColumn, isRow);
        } // 非虚拟布局才执行，防止重复


        if (!isAbs && !isColumn && !isRow) {
          // 计算结果存入computedStyle和6个坐标，inline在其inlineSize特殊处理
          var x = this.__x;
          var y = this.__y;

          if (!this.__isInline) {
            x = this.__x1 = x + __computedStyle[MARGIN_LEFT$5];
            x = this.__x2 = x + __computedStyle[BORDER_LEFT_WIDTH$5];
            x = this.__x3 = x + __computedStyle[PADDING_LEFT$5];
            x = this.__x4 = x + this.__width;
            x = this.__x5 = x + __computedStyle[PADDING_RIGHT$4];
            this.__x6 = x + __computedStyle[BORDER_RIGHT_WIDTH$4];
            y = this.__y1 = y + __computedStyle[MARGIN_TOP$3];
            y = this.__y2 = y + __computedStyle[BORDER_TOP_WIDTH$3];
            y = this.__y3 = y + __computedStyle[PADDING_TOP$3];
            y = this.__y4 = y + this.__height;
            y = this.__y5 = y + __computedStyle[PADDING_BOTTOM$2];
            this.__y6 = y + __computedStyle[BORDER_BOTTOM_WIDTH$2];
          } // relative渲染时做偏移，百分比基于父元素，若父元素没有定高则为0


          if (position === 'relative') {
            var top = __currentStyle[TOP$3],
                right = __currentStyle[RIGHT$2],
                bottom = __currentStyle[BOTTOM$3],
                left = __currentStyle[LEFT$2];
            var parent = this.parent;

            if (top.u !== AUTO$4) {
              var n = calRelative(__currentStyle, TOP$3, top, parent);

              if (n) {
                this.__offsetY(n, true, null);

                if (this.__isInline) {
                  var list = this.__contentBoxList;

                  if (Array.isArray(list)) {
                    var last;
                    list.forEach(function (item) {
                      var p = item.__parentLineBox;

                      if (p && p !== last) {
                        p.__oy += n;
                      }

                      last = p;
                    });
                  }
                }
              }

              __computedStyle[TOP$3] = n;
              __computedStyle[BOTTOM$3] = 'auto';
            } else if (bottom.u !== AUTO$4) {
              var _n = calRelative(__currentStyle, BOTTOM$3, bottom, parent);

              if (_n) {
                this.__offsetY(-_n, true, null);

                if (this.__isInline) {
                  var _list = this.__contentBoxList;

                  if (Array.isArray(_list)) {
                    var _last;

                    _list.forEach(function (item) {
                      var p = item.__parentLineBox;

                      if (p && p !== _last) {
                        p.__oy -= _n;
                      }

                      _last = p;
                    });
                  }
                }
              }

              __computedStyle[BOTTOM$3] = _n;
              __computedStyle[TOP$3] = 'auto';
            } else {
              __computedStyle[TOP$3] = __computedStyle[BOTTOM$3] = 'auto';
            }

            if (left.u !== AUTO$4) {
              var _n2 = calRelative(__currentStyle, LEFT$2, left, parent, true);

              if (_n2) {
                this.__offsetX(_n2, true, null);
              }

              __computedStyle[LEFT$2] = _n2;
              __computedStyle[RIGHT$2] = 'auto';
            } else if (right.u !== AUTO$4) {
              var _n3 = calRelative(__currentStyle, RIGHT$2, right, parent, true);

              if (_n3) {
                this.__offsetX(-_n3, true, null);
              }

              __computedStyle[RIGHT$2] = _n3;
              __computedStyle[LEFT$2] = 'auto';
            } else {
              __computedStyle[LEFT$2] = __computedStyle[RIGHT$2] = 'auto';
            }
          } else if (position !== 'absolute') {
            __computedStyle[TOP$3] = __computedStyle[BOTTOM$3] = __computedStyle[LEFT$2] = __computedStyle[RIGHT$2] = 'auto';
          }

          __computedStyle[WIDTH$5] = this.__width;
          __computedStyle[HEIGHT$5] = this.__height; // abs为parse的根节点时特殊自己执行，前提是真布局

          if (position !== 'absolute' && this.__animateRecords) {
            this.__root.__addAr(this);
          }

          this.__hasComputeReflow = false;
        }

        return lineClampCount;
      }
    }, {
      key: "__layoutStyle",
      value: function __layoutStyle() {
        var currentStyle = this.__currentStyle;
        var computedStyle = this.__computedStyle;
        var cacheStyle = this.__cacheStyle;

        this.__calStyle(REFLOW$3, currentStyle, computedStyle, cacheStyle);

        this.__calPerspective(currentStyle, computedStyle, cacheStyle); // 每次reflow传数据到wasm


        this.__wasmStyle(currentStyle);
      } // 传递transform/opacity相关样式到wasm中计算

    }, {
      key: "__wasmStyle",
      value: function __wasmStyle(currentStyle) {
        var wn = this.__wasmNode;

        if (wn) {
          // 第一次布局时全部传入，后续由updateStyle更新wasm数据，transform/opacity相关不能再用初始赋值会错
          if (this.__firstInit) {
            this.__firstInit = false;
            wn.set_style(this.__x1, this.__y1, this.__offsetWidth, this.__offsetHeight, currentStyle[TRANSLATE_X].v, currentStyle[TRANSLATE_Y].v, currentStyle[TRANSLATE_Z].v, currentStyle[ROTATE_X].v, currentStyle[ROTATE_Y].v, currentStyle[ROTATE_Z].v, currentStyle[ROTATE_3D][0], currentStyle[ROTATE_3D][1], currentStyle[ROTATE_3D][2], currentStyle[ROTATE_3D][3].v, currentStyle[SCALE_X].v, currentStyle[SCALE_Y].v, currentStyle[SCALE_Z].v, currentStyle[SKEW_X].v, currentStyle[SKEW_Y].v, currentStyle[OPACITY$3], currentStyle[TRANSFORM_ORIGIN$2][0].v, currentStyle[TRANSFORM_ORIGIN$2][1].v, currentStyle[TRANSLATE_X].u, currentStyle[TRANSLATE_Y].u, currentStyle[TRANSLATE_Z].u, currentStyle[TRANSFORM_ORIGIN$2][0].u, currentStyle[TRANSFORM_ORIGIN$2][1].u);
          } else {
            wn.set_xywh(this.__x1, this.__y1, this.__offsetWidth, this.__offsetHeight);
          }
        }
      }
    }, {
      key: "__execAr",
      value: function __execAr() {
        // 动态json引用时动画暂存，第一次布局时处理这些动画到root的animateController上
        var ar = this.__animateRecords;

        if (ar) {
          this.__animateRecords = null; // parse没有dom时，animate的target引用都是json，vd后生成需重新赋值

          ar.list.forEach(function (item) {
            if (item.target.vd instanceof Xom) {
              item.target = item.target.vd;
            }
          });
          var ac = ar.controller || this.__root.animateController; // 不自动播放进入记录列表，初始化并等待手动调用

          if (ar.options && ar.options.autoPlay === false) {
            ac.__records2 = ac.__records2.concat(ar.list);
            ac.init(ac.__records2, ac.list2);
          } else {
            ac.__records = ac.__records.concat(ar.list);

            ac.__playAuto();
          }
        }
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        this.__computeReflow();

        var __computedStyle = this.__computedStyle;
        __computedStyle[DISPLAY$6] = 'none';

        this.__reset0();

        this.__hasComputeReflow = false;
      }
    }, {
      key: "__reset0",
      value: function __reset0() {
        var __computedStyle = this.__computedStyle;
        __computedStyle[MARGIN_TOP$3] = __computedStyle[MARGIN_RIGHT$4] = __computedStyle[MARGIN_BOTTOM$3] = __computedStyle[MARGIN_LEFT$5] = __computedStyle[BORDER_TOP_WIDTH$3] = __computedStyle[BORDER_RIGHT_WIDTH$4] = __computedStyle[BORDER_BOTTOM_WIDTH$2] = __computedStyle[BORDER_LEFT_WIDTH$5] = __computedStyle[PADDING_TOP$3] = __computedStyle[PADDING_RIGHT$4] = __computedStyle[PADDING_BOTTOM$2] = __computedStyle[PADDING_LEFT$5] = __computedStyle[WIDTH$5] = __computedStyle[HEIGHT$5] = this.__width = this.__height = this.__clientWidth = this.__clientHeight = this.__offsetWidth = this.__offsetHeight = this.__outerWidth = this.__outerHeight = 0;
      } // 预先计算是否是固定宽高，布局点位和尺寸考虑margin/border/padding

    }, {
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            w2 = data.w2,
            h2 = data.h2,
            w3 = data.w3,
            h3 = data.h3,
            lx = data.lx,
            ly = data.ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            isParentVertical = data.isUpright,
            container = data.container;
        this.__x = x;
        this.__y = y;
        var currentStyle = this.__currentStyle,
            computedStyle = this.__computedStyle;
        var width = currentStyle[WIDTH$5],
            height = currentStyle[HEIGHT$5];
        var position = computedStyle[POSITION$3];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            marginTop = computedStyle[MARGIN_TOP$3],
            marginRight = computedStyle[MARGIN_RIGHT$4],
            marginBottom = computedStyle[MARGIN_BOTTOM$3],
            marginLeft = computedStyle[MARGIN_LEFT$5],
            paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$4],
            paddingBottom = computedStyle[PADDING_BOTTOM$2],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            writingMode = computedStyle[WRITING_MODE$2],
            boxSizing = computedStyle[BOX_SIZING];
        var isUpright = writingMode.indexOf('vertical') === 0; // 除了auto外都是固定宽高度

        var fixedWidth;
        var fixedHeight; // 绝对定位是left+right这种其实等于定义了width，但不能修改原始style，存入特殊变量标识

        if (w2 !== undefined) {
          fixedWidth = true;
          w = w2;
        } // flex时也会用到，子级得出目标主尺寸后按这个来
        else if (w3 !== undefined) {
          fixedWidth = true;
          w = w3;
        } else if (width.u !== AUTO$4 && !isInline) {
          fixedWidth = true; // abs的百分比尺寸相对于container

          if (position === 'absolute' && width.u === PERCENT$4) {
            w = this.__calSize(width, container.__clientWidth, true);
          } else {
            w = this.__calSize(width, w, true);

            if (boxSizing === 'borderBox') {
              w -= borderLeftWidth + borderRightWidth + paddingLeft + paddingRight;
            }
          }
        }

        if (h2 !== undefined) {
          fixedHeight = true;
          h = h2;
        } else if (h3 !== undefined) {
          fixedHeight = true;
          h = h3;
        } // height的百分比需要parent有值不能auto，或者parent的flex定高且侧轴stretch时；abs的百分比相对于container
        else if (height.u !== AUTO$4 && !isInline) {
          if (position === 'absolute' && height.u === PERCENT$4) {
            h = this.__calSize(height, container.__clientHeight, true);
          } else {
            var p = this.__domParent;

            if (height.u === PERCENT$4) {
              // 一般都是0，除了定高，或者flex的stretch
              if (p.height) {
                fixedHeight = true;
                h = this.__calSize(height, p.height || 0, true);
              }
            } else {
              fixedHeight = true;
              h = this.__calSize(height, h, true);
            }

            if (boxSizing === 'borderBox') {
              h -= borderTopWidth + borderBottomWidth + paddingTop + paddingBottom;
            }
          }
        } // margin/border/padding影响x和y和尺寸，注意inline的y不受mpb影响（垂直模式则是x）


        if (!isInline) {
          x += borderLeftWidth + marginLeft + paddingLeft;
          y += borderTopWidth + marginTop + paddingTop;
        } else {
          if (isUpright) {
            y += borderTopWidth + marginTop + paddingTop;
          } else {
            x += borderLeftWidth + marginLeft + paddingLeft;
          }
        }

        data.x = x;
        data.y = y; // inline的w/h很特殊，需不考虑inline自身水平的mpb以便换行，因为mpb只在首尾行生效，所以首尾需特殊处理中间忽略
        // 当嵌套inline时更加复杂，假如inline有尾部mpb，最后一行需考虑，如果此inline是父的最后一个且父有mpb需叠加

        var selfEndSpace = 0;

        if (isInline) {
          if (isUpright) {
            selfEndSpace = paddingBottom + borderBottomWidth + marginBottom;
          } else {
            selfEndSpace = paddingRight + borderRightWidth + marginRight;
          }
        } // 传入w3/h3时，flex的item已知目标主尺寸，需减去mbp，其一定是block，和inline互斥
        else {
          if (width.u === AUTO$4 || w3 !== undefined) {
            w -= borderLeftWidth + borderRightWidth + marginLeft + marginRight + paddingLeft + paddingRight;
          }

          if (height.u === AUTO$4 || h3 !== undefined) {
            h -= borderTopWidth + borderBottomWidth + marginTop + marginBottom + paddingTop + paddingBottom;
          }
        }

        return {
          fixedWidth: fixedWidth,
          fixedHeight: fixedHeight,
          x: x,
          y: y,
          w: w,
          h: h,
          lx: lx,
          ly: ly,
          lineBoxManager: lineBoxManager,
          endSpace: endSpace,
          selfEndSpace: selfEndSpace,
          isParentVertical: isParentVertical,
          isUpright: isUpright
        };
      } // 处理margin:xx auto居中对齐或右对齐

    }, {
      key: "__marginAuto",
      value: function __marginAuto(style, data, isUpright) {
        var position = style[POSITION$3],
            display = style[DISPLAY$6],
            marginTop = style[MARGIN_TOP$3],
            marginBottom = style[MARGIN_BOTTOM$3],
            marginLeft = style[MARGIN_LEFT$5],
            marginRight = style[MARGIN_RIGHT$4],
            width = style[WIDTH$5],
            height = style[HEIGHT$5];

        if (position !== 'absolute' && (display === 'block' || display === 'flex')) {
          if (isUpright) {
            if ((height.u !== AUTO$4 || this.isReplaced) && marginTop.u === AUTO$4 && marginBottom.u === AUTO$4) {
              var oh = this.outerHeight;

              if (oh < data.h) {
                this.__offsetY((data.h - oh) * 0.5, true, null);
              }
            }
          } else {
            if ((width.u !== AUTO$4 || this.isReplaced) && marginLeft.u === AUTO$4 && marginRight.u === AUTO$4) {
              var ow = this.outerWidth;

              if (ow < data.w) {
                this.__offsetX((data.w - ow) * 0.5, true, null);
              }
            }
          }
        }
      }
    }, {
      key: "__calMatrix",
      value: function __calMatrix(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this4 = this;

        var __x1 = this.__x1,
            __y1 = this.__y1,
            __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight;

        if (this.__isInline) {
          __computedStyle[TRANSFORM_ORIGIN$2] = [__x1, __y1];
          return __cacheStyle[MATRIX$1] = toE(this.__matrix);
        }

        var optimize = true;
        var matrixCache = this.__matrix; // 优化计算scale不能为0，无法计算倍数差，rotateZ优化不能包含rotateX/rotateY/skew

        if (lv >= REFLOW$3 || lv & TF$1) {
          optimize = false;
        } else if (lv & SX && !__computedStyle[SCALE_X] || lv & SY && !__computedStyle[SCALE_Y] || lv & SZ && !__computedStyle[SCALE_Z] || lv & RZ && (__computedStyle[ROTATE_X] || __computedStyle[ROTATE_Y] || __computedStyle[SKEW_X] || __computedStyle[SKEW_Y])) {
          optimize = false;
        } // translate/scale变化特殊优化，d/h/l不能有值，否则不能这样直接简化运算，因为这里不包含perspective，所以一定没有


        if (optimize) {
          var transform = __computedStyle[TRANSFORM$3];

          if (lv & TX) {
            var v = __currentStyle[TRANSLATE_X];

            if (!v) {
              v = 0;
            } else if (v.u === PX$5) {
              v = v.v;
            } else {
              v = this.__calSize(v, this.__offsetWidth, true);
            }

            var x = v - __computedStyle[TRANSLATE_X];
            __computedStyle[TRANSLATE_X] = v;
            transform[12] += x;
            matrixCache[12] += x;
          }

          if (lv & TY) {
            var _v = __currentStyle[TRANSLATE_Y];

            if (!_v) {
              _v = 0;
            } else if (_v.u === PX$5) {
              _v = _v.v;
            } else {
              _v = this.__calSize(_v, this.__offsetHeight, true);
            }

            var y = _v - __computedStyle[TRANSLATE_Y];
            __computedStyle[TRANSLATE_Y] = _v;
            transform[13] += y;
            matrixCache[13] += y;
          }

          if (lv & TZ) {
            var _v2 = __currentStyle[TRANSLATE_Z];

            if (!_v2) {
              _v2 = 0;
            } else if (_v2.u === PX$5) {
              _v2 = _v2.v;
            } else {
              _v2 = this.__calSize(_v2, this.__offsetWidth, true);
            }

            var z = _v2 - __computedStyle[TRANSLATE_Z];
            __computedStyle[TRANSLATE_Z] = _v2;
            transform[14] += z;
            matrixCache[14] += z;
          }

          if (lv & RZ) {
            var _v3 = __currentStyle[ROTATE_Z].v;
            __computedStyle[ROTATE_Z] = _v3;
            var r = d2r(_v3);
            var sin = Math.sin(r),
                cos = Math.cos(r);
            var _x = __computedStyle[SCALE_X],
                _y = __computedStyle[SCALE_Y];
            var cx = matrixCache[0] = transform[0] = cos * _x;
            var sx = matrixCache[1] = transform[1] = sin * _x;
            var sy = matrixCache[4] = transform[4] = -sin * _y;
            var cy = matrixCache[5] = transform[5] = cos * _y;
            var t = __computedStyle[TRANSFORM_ORIGIN$2],
                ox = t[0],
                oy = t[1];
            ox += __x1;
            oy += __y1;
            matrixCache[12] = transform[12] + ox - cx * ox - oy * sy;
            matrixCache[13] = transform[13] + oy - sx * ox - oy * cy;
          }

          if (lv & SCALE) {
            if (lv & SX) {
              // if(!__computedStyle[SCALE_X]) {
              //   return this.__calMatrix(REFLOW, __currentStyle, __computedStyle, __cacheStyle, false);
              // }
              var _v4 = __currentStyle[SCALE_X].v;

              var _x2 = _v4 / __computedStyle[SCALE_X];

              __computedStyle[SCALE_X] = _v4;
              transform[0] *= _x2;
              transform[1] *= _x2;
              transform[2] *= _x2;
              matrixCache[0] *= _x2;
              matrixCache[1] *= _x2;
              matrixCache[2] *= _x2;
            }

            if (lv & SY) {
              // if(!__computedStyle[SCALE_Y]) {
              //   return this.__calMatrix(REFLOW, __currentStyle, __computedStyle, __cacheStyle, false);
              // }
              var _v5 = __currentStyle[SCALE_Y].v;

              var _y2 = _v5 / __computedStyle[SCALE_Y];

              __computedStyle[SCALE_Y] = _v5;
              transform[4] *= _y2;
              transform[5] *= _y2;
              transform[6] *= _y2;
              matrixCache[4] *= _y2;
              matrixCache[5] *= _y2;
              matrixCache[6] *= _y2;
            }

            if (lv & SZ) {
              // if(!__computedStyle[SCALE_Z]) {
              //   return this.__calMatrix(REFLOW, __currentStyle, __computedStyle, __cacheStyle, false);
              // }
              var _v6 = __currentStyle[SCALE_Z].v;

              var _z = _v6 / __computedStyle[SCALE_Z];

              __computedStyle[SCALE_Z] = _v6;
              transform[8] *= _z;
              transform[9] *= _z;
              transform[10] *= _z;
              matrixCache[8] *= _z;
              matrixCache[9] *= _z;
              matrixCache[10] *= _z;
            }

            var _t = __computedStyle[TRANSFORM_ORIGIN$2],
                _ox = _t[0],
                _oy = _t[1];
            _ox += __x1;
            _oy += __y1;
            matrixCache[12] = transform[12] + _ox - transform[0] * _ox - transform[4] * _oy;
            matrixCache[13] = transform[13] + _oy - transform[1] * _ox - transform[5] * _oy;
            matrixCache[14] = transform[14] - transform[2] * _ox - transform[6] * _oy;
          }
        } // 先根据cache计算需要重新计算的computedStyle
        else {
          if (__cacheStyle[TRANSFORM_ORIGIN$2] === undefined) {
            __cacheStyle[TRANSFORM_ORIGIN$2] = true;
            __computedStyle[TRANSFORM_ORIGIN$2] = __currentStyle[TRANSFORM_ORIGIN$2].map(function (item, i) {
              return _this4.__calSize(item, i ? __offsetHeight : __offsetWidth, true);
            });
          } // 任何一个transform子项变更会清空cacheStyle，即重新计算


          if (__cacheStyle[TRANSFORM$3] === undefined || __cacheStyle[TRANSLATE_X] === undefined || __cacheStyle[TRANSLATE_Y] === undefined || __cacheStyle[TRANSLATE_Z] === undefined || __cacheStyle[ROTATE_X] === undefined || __cacheStyle[ROTATE_Y] === undefined || __cacheStyle[ROTATE_Z] === undefined || __cacheStyle[ROTATE_3D] === undefined || __cacheStyle[SCALE_X] === undefined || __cacheStyle[SCALE_Y] === undefined || __cacheStyle[SCALE_Z] === undefined || __cacheStyle[SKEW_X] === undefined || __cacheStyle[SKEW_Y] === undefined) {
            __cacheStyle[TRANSFORM$3] = __cacheStyle[TRANSLATE_X] = __cacheStyle[TRANSLATE_Y] = __cacheStyle[TRANSLATE_Z] = __cacheStyle[ROTATE_X] = __cacheStyle[ROTATE_Y] = __cacheStyle[ROTATE_Z] = __cacheStyle[SCALE_X] = __cacheStyle[SCALE_Y] = __cacheStyle[SCALE_Z] = __cacheStyle[SKEW_X] = __cacheStyle[SKEW_Y] = true;
            this.__selfPerspective = 0;
            var matrix$1,
                spm = this.__selfPerspectiveMatrix,
                ct = __currentStyle[TRANSFORM$3];
            toE(spm); // transform相对于自身

            if (ct && ct.length) {
              inject.warn('CSS transform is deprecated');
              var first = ct[0]; // 特殊处理，抽取出来transform的ppt，视为tfo原点的透视

              if (first.k === PERSPECTIVE$1) {
                var ppt = this.__selfPerspective = this.__calSize(first.v, this.__clientWidth, true);

                var _tfo = __computedStyle[TRANSFORM_ORIGIN$2];
                assignMatrix$2(spm, transform$1.calPerspectiveMatrix(ppt, _tfo[0] + __x1, _tfo[1] + __y1));
                matrix$1 = transform$1.calMatrix(ct.slice(1), __offsetWidth, __offsetHeight, this.__root);
              } else {
                matrix$1 = transform$1.calMatrix(ct, __offsetWidth, __offsetHeight, this.__root);
              }
            } // 没有transform则看是否有扩展的css独立变换属性
            else {
              __computedStyle[TRANSLATE_X] = 0;
              var _v7 = __currentStyle[TRANSLATE_X];

              if (_v7) {
                _v7 = __computedStyle[TRANSLATE_X] = this.__calSize(_v7, this.__offsetWidth, true);

                if (_v7) {
                  matrix$1 = matrix$1 || matrix.identity();
                  matrix$1[12] = _v7;
                }
              }

              __computedStyle[TRANSLATE_Y] = 0;
              _v7 = __currentStyle[TRANSLATE_Y];

              if (_v7) {
                _v7 = __computedStyle[TRANSLATE_Y] = this.__calSize(_v7, this.__offsetHeight, true);

                if (_v7) {
                  matrix$1 = matrix$1 || matrix.identity();
                  matrix$1[13] = _v7;
                }
              }

              __computedStyle[TRANSLATE_Z] = 0;
              _v7 = __currentStyle[TRANSLATE_Z];

              if (_v7) {
                _v7 = __computedStyle[TRANSLATE_Z] = this.__calSize(_v7, this.__offsetWidth, true);

                if (_v7) {
                  matrix$1 = matrix$1 || matrix.identity();
                  matrix$1[14] = _v7;
                }
              }

              __computedStyle[ROTATE_X] = 0;
              _v7 = __currentStyle[ROTATE_X];

              if (_v7) {
                _v7 = __computedStyle[ROTATE_X] = _v7.v;

                if (_v7) {
                  matrix$1 = matrix$1 || matrix.identity();

                  if (matrix$1) {
                    matrix$1 = multiplyRotateX(matrix$1, d2r(_v7));
                  } else {
                    matrix$1 = calRotateX(matrix.identity(), _v7);
                  }
                }
              }

              __computedStyle[ROTATE_Y] = 0;
              _v7 = __currentStyle[ROTATE_Y];

              if (_v7) {
                _v7 = __computedStyle[ROTATE_Y] = _v7.v;

                if (_v7) {
                  if (matrix$1) {
                    matrix$1 = multiplyRotateY(matrix$1, d2r(_v7));
                  } else {
                    matrix$1 = calRotateY(matrix.identity(), _v7);
                  }
                }
              }

              __computedStyle[ROTATE_Z] = 0;
              _v7 = __currentStyle[ROTATE_Z];

              if (_v7) {
                _v7 = __computedStyle[ROTATE_Z] = _v7.v;

                if (_v7) {
                  if (matrix$1) {
                    matrix$1 = multiplyRotateZ(matrix$1, d2r(_v7));
                  } else {
                    matrix$1 = calRotateZ(matrix.identity(), _v7);
                  }
                }
              }

              __computedStyle[ROTATE_3D] = [0, 0, 0, 0];
              _v7 = __currentStyle[ROTATE_3D];

              if (_v7) {
                _v7 = __computedStyle[ROTATE_3D] = [_v7[0], _v7[1], _v7[2], _v7[3].v];

                if ((_v7[0] || _v7[1] || _v7[2]) && _v7[3]) {
                  if (matrix$1) {
                    matrix$1 = multiply$2(matrix$1, calRotate3d(matrix.identity(), _v7));
                  } else {
                    matrix$1 = calRotate3d(matrix.identity(), _v7);
                  }
                }
              }

              __computedStyle[SKEW_X] = 0;
              _v7 = __currentStyle[SKEW_X];

              if (_v7) {
                _v7 = __computedStyle[SKEW_X] = _v7.v;

                if (_v7) {
                  if (matrix$1) {
                    matrix$1 = multiplySkewX(matrix$1, d2r(_v7));
                  } else {
                    matrix$1 = matrix.identity();
                    matrix$1[4] = Math.tan(d2r(_v7));
                  }
                }
              }

              __computedStyle[SKEW_Y] = 0;
              _v7 = __currentStyle[SKEW_Y];

              if (_v7) {
                _v7 = __computedStyle[SKEW_Y] = _v7.v;

                if (_v7) {
                  if (matrix$1) {
                    matrix$1 = multiplySkewY(matrix$1, d2r(_v7));
                  } else {
                    matrix$1 = matrix.identity();
                    matrix$1[1] = Math.tan(d2r(_v7));
                  }
                }
              }

              __computedStyle[SCALE_X] = 1;
              _v7 = __currentStyle[SCALE_X];

              if (_v7) {
                _v7 = __computedStyle[SCALE_X] = _v7.v;

                if (_v7 !== 1) {
                  if (matrix$1) {
                    matrix$1 = multiplyScaleX(matrix$1, _v7);
                  } else {
                    matrix$1 = matrix.identity();
                    matrix$1[0] = _v7;
                  }
                }
              }

              __computedStyle[SCALE_Y] = 1;
              _v7 = __currentStyle[SCALE_Y];

              if (_v7) {
                _v7 = __computedStyle[SCALE_Y] = _v7.v;

                if (_v7 !== 1) {
                  if (matrix$1) {
                    matrix$1 = multiplyScaleY(matrix$1, _v7);
                  } else {
                    matrix$1 = matrix.identity();
                    matrix$1[5] = _v7;
                  }
                }
              }

              __computedStyle[SCALE_Z] = 1;
              _v7 = __currentStyle[SCALE_Z];

              if (_v7) {
                _v7 = __computedStyle[SCALE_Z] = _v7.v;

                if (_v7 !== 1) {
                  if (matrix$1) {
                    matrix$1 = multiplyScaleZ(matrix$1, _v7);
                  } else {
                    matrix$1 = matrix.identity();
                    matrix$1[10] = _v7;
                  }
                }
              }
            }

            __computedStyle[TRANSFORM$3] = __computedStyle[TRANSFORM$3] || matrix.identity();
            assignMatrix$2(__computedStyle[TRANSFORM$3], matrix$1);
          }

          var m = __computedStyle[TRANSFORM$3];
          var tfo = __computedStyle[TRANSFORM_ORIGIN$2];

          var _t2 = transform$1.calMatrixByOrigin(m, tfo[0] + __x1, tfo[1] + __y1);

          assignMatrix$2(this.__matrix, _t2);
          matrixCache = __cacheStyle[MATRIX$1] = this.__matrix;
        }

        return matrixCache;
      }
      /**
       * 将currentStyle计算为computedStyle，同时存入cacheStyle可缓存的结果防止无变更重复计算，返回背景渲染范围
       */

    }, {
      key: "__calStyle",
      value: function __calStyle(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this5 = this;

        var __x1 = this.__x1,
            __x2 = this.__x2,
            __x3 = this.__x3,
            __x4 = this.__x4,
            __x5 = this.__x5,
            __x6 = this.__x6,
            __y1 = this.__y1,
            __y2 = this.__y2,
            __y3 = this.__y3,
            __y4 = this.__y4,
            __y5 = this.__y5,
            __y6 = this.__y6;
        this.__bbox = null;
        var bx1 = __x1,
            by1 = __y1,
            bx2 = __x6,
            by2 = __y6;
        var backgroundClip = __computedStyle[BACKGROUND_CLIP] = __currentStyle[BACKGROUND_CLIP]; // 默认border-box

        if (backgroundClip === 'paddingBox') {
          bx1 = __x2;
          by1 = __y2;
          bx2 = __x5;
          by2 = __y5;
        } else if (backgroundClip === 'contentBox') {
          bx1 = __x3;
          by1 = __y3;
          bx2 = __x4;
          by2 = __y4;
        }

        var isInline = this.__isInline;

        if (isInline && !this.__contentBoxList.length) {
          isInline = false;
        } // 这些直接赋值的不需要再算缓存


        [OPACITY$3, Z_INDEX$2, BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE, BORDER_LEFT_STYLE, BACKGROUND_REPEAT, OVERFLOW$2, MIX_BLEND_MODE$3, TEXT_OVERFLOW, BACKGROUND_CLIP, TRANSFORM_STYLE$1, BACKFACE_VISIBILITY$1].forEach(function (k) {
          __computedStyle[k] = __currentStyle[k];
        });

        if (isNil$a(__cacheStyle[FILTER$2])) {
          this.__calFilter(__currentStyle, __computedStyle, __cacheStyle);
        } // 特殊的判断，MATRIX不存在于样式key中，所有的transform共用一个


        if (isNil$a(__cacheStyle[MATRIX$1]) || lv & TRANSFORM_ALL$3) {
          var wn = this.__wasmNode;

          if (!wn) {
            this.__calMatrix(lv, __currentStyle, __computedStyle, __cacheStyle, false);
          }
        }

        if (isNil$a(__cacheStyle[BACKGROUND_POSITION_X])) {
          __cacheStyle[BACKGROUND_POSITION_X] = true;
          var bgX = __currentStyle[BACKGROUND_POSITION_X];
          __computedStyle[BACKGROUND_POSITION_X] = (bgX || []).map(function (item) {
            if (item.u === PERCENT$4) {
              return item.v + '%';
            }

            return _this5.__calSize(item, bx2 - bx1, true);
          });
        }

        if (isNil$a(__cacheStyle[BACKGROUND_POSITION_Y])) {
          __cacheStyle[BACKGROUND_POSITION_Y] = true;
          var bgY = __currentStyle[BACKGROUND_POSITION_Y];
          __computedStyle[BACKGROUND_POSITION_Y] = (bgY || []).map(function (item) {
            if (item.u === PERCENT$4) {
              return item.v + '%';
            }

            return _this5.__calSize(item, by2 - by1, true);
          });
        }

        if (isNil$a(__cacheStyle[BACKGROUND_SIZE])) {
          __cacheStyle[BACKGROUND_SIZE] = true;
          __computedStyle[BACKGROUND_SIZE] = (__currentStyle[BACKGROUND_SIZE] || []).map(function (item) {
            if (Array.isArray(item)) {
              // 每项是x/y2个
              return item.map(function (item2, i) {
                if (item2.u === AUTO$4) {
                  return -1;
                } else if (item2.u === STRING) {
                  return item2.v === 'contain' ? -2 : -3;
                }

                return _this5.__calSize(item2, i ? by2 - by1 : bx2 - bx1, true);
              });
            }
          });
        }

        if (isNil$a(__cacheStyle[BACKGROUND_IMAGE])) {
          var bgI = __currentStyle[BACKGROUND_IMAGE];
          __computedStyle[BACKGROUND_IMAGE] = bgI.map(function (item) {
            if (item) {
              return item.v;
            }

            return null;
          });
          __cacheStyle[BACKGROUND_IMAGE] = bgI.map(function (bgi, i) {
            if (!bgi) {
              return null;
            } // 防止隐藏不加载背景图


            if (bgi.u === STRING) {
              var loadBgi = _this5.__loadBgi[i] = _this5.__loadBgi[i] || {};
              var cache = inject.IMG[bgi.v];

              if (cache && cache.state === inject.LOADED) {
                loadBgi.url = bgi.v;
                loadBgi.source = cache.source;
                loadBgi.width = cache.width;
                loadBgi.height = cache.height;
              } else if (loadBgi.url !== bgi.v) {
                // 可能改变导致多次加载，每次清空，成功后还要比对url是否相同
                loadBgi.url = bgi.v;
                loadBgi.source = null;
                var node = _this5;
                var root = _this5.__root;
                inject.measureImg(bgi.v, function (data) {
                  // 还需判断url，防止重复加载时老的替换新的，失败不绘制bgi
                  if (data.success && data.url === loadBgi.url && !_this5.__isDestroyed) {
                    loadBgi.source = data.source;
                    loadBgi.width = data.width;
                    loadBgi.height = data.height;
                    __cacheStyle[BACKGROUND_IMAGE] = undefined;

                    root.__addUpdate(node, null, REPAINT$3, false, false, false, false, null);
                  }
                });
              }

              return true;
            } else if (!isInline && bgi.v && bgi.u === GRADIENT$1) {
              // gradient在渲染时才生成
              return true;
            }
          });
        }

        if (isNil$a(__cacheStyle[BOX_SHADOW])) {
          __cacheStyle[BOX_SHADOW] = true;
          __computedStyle[BOX_SHADOW] = (__currentStyle[BOX_SHADOW] || []).map(function (item) {
            return item.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this5.__calSize(item2, i === 0 ? bx2 - bx1 : by2 - by1, true);
            });
          });
        }

        [BACKGROUND_COLOR, BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR, BORDER_LEFT_COLOR].forEach(function (k) {
          if (isNil$a(__cacheStyle[k])) {
            __cacheStyle[k] = int2rgba$1(__computedStyle[k] = __currentStyle[k].v);
          }
        }); // 圆角边计算

        if (isNil$a(__cacheStyle[BORDER_TOP_LEFT_RADIUS$1]) || isNil$a(__cacheStyle[BORDER_TOP_RIGHT_RADIUS$1]) || isNil$a(__cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1]) || isNil$a(__cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1])) {
          __cacheStyle[BORDER_TOP_LEFT_RADIUS$1] = __cacheStyle[BORDER_TOP_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1] = true; // 非替代的inline计算看contentBox首尾

          if (isInline) {
            border.calBorderRadiusInline(this.__contentBoxList, __currentStyle, __computedStyle, this.__root);
          } // 普通block整体计算
          else {
            border.calBorderRadius(this.__offsetWidth, this.__offsetHeight, __currentStyle, __computedStyle, this.__root);
          }
        } // width/style/radius影响border，color不影响渲染缓存


        var btlr = __computedStyle[BORDER_TOP_LEFT_RADIUS$1];
        var btrr = __computedStyle[BORDER_TOP_RIGHT_RADIUS$1];
        var bbrr = __computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1];
        var bblr = __computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1];
        var borderTopWidth = __computedStyle[BORDER_TOP_WIDTH$3];
        var borderRightWidth = __computedStyle[BORDER_RIGHT_WIDTH$4];
        var borderBottomWidth = __computedStyle[BORDER_BOTTOM_WIDTH$2];
        var borderLeftWidth = __computedStyle[BORDER_LEFT_WIDTH$5];
        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          k = 'border' + k;
          var k2 = STYLE_KEY[style2Upper(k)];
          var kw = STYLE_KEY[style2Upper(k + 'Width')];
          var ks = STYLE_KEY[style2Upper(k + 'Style')]; // width/style变更影响border重新计算

          if (isNil$a(__cacheStyle[kw])) {
            __cacheStyle[kw] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$a(__cacheStyle[ks])) {
            __cacheStyle[ks] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$a(__cacheStyle[k2])) {
            if (k2 === BORDER_TOP) {
              if (borderTopWidth > 0) {
                if (!isInline) {
                  var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                  var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                  __cacheStyle[k2] = border.calPoints(borderTopWidth, __computedStyle[ks], deg1, deg2, __x1, __x2, __x5, __x6, __y1, __y2, __y5, __y6, 0, btlr, btrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_RIGHT) {
              if (borderRightWidth > 0) {
                if (!isInline) {
                  var _deg = Math.atan(borderRightWidth / borderTopWidth);

                  var _deg2 = Math.atan(borderRightWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderRightWidth, __computedStyle[ks], _deg, _deg2, __x1, __x2, __x5, __x6, __y1, __y2, __y5, __y6, 1, btrr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_BOTTOM) {
              if (borderBottomWidth > 0) {
                if (!isInline) {
                  var _deg3 = Math.atan(borderBottomWidth / borderLeftWidth);

                  var _deg4 = Math.atan(borderBottomWidth / borderRightWidth);

                  __cacheStyle[k2] = border.calPoints(borderBottomWidth, __computedStyle[ks], _deg3, _deg4, __x1, __x2, __x5, __x6, __y1, __y2, __y5, __y6, 2, bblr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_LEFT) {
              if (borderLeftWidth > 0) {
                if (!isInline) {
                  var _deg5 = Math.atan(borderLeftWidth / borderTopWidth);

                  var _deg6 = Math.atan(borderLeftWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderLeftWidth, __computedStyle[ks], _deg5, _deg6, __x1, __x2, __x5, __x6, __y1, __y2, __y5, __y6, 3, btlr, bblr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            }
          }
        }); // 强制计算继承性的

        var parent = this.__domParent;
        var parentComputedStyle = parent && parent.__computedStyle;

        if (__currentStyle[FONT_STYLE].u === INHERIT$1) {
          __computedStyle[FONT_STYLE] = parent ? parentComputedStyle[FONT_STYLE] : 'normal';
        } else if (isNil$a(__cacheStyle[FONT_STYLE])) {
          __computedStyle[FONT_STYLE] = __currentStyle[FONT_STYLE].v;
        }

        __cacheStyle[FONT_STYLE] = __computedStyle[FONT_STYLE];
        var color = __currentStyle[COLOR$1];

        if (color.u === INHERIT$1) {
          var v = __computedStyle[COLOR$1] = parent ? parentComputedStyle[COLOR$1] : rgba2int(reset.INHERIT.color);

          if (v.k) {
            __cacheStyle[COLOR$1] = v;
          } else {
            __cacheStyle[COLOR$1] = int2rgba$1(__computedStyle[COLOR$1]);
          }
        } else if (isNil$a(__cacheStyle[COLOR$1])) {
          if (color.u === GRADIENT$1) {
            __cacheStyle[COLOR$1] = __computedStyle[COLOR$1] = color.v;
          } else {
            __cacheStyle[COLOR$1] = int2rgba$1(__computedStyle[COLOR$1] = rgba2int(color.v));
          }
        }

        var textStrokeColor = __currentStyle[TEXT_STROKE_COLOR$1];

        if (textStrokeColor.u === INHERIT$1) {
          var _v8 = __computedStyle[TEXT_STROKE_COLOR$1] = parent ? parentComputedStyle[TEXT_STROKE_COLOR$1] : rgba2int(reset.INHERIT.textStrokeColor);

          if (_v8.k) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = _v8;
          } else {
            __cacheStyle[TEXT_STROKE_COLOR$1] = int2rgba$1(__computedStyle[TEXT_STROKE_COLOR$1]);
          }
        } else if (isNil$a(__cacheStyle[TEXT_STROKE_COLOR$1])) {
          if (textStrokeColor.u === GRADIENT$1) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = __computedStyle[TEXT_STROKE_COLOR$1] = textStrokeColor.v;
          } else if (textStrokeColor.u === RGBA$1) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = int2rgba$1(__computedStyle[TEXT_STROKE_COLOR$1] = rgba2int(textStrokeColor.v));
          }
        }

        if (__currentStyle[TEXT_STROKE_WIDTH$1].u === INHERIT$1) {
          __computedStyle[TEXT_STROKE_WIDTH$1] = parent ? parentComputedStyle[TEXT_STROKE_WIDTH$1] : reset.INHERIT.textStrokeWidth;
          __cacheStyle[TEXT_STROKE_WIDTH$1] = true;
        } else if (isNil$a(__cacheStyle[TEXT_STROKE_WIDTH$1])) {
          var _v9 = __currentStyle[TEXT_STROKE_WIDTH$1];

          if (_v9.u === REM$4) {
            _v9 = _v9.v * this.__root.__computedStyle[FONT_SIZE$3];
          } else if (_v9.u === VW$4) {
            _v9 = _v9.v * this.__root.width * 0.01;
          } else if (_v9.u === VH$4) {
            _v9 = _v9.v * this.__root.height * 0.01;
          } else if (_v9.u === VMAX$4) {
            _v9 = _v9.v * Math.max(this.__root.width, this.__root.height) * 0.01;
          } else if (_v9.u === VMIN$4) {
            _v9 = _v9.v * Math.min(this.__root.width, this.__root.height) * 0.01;
          } else {
            _v9 = _v9.v;
          }

          __computedStyle[TEXT_STROKE_WIDTH$1] = _v9;
          __cacheStyle[TEXT_STROKE_WIDTH$1] = true;
        }

        if (__currentStyle[TEXT_STROKE_OVER$1].u === INHERIT$1) {
          __cacheStyle[TEXT_STROKE_OVER$1] = __computedStyle[TEXT_STROKE_OVER$1] = parent ? parentComputedStyle[TEXT_STROKE_OVER$1] : reset.INHERIT.textStrokeOver;
        } else {
          __cacheStyle[TEXT_STROKE_OVER$1] = __computedStyle[TEXT_STROKE_OVER$1] = __currentStyle[TEXT_STROKE_OVER$1].v;
        }

        if (__currentStyle[VISIBILITY$3].u === INHERIT$1) {
          __computedStyle[VISIBILITY$3] = parent ? parentComputedStyle[VISIBILITY$3] : 'visible';
        } else if (isNil$a(__cacheStyle[VISIBILITY$3])) {
          __computedStyle[VISIBILITY$3] = __currentStyle[VISIBILITY$3].v;
        }

        __cacheStyle[VISIBILITY$3] = __computedStyle[VISIBILITY$3];

        if (__currentStyle[POINTER_EVENTS$1].u === INHERIT$1) {
          __computedStyle[POINTER_EVENTS$1] = parent ? parentComputedStyle[POINTER_EVENTS$1] : 'auto';
        } else if (isNil$a(__cacheStyle[POINTER_EVENTS$1])) {
          __computedStyle[POINTER_EVENTS$1] = __currentStyle[POINTER_EVENTS$1].v;
        }

        __cacheStyle[POINTER_EVENTS$1] = __computedStyle[POINTER_EVENTS$1]; // transformStyle需要特殊判断，在一些情况下强制flat，取消规范的opacity<1限制

        if (__computedStyle[TRANSFORM_STYLE$1] === 'preserve3d') {
          if (__computedStyle[OVERFLOW$2] === 'hidden' || __computedStyle[FILTER$2].length || this.__cacheAsBitmap) {
            __computedStyle[TRANSFORM_STYLE$1] = 'flat';
          }
        } // 影响父级flat的


        if ((__computedStyle[MIX_BLEND_MODE$3] !== 'normal' || this.__mask) && parentComputedStyle) {
          parentComputedStyle[TRANSFORM_STYLE$1] = 'flat';
        }

        this.__bx1 = bx1;
        this.__bx2 = bx2;
        this.__by1 = by1;
        this.__by2 = by2;
        return [bx1, by1, bx2, by2];
      }
    }, {
      key: "__calPerspective",
      value: function __calPerspective(__currentStyle, __computedStyle, __cacheStyle) {
        var _this6 = this;

        this.__perspectiveMatrix = null;
        var rebuild;
        var __x1 = this.__x1,
            __y1 = this.__y1;

        if (isNil$a(__cacheStyle[PERSPECTIVE$1])) {
          __cacheStyle[PERSPECTIVE$1] = true;
          rebuild = true;
          var v = __currentStyle[PERSPECTIVE$1];
          __computedStyle[PERSPECTIVE$1] = this.__calSize(v, this.__clientWidth, true);
        }

        if (isNil$a(__cacheStyle[PERSPECTIVE_ORIGIN$1])) {
          __cacheStyle[PERSPECTIVE_ORIGIN$1] = true;
          rebuild = true;
          __computedStyle[PERSPECTIVE_ORIGIN$1] = __currentStyle[PERSPECTIVE_ORIGIN$1].map(function (item, i) {
            return _this6.__calSize(item, i ? _this6.__offsetHeight : _this6.__offsetWidth, true);
          });
        }

        var ppt = __computedStyle[PERSPECTIVE$1]; // perspective为0无效

        if (rebuild && ppt) {
          var po = __computedStyle[PERSPECTIVE_ORIGIN$1];
          this.__perspectiveMatrix = transform$1.calPerspectiveMatrix(ppt, po[0] + __x1, po[1] + __y1);
        }

        return this.__perspectiveMatrix;
      }
    }, {
      key: "__calFilter",
      value: function __calFilter(__currentStyle, __computedStyle, __cacheStyle) {
        var _this7 = this;

        __cacheStyle[FILTER$2] = true;
        this.__filterBbox = null;
        return __computedStyle[FILTER$2] = (__currentStyle[FILTER$2] || []).map(function (item) {
          var k = item.k,
              v = item.v;

          if (k === 'dropShadow') {
            var v2 = v.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this7.__calSize(item2, i === 0 ? _this7.__bx2 - _this7.__bx1 : _this7.__by2 - _this7.__by1, true);
            });
            return {
              k: k,
              v: v2
            };
          } else {
            // 部分%单位的滤镜强制使用数字
            if (v.u === DEG || v.u === NUMBER$1 || v.u === PERCENT$4) {
              v = v.v;
            } else {
              v = _this7.__calSize(v, _this7.root.width, true);
            }

            return {
              k: k,
              v: v
            };
          }
        });
      }
    }, {
      key: "__calOffscreen",
      value: function __calOffscreen(ctx, __computedStyle) {
        var offscreenBlend,
            offscreenMask,
            offscreenFilter,
            offscreenOverflow,
            root = this.__root;
        var width = root.width,
            height = root.height;
        var origin = ctx;
        var mixBlendMode = __computedStyle[MIX_BLEND_MODE$3],
            filter = __computedStyle[FILTER$2],
            overflow = __computedStyle[OVERFLOW$2],
            display = __computedStyle[DISPLAY$6];

        if (mixBlendMode !== 'normal' && isValidMbm(mixBlendMode)) {
          mixBlendMode = mbmName$1(mixBlendMode);
          var c = inject.getOffscreenCanvas(width, height, null, 'blend');
          offscreenBlend = {
            ctx: ctx,
            target: c,
            mixBlendMode: mixBlendMode
          };
          ctx = c.ctx;
        }

        if (this.__hasMask) {
          var _c = inject.getOffscreenCanvas(width, height, null, 'mask1');

          offscreenMask = {
            ctx: ctx,
            target: _c
          };
          ctx = _c.ctx;
        }

        if (filter && filter.length) {
          var _c2 = inject.getOffscreenCanvas(width, height, null, 'filter');

          offscreenFilter = {
            ctx: ctx,
            filter: filter,
            target: _c2
          };
          ctx = _c2.ctx;
        }

        if (overflow === 'hidden' && display !== 'inline') {
          var _c3 = inject.getOffscreenCanvas(width, height, null, 'overflow');

          var bx1 = this.__bx1;
          var bx2 = this.__bx2;
          var by1 = this.__by1;
          var by2 = this.__by2;
          var borderTopLeftRadius = __computedStyle[BORDER_TOP_LEFT_RADIUS$1],
              borderTopRightRadius = __computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
              borderBottomRightRadius = __computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
              borderBottomLeftRadius = __computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
              backgroundClip = __computedStyle[BACKGROUND_CLIP],
              borderLeftWidth = __computedStyle[BORDER_LEFT_WIDTH$5],
              borderRightWidth = __computedStyle[BORDER_RIGHT_WIDTH$4],
              borderTopWidth = __computedStyle[BORDER_TOP_WIDTH$3],
              borderBottomWidth = __computedStyle[BORDER_BOTTOM_WIDTH$2],
              paddingTop = __computedStyle[PADDING_TOP$3],
              paddingRight = __computedStyle[PADDING_RIGHT$4],
              paddingBottom = __computedStyle[PADDING_BOTTOM$2],
              paddingLeft = __computedStyle[PADDING_LEFT$5];
          var btlr = borderTopLeftRadius.slice(0);
          var btrr = borderTopRightRadius.slice(0);
          var bbrr = borderBottomRightRadius.slice(0);
          var bblr = borderBottomLeftRadius.slice(0);

          if (backgroundClip === 'paddingBox') {
            btlr[0] -= borderLeftWidth;
            btlr[1] -= borderTopWidth;
            btrr[0] -= borderRightWidth;
            btrr[1] -= borderTopWidth;
            bbrr[0] -= borderRightWidth;
            bbrr[1] -= borderBottomWidth;
            bblr[0] -= borderLeftWidth;
            bblr[1] -= borderBottomWidth;
          } else if (backgroundClip === 'contentBox') {
            btlr[0] -= borderLeftWidth + paddingLeft;
            btlr[1] -= borderTopWidth + paddingTop;
            btrr[0] -= borderRightWidth + paddingRight;
            btrr[1] -= borderTopWidth + paddingTop;
            bbrr[0] -= borderRightWidth + paddingRight;
            bbrr[1] -= borderBottomWidth + paddingBottom;
            bblr[0] -= borderLeftWidth + paddingLeft;
            bblr[1] -= borderBottomWidth + paddingBottom;
          }

          var borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
          offscreenOverflow = {
            ctx: ctx,
            target: _c3,
            matrix: this.__matrixEvent,
            x: this.__x1,
            y: this.__y1,
            offsetWidth: this.__offsetWidth,
            offsetHeight: this.__offsetHeight,
            borderList: borderList
          };
          ctx = _c3.ctx;
        } // 无离屏不返回


        if (origin === ctx) {
          return;
        }

        return {
          ctx: ctx,
          offscreenBlend: offscreenBlend,
          offscreenMask: offscreenMask,
          offscreenFilter: offscreenFilter,
          offscreenOverflow: offscreenOverflow
        };
      } // 自定义图形可能需要覆盖判断，所以是public方法

    }, {
      key: "calContent",
      value: function calContent(__currentStyle, __computedStyle) {
        var visibility = __currentStyle[VISIBILITY$3];

        if (visibility !== 'hidden') {
          var bgI = __currentStyle[BACKGROUND_IMAGE];

          if (Array.isArray(bgI)) {
            for (var i = 0, len = bgI.length; i < len; i++) {
              if (bgI[i]) {
                return this.__hasContent = true;
              }
            }
          }

          if (__currentStyle[BACKGROUND_COLOR].v[3] > 0) {
            var width = __computedStyle[WIDTH$5],
                height = __computedStyle[HEIGHT$5],
                paddingTop = __computedStyle[PADDING_TOP$3],
                paddingRight = __computedStyle[PADDING_RIGHT$4],
                paddingBottom = __computedStyle[PADDING_BOTTOM$2],
                paddingLeft = __computedStyle[PADDING_LEFT$5];

            if (width && height || paddingTop || paddingRight || paddingBottom || paddingLeft) {
              return this.__hasContent = true;
            }
          }

          for (var list = ['Top', 'Right', 'Bottom', 'Left'], _i = 0, _len = list.length; _i < _len; _i++) {
            var k = list[_i];

            if (__computedStyle[STYLE_KEY[style2Upper('border' + k + 'Width')]] > 0 && __currentStyle[STYLE_KEY[style2Upper('border' + k + 'Color')]].v[3] > 0) {
              return this.__hasContent = true;
            }
          }

          var _bs = __currentStyle[BOX_SHADOW];

          if (Array.isArray(_bs)) {
            for (var _i2 = 0, _len2 = _bs.length; _i2 < _len2; _i2++) {
              var item = _bs[_i2];

              if (item && item[4][3] > 0) {
                return this.__hasContent = true;
              }
            }
          }
        }

        return this.__hasContent = false;
      }
      /**
       * 渲染基础方法，Dom/Geom公用
       * @param renderMode
       * @see node/mode
       * @param ctx canvas/svg/webgl共用
       * @param dx cache时偏移x
       * @param dy cache时偏移y
       * @return Object
       * x1/x2/x3/x4/x5/x6/y1/y2/y3/y4/y5/y6 坐标
       * break svg判断无变化提前跳出
       */

    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var _this8 = this;

        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var isDestroyed = this.__isDestroyed;
        var cacheStyle = this.__cacheStyle;
        var computedStyle = this.__computedStyle;

        if (isDestroyed) {
          return {
            isDestroyed: isDestroyed,
            "break": true
          };
        }

        var virtualDom; // svg设置vd上的lv属性标明<REPAINT时应用缓存，初始化肯定没有

        if (renderMode === SVG$1) {
          virtualDom = this.__virtualDom = {
            bb: [],
            children: [],
            visibility: 'visible'
          };
        }

        var display = computedStyle[DISPLAY$6]; // canvas返回信息，svg已经初始化好了vd

        if (display === 'none') {
          return {
            "break": true
          };
        } // 考虑mpb的6个坐标，inline比较特殊单独计算


        var x1 = this.__x1;
        var x2 = this.__x2;
        var x3 = this.__x3;
        var x4 = this.__x4;
        var x5 = this.__x5;
        var x6 = this.__x6;
        var y1 = this.__y1;
        var y2 = this.__y2;
        var y3 = this.__y3;
        var y4 = this.__y4;
        var y5 = this.__y5;
        var y6 = this.__y6;
        var bx1 = this.__bx1;
        var bx2 = this.__bx2;
        var by1 = this.__by1;
        var by2 = this.__by2;
        var res = {
          ctx: ctx,
          dx: dx,
          dy: dy,
          x1: x1,
          x2: x2,
          x3: x3,
          x4: x4,
          x5: x5,
          x6: x6,
          y1: y1,
          y2: y2,
          y3: y3,
          y4: y4,
          y5: y5,
          y6: y6,
          bx1: bx1,
          bx2: bx2,
          by1: by1,
          by2: by2
        };

        if (renderMode === WEBGL$1) {
          return res;
        } // 使用x和y渲染位置，考虑了relative和translate影响


        var __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight;
        var paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$4],
            paddingBottom = computedStyle[PADDING_BOTTOM$2],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2],
            backgroundColor = computedStyle[BACKGROUND_COLOR],
            borderTopColor = computedStyle[BORDER_TOP_COLOR],
            borderRightColor = computedStyle[BORDER_RIGHT_COLOR],
            borderBottomColor = computedStyle[BORDER_BOTTOM_COLOR],
            borderLeftColor = computedStyle[BORDER_LEFT_COLOR],
            borderTopLeftRadius = computedStyle[BORDER_TOP_LEFT_RADIUS$1],
            borderTopRightRadius = computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
            borderBottomRightRadius = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
            borderBottomLeftRadius = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
            visibility = computedStyle[VISIBILITY$3],
            backgroundRepeat = computedStyle[BACKGROUND_REPEAT],
            backgroundImage = computedStyle[BACKGROUND_IMAGE],
            opacity = computedStyle[OPACITY$3],
            filter = computedStyle[FILTER$2],
            backgroundSize = computedStyle[BACKGROUND_SIZE],
            boxShadow = computedStyle[BOX_SHADOW],
            overflow = computedStyle[OVERFLOW$2],
            mixBlendMode = computedStyle[MIX_BLEND_MODE$3],
            backgroundClip = computedStyle[BACKGROUND_CLIP],
            writingMode = computedStyle[WRITING_MODE$2];
        var isRealInline = this.__isInline; // cache的canvas模式已经提前计算好了，其它需要现在计算

        var matrix$1 = this.__matrix;
        var isUpright = writingMode.indexOf('vertical') === 0;

        if (renderMode === SVG$1) {
          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        } // canvas/svg/事件需要3种不同的matrix


        if (renderMode === SVG$1) {
          if (!matrix.isE(matrix$1)) {
            virtualDom.transform = 'matrix(' + joinArr$1(matrix.m2m6(matrix$1), ',') + ')';
          } else {
            delete virtualDom.transform;
          }

          virtualDom.visibility = visibility;
        }

        if (renderMode === SVG$1) {
          if (mixBlendMode !== 'normal' && isValidMbm(mixBlendMode)) {
            mixBlendMode = mbmName$1(mixBlendMode);
            virtualDom.mixBlendMode = mixBlendMode;
          } else {
            delete virtualDom.mixBlendMode;
          }

          if (filter && filter.length) {
            virtualDom.filter = painter.svgFilter(filter);
          } else {
            delete virtualDom.filter;
          }
        } // 根据backgroundClip的不同值要调整bg渲染坐标尺寸，也会影响borderRadius


        var btlr = borderTopLeftRadius.slice(0);
        var btrr = borderTopRightRadius.slice(0);
        var bbrr = borderBottomRightRadius.slice(0);
        var bblr = borderBottomLeftRadius.slice(0);

        if (backgroundClip === 'paddingBox') {
          btlr[0] -= borderLeftWidth;
          btlr[1] -= borderTopWidth;
          btrr[0] -= borderRightWidth;
          btrr[1] -= borderTopWidth;
          bbrr[0] -= borderRightWidth;
          bbrr[1] -= borderBottomWidth;
          bblr[0] -= borderLeftWidth;
          bblr[1] -= borderBottomWidth;
        } else if (backgroundClip === 'contentBox') {
          btlr[0] -= borderLeftWidth + paddingLeft;
          btlr[1] -= borderTopWidth + paddingTop;
          btrr[0] -= borderRightWidth + paddingRight;
          btrr[1] -= borderTopWidth + paddingTop;
          bbrr[0] -= borderRightWidth + paddingRight;
          bbrr[1] -= borderBottomWidth + paddingBottom;
          bblr[0] -= borderLeftWidth + paddingLeft;
          bblr[1] -= borderBottomWidth + paddingBottom;
        } // overflow:hidden，最后判断，filter/mask优先


        var borderList;

        if (overflow === 'hidden' && display !== 'inline') {
          borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);

          if (renderMode === SVG$1) {
            var d = svgPolygon$2(borderList) || "M".concat(x1, ",").concat(y1, "L").concat(x1 + __offsetWidth, ",").concat(y1, "L").concat(x1 + __offsetWidth, ",").concat(y1 + __offsetHeight, "L").concat(x1, ",").concat(y1 + __offsetHeight, ",L").concat(x1, ",").concat(y1);
            var v = {
              tagName: 'clipPath',
              props: [],
              children: [{
                tagName: 'path',
                props: [['d', d]]
              }]
            };
            var id = ctx.add(v);

            this.__cacheDefs.push(v);

            virtualDom.overflow = 'url(#' + id + ')';
          }
        } else if (renderMode === SVG$1) {
          delete virtualDom.overflow;
        } // 隐藏不渲染


        if ((visibility === 'hidden' || res["break"]) && (renderMode === CANVAS$1 || renderMode === WEBGL$1)) {
          res["break"] = true;
          return res;
        }
        /**
         * inline的渲染同block/ib不一样，不是一个矩形区域
         * 它根据内部的contentBox渲染，contentBox是指lineBox中的内容，即TextBox/inline/ib元素
         * 首尾可能不满行，比如从一半开始或一半结束，甚至可能没有内容
         * 两行之间可能不满，如果lineBox的高度>lineHeight的话，另外特殊字体如arial拥有lineGap也会产生间隙，背景色不绘制这个间隙
         * x轴根据contentBox的范围坐标，y则固定和font/lineHeight相关
         * 圆角发生在首尾lineBox处，中间不会有，bgi则产生类似bgc作为mask的效果
         * 另外要注意多个时的顺序，必须依次渲染，后面的bb可能会覆盖前面行的
         */


        if (isRealInline) {
          var contentBoxList = this.contentBoxList;
          var length = contentBoxList.length;

          if (contentBoxList[length - 1] instanceof Ellipsis) {
            length--;
          }

          var hasBgi = backgroundImage.some(function (item) {
            return item;
          });

          if (length) {
            var _ret = function () {
              var fontSize = computedStyle[FONT_SIZE$3],
                  fontFamily = computedStyle[FONT_FAMILY$1],
                  lineHeight = computedStyle[LINE_HEIGHT$2];
              var iw = 0,
                  ih = 0;
              var offscreen,
                  svgBgSymbol = []; // bgi视作inline排满一行绘制，然后按分行拆开给每行

              if (hasBgi) {
                iw = inline.getInlineWidth(_this8, contentBoxList, isUpright);
                ih = lineHeight; // 垂直模式互换，计算时始终按照宽度为主轴计算的

                if (isUpright) {
                  var _ref = [ih, iw];
                  iw = _ref[0];
                  ih = _ref[1];
                }

                if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom;
                    ih += paddingLeft + paddingRight;
                  } else {
                    iw += paddingLeft + paddingRight;
                    ih += paddingTop + paddingBottom;
                  }
                } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                    ih += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                  } else {
                    iw += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                    ih += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                  }
                }

                if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
                  offscreen = inject.getOffscreenCanvas(iw, ih, '__$$INLINE_BGI$$__', null);
                }

                var _length = backgroundImage.length;
                backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
                  if (!bgi) {
                    return;
                  }

                  i = _length - 1 - i;

                  if (util.isString(bgi)) {
                    var loadBgi = _this8.__loadBgi[i];

                    if (loadBgi.url === bgi) {
                      var uuid = bg.renderImage(_this8, renderMode, offscreen && offscreen.ctx || ctx, loadBgi, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, true, dx, dy);

                      if (renderMode === SVG$1 && uuid) {
                        svgBgSymbol.push(uuid);
                      }
                    }
                  } else if (bgi.k) {
                    var gd = _this8.__gradient(renderMode, ctx, 0, 0, iw, ih, bgi, dx, dy);

                    if (gd) {
                      if (gd.k === 'conic') {
                        gradient.renderConic(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, 0, 0, iw, lineHeight, btlr, btrr, bbrr, bblr, true);
                      } else {
                        var _uuid = bg.renderBgc(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, null, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, 'fill', true);

                        if (renderMode === SVG$1 && _uuid) {
                          svgBgSymbol.push(_uuid);
                        }
                      }
                    }
                  }
                });
              } // 获取当前dom的baseline，再减去lineBox的baseline得出差值，这样渲染范围y就是lineBox的y+差值为起始，lineHeight为高
              // lineGap，一般为0，某些字体如arial有，渲染高度需减去它，最终是lineHeight - leading，上下均分


              var leading = fontSize * ((o$3.info[calFontFamily(fontFamily)] || {}).lgr || 0) * 0.5;
              var baseline = isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle); // 注意只有1个的时候特殊情况，圆角只在首尾行出现

              var isFirst = true;
              var lastContentBox = contentBoxList[0],
                  lastLineBox = lastContentBox.parentLineBox; // bgi需统计宽度累计值，将当前行所处理想单行的x范围位置计算出来，并进行bgi贴图绘制，svg还需统计第几行

              var count = 0;

              for (var i = 0; i < length; i++) {
                var contentBox = contentBoxList[i];

                if (contentBox.parentLineBox !== lastLineBox) {
                  (function () {
                    // 上一行
                    var _inline$getInlineBox = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i - 1], lastLineBox, baseline, lineHeight, leading, isFirst, false, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox2 = _slicedToArray(_inline$getInlineBox, 8),
                        ix1 = _inline$getInlineBox2[0],
                        iy1 = _inline$getInlineBox2[1],
                        ix2 = _inline$getInlineBox2[2],
                        iy2 = _inline$getInlineBox2[3],
                        bx1 = _inline$getInlineBox2[4],
                        by1 = _inline$getInlineBox2[5],
                        bx2 = _inline$getInlineBox2[6],
                        by2 = _inline$getInlineBox2[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var n = getFirstEmptyInlineWidth(_this8);
                      ix1 -= n;
                      bx1 -= n;
                    }

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], null, ix1, iy1, ix2 - ix1, iy2 - iy1, btlr, [0, 0], [0, 0], bblr, 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // 世界参考系的宽高，根据writingMode不同取值使用
                    // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$1 || renderMode === WEBGL$1) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$1 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v10 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v10);

                          _this8.__cacheDefs.push(_v10);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    count += isUpright ? h : w; // 增加主轴方向的一行/列尺寸

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], [0, 0]);
                      border.renderBorder(_this8, renderMode, ctx, list, cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    } // right在最后这里不渲染


                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg7 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg8 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list2 = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg7, _deg8, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], [0, 0]);

                      border.renderBorder(_this8, renderMode, ctx, _list2, cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg9 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg10 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list3 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg9, _deg10, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list3, cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }

                    isFirst = false;
                    lastContentBox = contentBox;
                    lastLineBox = contentBox.parentLineBox;
                  })();
                } // 最后一个特殊判断


                if (i === length - 1) {
                  (function () {
                    var _inline$getInlineBox3 = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i], lastLineBox, baseline, lineHeight, leading, isFirst, true, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox4 = _slicedToArray(_inline$getInlineBox3, 8),
                        ix1 = _inline$getInlineBox4[0],
                        iy1 = _inline$getInlineBox4[1],
                        ix2 = _inline$getInlineBox4[2],
                        iy2 = _inline$getInlineBox4[3],
                        bx1 = _inline$getInlineBox4[4],
                        by1 = _inline$getInlineBox4[5],
                        bx2 = _inline$getInlineBox4[6],
                        by2 = _inline$getInlineBox4[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var _n4 = getFirstEmptyInlineWidth(_this8);

                      ix1 -= _n4;
                      bx1 -= _n4;
                    } // 要算上末尾空白inline，可能有多个和递归嵌套


                    var n = getLastEmptyInlineWidth(_this8);
                    ix2 += n;
                    bx2 += n;

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], null, ix1, iy1, ix2 - ix1, iy2 - iy1, isFirst ? btlr : [0, 0], btrr, bbrr, isFirst ? bblr : [0, 0], 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$1 || renderMode === WEBGL$1) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$1 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v11 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v11);

                          _this8.__cacheDefs.push(_v11);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], btrr);
                      border.renderBorder(_this8, renderMode, ctx, list, cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    }

                    if (borderRightWidth > 0 && borderRightColor[3] > 0) {
                      var _deg11 = Math.atan(borderRightWidth / borderTopWidth);

                      var _deg12 = Math.atan(borderRightWidth / borderBottomWidth);

                      var _list4 = border.calPoints(borderRightWidth, computedStyle[BORDER_RIGHT_STYLE], _deg11, _deg12, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 1, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list4, cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
                    }

                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg13 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg14 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list5 = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg13, _deg14, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list5, cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg15 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg16 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list6 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg15, _deg16, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list6, cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }
                  })();
                }
              }

              if (offscreen) {
                offscreen.ctx.clearRect(0, 0, iw, ih);
              }

              return {
                v: res
              };
            }();

            if (_typeof(_ret) === "object") return _ret.v;
          } // 无内容且无尺寸的无需渲染
          else if (bx1 === bx2 || by1 === by2) {
            return res;
          }
        } // block渲染，bgc垫底


        if (backgroundColor[3] > 0) {
          bg.renderBgc(this, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
        } // 渐变或图片叠加


        if (backgroundImage) {
          var _length2 = backgroundImage.length;
          backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
            if (!bgi) {
              return;
            }

            i = _length2 - 1 - i;

            if (util.isString(bgi)) {
              var loadBgi = _this8.__loadBgi[i];

              if (loadBgi.url === bgi) {
                bg.renderImage(_this8, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, false, dx, dy);
              }
            } else if (bgi.k) {
              var gd = _this8.__gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi, dx, dy);

              if (gd) {
                if (gd.k === 'conic') {
                  gradient.renderConic(_this8, renderMode, ctx, gd.v, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
                } else {
                  bg.renderBgc(_this8, renderMode, ctx, gd.v, borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
                }
              }
            }
          });
        } // boxShadow可能会有多个


        if (boxShadow) {
          boxShadow.forEach(function (item) {
            bs.renderBoxShadow(_this8, renderMode, ctx, item, x1, y1, x6, y6, x6 - x1, y6 - y1, dx, dy);
          });
        } // 边框需考虑尖角，两条相交边平分45°夹角


        if (borderTopWidth > 0 && borderTopColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_TOP], cacheStyle[BORDER_TOP_COLOR], dx, dy);
        }

        if (borderRightWidth > 0 && borderRightColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_RIGHT], cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
        }

        if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_BOTTOM], cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
        }

        if (borderLeftWidth > 0 && borderLeftColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_LEFT], cacheStyle[BORDER_LEFT_COLOR], dx, dy);
        }

        return res;
      } // 强制刷新API

    }, {
      key: "refresh",
      value: function refresh(lv, cb) {
        var root = this.__root;

        if (isFunction$4(lv) || !lv) {
          lv = CACHE$3;
        }

        if (lv) {
          this.clearCache(lv < REPAINT$3);
        }

        if (root && !this.__isDestroyed) {
          root.__addUpdate(this, null, lv, false, false, false, false, cb);
        } else if (isFunction$4(cb)) {
          cb(-1);
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        var ref = this.props.ref;

        if (!isNil$a(ref) && !isFunction$4(ref)) {
          delete this.__root.__ref[ref];
        }

        _get(_getPrototypeOf(Xom.prototype), "__destroy", this).call(this);

        this.clearAnimate();
        this.clearFrameAnimate();
        this.clearCache();
        var fontRegister = this.__fontRegister;

        for (var i in fontRegister) {
          if (fontRegister.hasOwnProperty(i)) {
            o$3.offRegister(i, this);
          }
        }

        this.__host = this.__hostRoot = this.__root = this.__prev = this.__next = this.__parent = this.__domParent = null;

        this.__reset0();

        var wa = this.__wasmNode;

        if (wa) {
          wa.clear();
          wa.free();
          this.__wasmNode = null;
        }
      } // 先查找到注册了事件的节点，再捕获冒泡判断增加性能

    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var _this9 = this;

        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.__computedStyle,
            __mask = this.__mask;

        if (__isDestroyed || computedStyle[DISPLAY$6] === 'none' || e.__stopPropagation || __mask) {
          return;
        }

        var type = e.event.type;
        var __listener = this.__listener,
            __hasMask = this.__hasMask;
        var cb;

        if (__listener.hasOwnProperty(type)) {
          cb = __listener[type];
        } // touchmove之类强制的直接由Root通知即可


        if (force) {
          if (computedStyle[POINTER_EVENTS$1] !== 'none' && !e.__stopImmediatePropagation && (isFunction$4(cb) || Array.isArray(cb))) {
            if (Array.isArray(cb)) {
              cb.forEach(function (item) {
                if (isFunction$4(item)) {
                  item.call(_this9, e);
                }
              });
            } else {
              cb.call(this, e);
            }
          }

          return true;
        } // 非force的判断事件坐标是否在节点内


        if (this.willResponseEvent(e)) {
          // 如果有mask，点在mask上才行，点在clip外才行
          if (__hasMask) {
            var next = this.next;
            var isClip = next.__clip;
            var hasEmitMask;

            while (next && next.__mask) {
              if (next.willResponseEvent(e, true)) {
                hasEmitMask = true;
                break;
              }

              next = next.next;
            }

            if (!isClip && !hasEmitMask) {
              return;
            }
          }

          if (Array.isArray(cb) && !e.__stopImmediatePropagation) {
            cb.forEach(function (item) {
              if (isFunction$4(item)) {
                item.call(_this9, e);
              }
            });
          } else if (isFunction$4(cb) && !e.__stopImmediatePropagation) {
            cb.call(this, e);
          }

          return true;
        }
      }
    }, {
      key: "willResponseEvent",
      value: function willResponseEvent(e, ignore) {
        var x = e.x,
            y = e.y;
        var __x1 = this.__x1,
            __y1 = this.__y1,
            __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight,
            __matrixEvent = this.__matrixEvent,
            __computedStyle = this.__computedStyle;

        if (__computedStyle[POINTER_EVENTS$1] === 'none') {
          return;
        }

        var inThis = geom.pointInQuadrilateral(x, y, __x1, __y1, __x1 + __offsetWidth, __y1, __x1 + __offsetWidth, __y1 + __offsetHeight, __x1, __y1 + __offsetHeight, __matrixEvent);

        if (inThis) {
          if (!e.target && !ignore) {
            e.target = this; // 缓存target给move用

            if (e.event.type === 'touchstart') {
              this.root && (this.root.__touchstartTarget = this);
            }
          }

          return true;
        }
      }
    }, {
      key: "__gradient",
      value: function __gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi) {
        var dx = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var dy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var iw = bx2 - bx1;
        var ih = by2 - by1; // 无尺寸无需创建渐变

        if (!iw || !ih) {
          return;
        }

        var k = bgi.k,
            v = bgi.v,
            d = bgi.d,
            s = bgi.s,
            z = bgi.z,
            p = bgi.p;
        var cx = bx1 + iw * 0.5;
        var cy = by1 + ih * 0.5;
        var res = {
          k: k
        };

        if (k === 'linear') {
          var gd = gradient.getLinear(v, d, bx1, by1, cx, cy, iw, ih, this.root, dx, dy);
          res.v = this.__getLg(renderMode, ctx, gd);
        } else if (k === 'radial') {
          var _gd = gradient.getRadial(v, s, z, p, bx1, by1, bx2, by2, this.root, dx, dy);

          if (_gd) {
            res.v = this.__getRg(renderMode, ctx, _gd);

            if (_gd.matrix) {
              res.v = [res.v, _gd.matrix, _gd.cx, _gd.cy];
            }
          }
        } else if (k === 'conic') {
          var bbox = this.bbox;
          var m1 = Math.max(Math.abs(bbox[2] - bbox[0]), Math.abs(bbox[3] - bbox[1]));
          var m2 = Math.max(Math.abs(iw), Math.abs(ih));

          var _gd2 = gradient.getConic(v, d, p, bx1, by1, bx2, by2, m1 / m2, this.root, dx, dy);

          res.v = this.__getCg(renderMode, ctx, _gd2);
        }

        return res;
      }
    }, {
      key: "__getLg",
      value: function __getLg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          var lg = ctx.createLinearGradient(gd.x1, gd.y1, gd.x2, gd.y2);
          gd.stop.forEach(function (item) {
            lg.addColorStop(item[1], int2rgba$1(item[0]));
          });
          return lg;
        } else if (renderMode === SVG$1) {
          var v = {
            tagName: 'linearGradient',
            props: [['x1', gd.x1], ['y1', gd.y1], ['x2', gd.x2], ['y2', gd.y2]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };
          var uuid = ctx.add(v);

          this.__cacheDefs.push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getRg",
      value: function __getRg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          var rg = ctx.createRadialGradient(gd.cx, gd.cy, 0, gd.tx, gd.ty, gd.r);
          gd.stop.forEach(function (item) {
            rg.addColorStop(item[1], int2rgba$1(item[0]));
          });
          return rg;
        } else if (renderMode === SVG$1) {
          var v = {
            tagName: 'radialGradient',
            props: [['cx', gd.tx], ['cy', gd.ty], ['r', gd.r]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };

          if (gd.tx !== gd.cx) {
            v.props.push(['fx', gd.cx]);
          }

          if (gd.ty !== gd.cy) {
            v.props.push(['fy', gd.cy]);
          }

          var uuid = ctx.add(v);

          this.__cacheDefs.push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getCg",
      value: function __getCg(renderMode, ctx, gd) {
        var stop = gd.stop;
        var len = stop.length - 1;

        if (stop[len][1] < 1) {
          stop.push([stop[len][0].slice(0), 1]);
        }

        if (stop[0][1] > 0) {
          stop.unshift([stop[0][0].slice(0), 0]);
        } // canvas采用点色值计算法，svg则分360度画块


        var res = [];

        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          return gd;
        }

        return res;
      } // canvas清空自身cache，cacheTotal在Root的自底向上逻辑做，svg仅有cacheTotal

    }, {
      key: "clearCache",
      value: function clearCache(onlyTotal) {
        var __cacheTotal = this.__cacheTotal;
        var __cacheFilter = this.__cacheFilter;
        var __cacheMask = this.__cacheMask;
        var __cache = this.__cache;

        if (__cache && !onlyTotal) {
          __cache.release();

          this.__refreshLevel |= REPAINT$3;
        }

        if (__cacheTotal) {
          __cacheTotal.release();
        }

        if (__cacheFilter) {
          __cacheFilter.release();
        }

        if (__cacheMask) {
          __cacheMask.release();
        }

        this.__cacheTarget = onlyTotal ? __cache && __cache.__available ? __cache : null : null;
        this.__refreshLevel |= CACHE$3;
        this.clearTopCache();
      }
    }, {
      key: "clearTopCache",
      value: function clearTopCache() {
        var p = this.__domParent;

        while (p) {
          var __cache = p.__cache;
          var __cacheTotal = p.__cacheTotal;
          var __cacheFilter = p.__cacheFilter;
          var __cacheMask = p.__cacheMask;
          p.__refreshLevel |= CACHE$3;

          if (__cacheTotal) {
            __cacheTotal.release();
          }

          if (__cacheFilter) {
            __cacheFilter.release();
          }

          if (__cacheMask) {
            __cacheMask.release();
          }

          p.__cacheTarget = __cache && __cache.__available ? __cache : null;
          p = p.__domParent;
        }
      }
    }, {
      key: "updateStyle",
      value: function updateStyle(style, cb) {
        var formatStyle = normalize(style);
        this.updateFormatStyle(formatStyle, cb);
      } // 传入格式化好key/value的样式

    }, {
      key: "updateFormatStyle",
      value: function updateFormatStyle(style, cb) {
        var root = this.__root,
            currentStyle = this.__currentStyle,
            currentProps = this.__currentProps;
        var keys = [];
        var wn = this.__wasmNode;

        for (var k in style) {
          if (style.hasOwnProperty(k)) {
            var isGeom = GEOM.hasOwnProperty(k);
            var v = style[k];

            if (isGeom) {
              if (!equalStyle(k, currentProps[k], v, this)) {
                currentProps[k] = v;
                keys.push(k);
              }
            } else {
              k = parseInt(k);

              if (wn && wasm$1.isWasmStyle(k)) {
                var k2 = WASM_STYLE_KEY[k];

                if (k === TRANSFORM_ORIGIN$2) {
                  var res = void 0;

                  if (!wn.equal_style(k2, v[0].v, v[0].u)) {
                    wn.update_style(k2, v[0].v, v[0].u);
                    res = true;
                  }

                  k2++;

                  if (!wn.equal_style(k2, v[1].v, v[1].u)) {
                    wn.update_style(k2, v[1].v, v[1].u);
                    res = true;
                  }

                  if (res) {
                    keys.push(k);
                  }
                } else {
                  if (!wn.equal_style(k2, v.v, v.u)) {
                    wn.update_style(k2, v.v, v.u);
                    keys.push(k);
                  }
                }
              } else if (!equalStyle(k, currentStyle[k], v, this)) {
                currentStyle[k] = v;
                keys.push(k);
              }
            }
          }
        }

        if (!keys.length || this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb(true);
          }

          return;
        }

        if (root) {
          root.__addUpdate(this, keys, null, false, false, false, false, cb);
        }
      }
    }, {
      key: "animate",
      value: function animate(list) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var animation = new Animation(this, list, options);

        if (this.__isDestroyed) {
          animation.__destroy();

          return animation;
        }

        var wn = this.__wasmNode;

        if (wn) {
          var wa = animation.__wasmAnimation;

          if (wa) {
            wn.add_ani(wa.ptr);
          }
        }

        this.__animationList.push(animation);

        if (options.autoPlay === false) {
          return animation;
        }

        return animation.play();
      }
    }, {
      key: "removeAnimate",
      value: function removeAnimate(o) {
        if (o instanceof Animation) {
          var i = this.__animationList.indexOf(o);

          if (i > -1) {
            o.cancel();

            o.__destroy();

            this.__animationList.splice(i, 1);

            var wn = this.__wasmNode;

            if (wn) {
              var wa = animation.__wasmAnimation;

              if (wa) {
                wn.remove_ani(wa.ptr);
              }
            }
          }
        }
      }
    }, {
      key: "clearAnimate",
      value: function clearAnimate() {
        this.__animationList.splice(0).forEach(function (o) {
          o.cancel();

          o.__destroy();
        });

        var wn = this.__wasmNode;

        if (wn) {
          wn.clear();
        }
      }
    }, {
      key: "frameAnimate",
      value: function frameAnimate(cb) {
        if (isFunction$4(cb)) {
          this.__frameAnimateList.push(cb);

          this.__root.__onFrame(cb);
        }
      }
    }, {
      key: "removeFrameAnimate",
      value: function removeFrameAnimate(cb) {
        if (isFunction$4(cb)) {
          var frameAnimateList = this.__frameAnimateList;
          var i = frameAnimateList.indexOf(cb);

          if (i > -1) {
            frameAnimateList.splice(i, 1);

            this.__root.__offFrame(cb);
          }
        }
      }
    }, {
      key: "clearFrameAnimate",
      value: function clearFrameAnimate() {
        var root = this.__root;

        this.__frameAnimateList.splice(0).forEach(function (o) {
          root.__offFrame(o);
        });
      } // isLayout为false时，为relative，true则是absolute/justify/marginAuto等直接改layoutData数据的
      // lv是reflow偏移时传入，需要清除cacheStyle，并且对位图cache进行偏移设置
      // 注意所有的offset/resize都要避免display:none的，比如合并margin导致block的孩子inline因clamp为none时没有layoutData

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        if (this.__computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetX", this).call(this, diff);

        if (isLayout) {
          this.__layoutData.x += diff;
        }

        this.__x1 += diff;
        this.__x2 += diff;
        this.__x3 += diff;
        this.__x4 += diff;
        this.__x5 += diff;
        this.__x6 += diff;

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$3) {
            this.__cacheStyle = [];

            this.__layoutStyle(lv);
          }

          if (this.__bbox) {
            this.__bbox[0] += diff;
            this.__bbox[2] += diff;
          }

          if (this.__filterBbox) {
            this.__filterBbox[0] += diff;
            this.__filterBbox[2] += diff;
          }
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        if (this.__computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetY", this).call(this, diff);

        if (isLayout) {
          this.__layoutData && (this.__layoutData.y += diff);
        }

        this.__y1 += diff;
        this.__y2 += diff;
        this.__y3 += diff;
        this.__y4 += diff;
        this.__y5 += diff;
        this.__y6 += diff;

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$3) {
            this.__cacheStyle = [];

            this.__layoutStyle(lv);
          }

          if (this.__bbox) {
            this.__bbox[1] += diff;
            this.__bbox[3] += diff;
          }

          if (this.__filterBbox) {
            this.__filterBbox[1] += diff;
            this.__filterBbox[3] += diff;
          }

          if (this.__cache) {
            this.__cache.__offsetY(diff);
          }

          if (this.__cacheTotal) {
            this.__cacheTotal.__offsetY(diff);
          }

          if (this.__cacheFilter) {
            this.__cacheFilter.__offsetY(diff);
          }

          if (this.__cacheMask) {
            this.__cacheMask.__offsetY(diff);
          }
        }
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        if (this.__computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        this.__computedStyle.width = this.__width += diff;
        this.__clientWidth += diff;
        this.__offsetWidth += diff;
        this.__outerWidth += diff;
        this.__layoutData && (this.__layoutData.w += diff);
        this.__x4 += diff;
        this.__x5 += diff;
        this.__x6 += diff;

        if (diff < 0) {
          this.__limitCache = false;
        }

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$3) {
            this.__cacheStyle = [];

            this.__layoutStyle(lv);
          }
        }

        var wn = this.__wasmNode;

        if (wn) {
          wn.resize_x(diff);
        }

        this.clearCache();
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        if (this.__computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        this.__computedStyle.height = this.__height += diff;
        this.__clientHeight += diff;
        this.__offsetHeight += diff;
        this.__outerHeight += diff;
        this.__layoutData.h += diff;
        this.__y4 += diff;
        this.__y5 += diff;
        this.__y6 += diff;

        if (diff < 0) {
          this.__limitCache = false;
        }

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$3) {
            this.__cacheStyle = [];

            this.__layoutStyle(lv);
          }
        }

        var wn = this.__wasmNode;

        if (wn) {
          wn.resize_y(diff);
        }

        this.clearCache();
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        var computedStyle = this.__computedStyle;
        var res = {};
        var keys = [];

        if (key) {
          var temp;

          if (Array.isArray(key)) {
            temp = key;
          } else {
            temp = [key];
          }

          temp.forEach(function (k) {
            if (abbr.hasOwnProperty(k)) {
              abbr[k].forEach(function (k) {
                keys.push(STYLE_KEY[style2Upper(k)]);
              });
            } else {
              keys.push(STYLE_KEY[style2Upper(k)]);
            }
          });
        } else {
          keys = Object.keys(computedStyle);
        }

        var wn = this.__wasmNode,
            wasmCps;
        keys.forEach(function (k) {
          if (GEOM.hasOwnProperty(k)) {
            res[k] = computedStyle[k];
          } else {
            if (wn && wasm$1.isWasmStyle(k)) {
              if (!wasmCps) {
                wasmCps = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
              }

              if (k === TRANSFORM_ORIGIN$2) {
                var k2 = WASM_STYLE_KEY[k];
                res[STYLE_RV_KEY[k]] = [wasmCps[k2], wasmCps[k2 + 1]];
              } else {
                res[STYLE_RV_KEY[k]] = wasmCps[WASM_STYLE_KEY[k]];
              }
            } else {
              res[STYLE_RV_KEY[k]] = computedStyle[k];
            }
          }
        });
        return res;
      }
    }, {
      key: "getStyle",
      value: function getStyle(k) {
        if (!k || !util.isString(k) || abbr.hasOwnProperty(k)) {
          throw new Error('Param must be a single style key');
        }

        var computedStyle = this.__computedStyle;

        if (GEOM.hasOwnProperty(k)) {
          return computedStyle[k];
        }

        var k2 = STYLE_KEY[style2Upper(k)];
        var wn = this.__wasmNode;

        if (wn && wasm$1.isWasmStyle(k2)) {
          var wasmCps = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);

          if (k === TRANSFORM_ORIGIN$2) {
            k2 = WASM_STYLE_KEY[k2];
            return [wasmCps[k2], wasmCps[k2 + 1]];
          } else {
            return wasmCps[WASM_STYLE_KEY[k2]];
          }
        }

        return computedStyle[k2];
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(includeBbox) {
        var box;

        if (includeBbox) {
          box = this.bbox;
        } else {
          var __x1 = this.__x1,
              __y1 = this.__y1,
              __offsetWidth = this.__offsetWidth,
              __offsetHeight = this.__offsetHeight;
          box = [__x1, __y1, __x1 + __offsetWidth, __y1 + __offsetHeight];
        }

        var matrixEvent = this.__matrixEvent;
        var p1 = point2d(matrix.calPoint({
          x: box[0],
          y: box[1]
        }, matrixEvent));
        var p2 = point2d(matrix.calPoint({
          x: box[2],
          y: box[1]
        }, matrixEvent));
        var p3 = point2d(matrix.calPoint({
          x: box[2],
          y: box[3]
        }, matrixEvent));
        var p4 = point2d(matrix.calPoint({
          x: box[0],
          y: box[3]
        }, matrixEvent));
        return {
          left: Math.min(p1.x, p2.x, p3.x, p4.x),
          top: Math.min(p1.y, p2.y, p3.y, p4.y),
          right: Math.max(p1.x, p2.x, p3.x, p4.x),
          bottom: Math.max(p1.y, p2.y, p3.y, p4.y),
          points: [p1, p2, p3, p4]
        };
      } // img和geom返回false，在inline布局时判断是否是真的inline

    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return true;
      }
    }, {
      key: "remove",
      value: function remove(cb) {
        var root = this.__root;
        var parent = this.isShadowRoot ? this.hostRoot.__parent : this.__parent;
        var i;

        if (parent) {
          // 移除component的shadowRoot视为移除component
          var target = this.isShadowRoot ? this.hostRoot : this;
          i = parent.__children.indexOf(target);

          if (i === -1) {
            throw new Error('Invalid index of remove()');
          }

          parent.__children.splice(i, 1);

          if (parent.__zIndexChildren) {
            i = parent.__zIndexChildren.indexOf(target);

            if (i === -1) {
              throw new Error('Invalid index of remove()');
            }

            parent.__zIndexChildren.splice(i, 1);
          }

          var __prev = target.__prev,
              __next = target.__next;

          if (__prev) {
            __prev.__next = __next;
          }

          if (__next) {
            __next.__prev = __prev;
          }
        }

        if (this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb(true);
          }

          return;
        } // root没有


        parent && parent.__deleteStruct(this, i); // 不可见仅改变数据结构

        if (this.__computedStyle[DISPLAY$6] === 'none' || parent && parent.__computedStyle[DISPLAY$6] === 'none') {
          this.__destroy();

          if (isFunction$4(cb)) {
            cb(true);
          }

          return;
        } // 可见在reflow逻辑做结构关系等


        root.__addUpdate(this, null, REFLOW$3, false, true, false, false, cb);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, cb) {
        if (type && isFunction$4(cb)) {
          type = type.toLowerCase();
          var arr = this.__listener[type] = this.__listener[type] || [];

          for (var i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === cb) {
              return;
            }
          }

          arr.push(cb);
        }
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, cb) {
        if (!type) {
          return;
        }

        type = type.toLowerCase();
        var arr = this.__listener[type];

        if (Array.isArray(arr) && cb) {
          for (var i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === cb) {
              arr.splice(i, 1);
              break;
            }
          }
        } else if (isFunction$4(arr) && arr === cb) {
          delete this.__listener[type];
        }
      } // 加速，用cacheTarget指向当前可用最高优先级的cache，无则null

    }, {
      key: "__updateCache",
      value: function __updateCache() {
        var __cacheMask = this.__cacheMask,
            __cacheFilter = this.__cacheFilter,
            __cacheTotal = this.__cacheTotal,
            __cache = this.__cache;

        if (__cacheMask && __cacheMask.__available) {
          this.__cacheTarget = __cacheMask;
        } else if (__cacheFilter && __cacheFilter.__available) {
          this.__cacheTarget = __cacheFilter;
        } else if (__cacheTotal && __cacheTotal.__available) {
          this.__cacheTarget = __cacheTotal;
        } else if (__cache && __cache.__available) {
          this.__cacheTarget = __cache;
        } else {
          this.__cacheTarget = null;
        }
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "clientWidth",
      get: function get() {
        return this.__clientWidth || 0;
      }
    }, {
      key: "clientHeight",
      get: function get() {
        return this.__clientHeight || 0;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__offsetWidth || 0;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__offsetHeight || 0;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__outerWidth || 0;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__outerHeight || 0;
      } // 相对自身原点，不考虑margin的范围，>=REPAINT渲染或个别有影响的渲染改变（如blur）清空缓存

    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var __x1 = this.__x1,
              __y1 = this.__y1,
              __offsetWidth = this.__offsetWidth,
              __offsetHeight = this.__offsetHeight,
              boxShadow = this.__computedStyle[BOX_SHADOW];
          this.__bbox = spreadBoxShadow([__x1, __y1, __x1 + __offsetWidth, __y1 + __offsetHeight], boxShadow);
        }

        return this.__bbox;
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.__bbox || this.bbox;
          var filter = this.__computedStyle[FILTER$2];
          this.__filterBbox = spreadFilter$1(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "listener",
      get: function get() {
        return this.__listener;
      }
    }, {
      key: "opacity",
      get: function get() {
        var wn = this.__wasmNode;

        if (wn) {
          return wn.get_op();
        }

        return this.__opacity;
      }
    }, {
      key: "matrix",
      get: function get() {
        var wn = this.__wasmNode;

        if (wn) {
          return new Float64Array(wasm$1.instance.memory.buffer, wn.m_ptr(), 16);
        }

        return this.__matrix;
      } // TODO 渲染之前尚无数据，需判断refreshLevel

    }, {
      key: "matrixEvent",
      get: function get() {
        var wn = this.__wasmNode;

        if (wn) {
          return new Float64Array(wasm$1.instance.memory.buffer, wn.me_ptr(), 16);
        }

        return this.__matrixEvent;
      }
    }, {
      key: "perspectiveMatrix",
      get: function get() {
        return this.__perspectiveMatrix;
      }
    }, {
      key: "style",
      get: function get() {
        return this.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.__computedStyle;
      }
    }, {
      key: "animationList",
      get: function get() {
        return this.__animationList;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.__currentStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.__cacheStyle;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.parent && this.host && this.host !== this.root;
      }
    }, {
      key: "contentBoxList",
      get: function get() {
        return this.__contentBoxList;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.__offsetHeight;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        return this.__offsetHeight;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.__offsetWidth;
      }
    }, {
      key: "mask",
      get: function get() {
        return this.__mask;
      },
      set: function set(v) {
        v = !!v;

        if (this.__mask !== v) {
          this.__mask = v;
          var root = this.__root;

          if (root && !this.__isDestroyed) {
            var p = this.__domParent;

            if (p) {
              if (v) {
                p.__computedStyle[TRANSFORM_STYLE$1] = 'flat';
              } else {
                p.__computedStyle[TRANSFORM_STYLE$1] = p.__currentStyle[TRANSFORM_STYLE$1];
              }
            }

            root.__addUpdate(this, null, MASK$2, false, false, false, false, null);
          }
        }
      }
    }, {
      key: "clip",
      get: function get() {
        return this.__clip;
      },
      set: function set(v) {
        v = !!v;

        if (this.__clip !== v) {
          this.__clip = v;
          var root = this.__root;

          if (root && !this.__isDestroyed) {
            var p = this.__domParent;

            if (p) {
              if (v) {
                p.__computedStyle[TRANSFORM_STYLE$1] = 'flat';
              } else {
                p.__computedStyle[TRANSFORM_STYLE$1] = p.__currentStyle[TRANSFORM_STYLE$1];
              }
            }

            root.__addUpdate(this, null, MASK$2, false, false, false, false, null);
          }
        }
      }
    }, {
      key: "cacheAsBitmap",
      get: function get() {
        return this.__cacheAsBitmap;
      },
      set: function set(v) {
        v = !!v;

        if (this.__cacheAsBitmap !== v) {
          this.__cacheAsBitmap = v;
          var root = this.__root;

          if (root && !this.__isDestroyed) {
            if (v) {
              this.__computedStyle[TRANSFORM_STYLE$1] = 'flat';
            } else {
              this.__computedStyle[TRANSFORM_STYLE$1] = this.__currentStyle[TRANSFORM_STYLE$1];
            }

            root.__addUpdate(this, null, REPAINT$3, false, false, false, false, null);
          }
        }
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "env",
      get: function get() {
        var root = this.__root;

        if (root) {
          return root.__env || {
            x: this.__x1,
            y: this.__y1,
            width: root.__width,
            height: root.__height,
            node: root
          };
        }
      }
    }]);

    return Xom;
  }(Node$1);

  var _enums$STYLE_KEY$7 = enums.STYLE_KEY,
      DISPLAY$5 = _enums$STYLE_KEY$7.DISPLAY,
      MARGIN_TOP$2 = _enums$STYLE_KEY$7.MARGIN_TOP,
      MARGIN_BOTTOM$2 = _enums$STYLE_KEY$7.MARGIN_BOTTOM,
      MARGIN_LEFT$4 = _enums$STYLE_KEY$7.MARGIN_LEFT,
      MARGIN_RIGHT$3 = _enums$STYLE_KEY$7.MARGIN_RIGHT,
      BORDER_TOP_WIDTH$2 = _enums$STYLE_KEY$7.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$1 = _enums$STYLE_KEY$7.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$4 = _enums$STYLE_KEY$7.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$3 = _enums$STYLE_KEY$7.BORDER_RIGHT_WIDTH,
      PADDING_TOP$2 = _enums$STYLE_KEY$7.PADDING_TOP,
      PADDING_BOTTOM$1 = _enums$STYLE_KEY$7.PADDING_BOTTOM,
      PADDING_LEFT$4 = _enums$STYLE_KEY$7.PADDING_LEFT,
      PADDING_RIGHT$3 = _enums$STYLE_KEY$7.PADDING_RIGHT,
      LINE_HEIGHT$1 = _enums$STYLE_KEY$7.LINE_HEIGHT;
  /**
   * css中常见的概念，一行内容，里面可能有若干不同的内容，仅在布局阶段出现，不参与渲染逻辑
   * 本类是个抽象逻辑概念，会包含Text的内容TextBox和inlineBlock等节点，而内容TextBox则属于Text
   * 一个Text可能因为换行产生多个TextBox，从而形成不同行的内容就属于不同的LineBox
   * 本类属于block（包含flex和inlineBlock，下同）节点下，一个dom会有个专门列表，
   * 包含若干个LineBox保存着若干行文本内容TextBox，不直接关联Text，
   * inline则不会有此对象和列表，其复用最近block父层的，这样解决嵌套问题，
   * block在布局时将列表向孩子传递下去，每遇到block会重新生成
   * 每当发生换行时，专门列表中会新生成一个LineBox，让后续内容继续跟随新的LB
   * LB内部要进行垂直对齐，Text内容较简单x字符底部为baseline，inlineBlock等节点按最后一行baseline
   */

  var LineBox = /*#__PURE__*/function () {
    function LineBox(x, y, lineHeight, baseline, isUpright) {
      this.__list = [];
      this.__x = x;
      this.__y = y;
      this.__oy = 0; // 很难受，relative的offset不能直接加在x上，会引发重复以及block父尺寸问题

      this.__lineHeight = lineHeight; // 可能出现空的inline，因此一个inline进入布局时先设置当前lineBox的最小lineHeight/baseline

      this.__baseline = baseline;
      this.__isUpright = isUpright;
      this.__bOffset = 0;
    }

    _createClass(LineBox, [{
      key: "add",
      value: function add(item) {
        this.list.push(item);
        item.__parentLineBox = this;
      }
    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var baseline = isUpright ? this.verticalBaseline : this.baseline;
        var lineHeight = isUpright ? this.verticalLineHeight : this.lineHeight;
        var increase = lineHeight; // 只有1个也需要对齐，因为可能内嵌了空inline使得baseline发生变化

        if (this.list.length) {
          this.list.forEach(function (item) {
            if (item.isEllipsis) {
              return;
            } // 垂直排版计算不太一样，因为原点坐标系不一样


            if (isUpright) {
              var n = item.verticalBaseline;

              if (n !== baseline) {
                var d = baseline - n;

                item.__offsetX(d, true);

                if (item instanceof TextBox) {
                  item.__parent.__offsetX(d, false);
                } // 同下方


                increase = Math.max(increase, item.offsetWidth + d);
              }
            } else {
              var _n = item.baseline;

              if (_n !== baseline) {
                var _d = baseline - _n;

                item.__offsetY(_d, true); // TextBox偏移后，Text也要更改x/y坐标，否则bbox不对，webgl渲染缓存位图就会偏差


                if (item instanceof TextBox) {
                  item.__parent.__offsetY(_d, false);
                } // text的话对齐下移可能影响整体高度，在同行有img/ib这样的替换元素下，需记录最大偏移导致的高度调整值
                // 比如一个字符和img，字符下调y即字符的baseline和图片底部对齐，导致高度增加lineHeight和baseline的差值


                increase = Math.max(increase, item.offsetHeight + _d);
              }
            }
          }); // 特殊情况，有img这样的替换元素时，要参与这一行和baseline的对齐扩充，常见于css的img底部额外4px问题
          // 先计算总体baseline和本身baseline差值得出偏移，然后加到本身lineHeight上得出尺寸，再和其它扩充取最大值

          var diff = baseline - this.__baseline;
          increase = Math.max(increase, this.__lineHeight + diff);
        }

        return Math.max(0, increase - lineHeight);
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isAlign) {
        this.__x += diff; // vertical-align或水平情况特殊对齐，可能替换元素img和text导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetX(diff, true);
          });
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isAlign) {
        this.__y += diff; // vertical-align情况或水平特殊对齐，可能替换元素img和textBox导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetY(diff, true);
          });
        }
      }
      /**
       * 防止非行首空inline，每当遇到inline就设置当前lineBox的lineHeight/baseline，这样有最小值兜底
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "__setLB",
      value: function __setLB(l, b) {
        this.__lineHeight = Math.max(l, this.__lineHeight);
        this.__baseline = Math.max(b, this.__baseline);
      }
    }, {
      key: "__resetLb",
      value: function __resetLb(l, b) {
        this.list.forEach(function (item) {
          var dom = item;

          if (item instanceof TextBox) {
            dom = item.parent.parent;
          }

          var computedStyle = dom.computedStyle;

          while (computedStyle[DISPLAY$5] === 'inline') {
            l = Math.max(l, computedStyle[LINE_HEIGHT$1]);
            b = Math.max(b, css.getBaseline(computedStyle));
            dom = dom.domParent;
            computedStyle = dom.computedStyle;
          }
        });
        this.__lineHeight = l;
        this.__baseline = b;
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__list.length;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "ox",
      get: function get() {
        return this.__ox;
      }
    }, {
      key: "oy",
      get: function get() {
        return this.__oy;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.x + this.width;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.y + this.height;
      }
    }, {
      key: "width",
      get: function get() {
        if (this.isUpright) {
          return this.verticalLineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var x1 = first.x;
          var dom = first instanceof TextBox ? first.__parent.__domParent : first.__domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list = dom.__contentBoxList;
            var _dom$__computedStyle = dom.__computedStyle,
                display = _dom$__computedStyle[DISPLAY$5],
                marginLeft = _dom$__computedStyle[MARGIN_LEFT$4],
                borderLeftWidth = _dom$__computedStyle[BORDER_LEFT_WIDTH$4],
                paddingLeft = _dom$__computedStyle[PADDING_LEFT$4];

            if (display !== 'inline') {
              break;
            }

            if (first === _list[0]) {
              x1 -= marginLeft + borderLeftWidth + paddingLeft;
            }

            dom = dom.__domParent;
          }

          var x2 = last.x + last.outerWidth;
          dom = last instanceof TextBox ? last.__parent.__domParent : last.__domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list2 = dom.__contentBoxList;
            var _dom$__computedStyle2 = dom.__computedStyle,
                _display = _dom$__computedStyle2[DISPLAY$5],
                marginRight = _dom$__computedStyle2[MARGIN_RIGHT$3],
                borderRightWidth = _dom$__computedStyle2[BORDER_RIGHT_WIDTH$3],
                paddingRight = _dom$__computedStyle2[PADDING_RIGHT$3];

            if (_display !== 'inline') {
              break;
            }

            if (first === _list2[_list2.length - 1]) {
              x2 += marginRight + borderRightWidth + paddingRight;
            }

            dom = dom.__domParent;
          }

          return x2 - x1;
        }

        return 0;
      }
    }, {
      key: "height",
      get: function get() {
        if (!this.isUpright) {
          return this.lineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var y1 = first.y;
          var dom = first instanceof TextBox ? first.__parent.__domParent : first.__domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list3 = dom.__contentBoxList;
            var _dom$__computedStyle3 = dom.__computedStyle,
                display = _dom$__computedStyle3[DISPLAY$5],
                marginTop = _dom$__computedStyle3[MARGIN_TOP$2],
                borderTopWidth = _dom$__computedStyle3[BORDER_TOP_WIDTH$2],
                paddingTop = _dom$__computedStyle3[PADDING_TOP$2];

            if (display !== 'inline') {
              break;
            }

            if (first === _list3[0]) {
              y1 -= marginTop + borderTopWidth + paddingTop;
            }

            dom = dom.__domParent;
          }

          var y2 = last.y + last.outerHeight;
          dom = last instanceof TextBox ? last.__parent.__domParent : last.__domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list4 = dom.__contentBoxList;
            var _dom$computedStyle = dom.computedStyle,
                _display2 = _dom$computedStyle[DISPLAY$5],
                marginBottom = _dom$computedStyle[MARGIN_BOTTOM$2],
                borderBottomWidth = _dom$computedStyle[BORDER_BOTTOM_WIDTH$1],
                paddingBottom = _dom$computedStyle[PADDING_BOTTOM$1];

            if (_display2 !== 'inline') {
              break;
            }

            if (first === _list4[_list4.length - 1]) {
              y2 += marginBottom + borderBottomWidth + paddingBottom;
            }

            dom = dom.__domParent;
          }

          return y2 - y1;
        }

        return 0;
      }
    }, {
      key: "bOffset",
      get: function get() {
        return this.__bOffset;
      }
    }, {
      key: "baseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.baseline);
        });
        return baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.verticalBaseline);
        });
        return baseline;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerHeight);
        });
        return lineHeight;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerWidth);
        });
        return lineHeight;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isUpright;
      }
    }]);

    return LineBox;
  }();

  /**
   * 维护一个上下文的LineBox，向LineBox中添加Item以及新增下一行的LineBox，多个LineBox组成一个区域
   * 一个block/inlineBlock拥有一个本类对象，上下文即对应这个dom流，而inline则复用最近非inline父元素的
   * 同时LineBox可能连续也可能不连续，不连续的是中间有block之类的隔离开来
   */

  var LineBoxManager = /*#__PURE__*/function () {
    function LineBoxManager(x, y, lineHeight, baseline, isUpright) {
      this.__x = this.__lastX = x; // last存储目前最后一行LineBox的结尾位置，供后续inline使用

      this.__y = this.__lastY = y;
      this.__max = isUpright ? y : x;
      this.__domList = [];
      this.__domStack = [];
      this.__list = []; // 包含若干LineBox

      this.__isNewLine = true; // 区域内是否是新行，容器dom（block）开头肯定是

      this.__lineHeight = lineHeight;
      this.__baseline = baseline;
      this.__isEnd = true; // 在dom中是否一个区域处在结尾，外部控制

      this.__spreadList = []; // verticalAlign时每个区域增加的y高度

      this.__isVertical = isUpright;
    }
    /**
     * 每次换行时重新生成LineBox存入列表，同时由于flow流当前一定是流（dom）的结尾，设置isEnd
     * @returns {LineBox}
     */


    _createClass(LineBoxManager, [{
      key: "genLineBox",
      value: function genLineBox(x, y) {
        var lineBox = new LineBox(x, y, this.__lineHeight, this.__baseline, this.isUpright);
        this.list.push(lineBox);
        this.__isEnd = true;
        return lineBox;
      }
      /**
       * inline的特殊调用，防止空内容但有mbp的inline不占位，放入一个有lineHeight的空lineBox
       * 只有新行开头时需要，后面的无论是否有内容都会影响lineHeight
       * @param x
       * @param y
       * @param l
       * @param b
       * @returns {LineBox}
       */

    }, {
      key: "genLineBoxByInlineIfNewLine",
      value: function genLineBoxByInlineIfNewLine(x, y, l, b) {
        var lineHeight = Math.max(this.__lineHeight, l);
        var baseline = Math.max(this.__baseline, b);

        if (this.__isNewLine) {
          var lineBox = new LineBox(x, y, lineHeight, baseline, this.isUpright);
          this.list.push(lineBox);
          this.__isEnd = true;
          this.__isNewLine = false;
          return lineBox;
        }
      }
      /**
       * 外部设置为结尾，如一个LineBox后出现一个block，此时会被隔断，不再作为流的末尾
       */

    }, {
      key: "setNotEnd",
      value: function setNotEnd() {
        this.__isEnd = false;
      }
      /**
       * 外部设置新行，下次新生成LineBox
       */

    }, {
      key: "setNewLine",
      value: function setNewLine() {
        this.__isNewLine = true;
      }
      /**
       * 当前LineBox放入一个新项，当新行时（如第一行）产生一个新的LineBox并存入列表
       * 是否新区域和新行都是可以被外部控制，默认第一行是新
       * 当被隔断后会被外部重置新行，这样会生成新的来作为新加项的LineBox
       * 当换行时外部也会调用新行，这样再次添加Item时会自动生成新的LineBox而不是用之前的
       * @param o TextBox/Inline/InlineBlock
       * @param nextNewLine 是否设置newLine，标明下次添加新生成LineBox
       * @returns {LineBox}
       */

    }, {
      key: "addItem",
      value: function addItem(o, nextNewLine) {
        var lineBox,
            isUpright = this.isUpright; // 新行新的lineBox，否则复用最后一个

        if (this.__isNewLine) {
          this.__isNewLine = false;
          lineBox = this.genLineBox(o.x, o.y);
        } else {
          var list = this.list;
          var length = list.length;
          lineBox = list[length - 1];
        } // inline递归过程中所有inline父子顺序列表，每个dom都需要对当前内容保存


        this.__domStack.forEach(function (item) {
          item.__contentBoxList.push(o);
        });

        lineBox.add(o); // 设置结束x的位置给next的inline标记用，o可能是TextBox或inlineBlock，当next新行时注意位置

        if (nextNewLine) {
          this.__isNewLine = true;

          if (isUpright) {
            this.__lastX = o.x + o.outerWidth;
            this.__lastY = this.__y;
          } else {
            this.__lastX = this.__x;
            this.__lastY = o.y + o.outerHeight;
          }
        } else {
          if (isUpright) {
            this.__lastX = o.x;
            this.__lastY = o.y + o.outerHeight;
          } else {
            this.__lastX = o.x + o.outerWidth;
            this.__lastY = o.y;
          }
        }

        this.__max = Math.max(this.__max, isUpright ? o.y + o.outerHeight : o.x + o.outerWidth);
        return lineBox;
      }
    }, {
      key: "horizonAlign",
      value: function horizonAlign(size, textAlign, isUpright) {
        this.list.forEach(function (lineBox) {
          var diff = size - (isUpright ? lineBox.height : lineBox.width);

          if (diff > 0) {
            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (isUpright) {
              lineBox.__offsetY(diff, true);
            } else {
              lineBox.__offsetX(diff, true);
            }
          }
        });
      }
      /**
       * 垂直对齐过程中，如果遇到占位元素如img，可能会导致每行lineBox高度增加，需返回增加量，
       * next行也需要y偏移
       * @returns {number}
       */

    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var spreadList = this.__spreadList;
        spreadList.splice(0);
        var spread = 0;
        this.list.forEach(function (lineBox) {
          if (spread) {
            lineBox.__bOffset = spread; // 对齐造成的误差需记录给baseline修正

            if (isUpright) {
              lineBox.__offsetX(spread, true);
            } else {
              lineBox.__offsetY(spread, true);
            }
          }

          spread += lineBox.verticalAlign(isUpright);
          spreadList.push(spread);
        });
        return spread;
      }
    }, {
      key: "addX",
      value: function addX(n) {
        this.__lastX += n;
      }
    }, {
      key: "addY",
      value: function addY(n) {
        this.__lastY += n;
      }
      /**
       * inline递归过程中布局调用，不断出入栈dom对象，获取当前行状态下有哪些dom还在
       * @param dom
       */

    }, {
      key: "pushContentBoxList",
      value: function pushContentBoxList(dom) {
        this.__domList.push(dom);

        this.__domStack.push(dom);
      }
    }, {
      key: "popContentBoxList",
      value: function popContentBoxList() {
        this.__domStack.pop();
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetX(diff);
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetY(diff);
        });
      }
      /**
       * inline的特殊调用，非行首无论是否有内容都设置lineBox的lineHeight
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "setLbByInlineIfNotNewLine",
      value: function setLbByInlineIfNotNewLine(l, b) {
        var length = this.list.length;

        if (length && !this.isNewLine) {
          this.list[length - 1].__setLB(l, b, false);
        }
      }
    }, {
      key: "size",
      get: function get() {
        return this.list.length;
      }
    }, {
      key: "lastX",
      get: function get() {
        return this.__lastX;
      }
    }, {
      key: "lastY",
      get: function get() {
        return this.__lastY;
      }
    }, {
      key: "endX",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endX;
        }

        return this.__x;
      }
    }, {
      key: "endY",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endY;
        }

        return this.__y;
      }
    }, {
      key: "isEnd",
      get: function get() {
        return this.__isEnd;
      }
    }, {
      key: "isNewLine",
      get: function get() {
        return this.__isNewLine;
      }
    }, {
      key: "breakLine",
      get: function get() {
        return this.list.length > 1;
      }
    }, {
      key: "domList",
      get: function get() {
        return this.__domList;
      }
    }, {
      key: "baseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          var n = 0;

          for (var i = 0; i < length - 1; i++) {
            n += list[i].height;
          } // 需考虑因为verticalAlign造成的lineBox偏移offset值，修正计算正确的baseline


          return n + list[length - 1].baseline + list[length - 1].bOffset;
        }

        return 0;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline;
        }

        return 0;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline + list[0].bOffset;
        }

        return 0;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].lineHeight;
        }

        return 0;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].verticalLineHeight;
        }

        return 0;
      }
    }, {
      key: "lineBox",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1];
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "width",
      get: function get() {
        var w = 0;
        this.list.forEach(function (item) {
          w = Math.max(w, item.width);
        });
        return w;
      }
    }, {
      key: "spreadList",
      get: function get() {
        return this.__spreadList;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "max",
      get: function get() {
        return this.__max;
      }
    }]);

    return LineBoxManager;
  }();

  var TAG_NAME = {
    'div': true,
    'p': true,
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var INLINE = {
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var BOLD = {
    'b': true,
    'strong': true
  };
  var tag = {
    TAG_NAME: TAG_NAME,
    INLINE: INLINE,
    BOLD: BOLD
  };

  var _enums$STYLE_KEY$6 = enums.STYLE_KEY,
      MARGIN_RIGHT$2 = _enums$STYLE_KEY$6.MARGIN_RIGHT,
      MARGIN_LEFT$3 = _enums$STYLE_KEY$6.MARGIN_LEFT,
      PADDING_RIGHT$2 = _enums$STYLE_KEY$6.PADDING_RIGHT,
      PADDING_LEFT$3 = _enums$STYLE_KEY$6.PADDING_LEFT,
      WIDTH$4 = _enums$STYLE_KEY$6.WIDTH,
      HEIGHT$4 = _enums$STYLE_KEY$6.HEIGHT,
      BORDER_RIGHT_WIDTH$2 = _enums$STYLE_KEY$6.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$3 = _enums$STYLE_KEY$6.BORDER_LEFT_WIDTH,
      FILL$1 = _enums$STYLE_KEY$6.FILL,
      STROKE = _enums$STYLE_KEY$6.STROKE,
      STROKE_MITERLIMIT = _enums$STYLE_KEY$6.STROKE_MITERLIMIT,
      STROKE_WIDTH$6 = _enums$STYLE_KEY$6.STROKE_WIDTH,
      STROKE_LINECAP = _enums$STYLE_KEY$6.STROKE_LINECAP,
      STROKE_LINEJOIN = _enums$STYLE_KEY$6.STROKE_LINEJOIN,
      STROKE_DASHARRAY = _enums$STYLE_KEY$6.STROKE_DASHARRAY,
      STROKE_DASHARRAY_STR = _enums$STYLE_KEY$6.STROKE_DASHARRAY_STR,
      FILL_RULE = _enums$STYLE_KEY$6.FILL_RULE,
      FLEX_BASIS$2 = _enums$STYLE_KEY$6.FLEX_BASIS;
  var AUTO$3 = o$4.AUTO,
      PX$4 = o$4.PX,
      PERCENT$3 = o$4.PERCENT,
      REM$3 = o$4.REM,
      VW$3 = o$4.VW,
      VH$3 = o$4.VH,
      VMAX$3 = o$4.VMAX,
      VMIN$3 = o$4.VMIN,
      RGBA = o$4.RGBA,
      GRADIENT = o$4.GRADIENT;
  var int2rgba = util.int2rgba,
      isNil$9 = util.isNil,
      isNumber = util.isNumber,
      joinArr = util.joinArr;
  var canvasPolygon$2 = painter.canvasPolygon,
      svgPolygon$1 = painter.svgPolygon;
  var REGISTER = {};

  var Geom = /*#__PURE__*/function (_Xom) {
    _inherits(Geom, _Xom);

    function Geom(tagName, props) {
      var _this;

      _this = _Xom.call(this, tagName, props) || this;
      _this.__isMulti = !!_this.props.multi;
      _this.__style = css.normalize(_this.style, reset.DOM_ENTRY_SET.concat(reset.GEOM_ENTRY_SET));
      _this.__currentStyle = util.extend([], _this.__style);
      _this.__currentProps = util.clone(_this.props);
      _this.__cacheProps = {};
      return _this;
    }

    _createClass(Geom, [{
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        this.__computeReflow(); // 无children，直接以style的width为宽度，不定义则为0


        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$4],
            marginLeft = _this$currentStyle[MARGIN_LEFT$3],
            marginRight = _this$currentStyle[MARGIN_RIGHT$2],
            paddingLeft = _this$currentStyle[PADDING_LEFT$3],
            paddingRight = _this$currentStyle[PADDING_RIGHT$2],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$3],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$2];

        if (width[1] !== AUTO$3) {
          w -= this.__calSize(width, total, true);
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS$2],
            width = currentStyle[WIDTH$4],
            height = currentStyle[HEIGHT$4];
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$4, PERCENT$3, REM$3, VW$3, VH$3, VMAX$3, VMIN$3].indexOf(flexBasis.u) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$4, PERCENT$3, REM$3, VW$3, VH$3, VMAX$3, VMIN$3].indexOf(main.u) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        _get(_getPrototypeOf(Geom.prototype), "__layout", this).call(this, data, isAbs, isColumn, isRow);

        this.__layoutStyle();
      }
    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright;

        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        }

        this.__ioSize(tw, th);

        if (isAbs || isColumn || isRow) {
          return;
        }

        this.__marginAuto(this.currentStyle, data);

        this.__cacheProps = {};
      }
    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        // 无children所以等同于block
        this.__layoutBlock(data, isAbs, isColumn, isRow);
      }
    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isInline) {
        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h;

        var tw = fixedWidth ? w : 0;
        var th = fixedHeight ? h : 0;

        this.__ioSize(tw, th);

        this.__cacheProps = {};
      }
    }, {
      key: "__calStyle",
      value: function __calStyle(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this2 = this;

        var res = _get(_getPrototypeOf(Geom.prototype), "__calStyle", this).call(this, lv, __currentStyle, __computedStyle, __cacheStyle);

        if (isNil$9(__cacheStyle[STROKE_WIDTH$6])) {
          __cacheStyle[STROKE_WIDTH$6] = true;
          var strokeWidth = __currentStyle[STROKE_WIDTH$6] || [];
          var w = this.width;
          __computedStyle[STROKE_WIDTH$6] = strokeWidth.map(function (item) {
            return _this2.__calSize(item, w, true);
          });
        }

        if (isNil$9(__cacheStyle[STROKE_DASHARRAY])) {
          __cacheStyle[STROKE_DASHARRAY] = true;
          __computedStyle[STROKE_DASHARRAY] = __currentStyle[STROKE_DASHARRAY] || [];
          __cacheStyle[STROKE_DASHARRAY_STR] = __computedStyle[STROKE_DASHARRAY].map(function (item) {
            return joinArr(item, ',');
          });
        } // 直接赋值的


        [STROKE_LINECAP, STROKE_LINEJOIN, STROKE_MITERLIMIT, FILL_RULE].forEach(function (k) {
          __computedStyle[k] = __currentStyle[k];
        }); // stroke/fll移至render里处理，因为cache涉及渐变坐标偏移

        [FILL$1, STROKE].forEach(function (k) {
          if (isNil$9(__cacheStyle[k])) {
            var v = __currentStyle[k];
            var cs = __computedStyle[k] = [];

            var _res = __cacheStyle[k] = [];

            if (Array.isArray(v)) {
              v.forEach(function (item) {
                if (item && item.u === GRADIENT) {
                  // let t = this.__gradient(renderMode, ctx, x3, y3, x4, y4, item[0], 0, 0);
                  cs.push(item.v);

                  _res.push(true);
                } else if (item && item.u === RGBA && item.v[3] > 0) {
                  cs.push(item.v);

                  _res.push(int2rgba(item.v));
                } else {
                  cs.push('none');

                  _res.push('none');
                }
              });
            }
          }
        });
        return res;
      }
    }, {
      key: "calContent",
      value: function calContent(currentStyle, computedStyle) {
        var res = _get(_getPrototypeOf(Geom.prototype), "calContent", this).call(this, currentStyle, computedStyle);

        this.__hasXomContent = res;
        var fill = computedStyle[FILL$1],
            stroke = computedStyle[STROKE],
            strokeWidth = computedStyle[STROKE_WIDTH$6];
        var empty = true;

        for (var i = 0, len = fill.length; i < len; i++) {
          var item = fill[i];

          if (item.k || item[3] > 0) {
            empty = false;
            break;
          }
        }

        for (var _i = 0, _len = stroke.length; _i < _len; _i++) {
          var _item = stroke[_i];

          if ((_item.k || _item[3] > 0) && strokeWidth[_i] > 0) {
            empty = false;
            break;
          }
        } // 矢量图形默认有内容


        if (!empty) {
          return true;
        } // 没有fill和stroke则认为矢量图形为空


        if (!res && empty) {
          return false;
        }

        return res;
      }
    }, {
      key: "__preSet",
      value: function __preSet(renderMode, res) {
        var _this3 = this;

        var width = this.width,
            height = this.height,
            __cacheStyle = this.__cacheStyle,
            computedStyle = this.computedStyle;
        var cx = res.x3 + width * 0.5;
        var cy = res.y3 + height * 0.5;
        var strokeDasharrayStr = __cacheStyle[STROKE_DASHARRAY_STR];
        var fill = computedStyle[FILL$1],
            stroke = computedStyle[STROKE],
            strokeWidth = computedStyle[STROKE_WIDTH$6],
            strokeLinecap = computedStyle[STROKE_LINECAP],
            strokeLinejoin = computedStyle[STROKE_LINEJOIN],
            strokeMiterlimit = computedStyle[STROKE_MITERLIMIT],
            strokeDasharray = computedStyle[STROKE_DASHARRAY],
            fillRule = computedStyle[FILL_RULE];
        stroke = stroke.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.x3, res.y3, res.x4, res.y4, item, res.dx, res.dy);
          }

          return int2rgba(item);
        });
        fill = fill.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.x3, res.y3, res.x4, res.y4, item, res.dx, res.dy);
          }

          return int2rgba(item);
        });
        return {
          cx: cx,
          cy: cy,
          stroke: stroke,
          strokeWidth: strokeWidth,
          strokeDasharray: strokeDasharray,
          strokeDasharrayStr: strokeDasharrayStr,
          strokeLinecap: strokeLinecap,
          strokeLinejoin: strokeLinejoin,
          strokeMiterlimit: strokeMiterlimit,
          fill: fill,
          fillRule: fillRule
        };
      }
    }, {
      key: "__preSetCanvas",
      value: function __preSetCanvas(renderMode, ctx, res) {
        var stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            strokeDasharray = res.strokeDasharray,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            fill = res.fill;

        if (renderMode === mode.CANVAS) {
          if (fill) {
            if (fill.k === 'linear') {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'radial' && !Array.isArray(fill.v)) {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'conic') ; else if (!fill.k && ctx.fillStyle !== fill) {
              ctx.fillStyle = fill;
            }
          }

          if (stroke) {
            if (stroke.k === 'linear') {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'radial' && !Array.isArray(stroke.v)) {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'conic') ; else if (!stroke.k && ctx.strokeStyle !== stroke) {
              ctx.strokeStyle = stroke;
            }
          }

          if (strokeWidth !== undefined && ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          if (strokeLinecap !== undefined && ctx.lineCap !== strokeLinecap) {
            ctx.lineCap = strokeLinecap;
          }

          if (strokeLinejoin !== undefined && ctx.lineJoin !== strokeLinejoin) {
            ctx.lineJoin = strokeLinejoin;
          }

          if (strokeMiterlimit !== undefined && ctx.miterLimit !== strokeMiterlimit) {
            ctx.miterLimit = strokeMiterlimit;
          } // 小程序没这个方法


          if (util.isFunction(ctx.getLineDash)) {
            if (strokeDasharray && !util.equalArr(ctx.getLineDash(), strokeDasharray)) {
              ctx.setLineDash(strokeDasharray);
            }
          } else if (strokeDasharray) {
            ctx.setLineDash(strokeDasharray);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Geom.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (renderMode === mode.SVG) {
          this.virtualDom.type = 'geom';
        } // 无论canvas/svg，break可提前跳出省略计算


        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        } // data在无cache时没有提前设置


        var preData = this.__preSet(renderMode, res);

        return Object.assign(res, preData);
      }
    }, {
      key: "__renderPolygon",
      value: function __renderPolygon(renderMode, ctx, res) {
        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var list = this.__cacheProps.list,
            isMulti = this.isMulti,
            bbox = this.bbox; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy,
            bbox: bbox
          };

          this.__renderOnePolygon(renderMode, ctx, isMulti, list, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o);
            }
          }

          for (var _i2 = 0, _len2 = strokes.length; _i2 < _len2; _i2++) {
            var stroke = strokes[_i2];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i2],
                strokeDasharray: strokeDasharrays[_i2],
                strokeDasharrayStr: strokeDasharrayStrs[_i2],
                strokeLinecap: strokeLinecaps[_i2],
                strokeLinejoin: strokeLinejoins[_i2],
                strokeMiterlimit: strokeMiterlimits[_i2],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o2);
            }
          }
        }
      }
    }, {
      key: "__renderOnePolygon",
      value: function __renderOnePolygon(renderMode, ctx, isMulti, list, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill && fill.k === 'conic';
        var isStrokeCE = stroke && stroke.k === 'conic'; // 椭圆是array

        var isFillRE = fill && fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth && strokeWidth > 0 && stroke && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth && strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth && strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke.v = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, true);
        }
      }
    }, {
      key: "__drawPolygon",
      value: function __drawPolygon(renderMode, ctx, isMulti, list, res, isFill, isStroke) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            fillRule = res.fillRule,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        if (renderMode === mode.CANVAS) {
          this.__preSetCanvas(renderMode, ctx, res);

          ctx.beginPath();

          if (isMulti) {
            list.forEach(function (item) {
              return canvasPolygon$2(ctx, item, dx, dy, true);
            });
          } else {
            canvasPolygon$2(ctx, list, dx, dy, true);
          }

          if (isFill && fill && fill !== 'none') {
            ctx.fill(fillRule);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            ctx.stroke();
          }
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$1(item);
            });
          } else {
            d = svgPolygon$1(list);
          }

          var props = [['d', d]]; // 2个都没有常出现在多fill/stroke时，也有可能特殊单个故意这样写的

          if ((!fill || fill === 'none') && (!stroke || stroke === 'none')) {
            return;
          }

          if (isFill && fill && fill !== 'none') {
            props.push(['fill', fill.v || fill]);

            if (fillRule && fillRule !== 'nonzero') {
              // evenodd
              props.push(['fill-rule', fillRule]);
            }
          } else {
            props.push(['fill', 'none']);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            props.push(['stroke', stroke.v || stroke]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          } else {
            props.push(['stroke-width', 0]);
          }

          this.addGeom('path', props);
        }
      }
    }, {
      key: "__inversePtList",
      value: function __inversePtList(list, isMulti, t) {
        var dx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var dy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

        if (isMulti) {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            return item.map(function (item) {
              if (!item || !item.length) {
                return null;
              }

              var arr = [];

              for (var i = 0, len = item.length; i < len; i += 2) {
                var p = matrix.calPoint({
                  x: item[i] + dx,
                  y: item[i + 1] + dy
                }, t);
                arr.push(p.x);
                arr.push(p.y);
              }

              return arr;
            });
          });
        } else {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            var arr = [];

            for (var i = 0, len = item.length; i < len; i += 2) {
              var p = matrix.calPoint({
                x: item[i] + dx,
                y: item[i + 1] + dy
              }, t);
              arr.push(p.x);
              arr.push(p.y);
            }

            return arr;
          });
        }
      }
    }, {
      key: "__radialEllipse",
      value: function __radialEllipse(renderMode, ctx, list, isMulti, res, method) {
        var strokeWidth = res.strokeWidth,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        var _res$method$v = _slicedToArray(res[method].v, 4),
            color = _res$method$v[0],
            matrix$1 = _res$method$v[1],
            cx = _res$method$v[2],
            cy = _res$method$v[3]; // 椭圆渐变的转换，顶点逆矩阵变换


        matrix$1 = transform$1.calMatrixByOrigin(matrix$1, cx, cy);
        var t = matrix.inverse(matrix$1);
        list = this.__inversePtList(list, isMulti, t, dx, dy); // 用正向matrix渲染

        if (renderMode === mode.CANVAS) {
          if (matrix$1) {
            ctx.save(); // 获取当前matrix，在webgl中为E，在canvas中分无cache和有cache模式

            var me = ctx.getTransform();
            me = [me.a, me.b, 0, 0, me.c, me.d, 0, 0, 0, 0, 1, 0, me.e, me.f, 1, 0];
            matrix$1 = matrix.multiply(me, matrix$1);
            ctx.setTransform(matrix$1[0], matrix$1[1], matrix$1[4], matrix$1[5], matrix$1[12], matrix$1[13]);
          }

          ctx.beginPath();

          if (ctx[method + 'Style'] !== color) {
            ctx[method + 'Style'] = color;
          }

          if (isMulti) {
            list.forEach(function (item) {
              return painter.canvasPolygon(ctx, item, 0, 0, true);
            });
          } else {
            canvasPolygon$2(ctx, list, 0, 0, true);
          }

          ctx[method]();

          if (matrix$1) {
            ctx.restore();
          }
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$1(item);
            });
          } else {
            d = svgPolygon$1(list);
          }

          var props = [['d', d]];

          if (method === 'fill') {
            props.push(['fill', color]);
            props.push(['strokeWidth', 0]);
          } else if (method === 'stroke') {
            props.push(['fill', 'none']);
            props.push(['stroke', color]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          }

          props.push(['transform', "matrix(".concat(joinArr(matrix.m2m6(matrix$1), ','), ")")]);
          this.addGeom('path', props);
        }
      }
    }, {
      key: "__conicGradient",
      value: function __conicGradient(renderMode, ctx, list, isMulti, res) {
        var _this4 = this;

        var fill = res.fill,
            bbox = res.bbox,
            _res$dx = res.dx,
            dx = _res$dx === void 0 ? 0 : _res$dx,
            _res$dy = res.dy,
            dy = _res$dy === void 0 ? 0 : _res$dy;
        var color = fill.v;

        if (renderMode === mode.CANVAS) {
          var _bbox = _slicedToArray(bbox, 4),
              x1 = _bbox[0],
              y1 = _bbox[1],
              x2 = _bbox[2],
              y2 = _bbox[3];

          var w = x2 - x1,
              h = y2 - y1;
          var offscreen = inject.getOffscreenCanvas(w, h, '__$$CONIC_GRADIENT$$__', null);
          var imgData = offscreen.ctx.getImageData(0, 0, w, h);
          gradient$1.getConicGradientImage(w * 0.5, h * 0.5, w, h, fill.v.stop, imgData.data);
          offscreen.ctx.putImageData(imgData, 0, 0);

          if (isMulti) {
            list.forEach(function (item) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$2(ctx, item, dx, dy, true);
              ctx.clip();
              ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
              ctx.restore();
            });
          } else {
            ctx.save();
            ctx.beginPath();
            canvasPolygon$2(ctx, list, dx, dy, true);
            ctx.clip();
            ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
            ctx.restore();
          }

          offscreen.ctx.clearRect(0, 0, w, h);
        } else if (renderMode === mode.SVG) {
          if (isMulti) {
            list.forEach(function (item) {
              var v = {
                tagName: 'clipPath',
                children: [{
                  tagName: 'path',
                  props: [['d', svgPolygon$1(item)]]
                }]
              };
              var clip = ctx.add(v);

              _this4.__cacheDefs.push(v);

              color.forEach(function (item) {
                _this4.virtualDom.bb.push({
                  type: 'item',
                  tagName: 'path',
                  props: [['d', svgPolygon$1(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
                });
              });
            });
          } else {
            var v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$1(list)]]
              }]
            };
            var clip = ctx.add(v);

            this.__cacheDefs.push(v);

            color.forEach(function (item) {
              _this4.virtualDom.bb.push({
                type: 'item',
                tagName: 'path',
                props: [['d', svgPolygon$1(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
              });
            });
          }
        }
      }
    }, {
      key: "__propsStrokeStyle",
      value: function __propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (strokeDasharrayStr) {
          props.push(['stroke-dasharray', strokeDasharrayStr]);
        }

        if (strokeLinecap && strokeLinecap !== 'butt') {
          props.push(['stroke-linecap', strokeLinecap]);
        }

        if (strokeLinejoin && strokeLinejoin !== 'miter') {
          props.push(['stroke-linejoin', strokeLinejoin]);
        }

        if (strokeMiterlimit && strokeMiterlimit !== 4) {
          props.push(['stroke-miterlimit', strokeMiterlimit]);
        }
      } // offset/resize时要多一步清空props上记录的缓存

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeX", this).call(this, diff, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeY", this).call(this, diff, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "addGeom",
      value: function addGeom(tagName, props) {
        props = util.hash2arr(props);
        this.virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      }
    }, {
      key: "getProps",
      value: function getProps(k) {
        var v = this.currentProps[k];

        if (!isNil$9(v)) {
          return v;
        }

        return this['__' + k];
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      }
    }, {
      key: "animate",
      value: function animate(list) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (isNumber(options)) {
          options = {
            duration: options,
            isGeom: true
          };
        } else {
          options.isGeom = true;
        }

        return _get(_getPrototypeOf(Geom.prototype), "animate", this).call(this, list, options);
      }
    }, {
      key: "isMulti",
      get: function get() {
        return this.__isMulti;
      }
    }, {
      key: "currentProps",
      get: function get() {
        return this.__currentProps;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (name && !util.isString(name) && name.prototype && name.prototype instanceof Geom) {
          return name;
        }

        if (!name || !util.isString(name) || name.charAt(0) !== '$') {
          throw new Error('Invalid param');
        }

        if (!REGISTER.hasOwnProperty(name)) {
          throw new Error("Geom has not register: ".concat(name));
        }

        return REGISTER[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || name.charAt(0) !== '$' || !obj.prototype || !(obj.prototype instanceof Geom)) {
          throw new Error('Invalid param');
        }

        if (Geom.hasRegister(name)) {
          throw new Error("Geom has already register: ".concat(name));
        }

        REGISTER[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Geom.hasRegister(name)) {
          delete REGISTER[name];
        }
      }
    }]);

    return Geom;
  }(Xom);

  var _enums$STYLE_KEY$5 = enums.STYLE_KEY,
      DISPLAY$4 = _enums$STYLE_KEY$5.DISPLAY,
      TOP$2 = _enums$STYLE_KEY$5.TOP,
      BOTTOM$2 = _enums$STYLE_KEY$5.BOTTOM,
      POSITION$2 = _enums$STYLE_KEY$5.POSITION,
      WIDTH$3 = _enums$STYLE_KEY$5.WIDTH,
      HEIGHT$3 = _enums$STYLE_KEY$5.HEIGHT,
      MARGIN_TOP$1 = _enums$STYLE_KEY$5.MARGIN_TOP,
      MARGIN_BOTTOM$1 = _enums$STYLE_KEY$5.MARGIN_BOTTOM,
      MARGIN_LEFT$2 = _enums$STYLE_KEY$5.MARGIN_LEFT,
      BORDER_TOP_WIDTH$1 = _enums$STYLE_KEY$5.BORDER_TOP_WIDTH,
      PADDING_TOP$1 = _enums$STYLE_KEY$5.PADDING_TOP,
      BORDER_LEFT_WIDTH$2 = _enums$STYLE_KEY$5.BORDER_LEFT_WIDTH,
      PADDING_LEFT$2 = _enums$STYLE_KEY$5.PADDING_LEFT;
  var AUTO$2 = o$4.AUTO,
      PX$3 = o$4.PX,
      REM$2 = o$4.REM,
      VW$2 = o$4.VW,
      VH$2 = o$4.VH,
      VMAX$2 = o$4.VMAX,
      VMIN$2 = o$4.VMIN,
      PERCENT$2 = o$4.PERCENT;
  var REPAINT$2 = o$1.REPAINT,
      REFLOW$2 = o$1.REFLOW,
      CACHE$2 = o$1.CACHE;
  var isRelativeOrAbsolute$1 = css.isRelativeOrAbsolute;

  function clearSvgCache(node, child) {
    if (child) {
      node.__refreshLevel |= REPAINT$2;
    } else {
      node.__refreshLevel |= CACHE$2;
    }

    if (Array.isArray(node.children)) {
      node.children.forEach(function (child) {
        if (child instanceof Component) {
          child = child.shadowRoot;
        }

        clearSvgCache(child, true);
      });
    }
  } // 合并margin，和原本不合并情况下的差值


  function getMergeMargin(topList, bottomList) {
    var total = 0;
    var max = topList[0] || 0;
    var min = topList[0] || 0;
    topList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    });
    bottomList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    }); // 正数取最大，负数取最小，正负则相加

    var target = 0;

    if (max > 0 && min > 0) {
      target = Math.max(max, min);
    } else if (max < 0 && min < 0) {
      target = Math.min(max, min);
    } else if (max !== 0 || min !== 0) {
      target = max + min;
    }

    return {
      target: target,
      // 应该的目标margin
      total: total,
      // 累计的margin
      diff: target - total
    };
  } // 提取出对比节点尺寸是否固定非AUTO


  function isFixedWidthOrHeight(node, k) {
    var c = node.currentStyle[k];
    return c.u !== AUTO$2;
  } // 除了固定尺寸，父级也不能是flex


  function isFixedSize(node, includeParentFlex) {
    var res = isFixedWidthOrHeight(node, WIDTH$3) && isFixedWidthOrHeight(node, HEIGHT$3);

    if (res && includeParentFlex) {
      var parent = node.__domParent;

      if (parent) {
        if (parent.computedStyle[DISPLAY$4] === 'flex') {
          return false;
        }
      }
    }

    return res;
  }

  function getPrevMergeMargin(prev, mtList, mbList) {
    while (prev && !(prev instanceof Text) && !(prev instanceof Component && prev.shadowRoot instanceof Text) && ['block', 'flex'].indexOf(prev.computedStyle[DISPLAY$4]) > -1 && prev.computedStyle[POSITION$2] !== 'absolute') {
      mbList.push(prev.computedStyle[MARGIN_BOTTOM$1]);

      if (prev.offsetHeight > 0) {
        break;
      }

      mtList.push(prev.computedStyle[MARGIN_TOP$1]);
      prev = prev.__prev;
    }
  }

  function getNextMergeMargin(next, mtList, mbList) {
    while (next && !(next instanceof Text) && !(next instanceof Component && next.shadowRoot instanceof Text) && ['block', 'flex'].indexOf(next.computedStyle[DISPLAY$4]) > -1 && next.computedStyle[POSITION$2] !== 'absolute') {
      mtList.push(next.computedStyle[MARGIN_TOP$1]);

      if (next.offsetHeight > 0) {
        break;
      }

      mbList.push(next.computedStyle[MARGIN_BOTTOM$1]);
      next = next.__next;
    }
  }

  function offsetNext(next, diff, parentFixed, absList) {
    while (next) {
      var cs = next.currentStyle; // flow流和auto/px/rem的absolute流需要偏移diff值

      if (cs[POSITION$2] !== 'absolute' || cs[TOP$2].u === AUTO$2 && cs[BOTTOM$2].u === AUTO$2 || cs[TOP$2].u === AUTO$2 && [PX$3, REM$2, VW$2, VH$2, VMAX$2, VMIN$2].indexOf(cs[BOTTOM$2].u) > -1) {
        next.__offsetY(diff, true, REFLOW$2);
      } // absolute中百分比的特殊计算偏移，但要排除parent固定尺寸
      else if (!parentFixed && cs[POSITION$2] === 'absolute' && (cs[TOP$2].u === PERCENT$2 || cs[BOTTOM$2].u === PERCENT$2)) {
        if (cs[TOP$2].u === PERCENT$2) {
          next.__offsetY(diff * 0.01 * cs[TOP$2].v, true, REFLOW$2);
        } else {
          next.__offsetY(diff * (1 - 0.01 * cs[BOTTOM$2].v), true, REFLOW$2);
        }
      } // abs的percent调整，记录


      if (!(cs instanceof Text) && !(cs instanceof Component && cs.shadowRoot instanceof Text)) {
        if (cs[POSITION$2] === 'absolute' && cs[HEIGHT$3].u === PERCENT$2) {
          absList.push(next);
        }
      }

      next = next.__next;
    }

    return diff;
  }
  /**
   * 单独提出共用检测影响的函数，从节点本身开始向上分析影响，找到最上层的影响节点设置其重新布局
   * ---
   * 当一个元素absolute时，其变化不会影响父元素和兄弟元素，直接自己重新layout
   * 当absolute发生改变时，其变化会影响父和兄弟，视作父重新布局
   * 当inline变化时，视为其最近block/flex父变化
   * 当block/flex变化时，往上查找最上层flex视为其变化，如没有flex则影响后面兄弟offset和父resize
   * 以上情况向上查找时遇到父absolute均提前跳出，并layout
   * 上面所有情况即便结束还得额外看是否处于absolute中，是还是标记absolute重新布局
   * 当relative只变化left/top/right/bottom时，自己重新layout
   * ===
   * 返回最上层节点，可能为node自己
   */


  function checkTop(root, node, addDom, removeDom) {
    if (root === node) {
      return root;
    }

    if (node instanceof Text) {
      node = node.__domParent;
    } // add/remove情况abs节点特殊对待不影响其它节点，不能判断display，因为inline会强制block


    if (addDom && node.currentStyle[POSITION$2] === 'absolute') {
      return node;
    }

    if (removeDom && node.computedStyle[POSITION$2] === 'absolute') {
      return node;
    }

    var target = node; // add/remove的相邻出现inline的话，视为父节点reflow

    if (addDom || removeDom) {
      var isSiblingBlock = true;
      var _node = node,
          __prev = _node.__prev,
          __next = _node.__next;

      if (__prev && (__prev instanceof Text || ['inline', 'inlineBlock'].indexOf(__prev.computedStyle[DISPLAY$4]) > -1)) {
        isSiblingBlock = false;
      } else if (__next && (__next instanceof Text || ['inline', 'inlineBlock'].indexOf(__next.computedStyle[DISPLAY$4]) > -1)) {
        isSiblingBlock = false;
      }

      if (!isSiblingBlock) {
        target = node.__domParent;

        if (target === root) {
          return root;
        }
      }
    } // 如果一直是absolute，则不影响其它节点


    if (target.currentStyle[POSITION$2] === 'absolute' && target.computedStyle[POSITION$2] === 'absolute') {
      return target;
    } // inline节点变为最近的父非inline，自身可能会display变化前后状态都要看，
    // absolute不变会影响但被上面if排除，而absolute发生变化则也需要进入这里


    if (['inline', 'inlineBlock'].indexOf(target.currentStyle[DISPLAY$4]) > -1 || ['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$4]) > -1) {
      do {
        target = target.__domParent;

        if (target === root) {
          return root;
        }
      } // 父节点不会display变化，因为同步检测，只看computedStyle即可
      while (['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$4]) > -1 && target.computedStyle[POSITION$2] !== 'absolute'); // target已不是inline，父固定宽高跳出直接父进行LAYOUT即可，不影响上下文，但不能是flex孩子，此时固定尺寸无用
      // root也会进这里，因为root强制固定size


      if (isFixedSize(target, true)) {
        return target;
      }
    } // 此时target指向node，如果是inline/absolute变化则是其最近的非inline父


    var parent = target; // 向上检查flex/absolute/fixedSize，以最上层的flex视作其更改，node本身flex不进入

    var top;

    do {
      if (parent === root) {
        break;
      }

      if (parent.computedStyle[DISPLAY$4] === 'flex') {
        top = parent;
      } // 遇到固定size提前跳出，以及absolute也是


      if (parent.computedStyle[POSITION$2] === 'absolute' || isFixedSize(parent, true)) {
        break;
      }

      parent = parent.__domParent;
    } while (parent); // 找到最上层flex，视作其更改


    if (top) {
      target = top;
    }

    return target;
  }
  /**
   * checkReflow之后，节点重新布局对自己next的节点的offset影响，计算偏移量让所有next兄弟offsetY，
   * 以及递归向上父级resize和父级所有next兄弟offsetY
   */


  function checkNext(root, top, node, hasZ, addDom, removeDom) {
    var cps = top.computedStyle,
        crs = top.currentStyle;
    var position = cps[POSITION$2],
        display = cps[DISPLAY$4];
    var isLastAbs = position === 'absolute';
    var isNowAbs = crs[POSITION$2] === 'absolute';
    var isLastNone = display === 'none';
    var isNowNone = crs[DISPLAY$4] === 'none';
    var isLast0 = top.offsetHeight === 0; // none不可见布局无效可以无视，add/remove已提前判断，none时不会进来

    if (isLastNone && isNowNone) {
      return;
    }

    var parent = top.__domParent,
        oldH = top.offsetHeight; // svg在特殊children顺序变化的情况需清除缓存以便diff运行
    // add/remove已提前自己做好，zIndex有效变化也触发，position变更static和非static触发

    var svg = root.renderMode === mode.SVG;

    if (!addDom && !removeDom) {
      if (hasZ && position === 'static' && crs[POSITION$2] === 'static') {
        hasZ = false;
      } else if (position !== crs[POSITION$2] && (position === 'static' || crs[POSITION$2] === 'static')) {
        hasZ = true;
      } // 特殊，zIndexChildren不变化但影响svg的diff
      else if (isLastNone !== isNowNone && !hasZ) {
        svg && clearSvgCache(parent, false);
      }
    } else {
      hasZ = false;
    } // remove自身且abs时不影响其它，除了svg的zIndex


    if (removeDom && top === node && node.computedStyle[POSITION$2] === 'absolute') {
      top.clearCache(true);
      svg && clearSvgCache(parent, false);
      return;
    } // 后续调整offsetY需要考虑mergeMargin各种情况（包含上下2个方向），之前合并前和合并后的差值都需记录
    // 先记录没更新前的，如果是空节点则m1作为整个，忽视m2


    var t1 = 0,
        t2 = 0;
    var mbList = [],
        mtList = [];
    var prev = top.isShadowRoot ? top.__hostRoot.__prev : top.__prev;
    var next = top.isShadowRoot ? top.__hostRoot.__next : top.__next;

    if (addDom || isLast0) {
      getPrevMergeMargin(prev, mtList, mbList);
      getNextMergeMargin(next, mtList, mbList);

      if (!addDom) {
        mtList.push(cps[MARGIN_TOP$1]);
        mbList.push(cps[MARGIN_BOTTOM$1]);
      }

      var t = getMergeMargin(mtList, mbList);
      t1 = t.target;
      t.diff;
    } else {
      getPrevMergeMargin(prev, mtList, mbList);
      mtList.push(cps[MARGIN_TOP$1]);

      var _t = getMergeMargin(mtList, mbList);

      t1 = _t.target;
      _t.diff;
      mtList.splice(0);
      mbList.splice(0);
      getNextMergeMargin(next, mtList, mbList);
      mbList.push(cps[MARGIN_BOTTOM$1]);
      _t = getMergeMargin(mtList, mbList);
      t2 = _t.target;
      _t.diff;
    } // __layoutData使用prev或者父节点，并重新计算y（不包含合并margin），因为display:none或add的无数据或不对


    var __layoutData = parent.__layoutData;
    var x = __layoutData.x;
    var y = __layoutData.y;
    var w = parent.__width;
    var h = parent.__currentStyle[HEIGHT$3].u === AUTO$2 ? __layoutData.h : parent.__height;
    var current = top; // cp的shadowRoot要向上到cp本身，考虑高阶组件在内到真正的顶层cp

    if (current.isShadowRoot) {
      current = current.__hostRoot;
    } // y使用prev或者parent的，首个节点无prev，prev要忽略absolute的和display:none的


    var ref = current.__prev;
    var hasFlowPrev;

    while (ref) {
      // 注意有可能是text，此时可以直接用text位置，因为none的话不会进来，而text绝对不会absolute
      var isText = ref instanceof Text;
      var computedStyle = ref.computedStyle;

      if (isText || computedStyle[POSITION$2] !== 'absolute' && computedStyle[DISPLAY$4] !== 'none') {
        y = ref.y + ref.outerHeight;
        hasFlowPrev = true;
        break;
      }

      ref = ref.__prev;
    } // 找不到prev以默认parent的为基准，找到则增加自身，排除remove


    var __computedStyle = parent.__computedStyle;

    if (!hasFlowPrev) {
      y += __computedStyle[MARGIN_TOP$1] + __computedStyle[BORDER_TOP_WIDTH$1] + __computedStyle[PADDING_TOP$1];
    }

    x += __computedStyle[MARGIN_LEFT$2] + __computedStyle[BORDER_LEFT_WIDTH$2] + __computedStyle[PADDING_LEFT$2]; // 特殊的如add/remove时为absolute和none的在调用时即检查提前跳出了，不触发reflow，这里一定是触发的
    // 找到最上层容器供absolute使用，注意top本身是否abs的区别，非abs可能为relative）

    var container = isNowAbs ? parent : top;

    while (container && container !== root) {
      if (isRelativeOrAbsolute$1(container)) {
        break;
      }

      container = container.__domParent;
    }

    if (!container) {
      container = root;
    } // 删除的节点的影响top是自己，无需重新布局只要看next节点的offsetY


    if (removeDom && top === node) ; // 一定不是add/remove，同步操作提前判断
    else if (isNowNone) {
      top.__layoutNone();

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      }
    } // 现在是定位流，还要看之前是什么
    else if (isNowAbs) {
      parent.__layoutAbs(container, __layoutData, top);

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      } // add/remove的zIndex已提前做好无需关心，只看普通变更


      if (!addDom && !removeDom) {
        // 之前也是abs，可以跳出不会影响其它只看zIndex即可
        if (isLastAbs) {
          top.clearCache(true);
          return;
        }
      }
    } // 现在是普通流，不管之前是啥直接布局
    else {
      var ld = Object.assign({}, addDom ? __layoutData : top.__layoutData, {
        x: x,
        y: y,
        w: w,
        h: h
      });

      top.__layout(ld, false, false, false); // 防止Geom


      if (!(top instanceof Geom)) {
        top.__layoutAbs(container, ld, null);
      }

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      }
    } // add的情况在自身是abs时不影响next，除了svg的zIndex


    if (addDom && top === node && node.currentStyle[POSITION$2] === 'absolute') {
      top.clearCache(true);
      svg && clearSvgCache(parent, false);
      return;
    } // 向上查找最近的relative的parent，获取ox/oy并赋值，无需继续向上递归，因为parent已经递归包含了


    var p = parent;

    while (p) {
      if (p.__computedStyle[POSITION$2] === 'relative') {
        var _p = p,
            ox = _p.ox,
            oy = _p.oy;
        ox && top.__offsetX(ox, false, null);
        oy && top.__offsetY(oy, false, null);
        break;
      }

      p = p.__domParent;
    } // 高度不变一直0提前跳出，不影响包含margin合并，但需排除节点add/remove，因为空节点会上下穿透合并


    var isNow0 = removeDom && top === node || top.offsetHeight === 0; // 几种忽略的情况

    if (addDom && isNow0 || removeDom && isLast0) {
      top.clearCache(true);
      return;
    } // 查看现在的上下margin合并情况，和之前的对比得出diff差值进行offsetY/resizeY


    if (top.isShadowRoot) {
      top = top.__hostRoot;
    }

    var t3 = 0,
        d3 = 0,
        t4 = 0;
    mbList.splice(0);
    mtList.splice(0);

    if (removeDom || isNow0) {
      getPrevMergeMargin(prev, mtList, mbList);
      getNextMergeMargin(next, mtList, mbList);

      if (!removeDom) {
        mtList.push(cps[MARGIN_TOP$1]);
        mbList.push(cps[MARGIN_BOTTOM$1]);
      }

      var _t2 = getMergeMargin(mtList, mbList);

      t3 = _t2.target;
      d3 = _t2.diff;
    } else {
      getPrevMergeMargin(prev, mtList, mbList);
      mtList.push(cps[MARGIN_TOP$1]);

      var _t3 = getMergeMargin(mtList, mbList);

      t3 = _t3.target;
      d3 = _t3.diff;
      mtList.splice(0);
      mbList.splice(0);
      getNextMergeMargin(next, mtList, mbList);
      mbList.push(cps[MARGIN_BOTTOM$1]);
      _t3 = getMergeMargin(mtList, mbList);
      t4 = _t3.target;
      _t3.diff;
    }

    var nowH;

    if (removeDom) {
      // remove有没有向上影响，决定布局后的高度nowH
      var isRemoveSelf = top === node || node.isShadowRoot && node.__hostRoot === top;

      if (isRemoveSelf) {
        nowH = 0;
      } else {
        nowH = top.offsetHeight;
      }
    } else if (isNowAbs) {
      nowH = 0;
    } else {
      nowH = top.offsetHeight;
    } // 查看mergeMargin对top造成的偏移


    if (!removeDom && d3) {
      top.__offsetY(d3, true, REFLOW$2);
    } // 差值计算注意考虑margin合并前的值，和合并后的差值，height使用offsetHeight不考虑margin


    var diff = t3 + t4 - t1 - t2 + nowH - oldH; // console.log('t3', t3, 'd3', d3, 't4', t4, 'd4', d4, 't1', t1, 'd1', d1, 't2', t2, 'd2', d2, nowH, oldH, diff);

    if (!diff) {
      top.clearCache(true);
      return;
    }

    var parentFixed = isFixedWidthOrHeight(parent, HEIGHT$3);

    if (!parentFixed) {
      parent.__resizeY(diff, REFLOW$2);
    } // 调整的同时遇到百分比高度的abs需记录下来最后重新布局


    var absList = [];
    offsetNext(next, diff, parentFixed, absList);
    top.clearCache(true); // 影响完next之后，向上递归，所有parent的next都影响，遇到固定尺寸或absolute跳出

    while (parent && !parentFixed && parent.__computedStyle[POSITION$2] !== 'absolute') {
      next = parent.__next;
      parent = parent.__domParent;
      parentFixed = parent && isFixedWidthOrHeight(parent, HEIGHT$3);

      if (!parentFixed) {
        parent.__resizeY(diff, REFLOW$2);
      }

      offsetNext(next, diff, parentFixed, absList);

      if (parentFixed) {
        parent.clearCache(false);
      }
    } // 记录的受影响的abs节点，都是百分比高度，需重新布局


    absList.forEach(function (item) {
      var ld = item.__layoutData,
          container = ld.container;

      item.__domParent.__layoutAbs(container, ld, item);
    });
  }

  var reflow = {
    getMergeMargin: getMergeMargin,
    checkTop: checkTop,
    checkNext: checkNext,
    clearSvgCache: clearSvgCache
  };

  /**
   * 打平children，多维嵌套的数组变成一维
   */

  function buildChildren(parent, children) {
    var list = [];
    flatten(parent, children, list);
    return list;
  }

  function flatten(parent, children, list) {
    if (Array.isArray(children)) {
      children.forEach(function (item) {
        flatten(parent, item, list);
      });
    } else if (children instanceof Xom) {
      if (['canvas', 'svg', 'webgl'].indexOf(children.tagName) > -1) {
        throw new Error('Can not nest canvas/svg/webgl');
      }

      children.__parent = parent;
      list.push(children);
    } else if (children instanceof Component) {
      children.__parent = parent;
      list.push(children);
    } else if (!util.isNil(children) && children !== '') {
      var t = new Text(children);
      t.__parent = parent;
      list.push(t);
    }
  }
  /**
   * 设置关系，父子和兄弟，被添加到真实dom中前调用
   */


  function relation(root, host, parent, children) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    if (Array.isArray(children)) {
      children.forEach(function (item) {
        relation(root, host, parent, item, options);
      });
    } else if (children instanceof Xom || children instanceof Component || children instanceof Text) {
      children.__root = root;
      children.__host = children.__hostRoot = host;
      children.__parent = parent;
      children.__domParent = parent;
      children.__isDestroyed = false;

      if (options.prev) {
        options.prev.__next = children;
        children.__prev = options.prev;
      }

      options.prev = children; // wasm

      var wr = root.__wasmRoot;

      if (wr) {
        if (children instanceof Xom) {
          children.__wasmNode = wasm$1.Node["new"](false);
        } else if (children instanceof Text) {
          children.__wasmNode = wasm$1.Node["new"](true);
        }
      } // ref


      if (!(children instanceof Text)) {
        var ref = children.props.ref;

        if (util.isString(ref) && ref || util.isNumber(ref)) {
          host.ref[ref] = children;
        } else if (ref && util.isFunction(ref)) {
          ref(children);
        }
      }

      if (children instanceof Xom && children.__children) {
        relation(root, host, children, children.__children, {});
      } else if (children instanceof Component) {
        var sr = children.render();
        var hoc = [];

        while (sr && sr instanceof Component) {
          hoc.push(sr);
          var res = sr.render();

          if (res) {
            sr.__shadow = res;
            res.__host = sr;
          }

          sr = res;
        }

        if (!(sr instanceof Node$1)) {
          sr = new Text(sr);
        }

        if (hoc.length) {
          children.__shadow = hoc[0];
          hoc[0].__host = children;
          hoc.forEach(function (item) {
            item.__shadowRoot = sr;
            item.__hostRoot = children;
            item.__root = root;
            item.__domParent = parent;
          });
        } else {
          children.__shadow = sr;
          sr.__host = children;
        }

        children.__shadowRoot = sr;
        sr.__hostRoot = children;
        sr.__root = root;
        sr.__domParent = parent;
        sr.__isDestroyed = false;

        children.__init();

        if (sr instanceof Xom && sr.__children) {
          relation(root, children, sr, sr.__children, {});
        } // wasm


        if (wr) {
          if (sr instanceof Xom) {
            sr.__wasmNode = wasm$1.Node["new"](false);
          } else if (sr instanceof Text) {
            sr.__wasmNode = wasm$1.Node["new"](true);
          }
        }
      }
    }

    return children;
  } // 设置每个节点root引用，组件初始化


  function buildRoot(root, children) {
    root.__root = root;
    root.__host = root;
    relation(root, root, root, children, {});
  }

  var builder = {
    buildChildren: buildChildren,
    buildRoot: buildRoot,
    relation: relation
  };

  var _enums$STYLE_KEY$4 = enums.STYLE_KEY,
      POSITION$1 = _enums$STYLE_KEY$4.POSITION,
      DISPLAY$3 = _enums$STYLE_KEY$4.DISPLAY,
      MARGIN_LEFT$1 = _enums$STYLE_KEY$4.MARGIN_LEFT,
      MARGIN_TOP = _enums$STYLE_KEY$4.MARGIN_TOP,
      MARGIN_RIGHT$1 = _enums$STYLE_KEY$4.MARGIN_RIGHT,
      MARGIN_BOTTOM = _enums$STYLE_KEY$4.MARGIN_BOTTOM,
      PADDING_LEFT$1 = _enums$STYLE_KEY$4.PADDING_LEFT,
      PADDING_BOTTOM = _enums$STYLE_KEY$4.PADDING_BOTTOM,
      PADDING_RIGHT$1 = _enums$STYLE_KEY$4.PADDING_RIGHT,
      PADDING_TOP = _enums$STYLE_KEY$4.PADDING_TOP,
      BORDER_TOP_WIDTH = _enums$STYLE_KEY$4.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH = _enums$STYLE_KEY$4.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$1 = _enums$STYLE_KEY$4.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$1 = _enums$STYLE_KEY$4.BORDER_LEFT_WIDTH,
      TOP$1 = _enums$STYLE_KEY$4.TOP,
      RIGHT$1 = _enums$STYLE_KEY$4.RIGHT,
      BOTTOM$1 = _enums$STYLE_KEY$4.BOTTOM,
      LEFT$1 = _enums$STYLE_KEY$4.LEFT,
      WIDTH$2 = _enums$STYLE_KEY$4.WIDTH,
      HEIGHT$2 = _enums$STYLE_KEY$4.HEIGHT,
      TEXT_ALIGN = _enums$STYLE_KEY$4.TEXT_ALIGN,
      FLEX_DIRECTION = _enums$STYLE_KEY$4.FLEX_DIRECTION,
      FLEX_BASIS$1 = _enums$STYLE_KEY$4.FLEX_BASIS,
      FLEX_SHRINK = _enums$STYLE_KEY$4.FLEX_SHRINK,
      FLEX_GROW = _enums$STYLE_KEY$4.FLEX_GROW,
      ALIGN_SELF = _enums$STYLE_KEY$4.ALIGN_SELF,
      ALIGN_ITEMS = _enums$STYLE_KEY$4.ALIGN_ITEMS,
      JUSTIFY_CONTENT = _enums$STYLE_KEY$4.JUSTIFY_CONTENT,
      Z_INDEX$1 = _enums$STYLE_KEY$4.Z_INDEX,
      WHITE_SPACE = _enums$STYLE_KEY$4.WHITE_SPACE,
      LINE_HEIGHT = _enums$STYLE_KEY$4.LINE_HEIGHT,
      LINE_CLAMP = _enums$STYLE_KEY$4.LINE_CLAMP,
      ORDER = _enums$STYLE_KEY$4.ORDER,
      FLEX_WRAP = _enums$STYLE_KEY$4.FLEX_WRAP,
      ALIGN_CONTENT = _enums$STYLE_KEY$4.ALIGN_CONTENT,
      OVERFLOW$1 = _enums$STYLE_KEY$4.OVERFLOW,
      FONT_SIZE$2 = _enums$STYLE_KEY$4.FONT_SIZE,
      FONT_FAMILY = _enums$STYLE_KEY$4.FONT_FAMILY,
      FONT_WEIGHT = _enums$STYLE_KEY$4.FONT_WEIGHT,
      WRITING_MODE$1 = _enums$STYLE_KEY$4.WRITING_MODE,
      ELLIPSIS = enums.ELLIPSIS;
  var AUTO$1 = o$4.AUTO,
      PX$2 = o$4.PX,
      PERCENT$1 = o$4.PERCENT,
      REM$1 = o$4.REM,
      VW$1 = o$4.VW,
      VH$1 = o$4.VH,
      VMAX$1 = o$4.VMAX,
      VMIN$1 = o$4.VMIN;
  var isRelativeOrAbsolute = css.isRelativeOrAbsolute,
      getBaseline = css.getBaseline,
      getVerticalBaseline = css.getVerticalBaseline;
  var extend$1 = util.extend,
      isFunction$3 = util.isFunction;
  var CANVAS = mode.CANVAS,
      SVG = mode.SVG,
      WEBGL = mode.WEBGL;
  var isE$2 = matrix.isE,
      multiply$1 = matrix.multiply,
      assignMatrix$1 = matrix.assignMatrix;
  var REFLOW$1 = o$1.REFLOW; // 渲染获取zIndex顺序

  function genZIndexChildren(dom) {
    var normal = [];
    var hasMc;
    var mcHash = {};
    var lastMaskIndex;
    var children = dom.children;
    children.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component) {
        item = item.shadowRoot;
      } // 遮罩单独保存后特殊排序


      if (item instanceof Xom && item.__mask) {
        // 开头的mc忽略，后续的连续mc以第一次出现为准
        if (lastMaskIndex !== undefined) {
          mcHash[lastMaskIndex].push(item);
        } else if (i) {
          lastMaskIndex = i - 1;
          children[lastMaskIndex].__iIndex = lastMaskIndex;
          mcHash[lastMaskIndex] = [item];
          hasMc = true;
        }
      } else {
        lastMaskIndex = undefined;

        if (item instanceof Xom) {
          child.__zIndex = item.currentStyle[Z_INDEX$1];

          if (isRelativeOrAbsolute(item)) {
            // 临时变量为排序使用
            child.__aIndex = true;
            normal.push(child);
          } else {
            // 之前遗留清除
            child.__aIndex = undefined;
            normal.push(child);
          }
        } else {
          child.__zIndex = 0;
          normal.push(child);
        }

        child.__iIndex = i;
      }
    });
    normal.sort(function (a, b) {
      if (a.__zIndex !== b.__zIndex) {
        return a.__zIndex - b.__zIndex;
      } // zIndex相等时abs优先flow


      if (a.__aIndex !== b.__aIndex) {
        if (a.__aIndex) {
          return 1;
        }

        return -1;
      } // 都相等看索引


      return a.__iIndex - b.__iIndex;
    }); // 将遮罩插入到对应顺序上

    if (hasMc) {
      for (var i = normal.length - 1; i >= 0; i--) {
        var idx = normal[i].__iIndex;

        if (mcHash.hasOwnProperty(idx)) {
          normal.splice.apply(normal, [i + 1, 0].concat(_toConsumableArray(mcHash[idx])));
        }
      }
    }

    return normal;
  } // flex布局阶段顺序，不是渲染也和struct结构无关，可以无视mask


  function genOrderChildren(flowChildren) {
    var normal = [];
    flowChildren.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component) {
        item = item.shadowRoot;
      }

      if (item instanceof Xom) {
        child.__order = item.currentStyle[ORDER];
      } else {
        child.__order = 0;
      }

      normal.push(child);
      child.__iIndex = i;
    });
    normal.sort(function (a, b) {
      if (a.__order !== b.__order) {
        return a.__order - b.__order;
      } // order相等时看节点索引


      return a.__iIndex - b.__iIndex;
    });
    return normal;
  }
  /**
   * lineClamp超出范围时ib作为最后一行最后一个无法挤下时进行回溯
   */


  function backtrack(bp, lineBoxManager, lineBox, total, endSpace, isUpright) {
    var ew,
        computedStyle = bp.computedStyle,
        root = bp.root,
        renderMode = root.renderMode;
    var list = lineBox.list; // 根据textBox里的内容，确定当前内容，索引，x和剩余宽度

    list.forEach(function (item) {
      total -= isUpright ? item.outerHeight : item.outerWidth;
    });
    var ctx;

    if (renderMode === CANVAS || renderMode === WEBGL) {
      ctx = renderMode === WEBGL ? inject.getFontCanvas().ctx : root.ctx;
    } // 临时测量ELLIPSIS的尺寸


    if (renderMode === CANVAS || renderMode === WEBGL) {
      var font = css.setFontStyle(computedStyle);

      if (ctx.font !== font) {
        ctx.font = font;
      }

      ew = ctx.measureText(ELLIPSIS).width;
    } else {
      ew = inject.measureTextSync(ELLIPSIS, computedStyle[FONT_FAMILY], computedStyle[FONT_SIZE$2], computedStyle[FONT_WEIGHT], false);
    }

    for (var i = list.length - 1; i >= 0; i--) {
      var item = list[i]; // 无论删除一个ib还是textBox，放得下的话都可以暂停循环，注意强制保留行首

      if (!i || total + item.outerWidth >= ew + 1e-10) {
        if (item instanceof TextBox) {
          var text = item.parent;

          text.__backtrack(bp, lineBoxManager, lineBox, item, total, endSpace, ew, computedStyle, ctx, renderMode, isUpright);
        } else {
          var ep = new Ellipsis(item.x + item.outerWidth + endSpace, item.y, ew, bp, item, isUpright);
          lineBoxManager.addItem(ep, true);
        }

        break;
      } // 放不下删除
      else {
        if (item instanceof TextBox) {
          var _text = item.parent;

          var _i = _text.textBoxes.indexOf(item);

          if (_i > -1) {
            _text.textBoxes.splice(_i, 1);
          }
        } else {
          item.__layoutNone();
        }

        list.pop();
        total += isUpright ? item.outerHeight : item.outerWidth;
      }
    }
  }

  var Dom = /*#__PURE__*/function (_Xom) {
    _inherits(Dom, _Xom);

    function Dom(tagName, props, children) {
      var _this;

      _this = _Xom.call(this, tagName, props) || this;

      var _assertThisInitialize = _assertThisInitialized(_this),
          style = _assertThisInitialize.style;

      if (!style.display || !{
        flex: true,
        block: true,
        inline: true,
        'inline-block': true,
        inlineBlock: true,
        none: true
      }.hasOwnProperty(style.display)) {
        if (tag.INLINE.hasOwnProperty(_this.tagName)) {
          style.display = 'inline';
        } else {
          style.display = 'block';
        }
      }

      if (!style[FONT_WEIGHT] && tag.BOLD.hasOwnProperty(tagName)) {
        style.fontWeight = 700;
      }

      _this.__style = css.normalize(style, reset.DOM_ENTRY_SET); // currentStyle/currentProps不深度clone，继承一层即可，动画时也是extend这样只改一层引用不动原始静态style

      _this.__currentStyle = extend$1([], _this.__style);
      _this.__children = builder.buildChildren(_assertThisInitialized(_this), children);
      _this.__flexLine = []; // flex布局多行模式时存储行

      _this.__ellipsis = null; // 虚拟节点，有的话渲染

      _this.__zIndexChildren = null;
      return _this;
    }

    _createClass(Dom, [{
      key: "__structure",
      value: function __structure(lv, j) {
        var res = _get(_getPrototypeOf(Dom.prototype), "__structure", this).call(this, lv, j);

        var arr = [res];
        var zIndexChildren = this.__zIndexChildren = this.__zIndexChildren || genZIndexChildren(this);
        zIndexChildren.forEach(function (child, i) {
          var temp = child.__structure(lv + 1, i);

          if (Array.isArray(temp)) {
            arr = arr.concat(temp);
          } else {
            arr.push(temp);
          }
        });
        var total = arr.length - 1;
        res.num = zIndexChildren.length;
        res.total = total;
        return arr;
      }
    }, {
      key: "__insertStruct",
      value: function __insertStruct(child, childIndex) {
        var struct = this.__struct;

        var cs = child.__structure(struct.lv + 1, childIndex);

        var root = this.__root,
            structs = root.__structs; // 根据是否有prev确定插入索引位置

        var zIndexChildren = this.__zIndexChildren;
        var i;

        if (childIndex) {
          var ps = zIndexChildren[childIndex - 1].__struct;

          var _total = ps.total || 0;

          i = structs.indexOf(ps) + _total + 1;
        } else {
          i = structs.indexOf(struct) + 1;
        }

        var total,
            wr = root.__wasmRoot;

        if (Array.isArray(cs)) {
          structs.splice.apply(structs, [i, 0].concat(_toConsumableArray(cs)));
          total = (cs[0].total || 0) + 1;

          if (wr) {
            for (var j = cs.length - 1; j >= 0; j--) {
              wr.insert_node(i, cs[j].node.__wasmNode.ptr);
            }
          }
        } else {
          structs.splice(i, 0, cs);
          total = (cs.total || 0) + 1;

          if (wr) {
            wr.insert_node(i, cs.node.__wasmNode.ptr);
          }
        } // 调整后面children的childIndex，+1


        i++;

        for (var len = zIndexChildren.length; i < len; i++) {
          zIndexChildren[i].__struct.childIndex++;
        } // 向上添加parent的total数量


        struct.num++;
        struct.total += total;
        var p = this.__domParent;

        while (p) {
          struct = p.__struct;
          struct.total = struct.total || 0;
          struct.total += total;
          p = p.__domParent;
        }
      }
    }, {
      key: "__deleteStruct",
      value: function __deleteStruct(child, childIndex) {
        var cs = child.__struct; // 未添加到真实DOM时没有

        if (!cs) {
          return;
        }

        var total = (cs.total || 0) + 1;
        var root = this.__root,
            structs = root.__structs;
        var i = structs.indexOf(cs);
        structs.splice(i, total);
        var wr = root.__wasmRoot;

        if (wr) {
          for (var j = i + total; j >= i; j--) {
            wr.remove_node(j);
          }
        } // zIndexChildren后面的childIndex偏移


        var zIndexChildren = this.__zIndexChildren;

        for (var _i2 = childIndex + 1, len = zIndexChildren.length; _i2 < len; _i2++) {
          zIndexChildren[_i2].__struct.childIndex--;
        } // 向上减少parent的total数量


        var struct = this.__struct;
        struct.num--;
        struct.total = struct.total || 0;
        struct.total -= total;
        var p = this.__domParent;

        while (p) {
          struct = p.__struct;
          struct.total = struct.total || 0;
          struct.total -= total;
          p = p.__domParent;
        }
      }
      /**
       * 因为zIndex/abs/add的变化造成的更新，只需重排这一段顺序即可
       */

    }, {
      key: "__updateStruct",
      value: function __updateStruct() {
        var root = this.__root;
        var structs = root.__structs;
        var struct = this.__struct;
        var total = struct.total || 0;
        var index = structs.indexOf(struct);
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);
        var length = zIndexChildren.length;

        if (length === 1) {
          return;
        }

        var needSort;
        zIndexChildren.forEach(function (child, i) {
          var cs = child.__struct;
          cs.childIndex = i; // 仅后面排序用
        }); // 按之前的structs划分为相同数量的若干段进行排序

        var source = [],
            count = 0;

        for (var i = index + 1; i <= index + total; i++) {
          var cs = structs[i];
          var o = {
            cs: cs,
            list: structs.slice(i, i + (cs.total || 0) + 1)
          };

          if (cs.childIndex !== count++) {
            needSort = true;
          }

          source.push(o);
          i += cs.total || 0;
        }

        if (needSort) {
          var list = [];
          source.sort(function (a, b) {
            return a.cs.childIndex - b.cs.childIndex;
          });
          source.forEach(function (item) {
            list = list.concat(item.list);
          });
          structs.splice.apply(structs, [index + 1, total].concat(_toConsumableArray(list)));
          var wr = root.__wasmRoot;

          if (wr) {
            for (var _i3 = index + 1; _i3 <= index + total; _i3++) {
              wr.set_node(structs[_i3].node, _i3);
            }
          }
        }
      }
      /**
       * 给定父宽度情况下，尝试行内放下后的剩余宽度，为负数即放不下，这里只会出现行内级即inline(Block)
       * 调用前提是非行开头的inline尝试计算是否放得下，开头无需且禁止判断，防止出现永远放不下一个字符卡死
       * 返回非负数就是放得下，这样一些尺寸为0的也算
       * @param free 剩余宽度
       * @param total 容器尺寸
       * @param isUpright 垂直排版
       * @returns {number|*}
       * @private
       */

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(free, total, isUpright) {
        this.__computeReflow();

        var flowChildren = this.flowChildren,
            _this$currentStyle = this.currentStyle,
            display = _this$currentStyle[DISPLAY$3],
            width = _this$currentStyle[WIDTH$2],
            height = _this$currentStyle[HEIGHT$2],
            marginLeft = _this$currentStyle[MARGIN_LEFT$1],
            marginRight = _this$currentStyle[MARGIN_RIGHT$1],
            marginTop = _this$currentStyle[MARGIN_TOP],
            marginBottom = _this$currentStyle[MARGIN_BOTTOM],
            paddingLeft = _this$currentStyle[PADDING_LEFT$1],
            paddingRight = _this$currentStyle[PADDING_RIGHT$1],
            paddingTop = _this$currentStyle[PADDING_TOP],
            paddingBottom = _this$currentStyle[PADDING_BOTTOM],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$1],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$1],
            borderTopWidth = _this$computedStyle[BORDER_TOP_WIDTH],
            borderBottomWidth = _this$computedStyle[BORDER_BOTTOM_WIDTH]; // inline没w/h，并且尝试孩子第一个能放下即可，如果是文字就是第一个字符

        if (display === 'inline') {
          if (flowChildren.length) {
            var first = flowChildren[0];

            if (first instanceof Component) {
              first = first.shadowRoot;
            }

            if (first instanceof Xom) {
              free = first.__tryLayInline(free, total, isUpright);
            } else {
              free -= first.firstCharWidth;
            }
          }
        } // inlineBlock尝试所有孩子在一行上
        else {
          if (width.u !== AUTO$1) {
            free -= isUpright ? this.__calSize(height, total, true) : this.__calSize(width, total, true);
          } else {
            for (var i = 0; i < flowChildren.length; i++) {
              // 当放不下时直接返回，无需继续多余的尝试计算
              if (free < 0) {
                return free;
              }

              var item = flowChildren[i];

              if (item instanceof Component) {
                item = item.shadowRoot;
              }

              if (item instanceof Xom) {
                free = item.__tryLayInline(free, total, isUpright);
              } // text强制一行，否则非头就是放不下，需从头开始
              else {
                free -= item.textWidth;
              }
            }
          } // ib要减去末尾mpb


          if (isUpright) {
            free -= this.__calSize(marginBottom, total, true);
            free -= this.__calSize(paddingBottom, total, true);
            free -= borderBottomWidth;
          } else {
            free -= this.__calSize(marginRight, total, true);
            free -= this.__calSize(paddingRight, total, true);
            free -= borderRightWidth;
          }
        } // 还要减去开头的mpb


        if (isUpright) {
          free -= this.__calSize(marginTop, total, true);
          free -= this.__calSize(paddingTop, total, true);
          free -= borderTopWidth;
        } else {
          free -= this.__calSize(marginLeft, total, true);
          free -= this.__calSize(paddingLeft, total, true);
          free -= borderLeftWidth;
        }

        return free;
      } // 设置y偏移值，递归包括children，此举在justify-content/margin-auto/relative等对齐用

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        if (this.__computedStyle[DISPLAY$3] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Dom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetX(diff, isLayout);
        } // 记得偏移LineBox


        if (isLayout && !this.__isInline && this.lineBoxManager) {
          this.lineBoxManager.__offsetX(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetX(diff, isLayout, lv);
          }
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        if (this.__computedStyle[DISPLAY$3] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Dom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetY(diff, isLayout);
        }

        if (isLayout && !this.__isInline && this.lineBoxManager) {
          this.lineBoxManager.__offsetY(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetY(diff, isLayout, lv);
          }
        });
      }
      /**
       * flex布局时，计算basis尺寸，如果有固定声明则以其为标准，content为内容最大尺寸，auto依赖w/h或降级content
       * basis要考虑相加直接item的mpb，非绝对值单位以container为基准，basis为内容时为max值
       * item的孩子为孙子节点需递归，不参与basis计算，只参与min/max，尺寸和mpb均只考虑绝对值
       * 自动计算时影响尺寸的只有换行的text，以及一组inline，均按其中最大尺寸的一个计算
       * auto自动计算递归进行，如果是普通row方向，按最大text的charWidth为准
       * 如果是column方向，则虚拟布局后看text的height
       * 在abs下时进入特殊状态，无论是row/column，都会按row方向尝试最大尺寸，直到舞台边缘或容器声明的w折行
       * 返回b，声明则按css值，否则是auto/content
       * 返回min为最小宽度，遇到字符/inline则单列排版后需要的最大宽度
       * 返回max为最大宽度，理想情况一排最大值，在abs时virtualMode状态参与计算，文本抵达边界才进行换行
       * 当为column方向时，特殊进行虚拟布局isVirtual，需要获取高度
       * @param isDirectionRow
       * @param isAbs
       * @param isColumn
       * @param data
       * @param isDirectChild
       * @private
       */

    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        var _this2 = this;

        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var flowChildren = this.flowChildren,
            currentStyle = this.__currentStyle,
            computedStyle = this.__computedStyle;
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexDirection = currentStyle[FLEX_DIRECTION],
            flexBasis = currentStyle[FLEX_BASIS$1],
            width = currentStyle[WIDTH$2],
            height = currentStyle[HEIGHT$2];
        var lineHeight = computedStyle[LINE_HEIGHT],
            display = computedStyle[DISPLAY$3],
            lineClamp = computedStyle[LINE_CLAMP],
            writingMode = computedStyle[WRITING_MODE$1];
        var isUpright = writingMode.indexOf('vertical') === 0;
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content

        var isAuto = flexBasis.u === AUTO$1;
        var isFixed = [PX$2, PERCENT$1, REM$1, VW$1, VH$1, VMAX$1, VMIN$1].indexOf(flexBasis.u) > -1;
        var isContent = !isAuto && !isFixed;
        var fixedSize; // flex的item固定basis计算

        if (isFixed) {
          b = fixedSize = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } // 已声明主轴尺寸的，当basis是auto时为main值
        else if (isAuto && [PX$2, PERCENT$1, REM$1, VW$1, VH$1, VMAX$1, VMIN$1].indexOf(main.u) > -1) {
          b = fixedSize = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 非固定尺寸的basis为auto时降级为content
        else if (isAuto) {
          isContent = true;
        }

        var countMin = 0,
            countMax = 0;
        lineClamp = lineClamp || 0; // row的flex时，child只需计算宽度的basis/min/max，递归下去也是如此，即便包含递归的flex

        if (isDirectionRow) {
          // flex的item还是flex时
          if (display === 'flex') {
            var isR = ['column', 'columnReverse'].indexOf(flexDirection) === -1;
            flowChildren = genOrderChildren(flowChildren);
            flowChildren.forEach(function (item) {
              if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
                var _item$__calBasis = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h
                }, false),
                    _item$__calBasis2 = _slicedToArray(_item$__calBasis, 3),
                    min2 = _item$__calBasis2[1],
                    max2 = _item$__calBasis2[2];

                if (isR) {
                  min += min2;
                  max += max2;
                } else {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                }
              } // text除了flex还需要分辨垂直排版
              else {
                if (isUpright) {
                  var lineBoxManager = _this2.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    isUpright: isUpright
                  });

                  min += item.width;
                  max += item.width;
                }

                if (isR) {
                  min += item.charWidth;
                  max += item.textWidth;
                } else {
                  min = Math.max(min, item.charWidth);
                  max = Math.max(max, item.textWidth);
                }
              }
            });
          } // 特殊的flex水平布局但书写垂直，遇到后直接假布局获取宽度，因为水平尺寸视为无限但垂直不是，
          // 这里一定是第一个垂直排版不会递归下去，因为flex的child匿名block，水平的垂直书写inline匿名ib
          else if (isUpright) {
            var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

            this.__layoutFlow({
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              isUpright: isUpright
            }, isAbs, false, true);

            min = max = b = this.width;
          } // flex的item是block/inline时，inline也会变成block统一对待，递归下去会有inline出现，但row的水平size为无穷不会换行可以忽略
          else {
            var _lineBoxManager = data.lineBoxManager;

            if (display !== 'inline') {
              _lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
            }

            flowChildren.forEach(function (item) {
              if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
                var _item$__calBasis3 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lineBoxManager: _lineBoxManager
                }, false),
                    _item$__calBasis4 = _slicedToArray(_item$__calBasis3, 3),
                    min2 = _item$__calBasis4[1],
                    max2 = _item$__calBasis4[2];

                var _display = item.computedStyle[DISPLAY$3]; // row看块级最大尺寸和连续行级最大尺寸的宽

                if (_display === 'block' || _display === 'flex') {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                  countMin = countMax = 0;
                } else {
                  countMin += min2;
                  countMax += max2;
                  min = Math.max(min, countMin);
                  max = Math.max(max, countMax);
                }
              } else {
                countMin += item.charWidth;
                countMax += item.textWidth;
                min = Math.max(min, countMin);
                max = Math.max(max, countMax);
              }
            });
          }

          if (fixedSize) {
            max = Math.max(fixedSize, max);
          } // row降级为内容时basis等同于max


          if (isContent) {
            b = max;
          }
        } // column的flex时，每个child做一次虚拟布局，获取到每个child的高度和宽度
        else {
          this.__layoutFlow({
            x: x,
            y: y,
            w: w,
            h: h,
            isUpright: isUpright
          }, isAbs, true, false);

          min = max = b = this.height; // column的child，max和b总相等
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      } // flow的layout包裹方法，布局后递归计算computedStyle，abs节点在__layoutAbs中做
      // 布局完成后才能计算相关样式，因为需要布局确定尺寸，很多样式有百分比或继承

    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        _get(_getPrototypeOf(Dom.prototype), "__layout", this).call(this, data, isAbs, isColumn, isRow);

        this.__layoutStyle();
      } // 布局结束后递归向下计算computedStyle，父级必须先算因为有inherit

    }, {
      key: "__layoutStyle",
      value: function __layoutStyle() {
        _get(_getPrototypeOf(Dom.prototype), "__layoutStyle", this).call(this);

        this.flowChildren.forEach(function (child) {
          // 文本不需要，但wasm情况要传入一些信息
          child.__layoutStyle();
        });
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        _get(_getPrototypeOf(Dom.prototype), "__layoutNone", this).call(this);

        var children = this.children;
        children.forEach(function (item) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            item.__layoutNone();
          }
        });
      }
      /**
       * block布局，本身固定尺寸优先，否则看内容从上往下从左往右flow流排布
       * 内部inline和inlineBlock组成LineBox，通过LineBoxManager来管理混排的现象
       * LineBoxManager只有block和inlineBlock内部生成，inline会复用最近父级的
       * 内部的block在垂直方向要考虑margin合并的问题，强制所有节点为bfc，精简逻辑
       * @param data
       * @param isAbs abs无尺寸时提前虚拟布局计算尺寸
       * @param isColumn flex列无尺寸时提前虚拟布局计算尺寸
       * @param isRow flex行布局时出现writingMode垂直排版计算尺寸
       */

    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this3 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN],
            whiteSpace = computedStyle[WHITE_SPACE],
            lineClamp = computedStyle[LINE_CLAMP],
            lineHeight = computedStyle[LINE_HEIGHT],
            overflow = computedStyle[OVERFLOW$1];

        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            x = _this$__preLayout.x,
            y = _this$__preLayout.y,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0; // 虚线管理一个block内部的LineBox列表，使得inline的元素可以中途衔接处理折行
        // 内部维护inline结束的各种坐标来达到目的，遇到block时中断并处理换行坐标

        var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright); // 因精度问题，统计宽度均从0开始累加每行，最后取最大值，仅在abs布局时isVirtual生效

        var maxSize = 0;
        var countSize = 0;
        var lx = x; // 行首，考虑了mbp

        var ly = y; // 连续block（flex相同，下面都是）的上下margin合并值记录，合并时从列表中取

        var mergeMarginEndList = [],
            mergeMarginStartList = [];
        var length = flowChildren.length;
        var ignoreNextLine; // lineClamp超过后，后面的均忽略并置none，注意block内部行数统计是跨子block的

        var ignoreNextWrap; // whiteSpace单行超过后，后面的均忽略并置none，注意这也是跨block的会被隔断重计

        flowChildren.forEach(function (item, i) {
          var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline = isXom && item.computedStyle[DISPLAY$3] === 'inline';
          var isInlineBlock = isXom && item.computedStyle[DISPLAY$3] === 'inlineBlock';

          var isRealInline = isInline && item.__isRealInline();

          var lastLineClampCount = lineClampCount; // 每次循环开始前，这次不是block的话，看之前遗留待合并margin，并重置

          if (!isXom || isInline || isInlineBlock) {
            if (mergeMarginEndList.length && mergeMarginStartList.length) {
              var diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

              if (diff) {
                if (isUpright) {
                  x += diff;
                } else {
                  y += diff;
                }
              }
            }

            mergeMarginStartList = [];
            mergeMarginEndList = [];
          }

          if (isXom) {
            // inline和inlineBlock的细节不同之处，ib除了w/h之外，更想像block一样占据一行
            // 比如2个inline前面占一半后面比一半多但还是会从一半开始然后第2行换行继续，但ib放不下则重开一行
            // inline和ib能互相嵌套，形成的LineBox中则是TextBox和节点混合
            if (isInlineBlock || isInline) {
              if (ignoreNextLine || ignoreNextWrap) {
                item.__layoutNone();

                return;
              } // x开头或者nowrap单行的非block，不用考虑是否放得下直接放


              if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  // ib内部新生成会内部判断，这里不管统一传入
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // inlineBlock的特殊之处，一旦w为auto且内部产生折行时，整个变成block独占一块区域，坐标计算和block一样，注意nowrap排除

                if (item.__isIbFull) {
                  lineClampCount++;
                }

                if ((isUpright && item.__isUprightIbFull || !isUpright && item.__isIbFull) && whiteSpace !== 'nowrap') {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                } // 单行时inline在ellipsis会导致行数变化，否则判断坐标尺寸(恰好有点空剩余inline排不下)，注意前提是非abs，其虚拟计算尺寸无视限制


                if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                  ignoreNextWrap = true;
                } else if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // abs统计宽度，注意nowrap时累加


                if (isAbs) {
                  if (whiteSpace === 'nowrap') {
                    countSize += isUpright ? item.outerHeight : item.outerWidth;
                  } else {
                    countSize = isUpright ? item.outerHeight : item.outerWidth;

                    if (lineClampCount > lastLineClampCount) {
                      countSize = Math.max(countSize, isUpright ? h : w);
                    }
                  }

                  maxSize = Math.max(maxSize, countSize);
                }
              } else {
                // 非开头先尝试是否放得下，内部判断了inline/ib，ib要考虑是否有width
                var free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x, isUpright ? h : w, isUpright); // 放得下继续，奇怪的精度问题，加上阈值


                if (free >= -1e-10) {
                  lineClampCount = item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    // ib和非换行inline累加
                    if (isInlineBlock || lineClampCount === lastLineClampCount) {
                      countSize += isUpright ? item.outerHeight : item.outerWidth;
                      maxSize = Math.max(maxSize, countSize);
                    } // inline换行时一定超过边界至少撑满w
                    else {
                      maxSize = Math.max(maxSize, isUpright ? h : w);
                      countSize = isUpright ? y - ly : x - lx;
                      maxSize = Math.max(maxSize, countSize);
                    }
                  }
                } // 放不下处理之前的lineBox，并考虑重新开头或截断
                else {
                  lineClampCount++;

                  if (isUpright) {
                    x = lineBoxManager.endX;
                    y = ly;
                  } else {
                    x = lx;
                    y = lineBoxManager.endY;
                  }

                  lineBoxManager.setNewLine(); // 超过行数，整个block共用计数器

                  if (lineClamp && lineClampCount >= lineClamp) {
                    item.__layoutNone();

                    ignoreNextLine = true;
                    var list = lineBoxManager.list;
                    var lineBox = list[list.length - 1];
                    backtrack(_this3, lineBoxManager, lineBox, isUpright ? h : w, 0, isUpright);
                    return;
                  }

                  lineClampCount = item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                  if (item.__isIbFull || item.__isUprightIbFull) {
                    lineBoxManager.addItem(item, false);

                    if (isUpright) {
                      x += item.outerWidth;
                      y = ly;
                    } else {
                      x = lx;
                      y += item.outerHeight;
                    }

                    lineBoxManager.setNotEnd();
                    lineClampCount++;
                  } // inline和不折行的ib，其中ib需要手动存入当前lb中
                  else {
                    (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                    x = lineBoxManager.lastX;
                    y = lineBoxManager.lastY;
                  }

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                    maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                    countSize = isUpright ? item.outerHeight : item.outerWidth;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              }
            } // block/flex先处理之前可能遗留的最后一行LineBox，然后递归时不传lineBoxManager，其内部生成新的
            else {
              ignoreNextWrap = false; // block出现的话只隔断单行，不影响多行计数器
              // 非开头，说明之前的text/ib未换行，需要增加行数

              if (isUpright && y > ly || !isUpright && x > lx) {
                lineClampCount++;
              }

              if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }

              if (isUpright) {
                y = ly;
              } else {
                x = lx;
              }

              if (lineBoxManager.isEnd) {
                if (isUpright) {
                  x = lineBoxManager.endX;
                } else {
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNotEnd();
                lineBoxManager.setNewLine();
              }

              item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 自身无内容


              var isNone = item.currentStyle[DISPLAY$3] === 'none';
              var isEmptyBlock;

              if (!isNone && item.flowChildren && item.flowChildren.length === 0) {
                var _item$computedStyle = item.computedStyle,
                    marginTop = _item$computedStyle[MARGIN_TOP],
                    marginRight = _item$computedStyle[MARGIN_RIGHT$1],
                    marginBottom = _item$computedStyle[MARGIN_BOTTOM],
                    marginLeft = _item$computedStyle[MARGIN_LEFT$1],
                    paddingTop = _item$computedStyle[PADDING_TOP],
                    paddingRight = _item$computedStyle[PADDING_RIGHT$1],
                    paddingBottom = _item$computedStyle[PADDING_BOTTOM],
                    paddingLeft = _item$computedStyle[PADDING_LEFT$1],
                    width = _item$computedStyle[WIDTH$2],
                    height = _item$computedStyle[HEIGHT$2],
                    borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH],
                    borderRightWidth = _item$computedStyle[BORDER_RIGHT_WIDTH$1],
                    borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH],
                    borderLeftWidth = _item$computedStyle[BORDER_LEFT_WIDTH$1]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

                if (isUpright && paddingLeft <= 0 && paddingRight <= 0 && width <= 0 && borderLeftWidth <= 0 && borderRightWidth <= 0) {
                  mergeMarginEndList.push(marginRight);
                  mergeMarginStartList.push(marginLeft);
                  isEmptyBlock = true;
                } else if (!isUpright && paddingTop <= 0 && paddingBottom <= 0 && height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                  mergeMarginEndList.push(marginBottom);
                  mergeMarginStartList.push(marginTop);
                  isEmptyBlock = true;
                }
              }

              if (isUpright) {
                x += item.outerWidth;
                lineBoxManager.__lastX = x;
              } else {
                y += item.outerHeight;
                lineBoxManager.__lastY = y;
              } // absolute/flex前置虚拟计算


              if (isAbs) {
                maxSize = Math.max(maxSize, isUpright ? item.outerHeight : item.outerWidth);
                countSize = 0;
              } // 空block要留下轮循环看，除非是最后一个，此处非空本轮处理掉看是否要合并


              if (!isNone && !isEmptyBlock) {
                var _item$computedStyle2 = item.computedStyle,
                    _marginTop = _item$computedStyle2[MARGIN_TOP],
                    _marginRight = _item$computedStyle2[MARGIN_RIGHT$1],
                    _marginBottom = _item$computedStyle2[MARGIN_BOTTOM],
                    _marginLeft = _item$computedStyle2[MARGIN_LEFT$1]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
                // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

                if (mergeMarginEndList.length) {
                  if (isUpright) {
                    mergeMarginStartList.push(_marginLeft);
                    var _diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                    if (_diff) {
                      item.__offsetX(_diff, true, null);

                      x += _diff;
                    }
                  } else {
                    mergeMarginStartList.push(_marginTop);
                    var _diff2 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                    if (_diff2) {
                      item.__offsetY(_diff2, true, null);

                      y += _diff2;
                    }
                  }
                } // 同时自己保存bottom，为后续block准备


                mergeMarginStartList = [];
                mergeMarginEndList = [isUpright ? _marginRight : _marginBottom];
              } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0
              else if (i === length - 1) {
                var _diff3 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                if (_diff3) {
                  if (isUpright) {
                    x += _diff3;
                  } else {
                    y += _diff3;
                  }
                }
              }
            }
          } // 文字和inline类似
          else {
            if (ignoreNextLine || ignoreNextWrap) {
              item.__layoutNone();

              return;
            } // x开头，不用考虑是否放得下直接放


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              });
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // 和inline很像，只是没有ib

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              } // abs统计宽度，注意nowrap时累加


              if (isAbs) {
                if (whiteSpace === 'nowrap') {
                  countSize += isUpright ? item.height : item.width;
                } else {
                  countSize = isUpright ? item.height : item.width;

                  if (lineClampCount > lastLineClampCount) {
                    countSize = Math.max(countSize, isUpright ? h : w);
                  }
                }

                maxSize = Math.max(maxSize, countSize);
              }
            } else {
              // 非开头先尝试是否放得下
              var _free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x); // 放得下继续


              if (_free >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  if (lineClampCount === lastLineClampCount) {
                    countSize += isUpright ? item.height : item.width;
                    maxSize = Math.max(maxSize, countSize);
                  } // inline换行一定超过边界
                  else {
                    maxSize = Math.max(maxSize, isUpright ? h : w);
                    countSize = isUpright ? y - ly : x - lx;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 和inline/ib一样

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list = lineBoxManager.list;
                  var _lineBox = _list[_list.length - 1];
                  backtrack(_this3, lineBoxManager, _lineBox, isUpright ? h : w, 0, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                  maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                  countSize = isUpright ? item.height : item.width;
                  maxSize = Math.max(maxSize, countSize);
                }
              }
            }
          }
        }); // 结束后如果是以LineBox结尾，则需要设置y到这里，否则流布局中block会设置
        // 当以block换行时，新行是true，否则是false即结尾

        if (lineBoxManager.isEnd) {
          if (isUpright) {
            x = lineBoxManager.endX;
          } else {
            y = lineBoxManager.endY;
          }
        }

        var tw = 0,
            th = 0; // 根据书写模式、嵌套等条件计算宽高，只有父子同向才会主轴撑满

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else if (isAbs) {
          tw = isUpright ? x - data.x : maxSize;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else if (isAbs) {
          th = isUpright ? maxSize : y - data.y;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th); // 除了水平abs的虚拟外，都需要垂直对齐，因为img这种占位元素会影响lineBox高度，水平abs虚拟只需宽度


        if (!isAbs) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread, null);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread, null);
            }
            /**
             * parent以及parent的next无需处理，因为深度遍历后面还会进行，
             * 但自己的block需处理，因为对齐只处理了inline元素，忽略了block，
             * 同时由于block和inline区域可能不连续，每个增加的y不一样，
             * 需要按照每个不同区域来判断，区域是按索引次序依次增大的，
             * 只有在inline出现过后才开始生效，inline之前的block忽略
             */


            var count = 0,
                spreadList = lineBoxManager.spreadList;
            var isLastBlock = false,
                hasStart = false;
            flowChildren.forEach(function (item) {
              var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;
              var isBlock = isXom && ['block', 'flex'].indexOf(item.computedStyle[DISPLAY$3]) > -1;

              if (isBlock) {
                if (!hasStart) {
                  return;
                }

                isLastBlock = true;

                if (isUpright) {
                  item.__offsetX(spreadList[count], true, null);
                } else {
                  item.__offsetY(spreadList[count], true, null);
                }
              } else {
                hasStart = true;

                if (isLastBlock) {
                  count++;
                }

                isLastBlock = false;
              }
            });
          } // 非abs提前的虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐


          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // 所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });

            this.__marginAuto(currentStyle, data, isUpright);
          }
        }
      } // 弹性布局时的计算位置

    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        var _this4 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __flexLine = this.__flexLine;
        var flexDirection = computedStyle[FLEX_DIRECTION],
            justifyContent = computedStyle[JUSTIFY_CONTENT],
            alignItems = computedStyle[ALIGN_ITEMS],
            lineClamp = computedStyle[LINE_CLAMP],
            flexWrap = computedStyle[FLEX_WRAP],
            alignContent = computedStyle[ALIGN_CONTENT],
            lineHeight = computedStyle[LINE_HEIGHT],
            textAlign = computedStyle[TEXT_ALIGN];

        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            x = _this$__preLayout2.x,
            y = _this$__preLayout2.y,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h,
            isParentVertical = _this$__preLayout2.isParentVertical,
            isUpright = _this$__preLayout2.isUpright;

        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 每次布局情况多行内容


        __flexLine.splice(0); // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0;
        var isDirectionRow = ['column', 'columnReverse'].indexOf(flexDirection) === -1; // 计算伸缩基数

        var growList = [];
        var shrinkList = [];
        var basisList = [];
        var maxList = [];
        var minList = [];
        var orderChildren = genOrderChildren(flowChildren);
        orderChildren.forEach(function (item) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            var _currentStyle = item.currentStyle,
                _computedStyle = item.computedStyle;

            var _item$__calBasis5 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
              x: x,
              y: y,
              w: w,
              h: h
            }, true),
                _item$__calBasis6 = _slicedToArray(_item$__calBasis5, 3),
                b = _item$__calBasis6[0],
                min = _item$__calBasis6[1],
                max = _item$__calBasis6[2];

            var flexGrow = _currentStyle[FLEX_GROW],
                flexShrink = _currentStyle[FLEX_SHRINK];
            _computedStyle[FLEX_BASIS$1] = b;
            growList.push(flexGrow);
            shrinkList.push(flexShrink); // 根据basis不同，计算方式不同

            basisList.push(b);
            maxList.push(max);
            minList.push(min);
          } // 文本
          else {
            growList.push(0);
            shrinkList.push(1); // 水平flex垂直文字和垂直flex水平文字都先假布局一次取结果，其它取文本最大最小宽度即可

            if (isDirectionRow && isUpright || !isDirectionRow && !isUpright) {
              var lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

              item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);

              var n = isUpright ? item.width : item.height;
              basisList.push(n);
              maxList.push(n);
              minList.push(n);
            } // 水平flex水平文本和垂直flex垂直文本
            else {
              var cw = item.charWidth;
              var _tw = item.textWidth;
              basisList.push(_tw);
              maxList.push(_tw);
              minList.push(cw);
            }
          }
        });
        var containerSize = isDirectionRow ? w : h;
        var isMultiLine = ['wrap', 'wrapReverse'].indexOf(flexWrap) > -1;
        /**
         * 判断是否需要分行，根据假设主尺寸来统计尺寸和计算，假设主尺寸是clamp(min_main_size, flex_base_size, max_main_size)
         * 当多行时，由于每行一定有最小限制，所以每行一般情况都不是shrink状态，
         * 但也有极端情况，比如一行只能放下1个元素时，且此元素比容器小，会是shrink
         */

        var line = [],
            sum = 0,
            hypotheticalList = [];
        basisList.forEach(function (item, i) {
          var min = minList[i],
              max = maxList[i];
          var hypothetical;

          if (item < min) {
            hypothetical = min;
          } else if (item > max) {
            hypothetical = max;
          } else {
            hypothetical = item;
          }

          hypotheticalList.push(hypothetical);

          if (isMultiLine) {
            // 超过尺寸时，要防止sum为0即1个也会超过尺寸
            if (sum + hypothetical > containerSize) {
              if (sum) {
                __flexLine.push(line);

                line = [orderChildren[i]];
                sum = hypothetical;
              } else {
                line.push(orderChildren[i]);

                __flexLine.push(line);

                line = [];
                sum = 0;
              }
            } else {
              line.push(orderChildren[i]);
              sum += hypothetical;
            }
          } else {
            line.push(orderChildren[i]);
          }
        });

        if (line.length) {
          __flexLine.push(line);
        }

        var offset = 0,
            clone = {
          x: x,
          y: y,
          w: w,
          h: h
        };
        var maxCrossList = [],
            marginAutoCountList = [],
            freeList = [];

        __flexLine.forEach(function (item) {
          var length = item.length;
          var end = offset + length;

          var _this4$__layoutFlexLi = _this4.__layoutFlexLine(clone, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren.slice(offset, end), item, textAlign, growList.slice(offset, end), shrinkList.slice(offset, end), basisList.slice(offset, end), hypotheticalList.slice(offset, end), minList.slice(offset, end), maxList.slice(offset, end)),
              _this4$__layoutFlexLi2 = _slicedToArray(_this4$__layoutFlexLi, 5),
              x1 = _this4$__layoutFlexLi2[0],
              y1 = _this4$__layoutFlexLi2[1],
              maxCross = _this4$__layoutFlexLi2[2],
              marginAutoCount = _this4$__layoutFlexLi2[3],
              free = _this4$__layoutFlexLi2[4]; // 下一行/列更新坐标


          if (isDirectionRow) {
            clone.y = y1;
          } else {
            clone.x = x1;
          }

          x = Math.max(x, x1);
          y = Math.max(y, y1);
          maxCrossList.push(maxCross);
          marginAutoCountList.push(marginAutoCount);
          freeList.push(free);
          offset += length;
        }); // abs预布局只计算宽度无需对齐


        if (isAbs) {
          var max = 0;

          __flexLine.forEach(function (line) {
            var count = 0;
            line.forEach(function (item) {
              if (isDirectionRow) {
                count += isUpright ? item.outerHeight : item.outerWidth;
              } else {
                count = Math.max(count, isUpright ? item.outerHeight : item.outerWidth);
              } // 文字发生换行无论row/column一定放不下需占满容器尺寸


              if (item instanceof Text) {
                if (isUpright) {
                  if (item.textWidth > h) {
                    max = Math.max(max, h);
                  }
                } else {
                  if (item.textWidth > w) {
                    max = Math.max(max, w);
                  }
                }
              }
            });
            max = Math.max(max, count);
          });

          if (isUpright) {
            this.__ioSize(undefined, max);
          } else {
            this.__ioSize(max, undefined);
          }

          return;
        } // 同block计算


        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th);

        if (isColumn || isRow) {
          return;
        } // flexDirection当有reverse时交换每line的主轴序


        if (flexDirection === 'rowReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = tw - item.outerWidth - (item.x - data.x) * 2;

              if (diff) {
                item.__offsetX(diff, true, null);
              }
            });
          });
        } else if (flexDirection === 'columnReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = th - item.outerHeight - (item.y - data.y) * 2;

              if (diff) {
                item.__offsetY(diff, true, null);
              }
            });
          });
        } // wrap-reverse且多轴线时交换轴线序，需要2行及以上才行


        var length = __flexLine.length;

        if (flexWrap === 'wrapReverse' && length > 1) {
          var crossSum = 0,
              crossSumList = [];
          maxCrossList.forEach(function (item) {
            crossSumList.push(crossSum);
            crossSum += item;
          });
          var count = 0;

          var _loop = function _loop(i) {
            var line = __flexLine[i];
            var source = crossSumList[i];
            var diff = count - source;

            if (diff) {
              line.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true, null);
                } else {
                  item.__offsetX(diff, true, null);
                }
              });
            }

            count += maxCrossList[i];
          };

          for (var i = length - 1; i >= 0; i--) {
            _loop(i);
          }

          __flexLine.reverse();
        } // 侧轴对齐分flexLine做，要考虑整体的alignContent的stretch和每行的alignItems的stretch
        // 先做整体的，得出交叉轴空白再均分给每一行做单行的，整体的只有1行忽略


        var per;

        if (length > 1 && (fixedHeight && isDirectionRow || !isDirectionRow)) {
          var diff = isDirectionRow ? th - (y - data.y) : tw - (x - data.x); // 有空余时才进行对齐

          if (diff > 0) {
            if (alignContent === 'center') {
              var _per = diff * 0.5;

              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(_per, true, null);
                } else {
                  item.__offsetX(_per, true, null);
                }
              });
            } else if (alignContent === 'flexStart') ; else if (alignContent === 'flexEnd') {
              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true, null);
                } else {
                  item.__offsetX(diff, true, null);
                }
              });
            } else if (alignContent === 'spaceBetween') {
              var between = diff / (length - 1); // 除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(between, true, null);
                    } else {
                      item.__offsetX(between, true, null);
                    }
                  });
                }
              });
            } else if (alignContent === 'spaceAround') {
              var around = diff / (length + 1);

              __flexLine.forEach(function (item, i) {
                item.forEach(function (item) {
                  if (isDirectionRow) {
                    item.__offsetY(around * (i + 1), true, null);
                  } else {
                    item.__offsetX(around * (i + 1), true, null);
                  }
                });
              });
            } // 默认stretch，每个flexLine进行扩充
            else {
              per = diff / length; // 因为每行都cross扩充了per，所有除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(per * i, true, null);
                    } else {
                      item.__offsetX(per * i, true, null);
                    }
                  });
                }
              });
            }
          }
        } // 每行再进行main/cross对齐，在alignContent为stretch时计算每行的高度


        if (!isColumn && !isRow) {
          if (length > 1) {
            __flexLine.forEach(function (item, i) {
              var maxCross = maxCrossList[i];

              if (per) {
                maxCross += per;
              }

              _this4.__flexAlign(item, alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCountList[i], freeList[i]);
            });
          } else if (length) {
            var maxCross = isDirectionRow ? th : tw;

            this.__flexAlign(__flexLine[0], alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCountList[0], freeList[0]);
          }

          this.__marginAuto(currentStyle, data, isUpright);
        }
      }
      /**
       * 计算获取子元素的b/min/max完毕后，尝试进行flex每行布局
       * https://www.w3.org/TR/css-flexbox-1/#layout-algorithm
       * 假想主尺寸，其为clamp(min_main_size, flex_base_size, max_main_size)
       * 随后按算法一步步来 https://zhuanlan.zhihu.com/p/354567655
       * 规范没提到mpb，item的要计算，孙子的只考虑绝对值
       * 先收集basis和假设主尺寸
       */

    }, {
      key: "__layoutFlexLine",
      value: function __layoutFlexLine(data, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren, flexLine, textAlign, growList, shrinkList, basisList, hypotheticalList, minList, maxList) {
        var _this5 = this;

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h;
        var hypotheticalSum = 0;
        hypotheticalList.forEach(function (item) {
          hypotheticalSum += item;
        }); // 根据假设尺寸确定使用grow还是shrink，冻结非弹性项并设置target尺寸，确定剩余未冻结数量

        var isOverflow = hypotheticalSum >= containerSize;
        var targetMainList = [];
        basisList.forEach(function (item, i) {
          if (isOverflow) {
            if (!shrinkList[i] || basisList[i] < hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          } else {
            if (!growList[i] || basisList[i] > hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          }
        }); // 初始可用空间，冻结使用确定的target尺寸，未冻结使用假想

        var free = 0;
        basisList.forEach(function (item, i) {
          if (targetMainList[i] !== undefined) {
            free += targetMainList[i];
          } else {
            free += item;
          }
        });
        var total = Infinity;

        if (isDirectionRow) {
          total = w;
        } else if (fixedHeight) {
          total = h;
        } else {
          total = free;
        }

        free = Math.abs(total - free); // 压缩也使用正值

        var lessOne = 0; // 循环，文档算法不够简练，其合并了grow和shrink，实际拆开写更简单

        var factorSum = 0;

        if (isOverflow) {
          (function () {
            // 计算真正的因子占比，同时得出缩小尺寸数值
            // 还需判断每个item收缩不能<min值，小于的话将无法缩小的这部分按比例分配到其它几项上
            // 于是写成一个循环，每轮先处理一遍，如果产生收缩超限的情况，将超限的设为最小值并剔除
            // 剩下的重新分配因子占比继续从头循环重来一遍
            var factorList = shrinkList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                // 冻结项的目标主尺寸有值，因子无值或为0
                factorSum += item;
                return item;
              }
            });

            while (true) {
              // 都冻结了
              if (factorSum === 0) {
                break;
              }

              if (factorSum < 1) {
                lessOne += free * (1 - factorSum);
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0,
                  count1 = 0,
                  count2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要收缩的尺寸

                  var n = basisList[i] - s; // 实际尺寸
                  // 比min还小设置为min，同时设0冻结剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    count1 += basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸，最终从free里减去
                  } // else if(n > maxList[i]) {
                  //   targetMainList[i] = maxList[i];
                  //   factorList[i] = 0;
                  //   needReset = true;
                  //   count1 += maxList[i];
                  // }
                  // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                    count2 += n;
                  }
                }
              });

              if (!needReset) {
                free -= count2;
                break;
              }

              free -= count1;
              factorSum = factorSum2;
            }
          })();
        } else {
          (function () {
            var factorList = growList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                factorSum += item;
                return item;
              }
            });

            while (true) {
              if (factorSum === 0) {
                break;
              }

              if (factorSum < 1) {
                lessOne += free * (1 - factorSum);
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0,
                  count1 = 0,
                  count2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要扩展的尺寸

                  var n = basisList[i] + s; // 实际尺寸
                  // 比min还小设置为min，同时设0剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    count1 += basisList[i] - minList[i];
                  } // else if(n > maxList[i]) {
                  //   targetMainList[i] = maxList[i];
                  //   factorList[i] = 0;
                  //   needReset = true;
                  //   count1 += maxList[i];
                  // }
                  // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                    count2 += n;
                  }
                }
              });

              if (!needReset) {
                free -= count2;
                break;
              }

              free -= count1;
              factorSum = factorSum2;
            }
          })();
        }

        var maxCross = 0;
        var lbmList = [];
        var marginAutoCount = 0;
        orderChildren.forEach(function (item, i) {
          var main = targetMainList[i];

          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            if (isDirectionRow) {
              item.__layoutFlow({
                x: x,
                y: y,
                w: main,
                h: h,
                w3: main,
                // w3假设固定宽度，忽略原始style中的设置
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
            } else {
              var _item$currentStyle = item.currentStyle,
                  alignSelf = _item$currentStyle[ALIGN_SELF],
                  width = _item$currentStyle[WIDTH$2]; // column的child真布局时，如果是stretch宽度，则可以直接生成animateRecord，否则自适应调整后才进行

              if (!isAbs && !isColumn && !isRow) {
                var needGenAr;

                if (width.u !== AUTO$1 || alignSelf === 'stretch') {
                  needGenAr = true;
                } else if (alignSelf === 'auto' && alignItems === 'stretch') {
                  needGenAr = true;
                }

                if (needGenAr) {
                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                } else {
                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, true, isColumn, isRow);

                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    w3: item.outerWidth,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                }
              } else {
                item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: main,
                  h3: main,
                  // 同w2
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
              }
            } // 记录主轴是否有margin为auto的情况


            if (!isAbs && !isColumn && !isRow) {
              var currentStyle = item.currentStyle;

              if (isDirectionRow) {
                if (currentStyle[MARGIN_LEFT$1].u === AUTO$1) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_RIGHT$1].u === AUTO$1) {
                  marginAutoCount++;
                }
              } else {
                if (currentStyle[MARGIN_TOP].u === AUTO$1) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_BOTTOM].u === AUTO$1) {
                  marginAutoCount++;
                }
              }
            }
          } // 文字
          else {
            var lineBoxManager = _this5.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
            lbmList.push(lineBoxManager);

            item.__layoutFlow({
              x: x,
              y: y,
              w: isDirectionRow ? main : w,
              h: isDirectionRow ? h : main,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount,
              isUpright: isUpright
            });
          }

          if (isDirectionRow) {
            x += item.outerWidth;
            maxCross = Math.max(maxCross, item.outerHeight);
          } else {
            y += item.outerHeight;
            maxCross = Math.max(maxCross, item.outerWidth);
          }
        });

        if (isDirectionRow) {
          y += maxCross;
        } else {
          x += maxCross;
        } // flex的直接text对齐比较特殊


        if (!isAbs && !isColumn && !isRow && ['center', 'right'].indexOf(textAlign) > -1) {
          lbmList.forEach(function (item) {
            item.horizonAlign(isUpright ? item.height : item.width, textAlign, isUpright);
          });
        }

        return [x, y, maxCross, marginAutoCount, isOverflow ? 0 : Math.max(0, free + lessOne)];
      } // 每个flexLine的主轴侧轴对齐

    }, {
      key: "__flexAlign",
      value: function __flexAlign(line, alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCount, free) {
        var baseline = 0;
        line.forEach(function (item) {
          baseline = Math.max(baseline, item.firstBaseline);
        }); // 先主轴对齐方式，需要考虑margin，如果有auto则优先于justifyContent

        var len = line.length;

        if (marginAutoCount) {
          // 类似于space-between，空白均分于auto，两边都有就是2份，只有1边是1份
          var count = 0,
              per = free / marginAutoCount;

          for (var i = 0; i < len; i++) {
            var child = line[i];
            var currentStyle = child.currentStyle;

            if (isDirectionRow) {
              if (currentStyle[MARGIN_LEFT$1].u === AUTO$1) {
                count += per;

                child.__offsetX(count, true, null);
              } else if (count) {
                child.__offsetX(count, true, null);
              }

              if (currentStyle[MARGIN_RIGHT$1].u === AUTO$1) {
                count += per;
              }
            } else {
              if (currentStyle[MARGIN_TOP].u === AUTO$1) {
                count += per;

                child.__offsetY(count, true, null);
              } else if (count) {
                child.__offsetY(count, true, null);
              }

              if (currentStyle[MARGIN_BOTTOM].u === AUTO$1) {
                count += per;
              }
            }
          }
        } else {
          if (justifyContent === 'flexEnd') {
            for (var _i4 = 0; _i4 < len; _i4++) {
              var _child = line[_i4];
              isDirectionRow ? _child.__offsetX(free, true, null) : _child.__offsetY(free, true, null);
            }
          } else if (justifyContent === 'center') {
            var center = free * 0.5;

            for (var _i5 = 0; _i5 < len; _i5++) {
              var _child2 = line[_i5];
              isDirectionRow ? _child2.__offsetX(center, true, null) : _child2.__offsetY(center, true, null);
            }
          } else if (justifyContent === 'spaceBetween') {
            var between = free / (len - 1);

            for (var _i6 = 1; _i6 < len; _i6++) {
              var _child3 = line[_i6];
              isDirectionRow ? _child3.__offsetX(between * _i6, true, null) : _child3.__offsetY(between * _i6, true, null);
            }
          } else if (justifyContent === 'spaceAround') {
            var around = free * 0.5 / len;

            for (var _i7 = 0; _i7 < len; _i7++) {
              var _child4 = line[_i7];
              isDirectionRow ? _child4.__offsetX(around * (_i7 * 2 + 1), true, null) : _child4.__offsetY(around * (_i7 * 2 + 1), true, null);
            }
          } else if (justifyContent === 'spaceEvenly') {
            var _around = free / (len + 1);

            for (var _i8 = 0; _i8 < len; _i8++) {
              var _child5 = line[_i8];
              isDirectionRow ? _child5.__offsetX(_around * (_i8 + 1), true, null) : _child5.__offsetY(_around * (_i8 + 1), true, null);
            }
          }
        } // 再侧轴


        line.forEach(function (item) {
          var alignSelf = item.currentStyle[ALIGN_SELF];

          if (isDirectionRow) {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var diff = maxCross - item.outerHeight;

              if (diff !== 0) {
                item.__offsetY(diff, true, null);
              }
            } else if (alignSelf === 'center') {
              var _diff4 = maxCross - item.outerHeight;

              if (_diff4 !== 0) {
                item.__offsetY(_diff4 * 0.5, true, null);
              }
            } else if (alignSelf === 'stretch') {
              var computedStyle = item.computedStyle,
                  height = item.currentStyle[HEIGHT$2];
              var borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
                  borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
                  marginTop = computedStyle[MARGIN_TOP],
                  marginBottom = computedStyle[MARGIN_BOTTOM],
                  paddingTop = computedStyle[PADDING_TOP],
                  paddingBottom = computedStyle[PADDING_BOTTOM];

              if (height.u === AUTO$1) {
                var old = item.height;
                var v = item.__height = computedStyle[HEIGHT$2] = maxCross - marginTop - marginBottom - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth;
                var d = v - old;
                item.__y4 += d;
                item.__y5 += d;
                item.__y6 += d;
                item.__height += d;
                item.__clientHeight += d;
                item.__offsetHeight += d;
                item.__outerHeight += d;
              }
            } else if (alignSelf === 'baseline') {
              var _diff5 = baseline - item.firstBaseline;

              if (_diff5 !== 0) {
                item.__offsetY(_diff5, true, null);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff6 = maxCross - item.outerHeight;

                if (_diff6 !== 0) {
                  item.__offsetY(_diff6 * 0.5, true, null);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff7 = maxCross - item.outerHeight;

                if (_diff7 !== 0) {
                  item.__offsetY(_diff7, true, null);
                }
              } else if (alignItems === 'baseline') {
                var _diff8 = baseline - item.firstBaseline;

                if (_diff8 !== 0) {
                  item.__offsetY(_diff8, true, null);
                }
              } // 默认stretch
              else {
                var _computedStyle2 = item.computedStyle,
                    _item$currentStyle2 = item.currentStyle,
                    display = _item$currentStyle2[DISPLAY$3],
                    flexDirection = _item$currentStyle2[FLEX_DIRECTION],
                    _height = _item$currentStyle2[HEIGHT$2]; // row的孩子还是flex且column且不定高时，如果高度<侧轴拉伸高度则重新布局

                if (isDirectionRow && display === 'flex' && flexDirection === 'column' && _height.u === AUTO$1 && item.outerHeight < maxCross) {
                  item.__layoutFlow(Object.assign(item.__layoutData, {
                    h3: maxCross
                  }));
                }

                var _borderTopWidth = _computedStyle2[BORDER_TOP_WIDTH],
                    _borderBottomWidth = _computedStyle2[BORDER_BOTTOM_WIDTH],
                    _marginTop2 = _computedStyle2[MARGIN_TOP],
                    _marginBottom2 = _computedStyle2[MARGIN_BOTTOM],
                    _paddingTop = _computedStyle2[PADDING_TOP],
                    _paddingBottom = _computedStyle2[PADDING_BOTTOM];

                if (_height.u === AUTO$1) {
                  var _old = item.height;

                  var _v = maxCross - _marginTop2 - _marginBottom2 - _paddingTop - _paddingBottom - _borderTopWidth - _borderBottomWidth;

                  var _d = _v - _old;

                  item.__y4 += _d;
                  item.__y5 += _d;
                  item.__y6 += _d;
                  item.__height += _d;
                  item.__clientHeight += _d;
                  item.__offsetHeight += _d;
                  item.__outerHeight += _d;
                }
              }
            }
          } // column
          else {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var _diff9 = maxCross - item.outerWidth;

              if (_diff9 !== 0) {
                item.__offsetX(_diff9, true, null);
              }
            } else if (alignSelf === 'center') {
              var _diff10 = maxCross - item.outerWidth;

              if (_diff10 !== 0) {
                item.__offsetX(_diff10 * 0.5, true, null);
              }
            } else if (alignSelf === 'stretch') {
              var _computedStyle3 = item.computedStyle,
                  width = item.currentStyle[WIDTH$2];
              var borderRightWidth = _computedStyle3[BORDER_RIGHT_WIDTH$1],
                  borderLeftWidth = _computedStyle3[BORDER_LEFT_WIDTH$1],
                  marginRight = _computedStyle3[MARGIN_RIGHT$1],
                  marginLeft = _computedStyle3[MARGIN_LEFT$1],
                  paddingRight = _computedStyle3[PADDING_RIGHT$1],
                  paddingLeft = _computedStyle3[PADDING_LEFT$1];

              if (width.u === AUTO$1) {
                var _old2 = item.width;

                var _v2 = item.__width = _computedStyle3[WIDTH$2] = maxCross - marginLeft - marginRight - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth;

                var _d2 = _v2 - _old2;

                item.__x4 += _d2;
                item.__x5 += _d2;
                item.__x6 += _d2;
                item.__width += _d2;
                item.__clientWidth += _d2;
                item.__offsetWidth += _d2;
                item.__outerWidth += _d2;
              }
            } else if (alignItems === 'baseline') {
              var _diff11 = baseline - item.firstBaseline;

              if (_diff11 !== 0) {
                item.__offsetX(_diff11, true, null);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff12 = maxCross - item.outerWidth;

                if (_diff12 !== 0) {
                  item.__offsetX(_diff12 * 0.5, true, null);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff13 = maxCross - item.outerWidth;

                if (_diff13 !== 0) {
                  item.__offsetX(_diff13, true, null);
                }
              } else if (alignItems === 'baseline') {
                var _diff14 = baseline - item.firstBaseline;

                if (_diff14 !== 0) {
                  item.__offsetX(_diff14, true, null);
                }
              } // 默认stretch
              else {
                var _computedStyle4 = item.computedStyle,
                    _width = item.currentStyle[WIDTH$2];
                var _borderRightWidth = _computedStyle4[BORDER_RIGHT_WIDTH$1],
                    _borderLeftWidth = _computedStyle4[BORDER_LEFT_WIDTH$1],
                    _marginRight2 = _computedStyle4[MARGIN_RIGHT$1],
                    _marginLeft2 = _computedStyle4[MARGIN_LEFT$1],
                    _paddingRight = _computedStyle4[PADDING_RIGHT$1],
                    _paddingLeft = _computedStyle4[PADDING_LEFT$1];

                if (_width.u === AUTO$1) {
                  var _old3 = item.width;

                  var _v3 = item.__width = _computedStyle4[WIDTH$2] = maxCross - _marginLeft2 - _marginRight2 - _paddingLeft - _paddingRight - _borderRightWidth - _borderLeftWidth;

                  var _d3 = _v3 - _old3;

                  item.__x4 += _d3;
                  item.__x5 += _d3;
                  item.__x6 += _d3;
                  item.__width += _d3;
                  item.__clientWidth += _d3;
                  item.__offsetWidth += _d3;
                  item.__outerWidth += _d3;
                }
              }
            }
          }
        });
      }
      /**
       * inline比较特殊，先简单顶部对齐，后续还需根据vertical和lineHeight计算y偏移
       * inlineBlock复用逻辑，可以设置w/h，在混排时表现不同，inlineBlock换行限制在规定的矩形内，
       * 且ib会在没设置width且换行的时候撑满上一行，即便内部尺寸没抵达边界
       * 而inline换行则会从父容器start处开始，且首尾可能占用矩形不同
       * 嵌套inline情况十分复杂，尾部mpb空白可能产生叠加情况，因此endSpace表示自身，
       * 然后根据是否在最后一个元素进行叠加父元素的，多层嵌套则多层尾部叠加，均以最后一个元素为依据判断
       * Text获取这个叠加的endSpace值即可，无需感知是否最后一个，外层（此处）进行逻辑封装
       * @param data
       * @param isAbs
       * @param isColumn
       * @param isRow
       * @param isInline
       * @private
       */

    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isColumn, isRow, isInline) {
        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN],
            whiteSpace = computedStyle[WHITE_SPACE],
            lineClamp = computedStyle[LINE_CLAMP],
            lineHeight = computedStyle[LINE_HEIGHT],
            marginTop = computedStyle[MARGIN_TOP],
            marginBottom = computedStyle[MARGIN_BOTTOM],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            marginRight = computedStyle[MARGIN_RIGHT$1],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$1],
            paddingTop = computedStyle[PADDING_TOP],
            paddingBottom = computedStyle[PADDING_BOTTOM],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            paddingRight = computedStyle[PADDING_RIGHT$1];
        var lineClampCount = data.lineClampCount || 0;

        var _this$__preLayout3 = this.__preLayout(data, isInline),
            fixedWidth = _this$__preLayout3.fixedWidth,
            fixedHeight = _this$__preLayout3.fixedHeight,
            x = _this$__preLayout3.x,
            y = _this$__preLayout3.y,
            w = _this$__preLayout3.w,
            h = _this$__preLayout3.h,
            lx = _this$__preLayout3.lx,
            ly = _this$__preLayout3.ly,
            lineBoxManager = _this$__preLayout3.lineBoxManager,
            endSpace = _this$__preLayout3.endSpace,
            selfEndSpace = _this$__preLayout3.selfEndSpace,
            isUpright = _this$__preLayout3.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return lineClampCount;
        }

        var width = currentStyle[WIDTH$2],
            height = currentStyle[HEIGHT$2];

        if (isInline && !this.__isRealInline()) {
          isInline = false;
        } // inline-block假布局提前结束


        if (!isInline) {
          if (isColumn && fixedHeight) {
            this.__ioSize(undefined, h);

            return lineClampCount;
          }

          if (isRow && fixedWidth) {
            this.__ioSize(w, undefined);

            return lineClampCount;
          }
        } // 只有inline的孩子需要考虑换行后从行首开始，而ib不需要，因此重置行首标识lx为x，末尾空白为0
        // 而inline的LineBoxManager复用最近非inline父dom的，ib需要重新生成，末尾空白叠加


        if (isInline) {
          this.__isInline = true;
          this.__lineBoxManager = lineBoxManager;
          var baseline = isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle); // 特殊inline调用，有内容的话（如左右mbp），默认生成一个lineBox，即便是空，也要形成占位，只有开头时需要

          if (isUpright && (marginTop || marginBottom || paddingTop || paddingBottom || borderTopWidth || borderBottomWidth) || !isUpright && (marginLeft || marginRight || paddingLeft || paddingRight || borderLeftWidth || borderRightWidth)) {
            if (lineBoxManager.isNewLine) {
              lineBoxManager.genLineBoxByInlineIfNewLine(x, y, lineHeight, baseline);
            } else {
              lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
            }
          } else {
            lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
          }

          lineClamp = data.lineClamp || 0;
        } else {
          lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
          lx = x;
          ly = y;
          endSpace = selfEndSpace = lineClampCount = 0;
        } // 存LineBox里的内容列表专用，布局过程中由lineBoxManager存入，递归情况每个inline节点都保存contentBox


        if (isInline) {
          this.contentBoxList.splice(0);
          lineBoxManager.pushContentBoxList(this);
        } // ib的bp是自己，inline是最近的非inline


        var bp = this;

        while (bp.computedStyle[DISPLAY$3] === 'inline') {
          bp = bp.domParent;
        }

        var overflow = bp.computedStyle[OVERFLOW$1];
        var isIbFull = false,
            isUprightIbFull = false; // ib时不限定w情况下发生折行则撑满行，即便内容没有撑满边界

        var length = flowChildren.length;
        var ignoreNextLine = false; // lineClamp超过后，后面的均忽略并置none，注意ib内部自己统计类似block

        var ignoreNextWrap = false; // whiteSpace单行超过后，后面的均忽略并置none，注意和block不一样不隔断

        var hasAddEndSpace; // 最后一行生效，只加1次防重复

        flowChildren.forEach(function (item, i) {
          // 和block不太一样可以提前判断，因为不可能包含block隔断区域了
          if (ignoreNextLine || ignoreNextWrap) {
            item.__layoutNone();

            return;
          }

          var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline2 = isXom && item.computedStyle[DISPLAY$3] === 'inline';
          var isInlineBlock2 = isXom && item.computedStyle[DISPLAY$3] === 'inlineBlock';

          var isRealInline = isInline2 && item.__isRealInline(); // 最后一个元素会产生最后一行，叠加父元素的尾部mpb，注意只执行一次防止重复叠加


          var isEnd = isInline && !hasAddEndSpace && (whiteSpace === 'nowrap' || !isXom && i === length - 1 || lineClamp && i === length - 1 || lineClampCount === lineClamp - 1);

          if (isEnd) {
            hasAddEndSpace = true;
            endSpace += selfEndSpace;
          }

          var lastLineClampCount = lineClampCount;

          if (isXom) {
            if (!isInline2 && !isInlineBlock2) {
              item.currentStyle[DISPLAY$3] = item.computedStyle[DISPLAY$3] = 'inlineBlock';
              isInlineBlock2 = true;
              inject.warn('Inline can not contain block/flex');
            } // x开头或者nowrap单行，不用考虑是否放得下直接放，因为有beginSpace所以要多判断i为0


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 同block布局

              if (item.__isIbFull || item.__isUprightIbFull) {
                lineClampCount++;
              }

              if (item.__isIbFull && whiteSpace !== 'nowrap') {
                if (isUpright && h.u === AUTO$1) {
                  isUprightIbFull = true;
                } else if (!isUpright && w.u === AUTO$1) {
                  isIbFull = true;
                }

                lineBoxManager.addItem(item, true);

                if (isUpright) {
                  x += item.outerWidth;
                  y = ly;
                } else {
                  x = lx;
                  y += item.outerHeight;
                }

                lineBoxManager.setNotEnd();
              } // inline和不折行的ib，其中ib需要手动存入当前lb中，以计算宽度
              else {
                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 不换行继续排，换行非开头先尝试是否放得下，结尾要考虑mpb因此减去endSpace
              var free = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace, isUpright ? h : w, isUpright); // 放得下继续


              if (free >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var list = lineBoxManager.list;
                  var lineBox = list[list.length - 1];
                  backtrack(bp, lineBoxManager, lineBox, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                if (item.__isIbFull || item.__isUprightIbFull) {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                  lineClampCount++;
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          } // inline里的其它只有文本，可能开始紧跟着之前的x，也可能换行后从lx行头开始
          // 紧跟着x可能出现在前面有节点换行后第2行，此时不一定放得下，因此不能作为判断依据，开头仅有lx
          else {
            var n = lineBoxManager.size; // i为0时强制不换行

            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // ib情况发生折行，且非定宽

              if (!isInline && lineBoxManager.size - n > 1) {
                if (height.u === AUTO$1 && isUpright) {
                  isUprightIbFull = true;
                }

                if (width.u === AUTO$1 && !isUpright) {
                  isIbFull = true;
                }
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 非开头先尝试是否放得下，如果放得下再看是否end，加end且只有1个字时放不下要换行，否则可以放，换行由text内部做
              var _free2 = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace); // 放得下继续


              if (_free2 >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // 这里ib放得下一定是要么没换行要么固定宽度，所以无需判断isIbFull

              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list2 = lineBoxManager.list;
                  var _lineBox2 = _list2[_list2.length - 1];
                  backtrack(bp, lineBoxManager, _lineBox2, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY; // ib情况发生折行

                if (!isInline && lineBoxManager.size - n > 1) {
                  if (height.u === AUTO$1 && isUpright) {
                    isUprightIbFull = true;
                  }

                  if (width.u === AUTO$1 && !isUpright) {
                    isIbFull = true;
                  }
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          }
        }); // 同block结尾，不过这里一定是lineBox结束，无需判断

        if (isUpright) {
          x = lineBoxManager.endX;
        } else {
          y = lineBoxManager.endY;
        } // 标识ib情况同block一样占满行


        this.__isIbFull = isIbFull;
        this.__isUprightIbFull = isUprightIbFull; // 元素的width在固定情况或者ibFull情况已被计算出来，否则为最大延展尺寸，inline没有固定尺寸概念

        var tw, th;

        if (isInline) {
          // inline最后的x要算上右侧mpb，为next行元素提供x坐标基准，同时其尺寸计算比较特殊
          if (selfEndSpace) {
            if (isUpright) {
              lineBoxManager.addY(selfEndSpace);
            } else {
              lineBoxManager.addX(selfEndSpace);
            }
          } // 如果没有内容，空白还要加上开头即左侧mpb


          if (!flowChildren.length) {
            var _marginTop3 = computedStyle[MARGIN_TOP],
                _marginLeft3 = computedStyle[MARGIN_LEFT$1],
                _paddingTop2 = computedStyle[PADDING_TOP],
                _paddingLeft2 = computedStyle[PADDING_LEFT$1],
                _borderTopWidth2 = computedStyle[BORDER_TOP_WIDTH],
                _borderLeftWidth2 = computedStyle[BORDER_LEFT_WIDTH$1];

            if (isUpright) {
              lineBoxManager.addY(_marginTop3 + _paddingTop2 + _borderTopWidth2);
            } else {
              lineBoxManager.addX(_marginLeft3 + _paddingLeft2 + _borderLeftWidth2);
            }
          } // 结束出栈contentBox，递归情况结束子inline获取contentBox，父inline继续


          lineBoxManager.popContentBoxList(); // abs非固定w时预计算，本来是最近非inline父层统一计算，但在abs时不算，这里无视textAlign默认left

          if (isAbs) {
            this.__inlineSize(0, 'left', isUpright);
          }
        } else {
          // ib在满时很特殊，取最大值，可能w本身很小不足排下1个字符，此时要用max
          var max = lineBoxManager.max - (isUpright ? data.y : data.x);

          if (isUpright) {
            tw = fixedWidth ? w : x - data.x;
            th = fixedHeight ? h : isIbFull ? Math.max(h, max) : max;
          } else {
            tw = fixedWidth ? w : isIbFull ? Math.max(w, max) : max;
            th = fixedHeight ? h : y - data.y;
          }

          this.__ioSize(tw, th);
        } // 非abs提前虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐，inline会被父级调用这里只看ib


        if (!isAbs && !isInline) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread, null);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread, null);
            }
          }

          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // block的所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });
          }
        } // inlineBlock新开上下文，但父级block遇到要处理换行


        return lineClampCount;
      }
      /**
       * inline的尺寸计算非常特殊，并非一个矩形区域，而是由字体行高结合节点下多个LineBox中的内容决定，
       * 且这个尺寸又并非真实LineBox中的内容直接合并计算而来，比如包含了个更大尺寸的ib却不会计入
       * 具体方法为遍历持有的LineBox下的内容，x取两侧极值，同时首尾要考虑mpb，y值取上下极值，同样首尾考虑mpb
       * 首尾行LineBox可能不是不是占满一行，比如前后都有同行inline的情况，非首尾行则肯定占满
       * 绘制内容（如背景色）的区域也很特殊，每行LineBox根据lineHeight对齐baseline得来，并非LineBox全部
       * 当LineBox只有直属Text时如果font没有lineGap则等价于全部，如有则需减去
       * 另外其client/offset/outer的w/h尺寸计算也很特殊，皆因首尾x方向的mpb导致
       * @private
       */

    }, {
      key: "__inlineSize",
      value: function __inlineSize(size, textAlign, isUpright) {
        var contentBoxList = this.contentBoxList,
            computedStyle = this.computedStyle;
        var display = computedStyle[DISPLAY$3],
            marginTop = computedStyle[MARGIN_TOP],
            marginRight = computedStyle[MARGIN_RIGHT$1],
            marginBottom = computedStyle[MARGIN_BOTTOM],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            paddingTop = computedStyle[PADDING_TOP],
            paddingRight = computedStyle[PADDING_RIGHT$1],
            paddingBottom = computedStyle[PADDING_BOTTOM],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$1],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            lineHeight = computedStyle[LINE_HEIGHT]; // 可能因为Ellipsis回溯变成none

        if (display === 'none') {
          return;
        } // x/clientX/offsetX/outerX


        var maxX, maxY, minX, minY, maxCX, maxCY, minCX, minCY, maxFX, maxFY, minFX, minFY, maxOX, maxOY, minOX, minOY;
        var length = contentBoxList.length;

        if (length) {
          // 遍历contentBox，里面存的是LineBox内容，根据父LineBox引用判断是否换行
          contentBoxList.forEach(function (item, i) {
            // 非第一个除了minY不用看其它都要，minX是换行导致，而maxX在最后一个要考虑右侧mpb，中间的无需考虑嵌套inline的mpb
            if (i) {
              minX = Math.min(minX, item.x);
              minCX = Math.min(minCX, item.x);
              minFX = Math.min(minFX, item.x);
              minOX = Math.min(minOX, item.x);

              if (i === length - 1) {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
                maxY = maxCY = maxFY = maxOY = Math.max(maxY, item.y + item.outerHeight);
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              } else {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
              }
            } // 第一个初始化
            else {
              minX = item.x;
              minY = item.y;
              minCX = minX - paddingLeft;
              minCY = minY - paddingTop;
              minFX = minCX - borderLeftWidth;
              minFY = minCY - borderTopWidth;
              minOX = minFX - marginLeft;
              minOY = minFY - marginTop;
              maxX = maxCX = maxFX = maxOX = item.x + item.outerWidth;
              maxY = maxCY = maxFY = maxOY = item.y + item.outerHeight;

              if (i === length - 1) {
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              }
            }
          });
          this.__x = minOX;
          this.__y = minOY;
          this.__width = computedStyle[WIDTH$2] = maxX - minX; // 防止比自己最小高度lineHeight还小，比如内容是个小字体

          this.__height = computedStyle[HEIGHT$2] = Math.max(lineHeight, maxY - minY);
          this.__clientWidth = maxCX - minCX;
          this.__clientHeight = maxCY - minCY;
          this.__offsetWidth = maxFX - minFX;
          this.__offsetHeight = maxFY - minFY;
          this.__outerWidth = maxOX - minOX;
          this.__outerHeight = maxOY - minOY;
          this.__x1 = minFX;
          this.__y1 = minFY;
          this.__x2 = minCX;
          this.__y2 = minCY;
          this.__x3 = minX;
          this.__y3 = minY;
          this.__x4 = maxX;
          this.__y4 = maxY;
          this.__x5 = maxCX;
          this.__y5 = maxCY;
          this.__x6 = maxFX;
          this.__y6 = maxFY; // inline的text整体设置相同

          if (['center', 'right'].indexOf(textAlign) > -1) {
            this.children.forEach(function (item) {
              if (item instanceof Text) {
                item.__inlineSize(isUpright);
              }
            });
          }
        } // 如果没有内容，宽度为0高度为lineHeight，对齐也特殊处理，lineBoxManager不会处理
        else {
          var tw = 0,
              th = 0;

          if (['center', 'right'].indexOf(textAlign) > -1) {
            var diff = size;

            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (diff > 0) {
              if (isUpright) {
                this.__offsetY(diff, true, null);
              } else {
                this.__offsetX(diff, true, null);
              }
            }
          }

          if (isUpright) {
            tw = lineHeight;

            this.__ioSize(tw, 0);

            this.__x -= marginLeft + paddingLeft + borderLeftWidth;
          } else {
            th = lineHeight;

            this.__ioSize(0, th);

            this.__y -= marginTop + paddingTop + borderTopWidth;
          }

          this.__x1 = this.__x + marginLeft;
          this.__y1 = this.__y + marginTop;
          this.__x2 = this.__x1 + borderLeftWidth;
          this.__y2 = this.__y1 + borderTopWidth;
          this.__x4 = this.__x3 = this.__x2 + paddingLeft;
          this.__y4 = this.__y3 = this.__y2 + paddingTop;
          this.__x5 = this.__x4 + tw + paddingRight;
          this.__y5 = this.__y4 + th + paddingBottom;
          this.__x6 = this.__x5 + borderRightWidth;
          this.__y6 = this.__y5 + borderBottomWidth;
          this.__clientWidth = this.__x5 - this.__x2;
          this.__clientHeight = this.__y5 - this.__y2;
          this.__offsetWidth = this.__x6 - this.__x1;
          this.__offsetHeight = this.__y6 - this.__y1;
          this.__outerWidth = this.__offsetWidth + marginLeft + marginRight;
          this.__outerHeight = this.__offsetHeight + marginTop + marginBottom;
        }
      }
      /**
       * 只针对绝对定位children布局
       * @param container
       * @param data
       * @param target 可选，只针对某个abs的child特定布局，在局部更新时用
       * @private
       */

    }, {
      key: "__layoutAbs",
      value: function __layoutAbs(container, data, target) {
        var _this6 = this;

        var x = container.__x,
            y = container.__y,
            clientWidth = container.__clientWidth,
            clientHeight = container.__clientHeight,
            computedStyle = container.__computedStyle;
        var isDestroyed = this.__isDestroyed,
            children = this.children,
            absChildren = this.absChildren;
        var display = computedStyle[DISPLAY$3],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            marginTop = computedStyle[MARGIN_TOP],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            paddingTop = computedStyle[PADDING_TOP];

        if (isDestroyed || display === 'none') {
          this.__layoutNone();

          return;
        }

        x += marginLeft + borderLeftWidth;
        y += marginTop + borderTopWidth; // 对absolute的元素进行相对容器布局

        absChildren.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          var currentStyle = item.currentStyle,
              computedStyle = item.computedStyle;

          if (item.isDestroyed || currentStyle[DISPLAY$3] === 'none') {
            item.__layoutNone();

            return;
          } // 先根据容器宽度计算margin/padding，匿名块对象特殊处理，此时没有computedStyle


          item.__computeReflow();

          item.__mp(currentStyle, computedStyle, clientWidth);

          var left = currentStyle[LEFT$1],
              top = currentStyle[TOP$1],
              right = currentStyle[RIGHT$1],
              bottom = currentStyle[BOTTOM$1],
              width = currentStyle[WIDTH$2],
              height = currentStyle[HEIGHT$2];
          var x2, y2, w2, h2;
          var onlyRight;
          var onlyBottom;
          var fixedTop;
          var fixedRight;
          var fixedBottom;
          var fixedLeft; // 判断何种方式的定位，比如左+宽度，左+右之类

          if (left.u !== AUTO$1) {
            fixedLeft = true;
            computedStyle[LEFT$1] = _this6.__calSize(left, clientWidth, true);
          } else {
            computedStyle[LEFT$1] = 'auto';
          }

          if (right.u !== AUTO$1) {
            fixedRight = true;
            computedStyle[RIGHT$1] = _this6.__calSize(right, clientWidth, true);
          } else {
            computedStyle[RIGHT$1] = 'auto';
          }

          if (top.u !== AUTO$1) {
            fixedTop = true;
            computedStyle[TOP$1] = _this6.__calSize(top, clientHeight, true);
          } else {
            computedStyle[TOP$1] = 'auto';
          }

          if (bottom.u !== AUTO$1) {
            fixedBottom = true;
            computedStyle[BOTTOM$1] = _this6.__calSize(bottom, clientHeight, true);
          } else {
            computedStyle[BOTTOM$1] = 'auto';
          } // 优先级最高left+right，其次left+width，再次right+width，再次仅申明单个，最次全部auto


          if (fixedLeft && fixedRight) {
            x2 = x + computedStyle[LEFT$1];
            w2 = clientWidth - computedStyle[RIGHT$1] - computedStyle[LEFT$1];
          } else if (fixedLeft) {
            x2 = x + computedStyle[LEFT$1];

            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } else if (fixedRight) {
            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            } else {
              onlyRight = true;
            }

            x2 = x + clientWidth - computedStyle[RIGHT$1] - (w2 || 0); // 右对齐有尺寸时还需减去margin/border/padding的

            x2 -= computedStyle[MARGIN_LEFT$1];
            x2 -= computedStyle[MARGIN_RIGHT$1];
            x2 -= computedStyle[PADDING_LEFT$1];
            x2 -= computedStyle[PADDING_RIGHT$1];
            x2 -= computedStyle[BORDER_LEFT_WIDTH$1];
            x2 -= computedStyle[BORDER_RIGHT_WIDTH$1];
          } else {
            x2 = x + paddingLeft;

            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } // top/bottom/height优先级同上


          if (fixedTop && fixedBottom) {
            y2 = y + computedStyle[TOP$1];
            h2 = clientHeight - computedStyle[TOP$1] - computedStyle[BOTTOM$1];
          } else if (fixedTop) {
            y2 = y + computedStyle[TOP$1];

            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } else if (fixedBottom) {
            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            } else {
              onlyBottom = true;
            }

            y2 = y + clientHeight - computedStyle[BOTTOM$1] - (h2 || 0); // 底对齐有尺寸时y值还需减去margin/border/padding的

            y2 -= computedStyle[MARGIN_TOP];
            y2 -= computedStyle[MARGIN_BOTTOM];
            y2 -= computedStyle[PADDING_TOP];
            y2 -= computedStyle[PADDING_BOTTOM];
            y2 -= computedStyle[BORDER_TOP_WIDTH];
            y2 -= computedStyle[BORDER_BOTTOM_WIDTH];
          } // 未声明y的找到之前的流布局child，紧随其下
          else {
            y2 = y + paddingTop;
            var prev = item.__prev,
                mtList = [],
                mbList = [];

            while (prev) {
              // 以前面的flow的最近的prev末尾为准
              if (prev instanceof Text || prev instanceof Component && prev.shadowRoot instanceof Text || prev.computedStyle[POSITION$1] !== 'absolute') {
                // 当prev是空白节点时，还要考虑margin合并的影响
                var cps = prev.computedStyle;

                if (prev.clientHeight <= 0) {
                  mtList.push(cps[MARGIN_TOP]);
                  mbList.push(cps[MARGIN_BOTTOM]);
                } else {
                  mbList.push(cps[MARGIN_BOTTOM]);
                  var t = reflow.getMergeMargin(mtList, mbList);
                  y2 = prev.__y1 + prev.offsetHeight + t.target;
                  break;
                }
              }

              prev = prev.__prev;
            }

            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } // onlyRight时做的布局其实是以那个点位为left/top布局然后offset，limit要特殊计算，从本点向左侧为边界


          var widthLimit = onlyRight ? x2 - x : clientWidth + x - x2; // onlyBottom相同，正常情况是左上到右下的尺寸限制

          var heightLimit = onlyBottom ? y2 - y : clientHeight + y - y2; // 未直接或间接定义尺寸，取特殊孩子宽度的最大值，同时不能超限

          if (w2 === undefined) {
            item.__layoutFlow({
              x: x2,
              y: y2,
              w: widthLimit,
              h: heightLimit,
              isUpright: data.isUpright,
              // 父亲的
              container: container
            }, true, false);

            widthLimit = item.outerWidth;
          } // 这里用包裹方法标明要递归计算computedStyle


          item.__layoutFlow({
            x: x2,
            y: y2,
            w: widthLimit,
            h: heightLimit,
            w2: w2,
            // left+right这种等于有宽度，但不能修改style，继续传入到__preLayout中特殊对待
            h2: h2,
            isUpright: data.isUpright,
            container: container
          }, false, false);

          if (onlyRight) {
            item.__offsetX(-item.width, true, null);
          }

          if (onlyBottom) {
            item.__offsetY(-item.height, true, null);
          }

          item.__layoutStyle();
        }); // 递归进行，遇到absolute/relative/component的设置新容器

        children.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          if (item instanceof Dom) {
            item.__layoutAbs(isRelativeOrAbsolute(item) ? item : container, data, null);
          } else if (item instanceof Component) {
            var sr = item.shadowRoot;

            if (sr instanceof Dom) {
              sr.__layoutAbs(sr, data, null);
            }
          }
        }); // parse的abs根节点自己特殊执行，不在layout统一

        this.__animateRecords && this.__root.__addAr(this);
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Dom.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        var ep = this.__ellipsis;

        if (ep) {
          ep.render(renderMode, res.ctx, dx, dy);
        }

        if (renderMode === SVG) {
          this.virtualDom.type = 'dom';
        }

        return res;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        this.children.forEach(function (child) {
          // 有可能为空，因为diff过程中相同的cp被移到新的vd中，老的防止destroy设null
          if (child) {
            child.__destroy();
          }
        });

        if (this.__ellipsis) {
          this.__ellipsis.__destroy();
        }

        _get(_getPrototypeOf(Dom.prototype), "__destroy", this).call(this);
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, pm, force) {
        var _this7 = this;

        if (force) {
          return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, force);
        }

        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.__computedStyle,
            __mask = this.__mask,
            __cacheTotal = this.__cacheTotal;

        if (__isDestroyed || computedStyle[DISPLAY$3] === 'none' || e.__stopPropagation || __mask) {
          return;
        } // 检查perspective嵌套状态，自身有perspective则设置10位，自身有transform的p矩阵则设置01位
        // if(computedStyle[PERSPECTIVE]) {
        //   perspectiveNest++;
        // }
        // if(tf.isPerspectiveMatrix(computedStyle[TRANSFORM])) {
        //   perspectiveTfNest++;
        // }
        // overflow:hidden时还需要判断是否超出范围外，如果是则无效


        if (computedStyle[OVERFLOW$1] === 'hidden' && !this.willResponseEvent(e, true)) {
          return;
        } // __cacheTotal可提前判断是否在bbox范围内，svg没有bbox防止进入判断，
        // img比较特殊，cache只有自己，不能进入，否则鼠标移入mousemove会错误覆盖matrixEvent


        if (__cacheTotal && __cacheTotal.__available && __cacheTotal.bbox && this.__tagName !== 'img') {
          // 不是E的话，因为缓存缘故影响cache的子元素，先左乘可能的父matrix（嵌套cache），再赋值给pm递归传下去
          if (!isE$2(this.matrix)) {
            pm = multiply$1(pm, this.matrix);
            assignMatrix$1(this.__matrixEvent, pm);
          } else if (this.__perspectiveMatrix) {
            pm = this.__perspectiveMatrix;
          }

          var bbox = __cacheTotal.bbox;

          if (!geom.pointInQuadrilateral(e.x, e.y, bbox[0], bbox[1], bbox[2], bbox[1], bbox[2], bbox[3], bbox[0], bbox[3], this.__matrixEvent)) {
            return;
          }
        } // 递归传下来的pm如果有说明是cache的子元素且需要重新计算matrix
        else if (!isE$2(pm)) {
          assignMatrix$1(this.__matrixEvent, matrix.multiply(pm, this.matrix));
        } // 找到对应的callback


        var type = e.event.type;
        var listener = this.listener,
            zIndexChildren = this.zIndexChildren;
        var cb;

        if (listener.hasOwnProperty(type)) {
          cb = listener[type];
        } // child触发则parent一定触发


        for (var i = zIndexChildren.length - 1; i >= 0; i--) {
          var child = zIndexChildren[i];

          if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
            if (child.__emitEvent(e, pm, false)) {
              // 孩子阻止冒泡
              if (e.__stopPropagation) {
                return;
              }

              if (Array.isArray(cb) && !e.__stopImmediatePropagation) {
                cb.forEach(function (item) {
                  if (isFunction$3(item)) {
                    item.call(_this7, e);
                  }
                });
              } else if (isFunction$3(cb) && !e.__stopImmediatePropagation) {
                cb.call(this, e);
              }

              return true;
            }
          }
        } // child不触发再看自己


        return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, false);
      }
    }, {
      key: "appendChild",
      value: function appendChild(child, cb) {
        var root = this.__root,
            host = this.__host,
            children = this.__children;

        if (!(child instanceof Node$1 || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove(); // 只设兄弟/parent，children在relation做，离屏则等真实添加时机

        var len = children.length;

        if (len) {
          var last = children[len - 1];
          last.__next = child;
          child.__prev = last;
        }

        child.__parent = this;
        children.push(child); // 离屏情况，不刷新

        if (this.__isDestroyed) {
          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, host || root, this, child, {});
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);

        this.__insertStruct(child, zIndexChildren.indexOf(child)); // 可能为component，不能用__currentStyle


        if (child.currentStyle[DISPLAY$3] === 'none' || this.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 在reflow过程中设置struct，text视为父变更


        if (child instanceof Text) {
          child = this;
        }

        root.__addUpdate(child, null, REFLOW$1, true, false, false, false, cb);
      }
    }, {
      key: "prependChild",
      value: function prependChild(child, cb) {
        var root = this.__root,
            host = this.__host,
            children = this.__children;

        if (!(child instanceof Node$1 || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove(); // 只设兄弟/parent，children在relation做，离屏则等真实添加时机

        var len = children.length;

        if (len) {
          var first = children[0];
          first.__prev = child;
          child.__next = first;
        }

        child.__parent = this;
        children.unshift(child); // 离屏情况，不刷新

        if (this.__isDestroyed) {
          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, host, this, child, {});
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);

        this.__insertStruct(child, zIndexChildren.indexOf(child)); // 可能为component，不能用__currentStyle


        if (child.currentStyle[DISPLAY$3] === 'none' || this.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 可见在reflow过程中设置struct


        if (child instanceof Text) {
          child = this;
        }

        root.__addUpdate(child, null, REFLOW$1, true, false, false, false, cb);
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(child, cb) {
        var root = this.__root;

        if (!(child instanceof Node$1 || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove();
        var parent = this.isShadowRoot ? this.__hostRoot.__parent : this.__parent;
        var i; // 即便没被添加到dom中，也有可能有父节点，除非是离屏根节点，注意组件

        if (parent) {
          var children = parent.__children;
          var target = this.isShadowRoot ? this.__hostRoot : this;
          i = children.indexOf(target);

          if (i === -1) {
            throw new Error('Index exception of insertBefore()');
          }

          var prev = target.__prev;

          if (prev) {
            prev.__next = child;
            child.__prev = prev;
          }

          child.__next = target;
          target.__prev = child;
          children.splice(i, 0, child);
        } else {
          throw new Error('InsertBefore() illegal');
        } // 离屏情况，不刷新


        if (this.__isDestroyed) {
          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, parent.__host, parent, child, {});
        parent.__zIndexChildren = genZIndexChildren(parent);

        parent.__insertStruct(child, parent.__zIndexChildren.indexOf(child));

        if (child.currentStyle[DISPLAY$3] === 'none' || parent.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$3(cb)) {
            cb();
          }

          return;
        }

        if (child instanceof Text) {
          child = parent;
        }

        root.__addUpdate(child, null, REFLOW$1, true, false, false, false, cb);
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(child, cb) {
        var root = this.__root;

        if (!(child instanceof Node$1 || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove();
        var parent = this.isShadowRoot ? this.__hostRoot.__parent : this.__parent;
        var i; // 即便没被添加到dom中，也有可能有父节点，除非是离屏根节点，注意组件

        if (parent) {
          var children = parent.__children;
          var target = this.isShadowRoot ? this.__hostRoot : this;
          i = children.indexOf(target);

          if (i === -1) {
            throw new Error('Index exception of insertBefore()');
          }

          target.__next = child;
          child.__prev = target;
          children.splice(i + 1, 0, child);
        } else {
          throw new Error('InsertAfter() illegal');
        } // 离屏情况，不刷新


        if (this.__isDestroyed) {
          if (isFunction$3(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, parent.__host, parent, child, {});
        parent.__zIndexChildren = genZIndexChildren(parent);

        parent.__insertStruct(child, parent.__zIndexChildren.indexOf(child));

        if (child.currentStyle[DISPLAY$3] === 'none' || parent.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$3(cb)) {
            cb();
          }

          return;
        }

        if (child instanceof Text) {
          child = parent;
        }

        root.__addUpdate(child, null, REFLOW$1, true, false, false, false, cb);
      }
    }, {
      key: "removeChild",
      value: function removeChild(target, cb) {
        if ((target.__parent === this || target.__domParent === this) && (target instanceof Node$1 || target instanceof Component)) {
          target.remove(cb);
        } else {
          inject.error('Invalid parameter of removeChild()');
        }
      }
    }, {
      key: "children",
      get: function get() {
        return this.__children;
      }
    }, {
      key: "flowChildren",
      get: function get() {
        return this.__children.filter(function (item) {
          if (item instanceof Component) {
            item = item.shadowRoot;
          }

          return item instanceof Text || item.__currentStyle[POSITION$1] !== 'absolute';
        });
      }
    }, {
      key: "absChildren",
      get: function get() {
        return this.__children.filter(function (item) {
          if (item instanceof Component) {
            item = item.__shadowRoot;
          }

          return item instanceof Xom && item.__currentStyle[POSITION$1] === 'absolute';
        });
      }
    }, {
      key: "zIndexChildren",
      get: function get() {
        return this.__zIndexChildren;
      }
    }, {
      key: "lineBoxManager",
      get: function get() {
        return this.__lineBoxManager;
      }
    }, {
      key: "baseline",
      get: function get() {
        var _this$computedStyle2 = this.computedStyle,
            marginTop = _this$computedStyle2[MARGIN_TOP],
            borderTopWidth = _this$computedStyle2[BORDER_TOP_WIDTH],
            paddingTop = _this$computedStyle2[PADDING_TOP],
            writingMode = _this$computedStyle2[WRITING_MODE$1];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === 0) {
          return this.offsetHeight;
        }

        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.baseline;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return this.offsetHeight;
        }

        var _this$computedStyle3 = this.computedStyle,
            marginTop = _this$computedStyle3[MARGIN_TOP],
            borderTopWidth = _this$computedStyle3[BORDER_TOP_WIDTH],
            paddingTop = _this$computedStyle3[PADDING_TOP];
        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.firstBaseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return 0;
        }

        var _this$computedStyle4 = this.computedStyle,
            marginLeft = _this$computedStyle4[MARGIN_LEFT$1],
            borderLeftWidth = _this$computedStyle4[BORDER_LEFT_WIDTH$1],
            paddingLeft = _this$computedStyle4[PADDING_LEFT$1],
            writingMode = _this$computedStyle4[WRITING_MODE$1];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === -1) {
          return 0;
        }

        return marginLeft + borderLeftWidth + paddingLeft + this.lineBoxManager.verticalBaseline;
      }
    }]);

    return Dom;
  }(Xom);

  /**
   * canvas和texture合图的基类，和Page类配合，抽象出基础尺寸偏差等信息
   * 派生2个子类
   */
  var uuid$2 = 0;

  var Cache = /*#__PURE__*/function () {
    function Cache(renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1) {
      this.__uuid = uuid$2++;
      this.__renderMode = renderMode;
      this.__ctx = ctx;
      this.__rootId = rootId;

      this.__init(w, h, bbox, page, pos, x1, y1);
    }

    _createClass(Cache, [{
      key: "__init",
      value: function __init(w, h, bbox, page, pos, x1, y1) {
        this.__width = this.__tw = w; // 由于图片共享一个，可能出现绘制尺寸和缓存尺寸不一致，所以单独存2份数据

        this.__height = this.__th = h;
        this.__bbox = bbox;
        this.__page = page;
        this.__pos = pos;

        var _page$getCoords = page.getCoords(pos),
            x = _page$getCoords.x,
            y = _page$getCoords.y;

        this.__x = x;
        this.__y = y;
        var size = page.__size;
        this.__tx1 = x / size;
        this.__ty1 = (size - y - h) / size;
        this.__tx2 = (x + w) / size;
        this.__ty2 = (size - y) / size;
        this.__enabled = true;
        this.__available = false;

        this.__appendData(x1, y1);
      }
    }, {
      key: "__appendData",
      value: function __appendData(x1, y1) {
        this.x1 = x1; // 去除margin的左上角原点坐标

        this.y1 = y1;
        var bbox = this.__bbox;
        this.dx = this.__x - bbox[0]; // cache坐标和box原点的差值

        this.dy = this.__y - bbox[1];
        this.dbx = x1 - bbox[0]; // 原始sx1/sy1和box原点的差值

        this.dby = y1 - bbox[1]; // this.update();
      } // canvas绘制时主动调用更新bbox, x1, y1

    }, {
      key: "update",
      value: function update() {
        this.__page.__update = true;
      }
    }, {
      key: "clear",
      value: function clear() {
        if (this.__available) {
          this.__available = false;
          this.update();
          return true;
        }
      } // svg打标用会覆盖此方法

    }, {
      key: "release",
      value: function release() {
        if (this.__enabled) {
          this.clear();

          this.__page.del(this.__pos);

          this.__page = null;
          this.__enabled = false;
          return true;
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1, klass) {
        // 尺寸没变复用之前的并清空
        this.release();
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var res = klass.getInstance(this.__renderMode, this.__ctx, this.__rootId, Math.max(w, h), null);

        if (!res) {
          return;
        }

        var page = res.page,
            pos = res.pos;

        this.__init(w, h, bbox, page, pos, x1, y1);
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.y1 += diff;
        var bbox = this.__bbox;
        bbox[1] += diff;
        bbox[3] += diff;
        this.dy -= diff;
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      } // 是否功能可用，生成离屏canvas及尺寸超限

    }, {
      key: "enabled",
      get: function get() {
        return this.__enabled;
      } // 是否有可用缓存内容

    }, {
      key: "available",
      get: function get() {
        return this.__enabled && this.__available;
      }
    }, {
      key: "bbox",
      get: function get() {
        return this.__bbox;
      }
    }, {
      key: "page",
      get: function get() {
        return this.__page;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "pos",
      get: function get() {
        return this.__pos;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__page.__size;
      }
    }, {
      key: "texture",
      get: function get() {
        return this.__page.texture;
      }
    }, {
      key: "updated",
      get: function get() {
        return this.__page.__update;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, bbox, x1, y1, cacheKlass, pageKlass, excludePage) {
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var n = Math.max(w, h);

        if (n <= 0) {
          return;
        }

        var res = pageKlass.getInstance(renderMode, ctx, rootId, n, excludePage);

        if (!res) {
          return;
        }

        var page = res.page,
            pos = res.pos;
        return new cacheKlass(renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1);
      }
    }, {
      key: "getImgInstance",
      value: function getImgInstance(renderMode, ctx, rootId, bbox, x1, y1, w, h, cacheKlass, pageKlass, excludePage) {
        var n = Math.max(w, h);

        if (n <= 0) {
          return;
        }

        var res = pageKlass.getInstance(renderMode, ctx, rootId, n, excludePage);

        if (!res) {
          return;
        }

        var page = res.page,
            pos = res.pos;
        var o = new cacheKlass(renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1);
        o.__tw = bbox[2] - bbox[0];
        o.__th = bbox[3] - bbox[1];
        return o;
      }
    }]);

    return Cache;
  }();

  /**
   * 默认的动态合图配置，保守低端机8个纹理单元和最大2048px尺寸，一般chrome是16个和16384px
   * webgl初始化会调用获取参数动态进行更改，16px是最小划分基本单位1，后续成2倍增长
   * 并不需要非常紧凑合理，因为特定需求如骨骼动画，合图都是前置做好的，这里应对临时的Dom位图
   * 应该尽可能避免纹理单元切换，因此设计固定的正方形尺寸，以2的幂次方增长，从16px开始到MAX
   * 每个texture从左到右按小到大排列，一列都为相同尺寸的正方形格子，用数组存储表示状态
   * 内容0为空白，1为单位1大小占用，2为2个单位1，如此成2倍增长，可能会形成这种状态：
   * 1 0 2 2 4 4 4 4 ...
   * 其中开头0位置是个单位1的正方形，1位置为空，2、3位置为一个2个单位的正方形，4、5、6、7是4个单位
   * 一张纹理存储时可以按照自己的bbox尺寸计算出正方形大小n，然后循环搜索，每次递增n，不必++遍历
   * 如此可满足不同尺寸分布在一张texture上的需求，碎片情况也较少，避免频繁纹理切换，清空置0
   * canvas模式时固定2048，是个保守值，当webgl第一次初始化，会改变这些值
   */
  var UNIT = 16;
  var MAX = 2048;
  var NUMBER = 128;
  var HASH$2 = {};
  var uuid$1 = 0;
  var _init = false;

  var Page = /*#__PURE__*/function () {
    function Page(renderMode, ctx, size, number) {
      this.__size = size;
      this.__number = number;
      this.__width = this.__height = size; // 标识n*n个单元格是否空闲可用，一维数组表示

      this.__grid = new Uint16Array(number * number);
      this.__uuid = uuid$1++; // webgl贴图缓存更新使用，canvas/img等发生变更需刷新重新生成texture，fbo的texture不需要

      this.__update = false;
      this.time = 0;
      this.__ctx = ctx;
      this.__count = 0;
    }

    _createClass(Page, [{
      key: "add",
      value: function add(unitSize, pos) {
        var number = this.number,
            grid = this.grid;

        for (var i = pos; i < pos + unitSize; i++) {
          grid[i] = unitSize;

          for (var j = 1; j < unitSize; j++) {
            grid[i + j * number] = unitSize;
          }
        }

        this.__count++;
      }
    }, {
      key: "del",
      value: function del(pos) {
        var number = this.number,
            grid = this.grid;
        var u = grid[pos];

        if (u) {
          grid[pos] = 0;

          for (var i = pos; i < pos + u; i++) {
            grid[i] = 0;

            for (var j = 1; j < u; j++) {
              grid[i + j * number] = 0;
            }
          }
        }

        this.__count--;
      }
    }, {
      key: "getCoords",
      value: function getCoords(pos) {
        var number = this.number;
        var x = pos % number * UNIT;
        var y = Math.floor(pos / number) * UNIT;
        return {
          x: x,
          y: y
        };
      }
    }, {
      key: "getFreePos",
      value: function getFreePos(unitSize) {
        var number = this.number,
            grid = this.grid;

        outer: for (var i = 0; i < number; i++) {
          var u = grid[i]; // 有值，判断是否相同可归同列

          if (u) {
            if (u === unitSize) {
              // 找到同尺寸的列位置，向下查找空白区域确定行位置
              for (var j = unitSize; j < number; j += unitSize) {
                var n = i + j * number;

                if (!grid[n]) {
                  return n;
                }
              }
            } else {
              i += u - 1;
            }
          } // 无值，先防止到右边距离不够
          else if (i + unitSize <= number) {
            // 如果需要占用这些列，那么所有数据都必须为空，因为可能之前其它尺寸的占了，但上面开头数据被删除了
            for (var _j = i, len = i + unitSize; _j < len; _j++) {
              for (var k = 0; k < number; k++) {
                if (grid[_j + k * number]) {
                  i = Math.max(i, _j - 1); // 防止首列检查就不符合死循环，至少列数增1

                  continue outer;
                }
              }
            }

            return i;
          }
        }

        return -1;
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__size;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "number",
      get: function get() {
        return this.__number;
      }
    }, {
      key: "grid",
      get: function get() {
        return this.__grid;
      }
    }, {
      key: "update",
      get: function get() {
        return this.__update;
      },
      set: function set(v) {
        this.__update = v;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, size, klass, excludePage) {
        if (size > MAX) {
          return;
        } // 换算为每单位16px占多少单位


        var unitSize = 1;

        while (UNIT * unitSize < size) {
          unitSize <<= 1;
        }

        var m = MAX,
            n = NUMBER; // 限制使用2048，部分机型大尺寸会卡或者黑屏，webgl甚至不渲染，超过的 TODO:
        // if(size < 2048 && MAX === 8192) {
        //   m = 2048;
        //   n = Math.ceil(m / UNIT);
        // }

        var key = rootId + ',' + renderMode; // 每个root复用自己的合图，webgl中为了隔离不同实例

        var list = HASH$2[key] = HASH$2[key] || [];
        var page, pos;

        for (var i = 0, len = list.length; i < len; i++) {
          var item = list[i];

          if (excludePage && item === excludePage || item.__size !== m) {
            continue;
          }

          pos = item.getFreePos(unitSize);

          if (pos > -1) {
            page = item;
            break;
          }
        }

        if (!page) {
          page = new klass(renderMode, ctx, m, n);
          pos = 0;
          list.push(page);
        }

        page.add(unitSize, pos);
        return {
          page: page,
          pos: pos
        };
      }
    }, {
      key: "UNIT",
      get: function get() {
        return UNIT;
      }
    }, {
      key: "MAX",
      get: function get() {
        return MAX;
      },
      set: function set(MAX_TEXTURE_SIZE) {
        _init = true; // 确保MAX_TEXTURE_SIZE是2的幂级数，如果不是向下取整

        var n = 2;

        while (n < MAX_TEXTURE_SIZE) {
          n = n << 1;

          if (n >= MAX_TEXTURE_SIZE) {
            if (n > MAX_TEXTURE_SIZE) {
              n = n << 1;
            }

            break;
          }
        }

        MAX = n;
        NUMBER = Math.ceil(MAX / UNIT);
      }
    }, {
      key: "NUMBER",
      get: function get() {
        return NUMBER;
      }
    }, {
      key: "genUuid",
      value: function genUuid() {
        return uuid$1++;
      }
    }, {
      key: "init",
      value: function init(MAX_TEXTURE_SIZE, isAuto) {
        // 手动随时设置，自动仅第一次生效
        if (_init && isAuto) {
          return;
        }

        if (MAX_TEXTURE_SIZE !== MAX) {
          // 超过限制会明显卡一下
          Page.MAX = Math.min(MAX_TEXTURE_SIZE, 2048);
        }
      }
    }]);

    return Page;
  }();

  var calRectPoint$1 = matrix.calRectPoint,
      calRectPointWasm = matrix.calRectPointWasm,
      calPoint = matrix.calPoint;
  /**
   * 初始化 shader
   * @param gl GL context
   * @param vshader vertex shader (string)
   * @param fshader fragment shader (string)
   * @return program, if the program object was created and successfully made current
   */

  function initShaders(gl, vshader, fshader) {
    var program = createProgram(gl, vshader, fshader);

    if (!program) {
      throw new Error('Failed to create program');
    } // 要开启透明度，用以绘制透明的图形


    gl.enable(gl.BLEND); // gl.enable(gl.DEPTH_TEST);
    // gl.enable(gl.POLYGON_OFFSET_FILL);

    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    return program;
  }
  /**
   * Create the linked program object
   * @param gl GL context
   * @param vshader a vertex shader program (string)
   * @param fshader a fragment shader program (string)
   * @return created program object, or null if the creation has failed
   */


  function createProgram(gl, vshader, fshader) {
    // Create shader object
    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

    if (!vertexShader || !fragmentShader) {
      return null;
    } // Create a program object


    var program = gl.createProgram();

    if (!program) {
      return null;
    }

    program.vertexShader = vertexShader;
    program.fragmentShader = fragmentShader; // Attach the shader objects

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader); // Link the program object

    gl.linkProgram(program); // Check the result of linking

    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (!linked) {
      var error = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      gl.deleteShader(fragmentShader);
      gl.deleteShader(vertexShader);
      throw new Error('Failed to link program: ' + error);
    }

    return program;
  }
  /**
   * Create a shader object
   * @param gl GL context
   * @param type the type of the shader object to be created
   * @param source shader program (string)
   * @return created shader object, or null if the creation has failed.
   */


  function loadShader(gl, type, source) {
    // Create shader object
    var shader = gl.createShader(type);

    if (shader == null) {
      throw new Error('unable to create shader');
    } // Set the shader program


    gl.shaderSource(shader, source); // Compile the shader

    gl.compileShader(shader); // Check the result of compilation

    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (!compiled) {
      var error = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error('Failed to compile shader: ' + error);
    }

    return shader;
  }

  function convertCoords2Gl(x, y, z, w, cx, cy, tz) {
    if (w && w !== 1) {
      x /= w;
      y /= w;
      z /= w;
    }

    if (x === cx) {
      x = 0;
    } else {
      x = (x - cx) / cx;
    }

    if (y === cy) {
      y = 0;
    } else {
      y = (cy - y) / cy;
    }

    if (tz) {
      z /= -tz;
    }

    if (w === 1) {
      return {
        x: x,
        y: y,
        z: z,
        w: w
      };
    }

    return {
      x: x * w,
      y: y * w,
      z: z * w,
      w: w
    };
  }

  function createTexture$1(gl, tex, n, width, height) {
    var texture = gl.createTexture();
    bindTexture$1(gl, texture, n);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); // 传入高宽时是绑定fbo，且tex一定为null

    if (width && height) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    } // 普通将canvas对象作为纹理
    else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
  }

  function bindTexture$1(gl, texture, n) {
    gl.activeTexture(gl['TEXTURE' + n]);
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }

  var lastVtPoint, lastVtTex, lastVtOpacity;
  /**
   * texCache集满纹理上传占用最多可用纹理单元后，进行批量顺序绘制
   * 将所有dom的矩形顶点（经过transform变换后的）、贴图坐标、透明度存入3个buffer中，
   * 然后相同纹理单元的形成一批，设置uniform的纹理单元号进行绘制，如此循环
   */

  function drawTextureCache$1(gl, list, cx, cy, dx, dy, wasmOp, wasmMe) {
    var length = list.length;

    if (!length) {
      return;
    }

    var vtPoint, vtTex, vtOpacity;

    if (lastVtPoint && lastVtPoint.length === length * 24) {
      vtPoint = lastVtPoint;
    } else {
      vtPoint = lastVtPoint = new Float32Array(length * 24);
    }

    if (lastVtTex && lastVtTex.length === length * 12) {
      vtTex = lastVtTex;
    } else {
      vtTex = lastVtTex = new Float32Array(length * 12);
    }

    if (lastVtOpacity && lastVtOpacity.length === length * 6) {
      vtOpacity = lastVtOpacity;
    } else {
      vtOpacity = lastVtOpacity = new Float32Array(length * 6);
    }

    for (var i = 0; i < length; i++) {
      var item = list[i];
      var cache = item.cache,
          index = item.index,
          wasm = item.wasm;
      var opacity = void 0,
          matrix = void 0;
      var width = cache.__tw,
          height = cache.__th,
          tx1 = cache.__tx1,
          ty1 = cache.__ty1,
          tx2 = cache.__tx2,
          ty2 = cache.__ty2,
          page = cache.__page,
          bbox = cache.__bbox;

      if (!i) {
        // canvas需要生成texture，texture则强制不会进来
        if (page.__update) {
          page.genTexture(gl);
        }

        bindTexture$1(gl, page.texture, 0);
      }

      if (wasm) {
        opacity = wasmOp[index];
      } else {
        opacity = item.opacity;
        matrix = item.matrix;
      } // 计算顶点坐标和纹理坐标，转换[0,1]对应关系


      var x1 = void 0,
          y1 = void 0,
          z1 = void 0,
          w1 = void 0,
          x2 = void 0,
          y2 = void 0,
          z2 = void 0,
          w2 = void 0,
          x3 = void 0,
          y3 = void 0,
          z3 = void 0,
          w3 = void 0,
          x4 = void 0,
          y4 = void 0,
          z4 = void 0,
          w4 = void 0; // wasm中的matrix和普通js取的方式不一样

      var bx = bbox[0],
          by = bbox[1];
      var xa = bx + dx,
          ya = by + height + dy;
      var xb = bx + width + dx,
          yb = by + dy;
      var t = wasm ? calRectPointWasm(xa, ya, xb, yb, wasmMe, index) : calRectPoint$1(xa, ya, xb, yb, matrix);
      x1 = t.x1;
      y1 = t.y1;
      z1 = t.z1;
      w1 = t.w1;
      x2 = t.x2;
      y2 = t.y2;
      z2 = t.z2;
      w2 = t.w2;
      x3 = t.x3;
      y3 = t.y3;
      z3 = t.z3;
      w3 = t.w3;
      x4 = t.x4;
      y4 = t.y4;
      z4 = t.z4;
      w4 = t.w4; // console.warn(x1,y1,z1,w1,',',x2,y2,z2,w2,',',x3,y3,z3,w3,',',x4,y4,z4,w4);
      // z范围取所有、对角线最大值，只有当非0有值时才求

      var z = Math.max(Math.abs(z1), Math.abs(z2));
      z = Math.max(z, Math.abs(z3));
      z = Math.max(z, Math.abs(z4));

      if (z) {
        z = Math.max(z, Math.sqrt(cx * cx + cy * cy));
      }

      t = convertCoords2Gl(x1, y1, z1, w1, cx, cy, z);
      x1 = t.x;
      y1 = t.y;
      z1 = t.z;
      t = convertCoords2Gl(x2, y2, z2, w2, cx, cy, z);
      x2 = t.x;
      y2 = t.y;
      z2 = t.z;
      t = convertCoords2Gl(x3, y3, z3, w3, cx, cy, z);
      x3 = t.x;
      y3 = t.y;
      z3 = t.z;
      t = convertCoords2Gl(x4, y4, z4, w4, cx, cy, z);
      x4 = t.x;
      y4 = t.y;
      z4 = t.z; // console.log(x1,y1,z1,w1,',',x2,y2,z2,w2,',',x3,y3,z3,w3,',',x4,y4,z4,w4);

      var j = i * 24;
      vtPoint[j] = x1;
      vtPoint[j + 1] = y1;
      vtPoint[j + 2] = z1;
      vtPoint[j + 3] = w1;
      vtPoint[j + 4] = x4;
      vtPoint[j + 5] = y4;
      vtPoint[j + 6] = z4;
      vtPoint[j + 7] = w4;
      vtPoint[j + 8] = x2;
      vtPoint[j + 9] = y2;
      vtPoint[j + 10] = z2;
      vtPoint[j + 11] = w2;
      vtPoint[j + 12] = x4;
      vtPoint[j + 13] = y4;
      vtPoint[j + 14] = z4;
      vtPoint[j + 15] = w4;
      vtPoint[j + 16] = x2;
      vtPoint[j + 17] = y2;
      vtPoint[j + 18] = z2;
      vtPoint[j + 19] = w2;
      vtPoint[j + 20] = x3;
      vtPoint[j + 21] = y3;
      vtPoint[j + 22] = z3;
      vtPoint[j + 23] = w3;
      j = i * 12;
      vtTex[j] = tx1;
      vtTex[j + 1] = ty1;
      vtTex[j + 2] = tx1;
      vtTex[j + 3] = ty2;
      vtTex[j + 4] = tx2;
      vtTex[j + 5] = ty1;
      vtTex[j + 6] = tx1;
      vtTex[j + 7] = ty2;
      vtTex[j + 8] = tx2;
      vtTex[j + 9] = ty1;
      vtTex[j + 10] = tx2;
      vtTex[j + 11] = ty2;
      j = i * 6;
      vtOpacity[j] = opacity;
      vtOpacity[j + 1] = opacity;
      vtOpacity[j + 2] = opacity;
      vtOpacity[j + 3] = opacity;
      vtOpacity[j + 4] = opacity;
      vtOpacity[j + 5] = opacity;
    } // 顶点buffer


    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtPoint, gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    gl.vertexAttribPointer(a_position, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtTex, gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtOpacity, gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, length * 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.disableVertexAttribArray(a_opacity);
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核扩大3倍性能慢
   * x/y方向分开执行，加速性能，计算次数由d*d变为d+d，d为卷积核大小
   * spread由d和sigma计算得出，d由sigma计算得出，sigma即css的blur()参数
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * i和j为filter和total的纹理单元，3次执行（x/y合起来算1次）需互换单元，来回执行源和结果
   * 由total变为filter时cache会各方向上扩展spread的大小到width/height
   */


  function drawBlur(gl, program, tex1, width, height) {
    gl.useProgram(program);
    gl.viewport(0, 0, width, height);
    /**
     * 注意max和ratio的设置，当是100尺寸的正方形时，传给direction的始终为1
     * 当正方形<100时，direction相应地要扩大相对于100的倍数，反之则缩小，如此为了取相邻点坐标时是+-1
     * 当非正方形时，长轴一端为基准值不变，短的要二次扩大比例倍数
     * tex1和tex2来回3次，最后是到tex1
     */

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position);
    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords);
    var u_texture = gl.getUniformLocation(program, 'u_texture');
    var u_direction = gl.getUniformLocation(program, 'u_direction');
    var recycle = []; // 3次过程中新生成的中间纹理需要回收

    var max = 100 / Math.max(width, height);
    var ratio = width / height;

    for (var n = 0; n < 3; n++) {
      // tex1到tex2
      var tex2 = createTexture$1(gl, null, 1, width, height);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex2, 0);
      bindTexture$1(gl, tex1, 0);

      if (width >= height) {
        gl.uniform2f(u_direction, max, 0);
      } else {
        gl.uniform2f(u_direction, max * ratio, 0);
      }

      gl.uniform1i(u_texture, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6); // tex2到tex1

      var tex3 = createTexture$1(gl, null, 0, width, height);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex3, 0);
      bindTexture$1(gl, tex2, 1);

      if (width >= height) {
        gl.uniform2f(u_direction, 0, max * ratio);
      } else {
        gl.uniform2f(u_direction, 0, max);
      }

      gl.uniform1i(u_texture, 1);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      recycle.push(tex1);
      recycle.push(tex2);
      tex1 = tex3;
    } // 0/1单元都解绑


    bindTexture$1(gl, null, 0);
    bindTexture$1(gl, null, 1); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    recycle.forEach(function (item) {
      return gl.deleteTexture(item);
    });
    return tex1;
  }

  function drawCm(gl, program, target, source, m, center, size) {
    gl.useProgram(program);
    bindTexture$1(gl, source.__page.texture, 0);
    gl.viewport(0, 0, size, size);
    var tx1 = target.x,
        ty1 = target.y,
        w1 = target.width,
        h1 = target.height;
    var tx2 = source.x,
        ty2 = source.y,
        w2 = source.width,
        h2 = source.height;

    var _convertCoords2Gl = convertCoords2Gl(tx1, ty1 + h1, 0, 1, center, center),
        x1 = _convertCoords2Gl.x,
        y2 = _convertCoords2Gl.y;

    var _convertCoords2Gl2 = convertCoords2Gl(tx1 + w1, ty1, 0, 1, center, center),
        x2 = _convertCoords2Gl2.x,
        y1 = _convertCoords2Gl2.y;

    var xa = tx2 / size,
        ya = (size - ty2) / size,
        xb = (tx2 + w2) / size,
        yb = (size - ty2 - h2) / size; // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([xa, ya, xa, yb, xb, ya, xa, yb, xb, ya, xb, yb]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, 0); // matrix

    var u_m = gl.getUniformLocation(program, 'u_m');
    gl.uniform1fv(u_m, new Float32Array(m));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    bindTexture$1(gl, null, 0);
  }
  /**
   * 根据total/filter生成overflow
   */


  function drawOverflow(gl, program, target, source, center, size) {
    gl.useProgram(program);
    var tx1 = target.x,
        ty1 = target.y,
        w1 = target.width,
        h1 = target.height,
        bbox1 = target.bbox;
    var tx2 = source.x,
        ty2 = source.y,
        bbox2 = source.bbox;
    var dx = bbox1[0] - bbox2[0],
        dy = bbox1[1] - bbox2[1];
    gl.viewport(0, 0, size, size);

    var _convertCoords2Gl3 = convertCoords2Gl(tx1, ty1 + h1, 0, 1, center, center),
        x1 = _convertCoords2Gl3.x,
        y2 = _convertCoords2Gl3.y;

    var _convertCoords2Gl4 = convertCoords2Gl(tx1 + w1, ty1, 0, 1, center, center),
        x2 = _convertCoords2Gl4.x,
        y1 = _convertCoords2Gl4.y;

    var xa = (tx2 + dx) / size,
        ya = (size - ty2 - dy) / size,
        xb = (tx2 + w1 + dx) / size,
        yb = (size - ty2 - h1 - dy) / size; // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([xa, ya, xa, yb, xb, ya, xa, yb, xb, ya, xb, yb]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    bindTexture$1(gl, source.__page.texture, 0);
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawMask(gl, program, target, source, temp, center, size) {
    gl.useProgram(program);
    bindTexture$1(gl, source.__page.texture, 0);
    bindTexture$1(gl, temp, 1);
    gl.viewport(0, 0, size, size);
    var tx1 = target.x,
        ty1 = target.y,
        w1 = target.width,
        h1 = target.height;
    var tx2 = source.x,
        ty2 = source.y,
        w2 = source.width,
        h2 = source.height;

    var _convertCoords2Gl5 = convertCoords2Gl(tx1, ty1 + h1, 0, 1, center, center),
        x1 = _convertCoords2Gl5.x,
        y2 = _convertCoords2Gl5.y;

    var _convertCoords2Gl6 = convertCoords2Gl(tx1 + w1, ty1, 0, 1, center, center),
        x2 = _convertCoords2Gl6.x,
        y1 = _convertCoords2Gl6.y;

    var xa = tx2 / size,
        ya = (size - ty2) / size,
        xb = (tx2 + w2) / size,
        yb = (size - ty2 - h2) / size; // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer1 = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer1);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([xa, ya, xa, yb, xb, ya, xa, yb, xb, ya, xb, yb]), gl.STATIC_DRAW);
    var a_texCoords1 = gl.getAttribLocation(program, 'a_texCoords1');
    gl.vertexAttribPointer(a_texCoords1, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords1);
    var texBuffer2 = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0]), gl.STATIC_DRAW);
    var a_texCoords2 = gl.getAttribLocation(program, 'a_texCoords2');
    gl.vertexAttribPointer(a_texCoords2, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords2); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, 0);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, 1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer1);
    gl.deleteBuffer(texBuffer2);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords1);
    gl.disableVertexAttribArray(a_texCoords2);
    gl.deleteTexture(temp);
    gl.bindTexture(gl.TEXTURE_2D, null);
    bindTexture$1(gl, null, 0);
    bindTexture$1(gl, null, 1);
  }

  function drawMbm(gl, program, tex1, tex2) {
    bindTexture$1(gl, tex1, 0);
    bindTexture$1(gl, tex2, 1); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, 0);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, 1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawDropShadow(gl, program, frameBuffer, cache, color, w1, w2, h1, h2) {
    gl.useProgram(program);
    var x = cache.x,
        y = cache.y,
        width = cache.width,
        height = cache.height,
        page = cache.__page;
    var size = page.size,
        texture = page.texture;
    var xa = x / size,
        ya = (size - y) / size,
        xb = (x + width) / size,
        yb = (size - y - height) / size; // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    var w = w1 / w2,
        h = h1 / h2;
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-w, -h, -w, h, w, -h, -w, h, w, -h, w, h]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([xa, yb, xa, ya, xb, yb, xa, ya, xb, yb, xb, ya]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    bindTexture$1(gl, texture, 0);
    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, 0); // color

    var u_color = gl.getUniformLocation(program, 'u_color');
    gl.uniform1fv(u_color, new Float32Array([color[0] / 255, color[1] / 255, color[2] / 255, color[3]]));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    bindTexture$1(gl, null, 0);
  }

  function drawDropShadowMerge(gl, target, size, tex1, dx1, dy1, w, h, tex2, dx2, dy2, width, height) {
    var x = target.x,
        y = target.y;
    var center = size * 0.5;

    var _convertCoords2Gl7 = convertCoords2Gl(x + dx1, y + h + dy1, 0, 1, center, center),
        x1 = _convertCoords2Gl7.x,
        y2 = _convertCoords2Gl7.y;

    var _convertCoords2Gl8 = convertCoords2Gl(x + w + dx1, y + dy1, 0, 1, center, center),
        x2 = _convertCoords2Gl8.x,
        y1 = _convertCoords2Gl8.y; // 顶点buffer


    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    bindTexture$1(gl, tex1, 0);
    var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    var _convertCoords2Gl9 = convertCoords2Gl(x + dx2, y + height + dy2, 0, 1, center, center),
        x3 = _convertCoords2Gl9.x,
        y4 = _convertCoords2Gl9.y;

    var _convertCoords2Gl10 = convertCoords2Gl(x + width + dx2, y + dy2, 0, 1, center, center),
        x4 = _convertCoords2Gl10.x,
        y3 = _convertCoords2Gl10.y;

    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x3, y3, x3, y4, x4, y3, x3, y4, x4, y3, x4, y4]), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
    bindTexture$1(gl, tex2, 0);
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    bindTexture$1(gl, null, 0); // gl.deleteBuffer(pointBuffer);
    // gl.deleteBuffer(texBuffer);
    // gl.deleteBuffer(opacityBuffer);
  }

  function drawTex2Cache$1(gl, program, cache, tex, width, height) {
    gl.useProgram(program);
    var page = cache.__page,
        size = page.__size;
    gl.viewport(0, 0, size, size);
    var x = cache.x,
        y = cache.y,
        center = size * 0.5;

    var _convertCoords2Gl11 = convertCoords2Gl(x, y + height, 0, 1, center, center),
        x1 = _convertCoords2Gl11.x,
        y2 = _convertCoords2Gl11.y;

    var _convertCoords2Gl12 = convertCoords2Gl(x + width, y, 0, 1, center, center),
        x2 = _convertCoords2Gl12.x,
        y1 = _convertCoords2Gl12.y;

    bindTexture$1(gl, tex, 0); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 透明度buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    bindTexture$1(gl, tex, 0);
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.disableVertexAttribArray(a_opacity);
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  function drawCache2Tex$1(gl, program, cache, width, height, spread) {
    var tx1 = cache.x,
        ty1 = cache.y,
        w1 = cache.width,
        h1 = cache.height,
        _cache$__page = cache.__page,
        texture = _cache$__page.texture,
        size = _cache$__page.size;
    gl.useProgram(program);
    gl.viewport(0, 0, width, height); // 首先将cache的纹理原状绘制到tex1上，为后续3次循环做准备，注意扩充的spread距离

    var cx = width * 0.5,
        cy = height * 0.5;

    var _convertCoords2Gl13 = convertCoords2Gl(spread, height - spread, 0, 1, cx, cy),
        x1 = _convertCoords2Gl13.x,
        y2 = _convertCoords2Gl13.y;

    var _convertCoords2Gl14 = convertCoords2Gl(width - spread, spread, 0, 1, cx, cy),
        x2 = _convertCoords2Gl14.x,
        y1 = _convertCoords2Gl14.y;

    var xa = tx1 / size,
        ya = (size - ty1) / size,
        xb = (tx1 + w1) / size,
        yb = (size - ty1 - h1) / size; // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([xa, ya, xa, yb, xb, ya, xa, yb, xb, ya, xb, yb]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    bindTexture$1(gl, texture, 0);
    gl.uniform1i(u_texture, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6); // gl.deleteBuffer(pointBuffer);
    // gl.deleteBuffer(texBuffer);
    // gl.deleteBuffer(opacityBuffer);
  }

  function drawSameSize(gl, tex, opacity) {
    var program = gl.programSs;
    gl.useProgram(program); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, 0);
    bindTexture$1(gl, tex, 0);
    var u_opacity = gl.getUniformLocation(program, 'u_opacity');
    gl.uniform1f(u_opacity, opacity);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.useProgram(gl.program);
  }

  function drawOitPlane(gl, structs, list, ppt, cx, cy, dx, dy) {
    var pointBuffer = gl.createBuffer();
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    var texBuffer = gl.createBuffer();
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    var opacityBuffer = gl.createBuffer();
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    var u_texture = gl.getUniformLocation(gl.program, 'u_texture'); // 循环所有顺序拼图/平面

    for (var i = 0, len = list.length; i < len; i++) {
      var _list$i = list[i],
          isPuzzle = _list$i.isPuzzle,
          node = _list$i.node,
          target = _list$i.target,
          points = _list$i.points;
      var width = target.__width,
          height = target.__height,
          tx1 = target.__tx1,
          ty1 = target.__ty1,
          tx2 = target.__tx2,
          ty2 = target.__ty2,
          page = target.__page,
          bbox = target.__bbox; // 固定绑定纹理0号单元

      if (page.__update) {
        page.genTexture(gl);
      }

      bindTexture$1(gl, page.texture, 0);
      var bx = bbox[0],
          by = bbox[1];
      var opacity = node.__opacity;
      var matrix = node.__matrixEvent;
      var tw = tx2 - tx1,
          th = ty2 - ty1; // 先按照没有拆分拼图的情况求出节点的四个顶点坐标列表，可能有重复利用hash缓存

      var vtPoint = [],
          vtTex = [],
          vtOpacity = [];
      var pHash = [],
          tHash = [];

      if (isPuzzle) {
        // 拼接三角形，以起点为初始点链接其它所有顶点组成n-2个三角形
        var x0 = void 0,
            y0 = void 0,
            z0 = void 0,
            w0 = void 0;
        var p = points[0];
        var o = calPoint({
          x: bx + dx + p.px * width,
          y: by + dy + p.py * height,
          z: 0,
          w: 1
        }, matrix);
        w0 = o.w;
        var t = convertCoords2Gl(o.x, o.y, o.z, w0, cx, cy, ppt);
        x0 = t.x;
        y0 = t.y;
        z0 = t.z;
        var tx0 = tx1 + p.px * tw,
            ty0 = ty1 + p.py * th; // 每次循环以第0个点为起点

        for (var j = 1, _len = points.length; j < _len - 1; j++) {
          vtPoint.push(x0);
          vtPoint.push(y0);
          vtPoint.push(z0);
          vtPoint.push(w0);
          vtTex.push(tx0);
          vtTex.push(ty0);
          vtOpacity.push(opacity); // 依次的2个相邻点

          for (var k = j; k < j + 2; k++) {
            var _p = points[k];
            var x = void 0,
                y = void 0,
                z = void 0,
                w = void 0;
            var hashP = pHash[k];

            if (hashP) {
              x = hashP.x;
              y = hashP.y;
              z = hashP.z;
              w = hashP.w;
            } else {
              var _o = calPoint({
                x: bx + dx + _p.px * width,
                y: by + dy + _p.py * height,
                z: 0,
                w: 1
              }, matrix);

              w = _o.w;

              var _t = convertCoords2Gl(_o.x, _o.y, _o.z, w, cx, cy, ppt);

              x = _t.x;
              y = _t.y;
              z = _t.z;
              pHash[k] = {
                x: x,
                y: y,
                z: z,
                w: w
              };
            }

            vtPoint.push(x);
            vtPoint.push(y);
            vtPoint.push(z);
            vtPoint.push(w);
            var tx = void 0,
                ty = void 0;
            var hashT = tHash[k];

            if (hashT) {
              tx = hashT.tx;
              ty = hashT.ty;
            } else {
              tx = tx1 + _p.px * tw;
              ty = ty1 + _p.py * th;
              tHash[k] = {
                tx: tx,
                ty: ty
              };
            }

            vtTex.push(tx);
            vtTex.push(ty);
            vtOpacity.push(opacity);
          }
        }
      } else {
        var xa = bx + dx,
            ya = by + height + dy;
        var xb = bx + width + dx,
            yb = by + dy;

        var _calRectPoint = calRectPoint$1(xa, ya, xb, yb, matrix),
            x1 = _calRectPoint.x1,
            y1 = _calRectPoint.y1,
            z1 = _calRectPoint.z1,
            w1 = _calRectPoint.w1,
            x2 = _calRectPoint.x2,
            y2 = _calRectPoint.y2,
            z2 = _calRectPoint.z2,
            w2 = _calRectPoint.w2,
            x3 = _calRectPoint.x3,
            y3 = _calRectPoint.y3,
            z3 = _calRectPoint.z3,
            w3 = _calRectPoint.w3,
            x4 = _calRectPoint.x4,
            y4 = _calRectPoint.y4,
            z4 = _calRectPoint.z4,
            w4 = _calRectPoint.w4;

        var _t2 = convertCoords2Gl(x1, y1, z1, w1, cx, cy, ppt);

        x1 = _t2.x;
        y1 = _t2.y;
        z1 = _t2.z;
        _t2 = convertCoords2Gl(x2, y2, z2, w2, cx, cy, ppt);
        x2 = _t2.x;
        y2 = _t2.y;
        z2 = _t2.z;
        _t2 = convertCoords2Gl(x3, y3, z3, w3, cx, cy, ppt);
        x3 = _t2.x;
        y3 = _t2.y;
        z3 = _t2.z;
        _t2 = convertCoords2Gl(x4, y4, z4, w4, cx, cy, ppt);
        x4 = _t2.x;
        y4 = _t2.y;
        z4 = _t2.z;
        vtPoint[0] = x1;
        vtPoint[1] = y1;
        vtPoint[2] = z1;
        vtPoint[3] = w1;
        vtPoint[4] = x4;
        vtPoint[5] = y4;
        vtPoint[6] = z4;
        vtPoint[7] = w4;
        vtPoint[8] = x2;
        vtPoint[9] = y2;
        vtPoint[10] = z2;
        vtPoint[11] = w2;
        vtPoint[12] = x4;
        vtPoint[13] = y4;
        vtPoint[14] = z4;
        vtPoint[15] = w4;
        vtPoint[16] = x2;
        vtPoint[17] = y2;
        vtPoint[18] = z2;
        vtPoint[19] = w2;
        vtPoint[20] = x3;
        vtPoint[21] = y3;
        vtPoint[22] = z3;
        vtPoint[23] = w3;
        vtTex[0] = tx1;
        vtTex[1] = ty1;
        vtTex[2] = tx1;
        vtTex[3] = ty2;
        vtTex[4] = tx2;
        vtTex[5] = ty1;
        vtTex[6] = tx1;
        vtTex[7] = ty2;
        vtTex[8] = tx2;
        vtTex[9] = ty1;
        vtTex[10] = tx2;
        vtTex[11] = ty2;
        vtOpacity[0] = opacity;
        vtOpacity[1] = opacity;
        vtOpacity[2] = opacity;
        vtOpacity[3] = opacity;
        vtOpacity[4] = opacity;
        vtOpacity[5] = opacity;
      } // 顶点buffer


      gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtPoint), gl.STATIC_DRAW);
      gl.vertexAttribPointer(a_position, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position); // 纹理buffer

      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtTex), gl.STATIC_DRAW);
      gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_texCoords); // opacity buffer

      gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vtOpacity), gl.STATIC_DRAW);
      gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_opacity);
      gl.uniform1i(u_texture, 0);
      gl.drawArrays(gl.TRIANGLES, 0, vtOpacity.length);
    }

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.disableVertexAttribArray(a_opacity);
  }

  var webgl = {
    initShaders: initShaders,
    convertCoords2Gl: convertCoords2Gl,
    createTexture: createTexture$1,
    bindTexture: bindTexture$1,
    drawTextureCache: drawTextureCache$1,
    drawBlur: drawBlur,
    drawOverflow: drawOverflow,
    drawMask: drawMask,
    drawMbm: drawMbm,
    drawCm: drawCm,
    drawDropShadow: drawDropShadow,
    drawDropShadowMerge: drawDropShadowMerge,
    drawTex2Cache: drawTex2Cache$1,
    drawCache2Tex: drawCache2Tex$1,
    drawSameSize: drawSameSize,
    drawOitPlane: drawOitPlane
  };

  var CanvasPage = /*#__PURE__*/function (_Page) {
    _inherits(CanvasPage, _Page);

    function CanvasPage(renderMode, ctx, size, number) {
      return _Page.call(this, renderMode, ctx, size, number) || this;
    }

    _createClass(CanvasPage, [{
      key: "genTexture",
      value: function genTexture(gl) {
        if (this.__update) {
          this.__update = false;
          var t = this.texture;

          if (t) {
            gl.deleteTexture(t);
          }

          this.texture = webgl.createTexture(gl, this.__offscreen.canvas, 0, null, null); // 默认0单元

          gl.bindTexture(gl.TEXTURE_2D, null);
        }
      }
    }, {
      key: "add",
      value: function add(unitSize, pos) {
        _get(_getPrototypeOf(CanvasPage.prototype), "add", this).call(this, unitSize, pos);

        if (!this.__offscreen) {
          this.__offscreen = inject.getOffscreenCanvas(this.__size, this.__size, null, this.__number);
        }
      }
    }, {
      key: "del",
      value: function del(pos) {
        _get(_getPrototypeOf(CanvasPage.prototype), "del", this).call(this, pos);

        if (!this.__count) {
          var t = this.texture;

          if (t) {
            var gl = this.__ctx;
            gl.deleteTexture(t);
            this.texture = null;
          }

          if (this.__offscreen) {
            this.__offscreen.release();

            this.__offscreen = null;
          }
        }
      }
    }, {
      key: "offscreen",
      get: function get() {
        return this.__offscreen;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.__offscreen.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__offscreen.ctx;
      }
    }, {
      key: "update",
      get: function get() {
        return this.__update;
      },
      set: function set(v) {
        this.__update = v;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, size, excludePage) {
        return _get(_getPrototypeOf(CanvasPage), "getInstance", this).call(this, renderMode, ctx, rootId, size, this, excludePage);
      }
    }]);

    return CanvasPage;
  }(Page);

  var _enums$STYLE_KEY$3 = enums.STYLE_KEY,
      TRANSFORM_ORIGIN$1 = _enums$STYLE_KEY$3.TRANSFORM_ORIGIN,
      TRANSFORM$2 = _enums$STYLE_KEY$3.TRANSFORM;
  var spreadFilter = css.spreadFilter;
  var isE$1 = matrix.isE;

  var CanvasCache = /*#__PURE__*/function (_Cache) {
    _inherits(CanvasCache, _Cache);

    function CanvasCache(renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1) {
      return _Cache.call(this, renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1) || this;
    }

    _createClass(CanvasCache, [{
      key: "clear",
      value: function clear() {
        if (_get(_getPrototypeOf(CanvasCache.prototype), "clear", this).call(this)) {
          this.__available = false;
          var page = this.__page,
              ctx = page.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(this.__x, this.__y, this.__width, this.__height);
          return true;
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1) {
        return _get(_getPrototypeOf(CanvasCache.prototype), "reset", this).call(this, bbox, x1, y1, CanvasPage);
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.__page.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__page.ctx;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, bbox, x1, y1, excludePage) {
        return _get(_getPrototypeOf(CanvasCache), "getInstance", this).call(this, renderMode, ctx, rootId, bbox, x1, y1, this, CanvasPage, excludePage);
      }
      /**
       * 复制cache的一块出来单独作为cacheFilter，尺寸边距保持一致，用浏览器原生ctx.filter滤镜
       * @param cache
       * @param filter
       */

    }, {
      key: "genFilter",
      value: function genFilter(cache, filter) {
        var x = cache.x,
            y = cache.y,
            size = cache.size,
            canvas = cache.canvas,
            x1 = cache.x1,
            y1 = cache.y1,
            width = cache.width,
            height = cache.height,
            bbox = cache.bbox;
        var oldX1 = bbox[0];
        bbox = spreadFilter(bbox, filter);
        var d = oldX1 - bbox[0];
        var widthNew = bbox[2] - bbox[0];
        var heightNew = bbox[3] - bbox[1];
        var offscreen = inject.getOffscreenCanvas(widthNew, heightNew, null, 'filter');
        offscreen.ctx.filter = painter.canvasFilter(filter);
        offscreen.ctx.drawImage(canvas, x, y, width, height, d, d, width, height);
        offscreen.ctx.filter = 'none';
        offscreen.bbox = bbox; // 单独的离屏，其dx/dy要重算

        offscreen.x = 0;
        offscreen.y = 0;
        offscreen.size = size;
        offscreen.x1 = x1;
        offscreen.y1 = y1;
        offscreen.dx = -bbox[0];
        offscreen.dy = -bbox[1];
        offscreen.dbx = cache.dbx + d;
        offscreen.dby = cache.dby + d;
        offscreen.width = widthNew;
        offscreen.height = heightNew;
        return offscreen;
      }
    }, {
      key: "genMask",
      value: function genMask(target, node, callback) {
        var cacheMask = genSingle(target, 'mask1');
        var list = [];
        var transform,
            tfo,
            wn = node.__wasmNode;

        if (wn) {
          transform = new Float64Array(wasm$1.instance.memory.buffer, wn.transform_ptr(), 16);
          var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
          tfo = [cs[16], cs[17]];
        } else {
          transform = node.__computedStyle[TRANSFORM$2];
          tfo = node.__computedStyle[TRANSFORM_ORIGIN$1];
        }

        var next = node.next;
        var isClip = next.__clip;

        while (next && next.__mask) {
          list.push(next);
          next = next.next;
        }

        var x = cacheMask.x,
            y = cacheMask.y,
            ctx = cacheMask.ctx,
            dbx = cacheMask.dbx,
            dby = cacheMask.dby;
        var inverse = transform$1.calMatrixByOrigin(transform, tfo[0] + x + dbx, tfo[1] + y + dby);

        if (isE$1(inverse)) {
          inverse = null;
        } // 先将mask本身绘制到cache上，再设置模式绘制dom本身


        list.forEach(function (item) {
          callback(item, cacheMask, inverse);
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = isClip ? 'source-out' : 'source-in';
        CanvasCache.drawCache(target, cacheMask);
        ctx.globalCompositeOperation = 'source-over';
        return cacheMask;
      }
    }, {
      key: "drawCache",
      value: function drawCache(source, target) {
        var tx = target.x,
            ty = target.y,
            x1 = target.x1,
            y1 = target.y1,
            ctx = target.ctx,
            dbx = target.dbx,
            dby = target.dby;
        var x = source.x,
            y = source.y,
            canvas = source.canvas,
            x2 = source.x1,
            y2 = source.y1,
            dbx2 = source.dbx,
            dby2 = source.dby,
            width = source.width,
            height = source.height;
        var ox = tx + x2 - x1 + dbx - dbx2;
        var oy = ty + y2 - y1 + dby - dby2;
        ctx.drawImage(canvas, x, y, width, height, ox, oy, width, height);
      }
    }]);

    return CanvasCache;
  }(Cache); // 根据一个共享cache的信息，生成一个独立的离屏canvas，一般是filter,mask用，可能尺寸会发生变化


  function genSingle(cache, message, bboxNew) {
    var size = cache.size,
        x1 = cache.x1,
        y1 = cache.y1,
        bbox = cache.bbox;
    bboxNew = bboxNew || bbox;
    var width = bboxNew[2] - bboxNew[0];
    var height = bboxNew[3] - bboxNew[1];
    var dx = bboxNew[0] - bbox[0];
    var dy = bboxNew[1] - bbox[1];
    var offscreen = inject.getOffscreenCanvas(width, height, null, message);
    offscreen.x = 0;
    offscreen.y = 0;
    offscreen.bbox = bboxNew;
    offscreen.size = size;
    offscreen.x1 = x1;
    offscreen.y1 = y1;
    offscreen.dx = -bboxNew[0];
    offscreen.dy = -bboxNew[1];
    offscreen.dbx = cache.dbx - dx;
    offscreen.dby = cache.dby - dy;
    offscreen.width = width;
    offscreen.height = height;
    return offscreen;
  }

  var HASH$1 = {};

  var ImgWebglCache = /*#__PURE__*/function (_CanvasCache) {
    _inherits(ImgWebglCache, _CanvasCache);

    function ImgWebglCache(renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1) {
      return _CanvasCache.call(this, renderMode, ctx, rootId, w, h, bbox, page, pos, x1, y1) || this;
    }

    _createClass(ImgWebglCache, [{
      key: "release",
      value: function release() {
        if (this.__enabled) {
          var key = this.key; // 一定有

          var o = HASH$1[key];
          o.count--;

          if (!o.count) {
            this.clear();
            delete HASH$1[key];

            this.__page.del(this.__pos);

            this.__page = null;
          }

          this.__enabled = false;
          return true;
        }
      }
    }, {
      key: "count",
      get: function get() {
        return HASH$1[this.key].count;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, bbox, loadImg, x1, y1) {
        var w = loadImg.width,
            h = loadImg.height;
        var w2 = bbox[2] - bbox[0],
            h2 = bbox[3] - bbox[1];
        var key = rootId + ',' + loadImg.width + ' ' + loadImg.height + ' ' + loadImg.src;

        if (HASH$1.hasOwnProperty(key)) {
          var o = HASH$1[key];
          o.count++;
          var _cache = o.cache;

          if (w > Page.MAX * 0.5 || h > Page.MAX * 0.5) {
            return {
              key: key,
              renderMode: renderMode,
              ctx: ctx,
              rootId: rootId,
              __bbox: bbox,
              __tx1: 0,
              __ty1: 0,
              __tx2: 1,
              __ty2: 1,
              __width: w,
              __height: h,
              __tw: w2,
              __th: h2,
              __available: true,
              __enabled: true,

              get available() {
                return this.__available;
              },

              get enabled() {
                return this.__enabled;
              },

              __page: _cache.page,

              get page() {
                return this.__page;
              },

              get bbox() {
                return this.__bbox;
              },

              reset: function reset(bbox, x1, y1) {
                this.release();
                this.__bbox = bbox;
              },
              release: function release() {
                if (this.__enabled) {
                  var _key = this.key; // 一定有

                  var _o = HASH$1[_key];
                  _o.count--;

                  if (!_o.count) {
                    delete HASH$1[_key];

                    this.__page.del();

                    this.__page = null;
                  }

                  this.__enabled = false;
                  return true;
                }
              }
            };
          }

          var res = new ImgWebglCache(renderMode, ctx, rootId, w, h, bbox, _cache.page, _cache.pos, x1, y1);
          res.__tw = w2;
          res.__th = h2;
          res.key = key;
          return res;
        } // 超过动态合图纹理MAX一半的使用单图纹理，没有count数据不调用render


        if (w > Page.MAX * 0.5 || h > Page.MAX * 0.5) {
          var _cache2 = {
            key: key,
            renderMode: renderMode,
            ctx: ctx,
            rootId: rootId,
            __bbox: bbox,
            __tx1: 0,
            __ty1: 0,
            __tx2: 1,
            __ty2: 1,
            __width: w,
            __height: h,
            __tw: w2,
            __th: h2,
            __available: true,
            __enabled: true,

            get available() {
              return this.__available;
            },

            get enabled() {
              return this.__enabled;
            },

            __page: {
              del: function del() {
                ctx.deleteTexture(this.texture);
              },
              texture: webgl.createTexture(ctx, loadImg.source, 0, null, null)
            },

            get page() {
              return this.__page;
            },

            get bbox() {
              return this.__bbox;
            },

            reset: function reset(bbox, x1, y1) {
              this.release();
              this.__bbox = bbox;
            },
            release: function release() {
              if (this.__enabled) {
                var _key2 = this.key; // 一定有

                var _o2 = HASH$1[_key2];
                _o2.count--;

                if (!_o2.count) {
                  delete HASH$1[_key2];

                  this.__page.del();

                  this.__page = null;
                }

                this.__enabled = false;
                return true;
              }
            }
          };
          HASH$1[key] = {
            cache: _cache2,
            count: 1
          };
          return _cache2;
        }

        var cache = Cache.getImgInstance(renderMode, ctx, rootId, bbox, x1, y1, w, h, this, CanvasPage, null); // 超限为空

        if (cache) {
          cache.key = key;

          if (cache) {
            HASH$1[key] = {
              cache: cache,
              count: 1
            };
            return cache;
          }
        }
      }
    }, {
      key: "HASH",
      get: function get() {
        return HASH$1;
      }
    }]);

    return ImgWebglCache;
  }(CanvasCache);

  var _enums$STYLE_KEY$2 = enums.STYLE_KEY,
      WIDTH$1 = _enums$STYLE_KEY$2.WIDTH,
      HEIGHT$1 = _enums$STYLE_KEY$2.HEIGHT,
      DISPLAY$2 = _enums$STYLE_KEY$2.DISPLAY,
      BORDER_RIGHT_WIDTH = _enums$STYLE_KEY$2.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH = _enums$STYLE_KEY$2.BORDER_LEFT_WIDTH,
      BORDER_TOP_LEFT_RADIUS = _enums$STYLE_KEY$2.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS = _enums$STYLE_KEY$2.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS = _enums$STYLE_KEY$2.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS = _enums$STYLE_KEY$2.BORDER_BOTTOM_LEFT_RADIUS,
      VISIBILITY$2 = _enums$STYLE_KEY$2.VISIBILITY,
      MARGIN_RIGHT = _enums$STYLE_KEY$2.MARGIN_RIGHT,
      MARGIN_LEFT = _enums$STYLE_KEY$2.MARGIN_LEFT,
      PADDING_RIGHT = _enums$STYLE_KEY$2.PADDING_RIGHT,
      PADDING_LEFT = _enums$STYLE_KEY$2.PADDING_LEFT,
      FONT_SIZE$1 = _enums$STYLE_KEY$2.FONT_SIZE,
      FLEX_BASIS = _enums$STYLE_KEY$2.FLEX_BASIS;
  var AUTO = o$4.AUTO,
      PX$1 = o$4.PX,
      PERCENT = o$4.PERCENT,
      REM = o$4.REM,
      VW = o$4.VW,
      VH = o$4.VH,
      VMAX = o$4.VMAX,
      VMIN = o$4.VMIN;
  var canvasPolygon$1 = painter.canvasPolygon,
      svgPolygon = painter.svgPolygon;
  var isFunction$2 = util.isFunction;

  var Img = /*#__PURE__*/function (_Dom) {
    _inherits(Img, _Dom);

    function Img(tagName, props) {
      var _this;

      _this = _Dom.call(this, tagName, props) || this;
      var src = _this.props.src;
      var loadImg = _this.__loadImg = {
        src: src
      }; // 空url用错误图代替

      if (!src) {
        loadImg.error = true;
      } else {
        var ca = inject.IMG[src];

        if (!ca) {
          inject.measureImg(src, function (res) {
            if (src === loadImg.src) {
              if (res.success) {
                if (isFunction$2(props.onLoad)) {
                  props.onLoad();
                }
              } else {
                if (isFunction$2(props.onError)) {
                  props.onError();
                }
              }
            }
          });
        } else if (ca.state === inject.LOADED) {
          if (ca.success) {
            loadImg.source = ca.source;
            loadImg.width = loadImg.__width = ca.width;
            loadImg.height = loadImg.__height = ca.height;
          } else {
            loadImg.error = true;
          }
        }
      }

      return _this;
    }
    /**
     * 覆盖xom的方法，在__layout()3个分支中会首先被调用
     * 当样式中固定宽高时，图片按样式尺寸，加载后重新绘制即可
     * 只固定宽高一个时，加载完要计算缩放比，重新布局绘制
     * 都没有固定，按照图片尺寸，重新布局绘制
     * 这里计算非固定的情况，将其改为固定供布局渲染使用，未加载完成为0
     */


    _createClass(Img, [{
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var res = _get(_getPrototypeOf(Img.prototype), "__preLayout", this).call(this, data, false);

        var loadImg = this.__loadImg; // 可能已提前加载好了，或有缓存，为减少刷新直接使用

        var src = loadImg.src;

        if (src) {
          var cache = inject.IMG[src];

          if (!cache || cache.state === inject.LOADING) {
            if (!loadImg.loading) {
              this.__loadAndRefresh(loadImg, null);
            }
          } else if (cache && cache.state === inject.LOADED && cache.success) {
            loadImg.loading = false;

            if (cache.success) {
              loadImg.source = cache.source;
              loadImg.width = loadImg.__width = cache.width;
              loadImg.height = loadImg.__height = cache.height;
            } else {
              loadImg.error = true;
            }
          }

          loadImg.cache = false;
        }

        if (res.fixedWidth && res.fixedHeight) {
          return res;
        }

        if (loadImg.error && !this.props.placeholder) {
          if (res.fixedWidth) {
            res.h = res.w;
          } else if (res.fixedHeight) {
            res.w = res.h;
          } else {
            res.w = res.h = 32;
          }
        } else if (loadImg.source) {
          if (res.fixedWidth) {
            res.h = res.w * loadImg.height / loadImg.width;
          } else if (res.fixedHeight) {
            res.w = res.h * loadImg.width / loadImg.height;
          } else {
            res.w = loadImg.width;
            res.h = loadImg.height;
          }
        } else {
          res.w = res.h = 0;
        }

        res.fixedWidth = true;
        res.fixedHeight = true;
        return res;
      }
    }, {
      key: "__addGeom",
      value: function __addGeom(tagName, props) {
        props = util.hash2arr(props);

        this.__virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      } // img根据加载情况更新__hasContent，同时识别是否仅有图片内容本身，多个相同图片视为同一个资源

    }, {
      key: "calContent",
      value: function calContent(__currentStyle, __computedStyle) {
        var res = _get(_getPrototypeOf(Img.prototype), "calContent", this).call(this, __currentStyle, __computedStyle);

        var loadImg = this.__loadImg;

        if (!res) {
          loadImg.onlyImg = true;

          if (__computedStyle[VISIBILITY$2] !== 'hidden' && (__computedStyle[WIDTH$1] || __computedStyle[HEIGHT$1]) && loadImg.source) {
            res = true;
          }
        } else {
          loadImg.onlyImg = false;
        }

        return this.__hasContent = res;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        var res = _get(_getPrototypeOf(Img.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        var width = this.width,
            height = this.height,
            __isDestroyed = this.__isDestroyed,
            placeholder = this.props.placeholder,
            _this$__computedStyle = this.__computedStyle,
            display = _this$__computedStyle[DISPLAY$2],
            borderTopLeftRadius = _this$__computedStyle[BORDER_TOP_LEFT_RADIUS],
            borderTopRightRadius = _this$__computedStyle[BORDER_TOP_RIGHT_RADIUS],
            borderBottomRightRadius = _this$__computedStyle[BORDER_BOTTOM_RIGHT_RADIUS],
            borderBottomLeftRadius = _this$__computedStyle[BORDER_BOTTOM_LEFT_RADIUS],
            visibility = _this$__computedStyle[VISIBILITY$2],
            virtualDom = this.virtualDom,
            loadImg = this.__loadImg;

        if (__isDestroyed || display === 'none' || visibility === 'hidden' || renderMode === mode.WEBGL) {
          return res;
        }

        var originX, originY;
        originX = res.x3 + dx;
        originY = res.y3 + dy; // 根据配置以及占位图显示error

        var source = loadImg.source;

        if (loadImg.error && !placeholder && Img.showError) {
          var strokeWidth = Math.min(width, height) * 0.02;
          var stroke = '#CCC';
          var fill = '#DDD';
          var cx = originX + width * 0.7;
          var cy = originY + height * 0.3;
          var r = strokeWidth * 5;
          var pts = [[originX + width * 0.15, originY + height * 0.7], [originX + width * 0.3, originY + height * 0.4], [originX + width * 0.5, originY + height * 0.6], [originX + width * 0.6, originY + height * 0.5], [originX + width * 0.9, originY + height * 0.8], [originX + width * 0.15, originY + height * 0.8]];

          if (renderMode === mode.CANVAS) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = strokeWidth;
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + width, originY);
            ctx.lineTo(originX + width, originY + height);
            ctx.lineTo(originX, originY + height);
            ctx.lineTo(originX, originY);
            ctx.stroke();
            ctx.closePath();
            ctx.beginPath();
            var points = geom.ellipsePoints(cx, cy, r, r);
            painter.canvasPolygon(ctx, points, 0, 0, true);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);

            for (var i = 1, len = pts.length; i < len; i++) {
              var point = pts[i];
              ctx.lineTo(point[0], point[1]);
            }

            ctx.lineTo(pts[0][0], pts[0][1]);
            ctx.fill();
            ctx.closePath();
          } else if (renderMode === mode.SVG) {
            this.__addGeom('rect', [['x', originX], ['y', originY], ['width', width], ['height', height], ['stroke', stroke], ['stroke-width', strokeWidth], ['fill', 'rgba(0,0,0,0)']]);

            this.__addGeom('circle', [['cx', cx], ['cy', cy], ['r', r], ['fill', fill]]);

            var s = '';

            for (var _i = 0, _len = pts.length; _i < _len; _i++) {
              var _point = pts[_i];

              if (_i) {
                s += ' ';
              }

              s += _point[0] + ',' + _point[1];
            }

            this.__addGeom('polygon', [['points', s], ['fill', fill]]);
          }
        } else if (source) {
          // 圆角需要生成一个mask
          var list = border.calRadius(originX, originY, width, height, borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius);

          if (renderMode === mode.CANVAS) {
            // 有border-radius需模拟遮罩裁剪
            if (list) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$1(ctx, list, dx, dy, true);
              ctx.clip();
              ctx.drawImage(source, originX, originY, width, height);
              ctx.restore();
            } else {
              ctx.drawImage(source, originX, originY, width, height);
            }
          } else if (renderMode === mode.SVG) {
            // img没有变化无需diff，直接用上次的vd
            if (loadImg.cache) {
              loadImg.cache.cache = true;
              virtualDom.children = [loadImg.cache]; // 但是还是要校验是否有borderRadius变化，引发img的圆角遮罩

              if (!virtualDom.cache && list) {
                var d = svgPolygon(list);
                var v = {
                  tagName: 'clipPath',
                  props: [],
                  children: [{
                    type: 'item',
                    tagName: 'path',
                    props: [['d', d], ['fill', '#FFF']]
                  }]
                };
                var id = ctx.add(v);

                this.__cacheDefs.push(v);

                virtualDom.conClip = 'url(#' + id + ')';
              }

              return;
            } // 缩放图片，无需考虑原先矩阵，xom里对父层<g>已经变换过了


            var matrix$1;

            if (width !== loadImg.width || height !== loadImg.height) {
              matrix$1 = image.matrixResize(loadImg.width, loadImg.height, width, height, originX, originY, width, height);
            }

            var props = [['xlink:href', loadImg.error ? placeholder : loadImg.src], ['x', originX], ['y', originY], ['width', loadImg.width], ['height', loadImg.height]];

            if (list) {
              var _d = svgPolygon(list);

              var _v = {
                tagName: 'clipPath',
                props: [],
                children: [{
                  type: 'item',
                  tagName: 'path',
                  props: [['d', _d], ['fill', '#FFF']]
                }]
              };

              var _id = ctx.add(_v);

              this.__cacheDefs.push(_v);

              virtualDom.conClip = 'url(#' + _id + ')';
              delete virtualDom.cache;
            }

            if (matrix$1 && !matrix.isE(matrix$1)) {
              props.push(['transform', 'matrix(' + util.joinArr(matrix.m2m6(matrix$1), ',') + ')']);
            }

            var vd = {
              type: 'img',
              tagName: 'image',
              props: props
            };
            virtualDom.children = [vd];
            loadImg.cache = vd;
          }
        }

        return res;
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      } // overwrite

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$1],
            height = _this$currentStyle[HEIGHT$1],
            marginLeft = _this$currentStyle[MARGIN_LEFT],
            marginRight = _this$currentStyle[MARGIN_RIGHT],
            paddingLeft = _this$currentStyle[PADDING_LEFT],
            paddingRight = _this$currentStyle[PADDING_RIGHT],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH];

        if (width.u !== AUTO) {
          w -= this.__calSize(width, total, true);
        } else {
          var loadImg = this.__loadImg; // 加载成功计算缩放后的宽度

          if (loadImg.source) {
            if (height.u === PX$1) {
              w -= loadImg.width * height.v / loadImg.height;
            } else if (height.u === PERCENT) {
              w -= loadImg.width * height.v * total * 0.01 / loadImg.height;
            } else if (height.u === REM) {
              w -= loadImg.width * height.v * this.root.computedStyle[FONT_SIZE$1] / loadImg.height;
            } else if (height.u === VW) {
              w -= loadImg.width * height.v * this.root.width * 0.01 / loadImg.height;
            } else if (height.u === VH) {
              w -= loadImg.width * height.v * this.root.height * 0.01 / loadImg.height;
            } else if (height.u === VMAX) {
              w -= height.v * Math.max(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else if (height.u === VMIN) {
              w -= height.v * Math.min(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else {
              w -= loadImg.width;
            }
          }
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __loadImg = this.__loadImg;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS],
            width = currentStyle[WIDTH$1],
            height = currentStyle[HEIGHT$1];
        var main = isDirectionRow ? width : height;
        var cross = isDirectionRow ? height : width; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$1, PERCENT, REM, VW, VH, VMAX, VMIN].indexOf(flexBasis.u) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$1, PERCENT, REM, VW, VH, VMAX, VMIN].indexOf(main.u) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // auto和content固定尺寸比例计算
        else if (__loadImg.source || __loadImg.error) {
          var res = this.__preLayout(data);

          if (cross.u !== AUTO) {
            cross = this.__calSize(cross, isDirectionRow ? h : w, true);
            var ratio = res.w / res.h;
            b = max = min = isDirectionRow ? cross * ratio : cross / ratio;
          } else {
            b = max = min = isDirectionRow ? res.w : res.h;
          }
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__loadAndRefresh",
      value: function __loadAndRefresh(loadImg, cb) {
        var self = this; // 先清空之前可能的

        if (loadImg.source || loadImg.error) {
          loadImg.source = null;
        }

        loadImg.loading = true;
        var root = this.__root,
            ctx = root.ctx;
        var props = this.props;
        var placeholder = props.placeholder,
            computedStyle = this.__computedStyle;
        var width = computedStyle[WIDTH$1],
            height = computedStyle[HEIGHT$1]; // 再测量，可能瞬间完成替换掉上面的

        inject.measureImg(loadImg.src, function (data) {
          // 还需判断url，防止重复加载时老的替换新的，失败走error绘制
          if (data.url === loadImg.src) {
            var reload = function reload() {
              var _self$__currentStyle = self.__currentStyle,
                  width = _self$__currentStyle[WIDTH$1],
                  height = _self$__currentStyle[HEIGHT$1];

              if (width.u !== AUTO && height.u !== AUTO) {
                root.__addUpdate(self, null, o$1.REPAINT, false, false, false, false, cb);
              } else {
                root.__addUpdate(self, null, o$1.REFLOW, false, false, false, false, cb);
              }
            };

            loadImg.cache && (loadImg.cache.cache = false);
            loadImg.loading = false;

            if (data.success) {
              loadImg.source = data.source;
              loadImg.width = data.width;
              loadImg.height = data.height;

              if (isFunction$2(props.onLoad)) {
                props.onLoad();
              }
            } else if (placeholder) {
              loadImg.error = true;
              inject.measureImg(placeholder, function (data) {
                if (data.success) {
                  loadImg.source = data.source;
                  loadImg.width = data.width;
                  loadImg.height = data.height;

                  if (computedStyle[DISPLAY$2] !== 'none' && !self.__isDestroyed) {
                    reload();
                  }
                }
              }, {
                ctx: ctx,
                root: root,
                width: width,
                height: height
              });

              if (isFunction$2(props.onError)) {
                props.onError();
              }

              return;
            } else {
              loadImg.error = true;

              if (isFunction$2(props.onError)) {
                props.onError();
              }
            } // 可见状态进行刷新操作，visibility某些情况需要刷新，可能宽高未定义要重新布局


            if (computedStyle[DISPLAY$2] !== 'none' && !self.__isDestroyed) {
              reload();
            }
          }
        });
      }
    }, {
      key: "updateSrc",
      value: function updateSrc(v, cb) {
        var _this2 = this;

        var loadImg = this.__loadImg; // 相等或空且当前error直接返回

        if (v === loadImg.src || this.__isDestroyed || !v && loadImg.error) {
          if (v && v !== loadImg.src) {
            inject.measureImg(v, function (res) {
              if (loadImg.src === v) {
                var props = _this2.props;

                if (res.success) {
                  if (isFunction$2(props.onLoad)) {
                    props.onLoad();
                  }
                } else {
                  if (isFunction$2(props.onError)) {
                    props.onError();
                  }
                }
              }
            });
          }

          loadImg.src = v;

          if (isFunction$2(cb)) {
            cb(true);
          }

          return;
        }

        loadImg.src = v;

        this.__loadAndRefresh(loadImg, cb);
      }
    }, {
      key: "appendChild",
      value: function appendChild() {
        inject.error('Img can not appendChild.');
      }
    }, {
      key: "src",
      get: function get() {
        return this.__loadImg.src;
      },
      set: function set(v) {
        this.updateSrc(v, null);
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return true;
      }
    }], [{
      key: "toWebglCache",
      value: function toWebglCache(gl, root, src, x1, y1, cb) {
        if (!gl || !src) {
          return;
        }

        var loadImg = {
          src: src
        };
        var ca = inject.IMG[src];

        if (!ca) {
          inject.measureImg(src, function (ca) {
            loadImg.source = ca.source;
            loadImg.width = loadImg.__width = ca.width;
            loadImg.height = loadImg.__height = ca.height;
            var res = ImgWebglCache.getInstance(mode.CANVAS, gl, root.__uuid, [x1, y1, x1 + loadImg.width, y1 + loadImg.height], loadImg, x1, y1);

            if (isFunction$2(cb)) {
              cb(res);
            }
          });
        } else if (ca.state === inject.LOADED) {
          loadImg.source = ca.source;
          loadImg.width = loadImg.__width = ca.width;
          loadImg.height = loadImg.__height = ca.height;
          var res = ImgWebglCache.getInstance(mode.CANVAS, gl, root.__uuid, [x1, y1, x1 + loadImg.width, y1 + loadImg.height], loadImg, x1, y1);

          if (isFunction$2(cb)) {
            cb(res);
          }
        }
      }
    }]);

    return Img;
  }(Dom);

  _defineProperty(Img, "showError", true);

  var Defs = /*#__PURE__*/function () {
    function Defs(uuid) {
      this.id = uuid;
      this.count = 0;
      this.list = [];
      this.cacheHash = {}; // 每次svg渲染前重置，存储前次渲染不变的缓存id
    }

    _createClass(Defs, [{
      key: "add",
      value: function add(data) {
        var uuid = this.count;
        var hash = this.cacheHash;

        while (hash.hasOwnProperty(uuid)) {
          uuid++;
        }

        this.count = uuid + 1;
        data.id = uuid;
        data.uuid = 'karas-defs-' + this.id + '-' + uuid;
        data.index = this.list.length;
        this.list.push(data);
        return data.uuid;
      }
    }, {
      key: "addCache",
      value: function addCache(data) {
        data.index = this.list.length;
        this.list.push(data);
        this.cacheHash[data.id] = true;
        return data.uuid;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.list = [];
        this.count = 0;
        this.cacheHash = {};
      }
    }, {
      key: "removeCache",
      value: function removeCache(data) {
        var list = this.list;
        var i = data.index; // 一般情况index即位置，但每次渲染过程中，可能会删掉一些，此时位置会往前，但index不变，因此遍历

        for (; i >= 0; i--) {
          if (list[i] === data) {
            list.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "value",
      get: function get() {
        return this.list;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(uuid) {
        return new Defs(uuid);
      }
    }]);

    return Defs;
  }();

  var joinVd = util.joinVd,
      joinDef = util.joinDef;
  var NONE$2 = o$1.NONE,
      TRANSFORM_ALL$2 = o$1.TRANSFORM_ALL,
      OPACITY$2 = o$1.OPACITY,
      FILTER$1 = o$1.FILTER,
      MIX_BLEND_MODE$2 = o$1.MIX_BLEND_MODE;

  function diff(elem, ovd, nvd) {
    var cns = elem.childNodes;
    diffDefs(cns[0], ovd.defs, nvd.defs); // <REPAINT不会有lv属性，无需对比

    if (!nvd.hasOwnProperty('lv')) {
      diffBb(cns[1], ovd.bb, nvd.bb);
    }

    diffD2D(elem, ovd, nvd, true);
  }

  function diffDefs(elem, od, nd) {
    var ol = od.length;
    var nl = nd.length;
    var i = 0;
    var cns = elem.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffDef(cns[i], od[i], nd[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinDef(nd[i]));
      }
    }
  }

  function diffDef(elem, od, nd) {
    if (od.tagName !== nd.tagName) {
      insertAdjacentHTML(elem, 'beforebegin', joinDef(nd)); // elem.insertAdjacentHTML('beforebegin', joinDef(nd));

      elem.parentNode.removeChild(elem);
    } else {
      if (od.uuid !== nd.uuid) {
        elem.setAttribute('id', nd.uuid);
      }

      var op = {};

      for (var _i = 0, len = (od.props || []).length; _i < len; _i++) {
        var prop = od.props[_i];

        var _prop = _slicedToArray(prop, 2),
            k = _prop[0],
            v = _prop[1];

        op[k] = v;
      }

      for (var _i2 = 0, _len = (nd.props || []).length; _i2 < _len; _i2++) {
        var _prop2 = nd.props[_i2];

        var _prop3 = _slicedToArray(_prop2, 2),
            _k = _prop3[0],
            _v = _prop3[1]; // 已有不等更新，没有添加


        if (op.hasOwnProperty(_k)) {
          if (op[_k] !== _v) {
            elem.setAttribute(_k, _v);
          }

          delete op[_k];
        } else {
          elem.setAttribute(_k, _v);
        }
      } // 多余的删除


      Object.keys(op).forEach(function (i) {
        elem.removeAttribute(i);
      });
      var cns = elem.childNodes;
      var ol = od.children.length;
      var nl = nd.children.length;
      var i = 0;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(elem, i, od.children[i], nd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(elem, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(elem, cns, i, joinVd(nd.children[i]));
        }
      }
    }
  }

  function diffChild(elem, ovd, nvd) {
    if (ovd.type === 'dom') {
      if (nvd.type === 'dom') {
        diffD2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffD2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'text') {
      if (nvd.type === 'text') {
        diffT2T(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'geom') {
      if (nvd.type === 'dom') {
        diffG2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffG2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'img') {
      if (nvd.type === 'img') {
        diffItemSelf(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } // 特殊情况，当有连续2个img，后面1个发生error时，其children内容不是type为img的图片，而是矢量图item，会进入此分支
    else if (ovd.type === 'item' && nvd.type === 'item') {
      diffItemSelf(elem, ovd, nvd);
    }
  }

  function diffX2X(elem, ovd, nvd) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        visibility = nvd.visibility,
        mask = nvd.mask,
        overflow = nvd.overflow,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode,
        conClip = nvd.conClip;

    if (ovd.transform !== transform) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (ovd.opacity !== opacity) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (ovd.visibility !== visibility) {
      elem.setAttribute('visibility', visibility);
    }

    if (ovd.mask !== mask) {
      if (mask) {
        elem.setAttribute('mask', mask);
      } else {
        elem.removeAttribute('mask');
      }
    }

    if (ovd.filter !== filter || ovd.mixBlendMode !== mixBlendMode) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('filter');
      }
    }

    if (ovd.overflow !== overflow) {
      if (overflow) {
        elem.setAttribute('clipPath', overflow);
      } else {
        elem.removeAttribute('overflow');
      }
    }

    if (ovd.conClip !== conClip) {
      if (conClip) {
        elem.childNodes[1].setAttribute('clip-path', conClip);
      } else {
        elem.childNodes[1].removeAttribute('clip-path');
      }
    }
  }

  function diffByLessLv(elem, ovd, nvd, lv) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        mask = nvd.mask,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode;

    if (lv === NONE$2) {
      return;
    }

    if (mask) {
      elem.setAttribute('mask', mask);
    } else {
      elem.removeAttribute('mask');
    }

    if (lv & TRANSFORM_ALL$2) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (lv & OPACITY$2) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (lv & FILTER$1 || lv & MIX_BLEND_MODE$2) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('style');
      }
    }
  }

  function diffD2D(elem, ovd, nvd, root) {
    // cache表明children无变化缓存，一定是REPAINT以下的，只需看自身的lv以及mask
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);

      if (!root) {
        diffBb(elem.firstChild, ovd.bb, nvd.bb);
      }
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffChild(cns[i], ovd.children[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffD2G(elem, ovd, nvd) {
    diffX2X(elem, ovd, nvd);
    diffBb(elem.firstChild, ovd.bb, nvd.bb);
    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      replaceWith(cns[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffT2T(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, ovd.children[i], nvd.children[i], true);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffG2D(elem, ovd, nvd) {
    diffD2G(elem, ovd, nvd);
  }

  function diffG2G(elem, ovd, nvd) {
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);
      diffBb(elem.firstChild, ovd.bb, nvd.bb);
      var ol = ovd.children.length;
      var nl = nvd.children.length;
      var i = 0;
      var lastChild = elem.lastChild;
      var cns = lastChild.childNodes;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(lastChild, i, ovd.children[i], nvd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(lastChild, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
        }
      }
    }
  }

  function diffBb(elem, obb, nbb) {
    var ol = obb.length;
    var nl = nbb.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, obb[i], nbb[i]);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd(nbb[i]));
      }
    }
  }

  function diffItem(elem, i, ovd, nvd, isText) {
    var cns = elem.childNodes;

    if (ovd.tagName !== nvd.tagName) {
      replaceWith(cns[i], nvd);
    } else {
      diffItemSelf(cns[i], ovd, nvd);

      if (isText && ovd.content !== nvd.content) {
        cns[i].innerHTML = nvd.content;
      }
    }
  }

  function diffItemSelf(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var op = {};

    for (var i = 0, len = (ovd.props || []).length; i < len; i++) {
      var prop = ovd.props[i];

      var _prop4 = _slicedToArray(prop, 2),
          k = _prop4[0],
          v = _prop4[1];

      op[k] = v;
    }

    for (var _i3 = 0, _len2 = (nvd.props || []).length; _i3 < _len2; _i3++) {
      var _prop5 = nvd.props[_i3];

      var _prop6 = _slicedToArray(_prop5, 2),
          _k2 = _prop6[0],
          _v2 = _prop6[1]; // 已有不等更新，没有添加


      if (op.hasOwnProperty(_k2)) {
        if (op[_k2] !== _v2) {
          elem.setAttribute(_k2, _v2);
        }

        delete op[_k2];
      } else {
        elem.setAttribute(_k2, _v2);
      }
    } // 多余的删除


    Object.keys(op).forEach(function (i) {
      elem.removeAttribute(i);
    });
  }

  function replaceWith(elem, vd) {
    var res;

    if (Array.isArray(vd)) {
      res = '';
      vd.forEach(function (item) {
        res += joinVd(item);
      });
    } else {
      res = joinVd(vd);
    }

    insertAdjacentHTML(elem, 'beforebegin', res); // elem.insertAdjacentHTML('beforebegin', res);

    elem.parentNode.removeChild(elem);
  }

  function insertAt(elem, cns, index, html) {
    if (index >= cns.length) {
      insertAdjacentHTML(elem, 'beforeend', html); // elem.insertAdjacentHTML('beforeend', html);
    } else {
      insertAdjacentHTML(cns[index], 'beforebegin', html); // cns[index].insertAdjacentHTML('beforebegin', html);
    }
  }

  function removeAt(elem, cns, index) {
    if (cns[index]) {
      elem.removeChild(cns[index]);
    }
  }

  var svg;

  function insertAdjacentHTML(elem, where, content) {
    if (elem.insertAdjacentHTML) {
      elem.insertAdjacentHTML(where, content);
    } else {
      switch (where) {
        case 'beforeend':
          elem.innerHTML += content;
          break;

        case 'beforebegin':
          svg = svg || document.createElement('svg');
          svg.innerHTML = content;
          elem.parentNode.insertBefore(svg.childNodes[0], elem);
          break;
      }
    }
  }

  var canvasPolygon = painter.canvasPolygon; // 无cache时应用离屏时的优先级，从小到大，OFFSCREEN_MASK2是个特殊的

  var OFFSCREEN_OVERFLOW$1 = 0;
  var OFFSCREEN_FILTER$1 = 1;
  var OFFSCREEN_MASK$1 = 2;
  var OFFSCREEN_BLEND$1 = 3;
  var OFFSCREEN_MASK2$1 = 4;

  function applyOffscreen$1(ctx, list, width, height) {
    list.sort(function (a, b) {
      if (a.lv === b.lv) {
        if (a.idx === b.idx) {
          return a.type - b.type;
        }

        return b.idx - a.idx;
      }

      return b.lv - a.lv;
    });
    list.forEach(function (item) {
      var type = item.type,
          offscreen = item.offscreen;

      if (type === OFFSCREEN_OVERFLOW$1) {
        var matrix = offscreen.matrix,
            target = offscreen.target,
            origin = offscreen.ctx,
            x = offscreen.x,
            y = offscreen.y,
            offsetWidth = offscreen.offsetWidth,
            offsetHeight = offscreen.offsetHeight,
            _list = offscreen.list;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.globalAlpha = 1;
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        ctx.fillStyle = '#FFF';
        ctx.beginPath();

        if (_list) {
          canvasPolygon(ctx, _list, 0, 0, true);
        } else {
          ctx.rect(x, y, offsetWidth, offsetHeight);
        }

        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx = origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        target.ctx.setTransform(1, 0, 0, 1, 0, 0);
        target.ctx.clearRect(0, 0, width, height);
        target.release();
      } else if (type === OFFSCREEN_FILTER$1) {
        var _target = offscreen.target,
            _origin = offscreen.ctx,
            filter = offscreen.filter; // 申请一个新的离屏，应用blur并绘制，如没有则降级，默认ctx.filter为'none'

        if (ctx.filter) {
          var apply = inject.getOffscreenCanvas(width, height, null, 'filter2');
          apply.ctx.filter = painter.canvasFilter(filter);

          if (width && height) {
            apply.ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          apply.ctx.filter = 'none';
          _target.ctx.globalAlpha = 1;

          _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target.ctx.clearRect(0, 0, width, height);

          if (width && height) {
            _target.ctx.drawImage(apply.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          apply.ctx.setTransform(1, 0, 0, 1, 0, 0);
          apply.ctx.clearRect(0, 0, width, height);
          apply.release();
        } // 绘制回主画布，如果不支持则等同无filter原样绘制


        ctx = _origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target.ctx.globalAlpha = 1;

        _target.ctx.clearRect(0, 0, width, height);

        _target.release();
      } else if (type === OFFSCREEN_MASK$1) {
        var mask = offscreen.mask,
            isClip = offscreen.isClip,
            _target2 = offscreen.target;

        if (isClip) {
          ctx = mask.ctx;
          ctx.globalCompositeOperation = 'source-out';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(_target2.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.globalCompositeOperation = 'source-over';

          _target2.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target2.ctx.clearRect(0, 0, width, height);

          _target2.release();

          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          mask.release();
        } else {
          var _target3 = offscreen.target;
          ctx = _target3.ctx;
          ctx.globalCompositeOperation = 'destination-in';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.globalCompositeOperation = 'source-over';
          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          mask.release();
          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(_target3.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          _target3.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target3.ctx.clearRect(0, 0, width, height);

          _target3.release();
        }
      } else if (type === OFFSCREEN_BLEND$1) {
        var _target4 = offscreen.target;
        ctx = offscreen.ctx;
        ctx.globalCompositeOperation = offscreen.mixBlendMode;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target4.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        ctx.globalCompositeOperation = 'source-over';
        _target4.ctx.globalAlpha = 1;

        _target4.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target4.ctx.clearRect(0, 0, width, height);

        _target4.release();
      } // 特殊的mask节点汇总结束，还原ctx
      else if (type === OFFSCREEN_MASK2$1) {
        ctx = offscreen.ctx;
      }
    });
    return ctx;
  }

  var offscreen = {
    OFFSCREEN_OVERFLOW: OFFSCREEN_OVERFLOW$1,
    OFFSCREEN_FILTER: OFFSCREEN_FILTER$1,
    OFFSCREEN_MASK: OFFSCREEN_MASK$1,
    OFFSCREEN_BLEND: OFFSCREEN_BLEND$1,
    OFFSCREEN_MASK2: OFFSCREEN_MASK2$1,
    applyOffscreen: applyOffscreen$1
  };

  var TOLERANCE$1 = 1e-6;
  /**
   * 计算线性方程的根
   * y = ax + b
   * root = -b / a
   * @param {Array<Number>} coefs 系数 [b, a] 本文件代码中的系数数组都是从阶次由低到高排列
   */

  function getLinearRoot(coefs) {
    var result = [];
    var a = coefs[1];

    if (a !== 0) {
      result.push(-coefs[0] / a);
    }

    return result;
  }
  /**
   * 计算二次方程的根，一元二次方程求根公式
   * y = ax^2 + bx + c
   * root = (-b ± sqrt(b^2 - 4ac)) / 2a
   * @param {Array<Number>} coefs 系数，系数 [c, b, a]
   */


  function getQuadraticRoots(coefs) {
    var results = [];
    var a = coefs[2];
    var b = coefs[1] / a;
    var c = coefs[0] / a;
    var d = b * b - 4 * c;

    if (d > 0) {
      var e = Math.sqrt(d);
      results.push(0.5 * (-b + e));
      results.push(0.5 * (-b - e));
    } else if (d === 0) {
      // 两个相同的根，只要返回一个
      results.push(0.5 * -b);
    }

    return results;
  }
  /**
   * 计算一元三次方程的根
   * y = ax^3 + bx^2 + cx + d
   * 求根公式参见: https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/10721952?fr=aladdin
   * @param {Array<Number>} coefs 系数
   */


  function getCubicRoots(coefs) {
    var results = [];
    var c3 = coefs[3];
    var c2 = coefs[2] / c3;
    var c1 = coefs[1] / c3;
    var c0 = coefs[0] / c3;
    var a = (3 * c1 - c2 * c2) / 3;
    var b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
    var offset = c2 / 3;
    var discrim = b * b / 4 + a * a * a / 27;
    var halfB = b / 2;

    if (Math.abs(discrim) <= TOLERANCE$1) {
      discrim = 0;
    }

    if (discrim > 0) {
      var e = Math.sqrt(discrim);
      var tmp;
      var root;
      tmp = -halfB + e;
      if (tmp >= 0) root = Math.pow(tmp, 1 / 3);else root = -Math.pow(-tmp, 1 / 3);
      tmp = -halfB - e;
      if (tmp >= 0) root += Math.pow(tmp, 1 / 3);else root -= Math.pow(-tmp, 1 / 3);
      results.push(root - offset);
    } else if (discrim < 0) {
      var distance = Math.sqrt(-a / 3);
      var angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var sqrt3 = Math.sqrt(3);
      results.push(2 * distance * cos - offset);
      results.push(-distance * (cos + sqrt3 * sin) - offset);
      results.push(-distance * (cos - sqrt3 * sin) - offset);
    } else {
      var _tmp;

      if (halfB >= 0) _tmp = -Math.pow(halfB, 1 / 3);else _tmp = Math.pow(-halfB, 1 / 3);
      results.push(2 * _tmp - offset); // really should return next root twice, but we return only one

      results.push(-_tmp - offset);
    }

    return results;
  }
  /**
   * 计算一元四次方程的根
   * 求根公式: https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/10721952?fr=aladdin
   * @param {Array<Number>} coefs 系数
   */


  function getQuarticRoots(coefs) {
    var results = [];
    var c4 = coefs[4];
    var c3 = coefs[3] / c4;
    var c2 = coefs[2] / c4;
    var c1 = coefs[1] / c4;
    var c0 = coefs[0] / c4;
    var resolveRoots = getCubicRoots([1, -c2, c3 * c1 - 4 * c0, -c3 * c3 * c0 + 4 * c2 * c0 - c1 * c1].reverse());
    var y = resolveRoots[0];
    var discrim = c3 * c3 / 4 - c2 + y;
    if (Math.abs(discrim) <= TOLERANCE$1) discrim = 0;

    if (discrim > 0) {
      var e = Math.sqrt(discrim);
      var t1 = 3 * c3 * c3 / 4 - e * e - 2 * c2;
      var t2 = (4 * c3 * c2 - 8 * c1 - c3 * c3 * c3) / (4 * e);
      var plus = t1 + t2;
      var minus = t1 - t2;
      if (Math.abs(plus) <= TOLERANCE$1) plus = 0;
      if (Math.abs(minus) <= TOLERANCE$1) minus = 0;

      if (plus >= 0) {
        var f = Math.sqrt(plus);
        results.push(-c3 / 4 + (e + f) / 2);
        results.push(-c3 / 4 + (e - f) / 2);
      }

      if (minus >= 0) {
        var _f = Math.sqrt(minus);

        results.push(-c3 / 4 + (_f - e) / 2);
        results.push(-c3 / 4 - (_f + e) / 2);
      }
    } else if (discrim < 0) ; else {
      var _t = y * y - 4 * c0;

      if (_t >= -TOLERANCE$1) {
        if (_t < 0) _t = 0;
        _t = 2 * Math.sqrt(_t);

        var _t2 = 3 * c3 * c3 / 4 - 2 * c2;

        if (_t2 + _t >= TOLERANCE$1) {
          var d = Math.sqrt(_t2 + _t);
          results.push(-c3 / 4 + d / 2);
          results.push(-c3 / 4 - d / 2);
        }

        if (_t2 - _t >= TOLERANCE$1) {
          var _d = Math.sqrt(_t2 - _t);

          results.push(-c3 / 4 + _d / 2);
          results.push(-c3 / 4 - _d / 2);
        }
      }
    }

    return results;
  }
  /**
   * 计算方程的根
   * @param {Array<Number>} coefs 系数按幂次方倒序
   */


  function getRoots$1(coefs) {
    var degree = coefs.length - 1;

    for (var i = degree; i >= 0; i--) {
      if (Math.abs(coefs[i]) < 1e-12) {
        degree--;
      } else {
        break;
      }
    }

    var result = [];

    switch (degree) {
      case 1:
        result = getLinearRoot(coefs);
        break;

      case 2:
        result = getQuadraticRoots(coefs);
        break;

      case 3:
        result = getCubicRoots(coefs);
        break;

      case 4:
        result = getQuarticRoots(coefs);
    }

    return result;
  }

  var equation = {
    getRoots: getRoots$1
  };

  var getRoots = equation.getRoots;
  var unitize3 = vector.unitize3,
      crossProduct3 = vector.crossProduct3,
      dotProduct3 = vector.dotProduct3,
      isParallel3 = vector.isParallel3,
      length3 = vector.length3; // 两个三次方程组的数值解.9阶的多项式方程,可以最多有9个实根(两个S形曲线的情况)
  // 两个三次方程组无法解析表示，只能数值计算
  // 参考：https://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf

  var TOLERANCE = 1e-6;
  var ACCURACY = 6;
  /**
   * 获取求导之后的系数
   * @param coefs
   */

  function getDerivativeCoefs(coefs) {
    var derivative = [];

    for (var i = 1; i < coefs.length; i++) {
      derivative.push(i * coefs[i]);
    }

    return derivative;
  }
  /**
   * 评估函数
   * @param x
   * @param coefs
   * @return {number}
   */


  function evaluate(x, coefs) {
    var result = 0;

    for (var i = coefs.length - 1; i >= 0; i--) {
      result = result * x + coefs[i];
    }

    return result;
  }

  function bisection(min, max, coefs) {
    var minValue = evaluate(min, coefs);
    var maxValue = evaluate(max, coefs);
    var result;

    if (Math.abs(minValue) <= TOLERANCE) {
      result = min;
    } else if (Math.abs(maxValue) <= TOLERANCE) {
      result = max;
    } else if (minValue * maxValue <= 0) {
      var tmp1 = Math.log(max - min);
      var tmp2 = Math.LN10 * ACCURACY;
      var iters = Math.ceil((tmp1 + tmp2) / Math.LN2);

      for (var i = 0; i < iters; i++) {
        result = 0.5 * (min + max);
        var value = evaluate(result, coefs);

        if (Math.abs(value) <= TOLERANCE) {
          break;
        }

        if (value * minValue < 0) {
          max = result;
          maxValue = value;
        } else {
          min = result;
          minValue = value;
        }
      }
    }

    return result;
  }

  function getRootsInInterval(min, max, coefs) {
    // console.log('getRootsInInterval', coefs);
    var roots = [];
    var root;
    var degree = coefs.length - 1;

    if (degree === 1) {
      root = bisection(min, max, coefs);

      if (root !== undefined) {
        roots.push(root);
      }
    } else {
      var derivativeCoefs = getDerivativeCoefs(coefs);
      var droots = getRootsInInterval(min, max, derivativeCoefs);

      if (droots.length > 0) {
        // find root on [min, droots[0]]
        root = bisection(min, droots[0], coefs);

        if (root !== undefined) {
          roots.push(root);
        } // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2


        for (var i = 0; i <= droots.length - 2; i++) {
          root = bisection(droots[i], droots[i + 1], coefs);

          if (root !== undefined) {
            roots.push(root);
          }
        } // find root on [droots[count-1],xmax]


        root = bisection(droots[droots.length - 1], max, coefs);

        if (root !== undefined) {
          roots.push(root);
        }
      } else {
        // polynomial is monotone on [min,max], has at most one root
        root = bisection(min, max, coefs);

        if (root !== undefined) {
          roots.push(root);
        }
      }
    }

    return roots;
  }
  /**
   * 二阶贝塞尔曲线 与 二阶贝塞尔曲线 交点
   * @return {[]}
   */


  function intersectBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3) {
    var c12, c11, c10;
    var c22, c21, c20;
    var result = [];
    c12 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c11 = {
      x: 2 * ax2 - 2 * ax1,
      y: 2 * ay2 - 2 * ay1
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c22 = {
      x: bx1 - 2 * bx2 + bx3,
      y: by1 - 2 * by2 + by3
    };
    c21 = {
      x: 2 * bx2 - 2 * bx1,
      y: 2 * by2 - 2 * by1
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var coefs;

    if (c12.y === 0) {
      var v0 = c12.x * (c10.y - c20.y);
      var v1 = v0 - c11.x * c11.y;
      var v3 = c11.y * c11.y;
      coefs = [c12.x * c22.y * c22.y, 2 * c12.x * c21.y * c22.y, c12.x * c21.y * c21.y - c22.x * v3 - c22.y * v0 - c22.y * v1, -c21.x * v3 - c21.y * v0 - c21.y * v1, (c10.x - c20.x) * v3 + (c10.y - c20.y) * v1].reverse();
    } else {
      var _v = c12.x * c22.y - c12.y * c22.x;

      var _v2 = c12.x * c21.y - c21.x * c12.y;

      var _v3 = c11.x * c12.y - c11.y * c12.x;

      var _v4 = c10.y - c20.y;

      var v4 = c12.y * (c10.x - c20.x) - c12.x * _v4;
      var v5 = -c11.y * _v3 + c12.y * v4;
      var v6 = _v3 * _v3;
      coefs = [_v * _v, 2 * _v * _v2, (-c22.y * v6 + c12.y * _v2 * _v2 + c12.y * _v * v4 + _v * v5) / c12.y, (-c21.y * v6 + c12.y * _v2 * v4 + _v2 * v5) / c12.y, (_v4 * v6 + v4 * v5) / c12.y].reverse();
    }

    var roots = getRoots(coefs);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];

      if (0 <= s && s <= 1) {
        var xRoots = getRoots([c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x].reverse());
        var yRoots = getRoots([c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y].reverse());

        if (xRoots.length > 0 && yRoots.length > 0) {
          var _TOLERANCE = 1e-4;

          checkRoots: for (var j = 0; j < xRoots.length; j++) {
            var xRoot = xRoots[j];

            if (0 <= xRoot && xRoot <= 1) {
              for (var k = 0; k < yRoots.length; k++) {
                if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE) {
                  var x = c22.x * s * s + c21.x * s + c20.x;
                  var y = c22.y * s * s + c21.y * s + c20.y;
                  result.push({
                    x: x,
                    y: y,
                    t: xRoot
                  }); // result.push(c22.multiply(s * s).add(c21.multiply(s).add(c20)));

                  break checkRoots;
                }
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var c13, c12, c11, c10; // 三阶系数

    var c23, c22, c21, c20;
    var result = [];
    c13 = {
      x: -ax1 + 3 * ax2 - 3 * ax3 + ax4,
      y: -ay1 + 3 * ay2 - 3 * ay3 + ay4
    };
    c12 = {
      x: 3 * ax1 - 6 * ax2 + 3 * ax3,
      y: 3 * ay1 - 6 * ay2 + 3 * ay3
    };
    c11 = {
      x: -3 * ax1 + 3 * ax2,
      y: -3 * ay1 + 3 * ay2
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c23 = {
      x: -bx1 + 3 * bx2 - 3 * bx3 + bx4,
      y: -by1 + 3 * by2 - 3 * by3 + by4
    };
    c22 = {
      x: 3 * bx1 - 6 * bx2 + 3 * bx3,
      y: 3 * by1 - 6 * by2 + 3 * by3
    };
    c21 = {
      x: -3 * bx1 + 3 * bx2,
      y: -3 * by1 + 3 * by2
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var c10x2 = c10.x * c10.x;
    var c10x3 = c10.x * c10.x * c10.x;
    var c10y2 = c10.y * c10.y;
    var c10y3 = c10.y * c10.y * c10.y;
    var c11x2 = c11.x * c11.x;
    var c11x3 = c11.x * c11.x * c11.x;
    var c11y2 = c11.y * c11.y;
    var c11y3 = c11.y * c11.y * c11.y;
    var c12x2 = c12.x * c12.x;
    var c12x3 = c12.x * c12.x * c12.x;
    var c12y2 = c12.y * c12.y;
    var c12y3 = c12.y * c12.y * c12.y;
    var c13x2 = c13.x * c13.x;
    var c13x3 = c13.x * c13.x * c13.x;
    var c13y2 = c13.y * c13.y;
    var c13y3 = c13.y * c13.y * c13.y;
    var c20x2 = c20.x * c20.x;
    var c20x3 = c20.x * c20.x * c20.x;
    var c20y2 = c20.y * c20.y;
    var c20y3 = c20.y * c20.y * c20.y;
    var c21x2 = c21.x * c21.x;
    var c21x3 = c21.x * c21.x * c21.x;
    var c21y2 = c21.y * c21.y;
    var c22x2 = c22.x * c22.x;
    var c22x3 = c22.x * c22.x * c22.x;
    var c22y2 = c22.y * c22.y;
    var c23x2 = c23.x * c23.x;
    var c23x3 = c23.x * c23.x * c23.x;
    var c23y2 = c23.y * c23.y;
    var c23y3 = c23.y * c23.y * c23.y;
    var coefs = [-c13x3 * c23y3 + c13y3 * c23x3 - 3 * c13.x * c13y2 * c23x2 * c23.y + 3 * c13x2 * c13.y * c23.x * c23y2, -6 * c13.x * c22.x * c13y2 * c23.x * c23.y + 6 * c13x2 * c13.y * c22.y * c23.x * c23.y + 3 * c22.x * c13y3 * c23x2 - 3 * c13x3 * c22.y * c23y2 - 3 * c13.x * c13y2 * c22.y * c23x2 + 3 * c13x2 * c22.x * c13.y * c23y2, -6 * c21.x * c13.x * c13y2 * c23.x * c23.y - 6 * c13.x * c22.x * c13y2 * c22.y * c23.x + 6 * c13x2 * c22.x * c13.y * c22.y * c23.y + 3 * c21.x * c13y3 * c23x2 + 3 * c22x2 * c13y3 * c23.x + 3 * c21.x * c13x2 * c13.y * c23y2 - 3 * c13.x * c21.y * c13y2 * c23x2 - 3 * c13.x * c22x2 * c13y2 * c23.y + c13x2 * c13.y * c23.x * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-c21.y * c23y2 - 2 * c22y2 * c23.y - c23.y * (2 * c21.y * c23.y + c22y2)), c11.x * c12.y * c13.x * c13.y * c23.x * c23.y - c11.y * c12.x * c13.x * c13.y * c23.x * c23.y + 6 * c21.x * c22.x * c13y3 * c23.x + 3 * c11.x * c12.x * c13.x * c13.y * c23y2 + 6 * c10.x * c13.x * c13y2 * c23.x * c23.y - 3 * c11.x * c12.x * c13y2 * c23.x * c23.y - 3 * c11.y * c12.y * c13.x * c13.y * c23x2 - 6 * c10.y * c13x2 * c13.y * c23.x * c23.y - 6 * c20.x * c13.x * c13y2 * c23.x * c23.y + 3 * c11.y * c12.y * c13x2 * c23.x * c23.y - 2 * c12.x * c12y2 * c13.x * c23.x * c23.y - 6 * c21.x * c13.x * c22.x * c13y2 * c23.y - 6 * c21.x * c13.x * c13y2 * c22.y * c23.x - 6 * c13.x * c21.y * c22.x * c13y2 * c23.x + 6 * c21.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.y * c23.x * c23.y + c22x3 * c13y3 - 3 * c10.x * c13y3 * c23x2 + 3 * c10.y * c13x3 * c23y2 + 3 * c20.x * c13y3 * c23x2 + c12y3 * c13.x * c23x2 - c12x3 * c13.y * c23y2 - 3 * c10.x * c13x2 * c13.y * c23y2 + 3 * c10.y * c13.x * c13y2 * c23x2 - 2 * c11.x * c12.y * c13x2 * c23y2 + c11.x * c12.y * c13y2 * c23x2 - c11.y * c12.x * c13x2 * c23y2 + 2 * c11.y * c12.x * c13y2 * c23x2 + 3 * c20.x * c13x2 * c13.y * c23y2 - c12.x * c12y2 * c13.y * c23x2 - 3 * c20.y * c13.x * c13y2 * c23x2 + c12x2 * c12.y * c13.x * c23y2 - 3 * c13.x * c22x2 * c13y2 * c22.y + c13x2 * c13.y * c23.x * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c22.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c21.y * c22.y * c23.y - c20.y * c23y2 - c22.y * (2 * c21.y * c23.y + c22y2) - c23.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), 6 * c11.x * c12.x * c13.x * c13.y * c22.y * c23.y + c11.x * c12.y * c13.x * c22.x * c13.y * c23.y + c11.x * c12.y * c13.x * c13.y * c22.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c23.y - c11.y * c12.x * c13.x * c13.y * c22.y * c23.x - 6 * c11.y * c12.y * c13.x * c22.x * c13.y * c23.x - 6 * c10.x * c22.x * c13y3 * c23.x + 6 * c20.x * c22.x * c13y3 * c23.x + 6 * c10.y * c13x3 * c22.y * c23.y + 2 * c12y3 * c13.x * c22.x * c23.x - 2 * c12x3 * c13.y * c22.y * c23.y + 6 * c10.x * c13.x * c22.x * c13y2 * c23.y + 6 * c10.x * c13.x * c13y2 * c22.y * c23.x + 6 * c10.y * c13.x * c22.x * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c23.y - 3 * c11.x * c12.x * c13y2 * c22.y * c23.x + 2 * c11.x * c12.y * c22.x * c13y2 * c23.x + 4 * c11.y * c12.x * c22.x * c13y2 * c23.x - 6 * c10.x * c13x2 * c13.y * c22.y * c23.y - 6 * c10.y * c13x2 * c22.x * c13.y * c23.y - 6 * c10.y * c13x2 * c13.y * c22.y * c23.x - 4 * c11.x * c12.y * c13x2 * c22.y * c23.y - 6 * c20.x * c13.x * c22.x * c13y2 * c23.y - 6 * c20.x * c13.x * c13y2 * c22.y * c23.x - 2 * c11.y * c12.x * c13x2 * c22.y * c23.y + 3 * c11.y * c12.y * c13x2 * c22.x * c23.y + 3 * c11.y * c12.y * c13x2 * c22.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c23.y - 2 * c12.x * c12y2 * c13.x * c22.y * c23.x - 2 * c12.x * c12y2 * c22.x * c13.y * c23.x - 6 * c20.y * c13.x * c22.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c13y2 * c23.x - 6 * c21.x * c13.x * c22.x * c13y2 * c22.y + 6 * c20.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.x * c22.y * c23.y + 2 * c12x2 * c12.y * c22.x * c13.y * c23.y + 2 * c12x2 * c12.y * c13.y * c22.y * c23.x + 3 * c21.x * c22x2 * c13y3 + 3 * c21x2 * c13y3 * c23.x - 3 * c13.x * c21.y * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c23.y + c13x2 * c22.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c13.y * c23.x * (6 * c20.y * c22.y + 3 * c21y2) + c21.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c22.y * c23.y - c23.y * (2 * c20.y * c22.y + c21y2) - c21.y * (2 * c21.y * c23.y + c22y2) - c22.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), c11.x * c21.x * c12.y * c13.x * c13.y * c23.y + c11.x * c12.y * c13.x * c21.y * c13.y * c23.x + c11.x * c12.y * c13.x * c22.x * c13.y * c22.y - c11.y * c12.x * c21.x * c13.x * c13.y * c23.y - c11.y * c12.x * c13.x * c21.y * c13.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c22.y - 6 * c11.y * c21.x * c12.y * c13.x * c13.y * c23.x - 6 * c10.x * c21.x * c13y3 * c23.x + 6 * c20.x * c21.x * c13y3 * c23.x + 2 * c21.x * c12y3 * c13.x * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c23.y + 6 * c10.x * c13.x * c21.y * c13y2 * c23.x + 6 * c10.x * c13.x * c22.x * c13y2 * c22.y + 6 * c10.y * c21.x * c13.x * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c23.y - 3 * c11.x * c12.x * c21.y * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c22.y + 2 * c11.x * c21.x * c12.y * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c13y2 * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c23.y - 6 * c10.y * c13x2 * c21.y * c13.y * c23.x - 6 * c10.y * c13x2 * c22.x * c13.y * c22.y - 6 * c20.x * c21.x * c13.x * c13y2 * c23.y - 6 * c20.x * c13.x * c21.y * c13y2 * c23.x - 6 * c20.x * c13.x * c22.x * c13y2 * c22.y + 3 * c11.y * c21.x * c12.y * c13x2 * c23.y - 3 * c11.y * c12.y * c13.x * c22x2 * c13.y + 3 * c11.y * c12.y * c13x2 * c21.y * c23.x + 3 * c11.y * c12.y * c13x2 * c22.x * c22.y - 2 * c12.x * c21.x * c12y2 * c13.x * c23.y - 2 * c12.x * c21.x * c12y2 * c13.y * c23.x - 2 * c12.x * c12y2 * c13.x * c21.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c22.y - 6 * c20.y * c21.x * c13.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c22.x * c13y2 + 6 * c20.y * c13x2 * c21.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c23.y + 2 * c12x2 * c12.y * c21.y * c13.y * c23.x + 2 * c12x2 * c12.y * c22.x * c13.y * c22.y - 3 * c10.x * c22x2 * c13y3 + 3 * c20.x * c22x2 * c13y3 + 3 * c21x2 * c22.x * c13y3 + c12y3 * c13.x * c22x2 + 3 * c10.y * c13.x * c22x2 * c13y2 + c11.x * c12.y * c22x2 * c13y2 + 2 * c11.y * c12.x * c22x2 * c13y2 - c12.x * c12y2 * c22x2 * c13.y - 3 * c20.y * c13.x * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c22.y + c12x2 * c12.y * c13.x * (2 * c21.y * c23.y + c22y2) + c11.x * c12.x * c13.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c21.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c21.y * c23.y - c22y2) + c10.y * c13x3 * (6 * c21.y * c23.y + 3 * c22y2) + c11.y * c12.x * c13x2 * (-2 * c21.y * c23.y - c22y2) + c11.x * c12.y * c13x2 * (-4 * c21.y * c23.y - 2 * c22y2) + c10.x * c13x2 * c13.y * (-6 * c21.y * c23.y - 3 * c22y2) + c13x2 * c22.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c21.y * c23.y - c22.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c21.y * c23.y + c22y2) - c21.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c23.y + c10.x * c11.y * c12.x * c13.x * c13.y * c23.y + 6 * c10.x * c11.y * c12.y * c13.x * c13.y * c23.x - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c23.y - c10.y * c11.x * c12.y * c13.x * c13.y * c23.x + c10.y * c11.y * c12.x * c13.x * c13.y * c23.x + c11.x * c11.y * c12.x * c12.y * c13.x * c23.y - c11.x * c11.y * c12.x * c12.y * c13.y * c23.x + c11.x * c20.x * c12.y * c13.x * c13.y * c23.y + c11.x * c20.y * c12.y * c13.x * c13.y * c23.x + c11.x * c21.x * c12.y * c13.x * c13.y * c22.y + c11.x * c12.y * c13.x * c21.y * c22.x * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c23.y - 6 * c20.x * c11.y * c12.y * c13.x * c13.y * c23.x - c11.y * c12.x * c20.y * c13.x * c13.y * c23.x - c11.y * c12.x * c21.x * c13.x * c13.y * c22.y - c11.y * c12.x * c13.x * c21.y * c22.x * c13.y - 6 * c11.y * c21.x * c12.y * c13.x * c22.x * c13.y - 6 * c10.x * c20.x * c13y3 * c23.x - 6 * c10.x * c21.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c23.x + 6 * c20.x * c21.x * c22.x * c13y3 + 2 * c20.x * c12y3 * c13.x * c23.x + 2 * c21.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c23.y - 6 * c10.x * c10.y * c13.x * c13y2 * c23.x + 3 * c10.x * c11.x * c12.x * c13y2 * c23.y - 2 * c10.x * c11.x * c12.y * c13y2 * c23.x - 4 * c10.x * c11.y * c12.x * c13y2 * c23.x + 3 * c10.y * c11.x * c12.x * c13y2 * c23.x + 6 * c10.x * c10.y * c13x2 * c13.y * c23.y + 6 * c10.x * c20.x * c13.x * c13y2 * c23.y - 3 * c10.x * c11.y * c12.y * c13x2 * c23.y + 2 * c10.x * c12.x * c12y2 * c13.x * c23.y + 2 * c10.x * c12.x * c12y2 * c13.y * c23.x + 6 * c10.x * c20.y * c13.x * c13y2 * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c22.y + 6 * c10.x * c13.x * c21.y * c22.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c23.y + 6 * c10.y * c20.x * c13.x * c13y2 * c23.x + 2 * c10.y * c11.y * c12.x * c13x2 * c23.y - 3 * c10.y * c11.y * c12.y * c13x2 * c23.x + 2 * c10.y * c12.x * c12y2 * c13.x * c23.x + 6 * c10.y * c21.x * c13.x * c22.x * c13y2 - 3 * c11.x * c20.x * c12.x * c13y2 * c23.y + 2 * c11.x * c20.x * c12.y * c13y2 * c23.x + c11.x * c11.y * c12y2 * c13.x * c23.x - 3 * c11.x * c12.x * c20.y * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c22.y - 3 * c11.x * c12.x * c21.y * c22.x * c13y2 + 2 * c11.x * c21.x * c12.y * c22.x * c13y2 + 4 * c20.x * c11.y * c12.x * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c23.y - 6 * c10.y * c20.x * c13x2 * c13.y * c23.y - 6 * c10.y * c20.y * c13x2 * c13.y * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c22.y - 2 * c10.y * c12x2 * c12.y * c13.x * c23.y - 2 * c10.y * c12x2 * c12.y * c13.y * c23.x - 6 * c10.y * c13x2 * c21.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c23.y - 2 * c11.x * c11y2 * c13.x * c13.y * c23.x + 3 * c20.x * c11.y * c12.y * c13x2 * c23.y - 2 * c20.x * c12.x * c12y2 * c13.x * c23.y - 2 * c20.x * c12.x * c12y2 * c13.y * c23.x - 6 * c20.x * c20.y * c13.x * c13y2 * c23.x - 6 * c20.x * c21.x * c13.x * c13y2 * c22.y - 6 * c20.x * c13.x * c21.y * c22.x * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c23.x + 3 * c11.y * c21.x * c12.y * c13x2 * c22.y + 3 * c11.y * c12.y * c13x2 * c21.y * c22.x - 2 * c12.x * c20.y * c12y2 * c13.x * c23.x - 2 * c12.x * c21.x * c12y2 * c13.x * c22.y - 2 * c12.x * c21.x * c12y2 * c22.x * c13.y - 2 * c12.x * c12y2 * c13.x * c21.y * c22.x - 6 * c20.y * c21.x * c13.x * c22.x * c13y2 - c11y2 * c12.x * c12.y * c13.x * c23.x + 2 * c20.x * c12x2 * c12.y * c13.y * c23.y + 6 * c20.y * c13x2 * c21.y * c22.x * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c23.y + c11x2 * c12.x * c12.y * c13.y * c23.y + 2 * c12x2 * c20.y * c12.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c22.y + 2 * c12x2 * c12.y * c21.y * c22.x * c13.y + c21x3 * c13y3 + 3 * c10x2 * c13y3 * c23.x - 3 * c10y2 * c13x3 * c23.y + 3 * c20x2 * c13y3 * c23.x + c11y3 * c13x2 * c23.x - c11x3 * c13y2 * c23.y - c11.x * c11y2 * c13x2 * c23.y + c11x2 * c11.y * c13y2 * c23.x - 3 * c10x2 * c13.x * c13y2 * c23.y + 3 * c10y2 * c13x2 * c13.y * c23.x - c11x2 * c12y2 * c13.x * c23.y + c11y2 * c12x2 * c13.y * c23.x - 3 * c21x2 * c13.x * c21.y * c13y2 - 3 * c20x2 * c13.x * c13y2 * c23.y + 3 * c20y2 * c13x2 * c13.y * c23.x + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c10.y * c13x3 * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c11.y * c12.x * c13x2 * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c12x2 * c12.y * c13.x * (2 * c20.y * c23.y + 2 * c21.y * c22.y) + c11.x * c12.y * c13x2 * (-4 * c20.y * c23.y - 4 * c21.y * c22.y) + c10.x * c13x2 * c13.y * (-6 * c20.y * c23.y - 6 * c21.y * c22.y) + c20.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c21.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21.y * c22.y - c20y2 * c23.y - c21.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c22.y + c10.x * c11.y * c12.x * c13.x * c13.y * c22.y + 6 * c10.x * c11.y * c12.y * c13.x * c22.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c22.y - c10.y * c11.x * c12.y * c13.x * c22.x * c13.y + c10.y * c11.y * c12.x * c13.x * c22.x * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c22.y - c11.x * c11.y * c12.x * c12.y * c22.x * c13.y + c11.x * c20.x * c12.y * c13.x * c13.y * c22.y + c11.x * c20.y * c12.y * c13.x * c22.x * c13.y + c11.x * c21.x * c12.y * c13.x * c21.y * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c22.y - 6 * c20.x * c11.y * c12.y * c13.x * c22.x * c13.y - c11.y * c12.x * c20.y * c13.x * c22.x * c13.y - c11.y * c12.x * c21.x * c13.x * c21.y * c13.y - 6 * c10.x * c20.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c22.x + 2 * c20.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c22.y - 6 * c10.x * c10.y * c13.x * c22.x * c13y2 + 3 * c10.x * c11.x * c12.x * c13y2 * c22.y - 2 * c10.x * c11.x * c12.y * c22.x * c13y2 - 4 * c10.x * c11.y * c12.x * c22.x * c13y2 + 3 * c10.y * c11.x * c12.x * c22.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c13.y * c22.y + 6 * c10.x * c20.x * c13.x * c13y2 * c22.y - 3 * c10.x * c11.y * c12.y * c13x2 * c22.y + 2 * c10.x * c12.x * c12y2 * c13.x * c22.y + 2 * c10.x * c12.x * c12y2 * c22.x * c13.y + 6 * c10.x * c20.y * c13.x * c22.x * c13y2 + 6 * c10.x * c21.x * c13.x * c21.y * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c22.y + 6 * c10.y * c20.x * c13.x * c22.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c22.y - 3 * c10.y * c11.y * c12.y * c13x2 * c22.x + 2 * c10.y * c12.x * c12y2 * c13.x * c22.x - 3 * c11.x * c20.x * c12.x * c13y2 * c22.y + 2 * c11.x * c20.x * c12.y * c22.x * c13y2 + c11.x * c11.y * c12y2 * c13.x * c22.x - 3 * c11.x * c12.x * c20.y * c22.x * c13y2 - 3 * c11.x * c12.x * c21.x * c21.y * c13y2 + 4 * c20.x * c11.y * c12.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c22.y - 6 * c10.y * c20.x * c13x2 * c13.y * c22.y - 6 * c10.y * c20.y * c13x2 * c22.x * c13.y - 6 * c10.y * c21.x * c13x2 * c21.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c22.y - 2 * c10.y * c12x2 * c12.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c22.y - 2 * c11.x * c11y2 * c13.x * c22.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c22.y - 2 * c20.x * c12.x * c12y2 * c13.x * c22.y - 2 * c20.x * c12.x * c12y2 * c22.x * c13.y - 6 * c20.x * c20.y * c13.x * c22.x * c13y2 - 6 * c20.x * c21.x * c13.x * c21.y * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c22.x + 3 * c11.y * c21.x * c12.y * c13x2 * c21.y - 2 * c12.x * c20.y * c12y2 * c13.x * c22.x - 2 * c12.x * c21.x * c12y2 * c13.x * c21.y - c11y2 * c12.x * c12.y * c13.x * c22.x + 2 * c20.x * c12x2 * c12.y * c13.y * c22.y - 3 * c11.y * c21x2 * c12.y * c13.x * c13.y + 6 * c20.y * c21.x * c13x2 * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c22.y + c11x2 * c12.x * c12.y * c13.y * c22.y + 2 * c12x2 * c20.y * c12.y * c22.x * c13.y + 2 * c12x2 * c21.x * c12.y * c21.y * c13.y - 3 * c10.x * c21x2 * c13y3 + 3 * c20.x * c21x2 * c13y3 + 3 * c10x2 * c22.x * c13y3 - 3 * c10y2 * c13x3 * c22.y + 3 * c20x2 * c22.x * c13y3 + c21x2 * c12y3 * c13.x + c11y3 * c13x2 * c22.x - c11x3 * c13y2 * c22.y + 3 * c10.y * c21x2 * c13.x * c13y2 - c11.x * c11y2 * c13x2 * c22.y + c11.x * c21x2 * c12.y * c13y2 + 2 * c11.y * c12.x * c21x2 * c13y2 + c11x2 * c11.y * c22.x * c13y2 - c12.x * c21x2 * c12y2 * c13.y - 3 * c20.y * c21x2 * c13.x * c13y2 - 3 * c10x2 * c13.x * c13y2 * c22.y + 3 * c10y2 * c13x2 * c22.x * c13.y - c11x2 * c12y2 * c13.x * c22.y + c11y2 * c12x2 * c22.x * c13.y - 3 * c20x2 * c13.x * c13y2 * c22.y + 3 * c20y2 * c13x2 * c22.x * c13.y + c12x2 * c12.y * c13.x * (2 * c20.y * c22.y + c21y2) + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c12x3 * c13.y * (-2 * c20.y * c22.y - c21y2) + c10.y * c13x3 * (6 * c20.y * c22.y + 3 * c21y2) + c11.y * c12.x * c13x2 * (-2 * c20.y * c22.y - c21y2) + c11.x * c12.y * c13x2 * (-4 * c20.y * c22.y - 2 * c21y2) + c10.x * c13x2 * c13.y * (-6 * c20.y * c22.y - 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21y2 - c20y2 * c22.y - c20.y * (2 * c20.y * c22.y + c21y2)), -c10.x * c11.x * c12.y * c13.x * c21.y * c13.y + c10.x * c11.y * c12.x * c13.x * c21.y * c13.y + 6 * c10.x * c11.y * c21.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c21.y * c13.y - c10.y * c11.x * c21.x * c12.y * c13.x * c13.y + c10.y * c11.y * c12.x * c21.x * c13.x * c13.y - c11.x * c11.y * c12.x * c21.x * c12.y * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c21.y + c11.x * c20.x * c12.y * c13.x * c21.y * c13.y + 6 * c11.x * c12.x * c20.y * c13.x * c21.y * c13.y + c11.x * c20.y * c21.x * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c13.x * c21.y * c13.y - 6 * c20.x * c11.y * c21.x * c12.y * c13.x * c13.y - c11.y * c12.x * c20.y * c21.x * c13.x * c13.y - 6 * c10.x * c20.x * c21.x * c13y3 - 2 * c10.x * c21.x * c12y3 * c13.x + 6 * c10.y * c20.y * c13x3 * c21.y + 2 * c20.x * c21.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c21.y * c13.y - 2 * c12x3 * c20.y * c21.y * c13.y - 6 * c10.x * c10.y * c21.x * c13.x * c13y2 + 3 * c10.x * c11.x * c12.x * c21.y * c13y2 - 2 * c10.x * c11.x * c21.x * c12.y * c13y2 - 4 * c10.x * c11.y * c12.x * c21.x * c13y2 + 3 * c10.y * c11.x * c12.x * c21.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c21.y * c13.y + 6 * c10.x * c20.x * c13.x * c21.y * c13y2 - 3 * c10.x * c11.y * c12.y * c13x2 * c21.y + 2 * c10.x * c12.x * c21.x * c12y2 * c13.y + 2 * c10.x * c12.x * c12y2 * c13.x * c21.y + 6 * c10.x * c20.y * c21.x * c13.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c21.y + 6 * c10.y * c20.x * c21.x * c13.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c21.y - 3 * c10.y * c11.y * c21.x * c12.y * c13x2 + 2 * c10.y * c12.x * c21.x * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c21.y * c13y2 + 2 * c11.x * c20.x * c21.x * c12.y * c13y2 + c11.x * c11.y * c21.x * c12y2 * c13.x - 3 * c11.x * c12.x * c20.y * c21.x * c13y2 + 4 * c20.x * c11.y * c12.x * c21.x * c13y2 - 6 * c10.x * c20.y * c13x2 * c21.y * c13.y - 2 * c10.x * c12x2 * c12.y * c21.y * c13.y - 6 * c10.y * c20.x * c13x2 * c21.y * c13.y - 6 * c10.y * c20.y * c21.x * c13x2 * c13.y - 2 * c10.y * c12x2 * c21.x * c12.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c21.y - c11.x * c11.y * c12x2 * c21.y * c13.y - 4 * c11.x * c20.y * c12.y * c13x2 * c21.y - 2 * c11.x * c11y2 * c21.x * c13.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c21.y - 2 * c20.x * c12.x * c21.x * c12y2 * c13.y - 2 * c20.x * c12.x * c12y2 * c13.x * c21.y - 6 * c20.x * c20.y * c21.x * c13.x * c13y2 - 2 * c11.y * c12.x * c20.y * c13x2 * c21.y + 3 * c11.y * c20.y * c21.x * c12.y * c13x2 - 2 * c12.x * c20.y * c21.x * c12y2 * c13.x - c11y2 * c12.x * c21.x * c12.y * c13.x + 6 * c20.x * c20.y * c13x2 * c21.y * c13.y + 2 * c20.x * c12x2 * c12.y * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c21.y * c13.y + c11x2 * c12.x * c12.y * c21.y * c13.y + 2 * c12x2 * c20.y * c21.x * c12.y * c13.y + 2 * c12x2 * c20.y * c12.y * c13.x * c21.y + 3 * c10x2 * c21.x * c13y3 - 3 * c10y2 * c13x3 * c21.y + 3 * c20x2 * c21.x * c13y3 + c11y3 * c21.x * c13x2 - c11x3 * c21.y * c13y2 - 3 * c20y2 * c13x3 * c21.y - c11.x * c11y2 * c13x2 * c21.y + c11x2 * c11.y * c21.x * c13y2 - 3 * c10x2 * c13.x * c21.y * c13y2 + 3 * c10y2 * c21.x * c13x2 * c13.y - c11x2 * c12y2 * c13.x * c21.y + c11y2 * c12x2 * c21.x * c13.y - 3 * c20x2 * c13.x * c21.y * c13y2 + 3 * c20y2 * c21.x * c13x2 * c13.y, c10.x * c10.y * c11.x * c12.y * c13.x * c13.y - c10.x * c10.y * c11.y * c12.x * c13.x * c13.y + c10.x * c11.x * c11.y * c12.x * c12.y * c13.y - c10.y * c11.x * c11.y * c12.x * c12.y * c13.x - c10.x * c11.x * c20.y * c12.y * c13.x * c13.y + 6 * c10.x * c20.x * c11.y * c12.y * c13.x * c13.y + c10.x * c11.y * c12.x * c20.y * c13.x * c13.y - c10.y * c11.x * c20.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c20.y * c13.x * c13.y + c10.y * c20.x * c11.y * c12.x * c13.x * c13.y - c11.x * c20.x * c11.y * c12.x * c12.y * c13.y + c11.x * c11.y * c12.x * c20.y * c12.y * c13.x + c11.x * c20.x * c20.y * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c20.y * c13.x * c13.y - 2 * c10.x * c20.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c20.y * c13.y - 3 * c10.x * c10.y * c11.x * c12.x * c13y2 - 6 * c10.x * c10.y * c20.x * c13.x * c13y2 + 3 * c10.x * c10.y * c11.y * c12.y * c13x2 - 2 * c10.x * c10.y * c12.x * c12y2 * c13.x - 2 * c10.x * c11.x * c20.x * c12.y * c13y2 - c10.x * c11.x * c11.y * c12y2 * c13.x + 3 * c10.x * c11.x * c12.x * c20.y * c13y2 - 4 * c10.x * c20.x * c11.y * c12.x * c13y2 + 3 * c10.y * c11.x * c20.x * c12.x * c13y2 + 6 * c10.x * c10.y * c20.y * c13x2 * c13.y + 2 * c10.x * c10.y * c12x2 * c12.y * c13.y + 2 * c10.x * c11.x * c11y2 * c13.x * c13.y + 2 * c10.x * c20.x * c12.x * c12y2 * c13.y + 6 * c10.x * c20.x * c20.y * c13.x * c13y2 - 3 * c10.x * c11.y * c20.y * c12.y * c13x2 + 2 * c10.x * c12.x * c20.y * c12y2 * c13.x + c10.x * c11y2 * c12.x * c12.y * c13.x + c10.y * c11.x * c11.y * c12x2 * c13.y + 4 * c10.y * c11.x * c20.y * c12.y * c13x2 - 3 * c10.y * c20.x * c11.y * c12.y * c13x2 + 2 * c10.y * c20.x * c12.x * c12y2 * c13.x + 2 * c10.y * c11.y * c12.x * c20.y * c13x2 + c11.x * c20.x * c11.y * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c20.y * c13y2 - 2 * c10.x * c12x2 * c20.y * c12.y * c13.y - 6 * c10.y * c20.x * c20.y * c13x2 * c13.y - 2 * c10.y * c20.x * c12x2 * c12.y * c13.y - 2 * c10.y * c11x2 * c11.y * c13.x * c13.y - c10.y * c11x2 * c12.x * c12.y * c13.y - 2 * c10.y * c12x2 * c20.y * c12.y * c13.x - 2 * c11.x * c20.x * c11y2 * c13.x * c13.y - c11.x * c11.y * c12x2 * c20.y * c13.y + 3 * c20.x * c11.y * c20.y * c12.y * c13x2 - 2 * c20.x * c12.x * c20.y * c12y2 * c13.x - c20.x * c11y2 * c12.x * c12.y * c13.x + 3 * c10y2 * c11.x * c12.x * c13.x * c13.y + 3 * c11.x * c12.x * c20y2 * c13.x * c13.y + 2 * c20.x * c12x2 * c20.y * c12.y * c13.y - 3 * c10x2 * c11.y * c12.y * c13.x * c13.y + 2 * c11x2 * c11.y * c20.y * c13.x * c13.y + c11x2 * c12.x * c20.y * c12.y * c13.y - 3 * c20x2 * c11.y * c12.y * c13.x * c13.y - c10x3 * c13y3 + c10y3 * c13x3 + c20x3 * c13y3 - c20y3 * c13x3 - 3 * c10.x * c20x2 * c13y3 - c10.x * c11y3 * c13x2 + 3 * c10x2 * c20.x * c13y3 + c10.y * c11x3 * c13y2 + 3 * c10.y * c20y2 * c13x3 + c20.x * c11y3 * c13x2 + c10x2 * c12y3 * c13.x - 3 * c10y2 * c20.y * c13x3 - c10y2 * c12x3 * c13.y + c20x2 * c12y3 * c13.x - c11x3 * c20.y * c13y2 - c12x3 * c20y2 * c13.y - c10.x * c11x2 * c11.y * c13y2 + c10.y * c11.x * c11y2 * c13x2 - 3 * c10.x * c10y2 * c13x2 * c13.y - c10.x * c11y2 * c12x2 * c13.y + c10.y * c11x2 * c12y2 * c13.x - c11.x * c11y2 * c20.y * c13x2 + 3 * c10x2 * c10.y * c13.x * c13y2 + c10x2 * c11.x * c12.y * c13y2 + 2 * c10x2 * c11.y * c12.x * c13y2 - 2 * c10y2 * c11.x * c12.y * c13x2 - c10y2 * c11.y * c12.x * c13x2 + c11x2 * c20.x * c11.y * c13y2 - 3 * c10.x * c20y2 * c13x2 * c13.y + 3 * c10.y * c20x2 * c13.x * c13y2 + c11.x * c20x2 * c12.y * c13y2 - 2 * c11.x * c20y2 * c12.y * c13x2 + c20.x * c11y2 * c12x2 * c13.y - c11.y * c12.x * c20y2 * c13x2 - c10x2 * c12.x * c12y2 * c13.y - 3 * c10x2 * c20.y * c13.x * c13y2 + 3 * c10y2 * c20.x * c13x2 * c13.y + c10y2 * c12x2 * c12.y * c13.x - c11x2 * c20.y * c12y2 * c13.x + 2 * c20x2 * c11.y * c12.x * c13y2 + 3 * c20.x * c20y2 * c13x2 * c13.y - c20x2 * c12.x * c12y2 * c13.y - 3 * c20x2 * c20.y * c13.x * c13y2 + c12x2 * c20y2 * c12.y * c13.x].reverse();
    var roots = getRootsInInterval(0, 1, coefs);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];
      var xRoots = getRoots([c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x].reverse());
      var yRoots = getRoots([c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y].reverse());

      if (xRoots.length > 0 && yRoots.length > 0) {
        var _TOLERANCE2 = 1e-4;

        checkRoots: for (var j = 0; j < xRoots.length; j++) {
          var xRoot = xRoots[j];

          if (0 <= xRoot && xRoot <= 1) {
            for (var k = 0; k < yRoots.length; k++) {
              if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE2) {
                var x = c23.x * s * s * s + c22.x * s * s + c21.x * s + c20.x;
                var y = c23.y * s * s * s + c22.y * s * s + c21.y * s + c20.y;
                result.push({
                  x: x,
                  y: y,
                  t: xRoot
                });
                break checkRoots;
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var c12, c11, c10;
    var c23, c22, c21, c20;
    var result = [];
    c12 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c11 = {
      x: 2 * ax2 - 2 * ax1,
      y: 2 * ay2 - 2 * ay1
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c23 = {
      x: -bx1 + 3 * bx2 - 3 * bx3 + bx4,
      y: -by1 + 3 * by2 - 3 * by3 + by4
    };
    c22 = {
      x: 3 * bx1 - 6 * bx2 + 3 * bx3,
      y: 3 * by1 - 6 * by2 + 3 * by3
    };
    c21 = {
      x: -3 * bx1 + 3 * bx2,
      y: -3 * by1 + 3 * by2
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var c10x2 = c10.x * c10.x;
    var c10y2 = c10.y * c10.y;
    var c11x2 = c11.x * c11.x;
    var c11y2 = c11.y * c11.y;
    var c12x2 = c12.x * c12.x;
    var c12y2 = c12.y * c12.y;
    var c20x2 = c20.x * c20.x;
    var c20y2 = c20.y * c20.y;
    var c21x2 = c21.x * c21.x;
    var c21y2 = c21.y * c21.y;
    var c22x2 = c22.x * c22.x;
    var c22y2 = c22.y * c22.y;
    var c23x2 = c23.x * c23.x;
    var c23y2 = c23.y * c23.y;
    var coefs = [-2 * c12.x * c12.y * c23.x * c23.y + c12x2 * c23y2 + c12y2 * c23x2, -2 * c12.x * c12.y * c22.x * c23.y - 2 * c12.x * c12.y * c22.y * c23.x + 2 * c12y2 * c22.x * c23.x + 2 * c12x2 * c22.y * c23.y, -2 * c12.x * c21.x * c12.y * c23.y - 2 * c12.x * c12.y * c21.y * c23.x - 2 * c12.x * c12.y * c22.x * c22.y + 2 * c21.x * c12y2 * c23.x + c12y2 * c22x2 + c12x2 * (2 * c21.y * c23.y + c22y2), 2 * c10.x * c12.x * c12.y * c23.y + 2 * c10.y * c12.x * c12.y * c23.x + c11.x * c11.y * c12.x * c23.y + c11.x * c11.y * c12.y * c23.x - 2 * c20.x * c12.x * c12.y * c23.y - 2 * c12.x * c20.y * c12.y * c23.x - 2 * c12.x * c21.x * c12.y * c22.y - 2 * c12.x * c12.y * c21.y * c22.x - 2 * c10.x * c12y2 * c23.x - 2 * c10.y * c12x2 * c23.y + 2 * c20.x * c12y2 * c23.x + 2 * c21.x * c12y2 * c22.x - c11y2 * c12.x * c23.x - c11x2 * c12.y * c23.y + c12x2 * (2 * c20.y * c23.y + 2 * c21.y * c22.y), 2 * c10.x * c12.x * c12.y * c22.y + 2 * c10.y * c12.x * c12.y * c22.x + c11.x * c11.y * c12.x * c22.y + c11.x * c11.y * c12.y * c22.x - 2 * c20.x * c12.x * c12.y * c22.y - 2 * c12.x * c20.y * c12.y * c22.x - 2 * c12.x * c21.x * c12.y * c21.y - 2 * c10.x * c12y2 * c22.x - 2 * c10.y * c12x2 * c22.y + 2 * c20.x * c12y2 * c22.x - c11y2 * c12.x * c22.x - c11x2 * c12.y * c22.y + c21x2 * c12y2 + c12x2 * (2 * c20.y * c22.y + c21y2), 2 * c10.x * c12.x * c12.y * c21.y + 2 * c10.y * c12.x * c21.x * c12.y + c11.x * c11.y * c12.x * c21.y + c11.x * c11.y * c21.x * c12.y - 2 * c20.x * c12.x * c12.y * c21.y - 2 * c12.x * c20.y * c21.x * c12.y - 2 * c10.x * c21.x * c12y2 - 2 * c10.y * c12x2 * c21.y + 2 * c20.x * c21.x * c12y2 - c11y2 * c12.x * c21.x - c11x2 * c12.y * c21.y + 2 * c12x2 * c20.y * c21.y, -2 * c10.x * c10.y * c12.x * c12.y - c10.x * c11.x * c11.y * c12.y - c10.y * c11.x * c11.y * c12.x + 2 * c10.x * c12.x * c20.y * c12.y + 2 * c10.y * c20.x * c12.x * c12.y + c11.x * c20.x * c11.y * c12.y + c11.x * c11.y * c12.x * c20.y - 2 * c20.x * c12.x * c20.y * c12.y - 2 * c10.x * c20.x * c12y2 + c10.x * c11y2 * c12.x + c10.y * c11x2 * c12.y - 2 * c10.y * c12x2 * c20.y - c20.x * c11y2 * c12.x - c11x2 * c20.y * c12.y + c10x2 * c12y2 + c10y2 * c12x2 + c20x2 * c12y2 + c12x2 * c20y2].reverse();
    var roots = getRootsInInterval(0, 1, coefs); // console.log(roots);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];
      var xRoots = getRoots([c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x].reverse());
      var yRoots = getRoots([c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y].reverse()); //
      // console.log('xRoots', xRoots);
      //
      // console.log('yRoots', yRoots);

      if (xRoots.length > 0 && yRoots.length > 0) {
        var _TOLERANCE3 = 1e-4;

        checkRoots: for (var j = 0; j < xRoots.length; j++) {
          var xRoot = xRoots[j];

          if (0 <= xRoot && xRoot <= 1) {
            for (var k = 0; k < yRoots.length; k++) {
              if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE3) {
                var x = c23.x * s * s * s + c22.x * s * s + c21.x * s + c20.x;
                var y = c23.y * s * s * s + c22.y * s * s + c21.y * s + c20.y;
                result.push({
                  x: x,
                  y: y,
                  t: xRoot
                });
                break checkRoots;
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2) {
    var c2, c1, c0;
    var cl, n;
    var isV = bx1 === bx2;
    var isH = by1 === by2;
    var result = [];
    var minbx = Math.min(bx1, bx2);
    var minby = Math.min(by1, by2);
    var maxbx = Math.max(bx1, bx2);
    var maxby = Math.max(by1, by2);

    var dot = function dot(a, b) {
      return a.x * b.x + a.y * b.y;
    };

    var lerp = function lerp(a, b, t) {
      return {
        x: a.x - (a.x - b.x) * t,
        y: a.y - (a.y - b.y) * t,
        t: t
      };
    };

    c2 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c1 = {
      x: -2 * ax1 + 2 * ax2,
      y: -2 * ay1 + 2 * ay2
    };
    c0 = {
      x: ax1,
      y: ay1
    };
    n = {
      x: by1 - by2,
      y: bx2 - bx1
    };
    cl = bx1 * by2 - bx2 * by1; // console.log('intersectBezier2Line', n, c0, c1, c2, cl);

    var coefs = [dot(n, c2), dot(n, c1), dot(n, c0) + cl].reverse(); // console.log('intersectBezier2Line coefs', coefs);

    var roots = getRoots(coefs); // console.log('intersectBezier2Line roots', roots);

    for (var i = 0; i < roots.length; i++) {
      var t = roots[i];

      if (0 <= t && t <= 1) {
        var p4 = lerp({
          x: ax1,
          y: ay1
        }, {
          x: ax2,
          y: ay2
        }, t);
        var p5 = lerp({
          x: ax2,
          y: ay2
        }, {
          x: ax3,
          y: ay3
        }, t);
        var p6 = lerp(p4, p5, t); // console.log('p4, p5, p6', p4, p5, p6);

        if (bx1 === bx2) {
          if (minby <= p6.y && p6.y <= maxby) {
            result.push(p6);
          }
        } else if (by1 === by2) {
          if (minbx <= p6.x && p6.x <= maxbx) {
            result.push(p6);
          }
        } else if (p6.x >= minbx && p6.y >= minby && p6.x <= maxbx && p6.y <= maxby) {
          result.push(p6);
        }
      }
    }

    if (isH || isV) {
      result.forEach(function (item) {
        if (isV) {
          if (item.x < minbx) {
            item.x = minbx;
          } else if (item.x > maxbx) {
            item.x = maxbx;
          }
        } else {
          if (item.y < minby) {
            item.y = minby;
          } else if (item.y > maxby) {
            item.y = maxby;
          }
        }
      });
    }

    return result;
  }
  /**
   *
   *    (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1
   *        /\                     /\                /\        /\
   *        ||                     ||                ||        ||
   *        c3                     c2                c1        c0
   */


  function intersectBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2) {
    var c3, c2, c1, c0;
    var cl, n;
    var isV = bx1 === bx2;
    var isH = by1 === by2;
    var result = [];
    var minbx = Math.min(bx1, bx2);
    var minby = Math.min(by1, by2);
    var maxbx = Math.max(bx1, bx2);
    var maxby = Math.max(by1, by2);

    var dot = function dot(a, b) {
      return a.x * b.x + a.y * b.y;
    };

    var lerp = function lerp(a, b, t) {
      return {
        x: a.x - (a.x - b.x) * t,
        y: a.y - (a.y - b.y) * t,
        t: t
      };
    };

    c3 = {
      x: -ax1 + 3 * ax2 - 3 * ax3 + ax4,
      y: -ay1 + 3 * ay2 - 3 * ay3 + ay4
    };
    c2 = {
      x: 3 * ax1 - 6 * ax2 + 3 * ax3,
      y: 3 * ay1 - 6 * ay2 + 3 * ay3
    };
    c1 = {
      x: -3 * ax1 + 3 * ax2,
      y: -3 * ay1 + 3 * ay2
    };
    c0 = {
      x: ax1,
      y: ay1
    };
    n = {
      x: by1 - by2,
      y: bx2 - bx1
    };
    cl = bx1 * by2 - bx2 * by1;
    var coefs = [cl + dot(n, c0), dot(n, c1), dot(n, c2), dot(n, c3)];
    var roots = getRoots(coefs);

    for (var i = 0; i < roots.length; i++) {
      var t = roots[i];

      if (0 <= t && t <= 1) {
        var p5 = lerp({
          x: ax1,
          y: ay1
        }, {
          x: ax2,
          y: ay2
        }, t);
        var p6 = lerp({
          x: ax2,
          y: ay2
        }, {
          x: ax3,
          y: ay3
        }, t);
        var p7 = lerp({
          x: ax3,
          y: ay3
        }, {
          x: ax4,
          y: ay4
        }, t);
        var p8 = lerp(p5, p6, t);
        var p9 = lerp(p6, p7, t);
        var p10 = lerp(p8, p9, t);

        if (bx1 === bx2) {
          if (minby <= p10.y && p10.y <= maxby) {
            result.push(p10);
          }
        } else if (by1 === by2) {
          if (minbx <= p10.x && p10.x <= maxbx) {
            result.push(p10);
          }
        } else if (p10.x >= minbx && p10.y >= minby && p10.x <= maxbx && p10.y <= maxby) {
          result.push(p10);
        }
      }
    }

    if (isH || isV) {
      result.forEach(function (item) {
        if (isV) {
          if (item.x < minbx) {
            item.x = minbx;
          } else if (item.x > maxbx) {
            item.x = maxbx;
          }
        } else {
          if (item.y < minby) {
            item.y = minby;
          } else if (item.y > maxby) {
            item.y = maxby;
          }
        }
      });
    }

    return result;
  }
  /**
   * 3d直线交点，允许误差，传入4个顶点坐标
   * limitToFiniteSegment可传0、1、2、3，默认0是不考虑点是否在传入的顶点组成的线段上
   * 1为限制在p1/p2线段，2为限制在p3/p4线段，3为都限制
   */


  function intersectLineLine3$1(p1, p2, p3, p4) {
    var limitToFiniteSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var tolerance = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1e-9;
    var p13 = subtractPoint(p1, p3);
    var p43 = subtractPoint(p4, p3);
    var p21 = subtractPoint(p2, p1);
    var d1343 = p13.x * p43.x + p13.y * p43.y + p13.z * p43.z;
    var d4321 = p43.x * p21.x + p43.y * p21.y + p43.z * p21.z;
    var d1321 = p13.x * p21.x + p13.y * p21.y + p13.z * p21.z;
    var d4343 = p43.x * p43.x + p43.y * p43.y + p43.z * p43.z;
    var d2121 = p21.x * p21.x + p21.y * p21.y + p21.z * p21.z;
    var denom = d2121 * d4343 - d4321 * d4321;

    if (Math.abs(denom) < tolerance) {
      return;
    }

    var numer = d1343 * d4321 - d1321 * d4343;
    var mua = numer / denom;
    var mub = (d1343 + d4321 * mua) / d4343;
    var pa = {
      x: p1.x + mua * p21.x,
      y: p1.y + mua * p21.y,
      z: p1.z + mua * p21.z
    };
    var pb = {
      x: p3.x + mub * p43.x,
      y: p3.y + mub * p43.y,
      z: p3.z + mub * p43.z
    };
    var distance = distanceTo(pa, pb);

    if (distance > tolerance) {
      return;
    }

    var intersectPt = divide(addPoint(pa, pb), 2);

    if (!limitToFiniteSegment) {
      return intersectPt;
    }

    var paramA = closestParam(intersectPt, p1, p2);
    var paramB = closestParam(intersectPt, p3, p4);

    if (paramA < 0 && Math.abs(paramA) < 1e-9) {
      paramA = 0;
    } else if (paramA > 1 && paramA - 1 < 1e-9) {
      paramA = 1;
    }

    if (paramB < 0 && Math.abs(paramB) < 1e-9) {
      paramB = 0;
    } else if (paramB > 1 && paramB - 1 < 1e-9) {
      paramB = 1;
    }

    intersectPt.pa = paramA;
    intersectPt.pb = paramB;

    if (limitToFiniteSegment === 1 && paramA >= 0 && paramA <= 1) {
      return intersectPt;
    }

    if (limitToFiniteSegment === 2 && paramB >= 0 && paramB <= 1) {
      return intersectPt;
    }

    if (limitToFiniteSegment === 3 && paramA >= 0 && paramA <= 1 && paramB >= 0 && paramB <= 1) {
      return intersectPt;
    }
  }

  function subtractPoint(p1, p2) {
    return {
      x: p1.x - p2.x,
      y: p1.y - p2.y,
      z: p1.z - p2.z
    };
  }

  function distanceTo(a, b) {
    return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2) + Math.pow(a.z - b.z, 2));
  }

  function addPoint(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y,
      z: a.z + b.z
    };
  }

  function divide(p, t) {
    var n = 1 / t;
    return {
      x: p.x * n,
      y: p.y * n,
      z: p.z * n
    };
  }

  function closestParam(p, from, to) {
    var startToP = subtractPoint(p, from);
    var startToEnd = subtractPoint(to, from);
    var startEnd2 = dotProduct3(startToEnd, startToEnd);
    var startEnd_startP = dotProduct3(startToEnd, startToP);
    return startEnd_startP / startEnd2;
  }
  /**
   * 平面相交线，传入2个平面的各3个顶点，返回2点式
   */


  function intersectPlanePlane$1(p1, p2, p3, p4, p5, p6) {
    var v1 = unitize3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z),
        v2 = unitize3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z),
        v4 = unitize3(p5.x - p4.x, p5.y - p4.y, p5.z - p4.z),
        v5 = unitize3(p6.x - p4.x, p6.y - p4.y, p6.z - p4.z);
    var v3 = unitize3(crossProduct3(v1.x, v1.y, v1.z, v2.x, v2.y, v2.z));
    var v6 = unitize3(crossProduct3(v4.x, v4.y, v4.z, v5.x, v5.y, v5.z));

    if (isParallel3(v3, v6)) {
      return null;
    }

    var normal = crossProduct3(v6.x, v6.y, v6.z, v3.x, v3.y, v3.z);
    var p7 = addPoint(v1, v4); // planeC

    var v9 = unitize3(normal.x, normal.y, normal.z); // 3平面相交

    var a1 = v3.x,
        b1 = v3.y,
        c1 = v3.z,
        d1 = -a1 * p1.x - b1 * p1.y - c1 * p1.z;
    var a2 = v6.x,
        b2 = v6.y,
        c2 = v6.z,
        d2 = -a2 * p4.x - b2 * p4.y - c2 * p4.z;
    var a3 = v9.x,
        b3 = v9.y,
        c3 = v9.z,
        d3 = -a3 * p7.x - b3 * p7.y - c3 * p7.z;
    var mb = [-d1, -d2, -d3];
    var det = a1 * (b2 * c3 - c2 * b3) - b1 * (a2 * c3 - c2 * a3) + c1 * (a2 * b3 - b2 * a3);

    if (Math.abs(det) < 1e-9) {
      return null;
    }

    var invDet = 1 / det;
    var v11 = invDet * (b2 * c3 - c2 * b3);
    var v12 = invDet * (c1 * b3 - b1 * c3);
    var v13 = invDet * (b1 * c2 - c1 * b2);
    var v21 = invDet * (c2 * a3 - a2 * c3);
    var v22 = invDet * (a1 * c3 - c1 * a3);
    var v23 = invDet * (c1 * a2 - a1 * c2);
    var v31 = invDet * (a2 * b3 - b2 * a3);
    var v32 = invDet * (b1 * a3 - a1 * b3);
    var v33 = invDet * (a1 * b2 - b1 * a2);
    var x = v11 * mb[0] + v12 * mb[1] + v13 * mb[2];
    var y = v21 * mb[0] + v22 * mb[1] + v23 * mb[2];
    var z = v31 * mb[0] + v32 * mb[1] + v33 * mb[2];
    var point = {
      x: x,
      y: y,
      z: z
    };
    return [point, addPoint(point, v9)];
  } // 点是否在线段上，注意误差


  function pointOnLine3$1(p, p1, p2) {
    var v1x = p1.x - p.x,
        v1y = p1.y - p.y,
        v1z = p1.z - p.z;
    var v2x = p2.x - p.x,
        v2y = p2.y - p.y,
        v2z = p2.z - p.z;
    var c = crossProduct3(v1x, v1y, v1z, v2x, v2y, v2z);
    return length3(c.x, c.y, c.z) < 1e-9;
  }

  var isec = {
    intersectBezier2Line: intersectBezier2Line,
    // 二阶贝塞尔曲线 与 直线
    intersectBezier3Line: intersectBezier3Line,
    // 三阶贝塞尔曲线 与 直线
    intersectBezier2Bezier2: intersectBezier2Bezier2,
    // 二阶贝塞尔曲线 与 二阶贝塞尔曲线
    intersectBezier3Bezier3: intersectBezier3Bezier3,
    // 三阶贝塞尔曲线 与 三阶贝塞尔曲线
    intersectBezier2Bezier3: intersectBezier2Bezier3,
    // 二阶贝塞尔曲线 与 三阶贝塞尔曲线
    intersectLineLine3: intersectLineLine3$1,
    intersectPlanePlane: intersectPlanePlane$1,
    pointOnLine3: pointOnLine3$1
  };

  var intersectPlanePlane = isec.intersectPlanePlane,
      intersectLineLine3 = isec.intersectLineLine3,
      pointOnLine3 = isec.pointOnLine3;
  var isRectsOverlap$1 = geom.isRectsOverlap,
      getPlainNormalEquation = geom.getPlainNormalEquation;
  var isZero3 = vector.isZero3; // 设置新拼图的x/y/z投影数据和bbox数据，原本平面矩形也算一个拼图

  function shadow(puzzle) {
    var points = puzzle.points;
    var xShadow = [{
      y: points[0].y,
      z: points[0].z
    }];

    outer: for (var i = 1, len = points.length; i < len; i++) {
      var p = points[i];

      for (var j = 0; j < i; j++) {
        var o = points[j];

        if (p.y === o.y && p.z === o.z) {
          continue outer;
        }
      }

      xShadow.push({
        y: p.y,
        z: p.z
      });
    } // 顶点和bbox，每个轴投影都要


    puzzle.xShadow = [];
    puzzle.xBbox = [];

    for (var _j = 0, _len = xShadow.length; _j < _len; _j++) {
      var a = xShadow[_j];
      puzzle.xShadow.push(a);

      if (_j === 0) {
        puzzle.xBbox[0] = a.z;
        puzzle.xBbox[1] = a.y;
        puzzle.xBbox[2] = a.z;
        puzzle.xBbox[3] = a.y;
      } else {
        puzzle.xBbox[0] = Math.min(puzzle.xBbox[0], a.z);
        puzzle.xBbox[1] = Math.min(puzzle.xBbox[1], a.y);
        puzzle.xBbox[2] = Math.max(puzzle.xBbox[2], a.z);
        puzzle.xBbox[3] = Math.max(puzzle.xBbox[3], a.y);
      }
    } // y/z类似


    var yShadow = [{
      x: points[0].x,
      z: points[0].z
    }];

    outer: for (var _i = 1, _len2 = points.length; _i < _len2; _i++) {
      var _p = points[_i];

      for (var _j2 = 0; _j2 < _i; _j2++) {
        var _o = points[_j2];

        if (_p.x === _o.x && _p.z === _o.z) {
          continue outer;
        }
      }

      yShadow.push({
        x: _p.x,
        z: _p.z
      });
    }

    puzzle.yShadow = [];
    puzzle.yBbox = [];

    for (var _j3 = 0, _len3 = yShadow.length; _j3 < _len3; _j3++) {
      var _a = yShadow[_j3];
      puzzle.yShadow.push(_a);

      if (_j3 === 0) {
        puzzle.yBbox[0] = _a.x;
        puzzle.yBbox[1] = _a.z;
        puzzle.yBbox[2] = _a.x;
        puzzle.yBbox[3] = _a.z;
      } else {
        puzzle.yBbox[0] = Math.min(puzzle.yBbox[0], _a.x);
        puzzle.yBbox[1] = Math.min(puzzle.yBbox[1], _a.z);
        puzzle.yBbox[2] = Math.max(puzzle.yBbox[2], _a.x);
        puzzle.yBbox[3] = Math.max(puzzle.yBbox[3], _a.z);
      }
    }

    var zShadow = [{
      x: points[0].x,
      y: points[0].y
    }];

    outer: for (var _i2 = 1, _len4 = points.length; _i2 < _len4; _i2++) {
      var _p2 = points[_i2];

      for (var _j4 = 0; _j4 < _i2; _j4++) {
        var _o2 = points[_j4];

        if (_p2.x === _o2.x && _p2.y === _o2.y) {
          continue outer;
        }
      }

      zShadow.push({
        x: _p2.x,
        y: _p2.y
      });
    }

    puzzle.zShadow = [];
    puzzle.zBbox = [];

    for (var _j5 = 0, _len5 = zShadow.length; _j5 < _len5; _j5++) {
      var _a2 = zShadow[_j5];
      puzzle.zShadow.push(_a2);

      if (_j5 === 0) {
        puzzle.zBbox[0] = _a2.x;
        puzzle.zBbox[1] = _a2.y;
        puzzle.zBbox[2] = _a2.x;
        puzzle.zBbox[3] = _a2.y;
      } else {
        puzzle.zBbox[0] = Math.min(puzzle.zBbox[0], _a2.x);
        puzzle.zBbox[1] = Math.min(puzzle.zBbox[1], _a2.y);
        puzzle.zBbox[2] = Math.max(puzzle.zBbox[2], _a2.x);
        puzzle.zBbox[3] = Math.max(puzzle.zBbox[3], _a2.y);
      }
    }
  } // 多个平面相交切割，每个平面有[3,]个顶点，且有index索引额外信息


  function splitQuadrilateralPlane(list) {
    var uuid = 0;
    var length = list.length;

    if (length < 2) {
      return;
    } // 先每个四边形计算x/y/z轴上的投影，可能是四边形也可能重合三角形或直线


    var xList = [];

    for (var i = 0; i < length; i++) {
      var item = list[i];
      shadow(item);
      item.uuid = uuid++;
      item.plane = item;
      var xShadow = item.xShadow;

      for (var _i3 = 0, len = xShadow.length; _i3 < len; _i3++) {
        // 只有2个点防重，x投影特殊需要，线段排序列表
        if (len === 2 && _i3 === 1) {
          break;
        }

        var a = xShadow[_i3];
        var b = xShadow[(_i3 + 1) % len];

        if (a.z > b.z) {
          var _ref = [b, a];
          a = _ref[0];
          b = _ref[1];
        }

        xList.push({
          belong: item,
          y1: a.y,
          z1: a.z,
          y2: b.y,
          z2: b.z
        });
      }
    }
    /**
     * 从侧面观看投影，即x轴，按照深度z顺序，每个平面可形成2或4条线（y/z坐标），用扫描线算法求交
     * 处在扫描线活动范围下的2个线段，如果属于2个不同平面，继续
     * 再检测面的x/y/z是否bbox重叠，3个都重叠是2个四边面空间重叠的必要条件，以此前提甄选
     * 再用平面相交公式求得相交线，查看双方顶点是否都存在于此条线上且范围内，都有则真正相交，开始拆分
     */


    var eventHash = {};

    for (var _i4 = 0, _len6 = xList.length; _i4 < _len6; _i4++) {
      var seg = xList[_i4];
      var o = eventHash[seg.z1] = eventHash[seg.z1] || [];
      o.push(seg);
      o = eventHash[seg.z2] = eventHash[seg.z2] || [];
      o.push(seg);
    } // z排序，不用管y


    var eventList = [];

    for (var _i5 in eventHash) {
      if (eventHash.hasOwnProperty(_i5)) {
        var _o3 = eventHash[_i5];
        eventList.push({
          z: _i5,
          list: _o3
        });
      }
    }

    eventList.sort(function (a, b) {
      return a.z - b.z;
    });
    var HISTORY = {}; // 求过的2个平面记录，只求1次防重

    var ael = []; // 当前扫描线活动边

    for (var _i6 = 0, elLen = eventList.length; _i6 < elLen; _i6++) {
      var _eventList$_i = eventList[_i6],
          z = _eventList$_i.z,
          _list = _eventList$_i.list;

      for (var j = 0, _length = _list.length; j < _length; j++) {
        var _seg = _list[j]; // 第1次进是start，第2次是end

        if (_seg.isVisited) {
          var _j6 = ael.indexOf(_seg);

          if (_j6 > -1) {
            ael.splice(_j6, 1);
          }
        } else {
          if (ael.length) {
            for (var _j7 = 0, _len7 = ael.length; _j7 < _len7; _j7++) {
              var _item = ael[_j7];
              var pa = _seg.belong,
                  pb = _item.belong; // 属于不同的平面才能相交

              if (pa.plane === pb.plane) {
                continue;
              } // 如果面被拆分过，忽略掉


              if (pa.isDeleted) {
                break;
              }

              if (pb.isDeleted) {
                continue;
              } // 无论结果如何，这2个拼图都记录下防止重复检测


              var key = pa.uuid > pb.uuid ? pb.uuid + ',' + pa.uuid : pa.uuid + ',' + pb.uuid;

              if (HISTORY.hasOwnProperty(key)) {
                continue;
              }

              HISTORY[key] = true; // 所属的2个面进行x/y/z上的bbox重叠验证，是屏幕真相交的前提必要条件

              if (isRectsOverlap$1(pa.xBbox, pb.xBbox, false) && isRectsOverlap$1(pa.yBbox, pb.yBbox, false) && isRectsOverlap$1(pa.zBbox, pb.zBbox, false)) {
                var pointsA = pa.points,
                    pointsB = pb.points; // 真正求交

                var line = intersectPlanePlane(pointsA[0], pointsA[1], pointsA[2], pointsB[0], pointsB[1], pointsB[2]);

                if (!line || line.length !== 2) {
                  continue;
                } // 这条线一定和2个四边形有2/4个不同交点，分别用每条边和直线求交点，2个是四边形a内切割b，4个是a和b恰好互相切割
                // 被切割后的puzzle解法相同，只是变成了多边形，n>=3


                var resA = [],
                    resB = [];

                for (var _i7 = 0, _len8 = pointsA.length; _i7 < _len8; _i7++) {
                  var r = intersectLineLine3(pointsA[_i7], pointsA[(_i7 + 1) % _len8], line[0], line[1], 1);

                  if (r) {
                    r.i = _i7;
                    resA.push(r);
                  }
                }

                for (var _i8 = 0, _len9 = pointsB.length; _i8 < _len9; _i8++) {
                  var _r = intersectLineLine3(pointsB[_i8], pointsB[(_i8 + 1) % _len9], line[0], line[1], 1);

                  if (_r) {
                    _r.i = _i8;
                    resB.push(_r);
                  }
                } // res只可能是2和0，2个res组合只有3种可能，其它则是精度误差忽略，切割的交点在边的索引和下个索引之间的边上


                if (resA.length === 2 && resB.length === 2 || resA.length === 2 && !resB.length || !resA.length && resB.length === 2) {
                  var puzzle = [],
                      t1 = void 0,
                      t2 = void 0; // 2个都需要切割，各自判断

                  if (resA.length) {
                    t1 = splitPlaneByLine(pa, resA);
                  }

                  if (resB.length) {
                    t2 = splitPlaneByLine(pb, resB);
                  } // 误差导致切割数量不对，要么一个不被切割另外一个被切为2，要么都被切2，不会出现被切但数量不对


                  if (t1 && t2 && t1.length !== t2.length) {
                    continue;
                  }

                  if (t1 && t1.length > 1) {
                    pa.puzzle = pa.puzzle || [];
                    pa.puzzle = pa.puzzle.concat(t1);
                    pa.isDeleted = true;
                    puzzle = puzzle.concat(t1);
                  }

                  if (t2 && t2.length > 1) {
                    pb.puzzle = pb.puzzle || [];
                    pb.puzzle = pb.puzzle.concat(t2);
                    pb.isDeleted = true;
                    puzzle = puzzle.concat(t2);
                  } // 新的拼图需考虑加入到eventList的合适位置，可能是新增的扫描事件


                  for (var _j8 = 0, _len10 = puzzle.length; _j8 < _len10; _j8++) {
                    var _item2 = puzzle[_j8];
                    shadow(_item2);
                    _item2.uuid = uuid++;
                    var xBbox = _item2.xBbox;

                    if (xBbox[2] <= z) {
                      continue;
                    }

                    var _xShadow = _item2.xShadow;

                    for (var _j9 = 0, _len11 = _xShadow.length; _j9 < _len11; _j9++) {
                      // 只有2个点防重，x投影特殊需要，线段排序列表
                      if (_len11 === 2 && _j9 === 1) {
                        break;
                      }

                      var _a3 = _xShadow[_j9];
                      var _b = _xShadow[(_j9 + 1) % _len11];

                      if (_a3.z > _b.z) {
                        var _ref2 = [_b, _a3];
                        _a3 = _ref2[0];
                        _b = _ref2[1];
                      } // 和初始化不一样多判断下，最大值比当前还小的是无效的事件，已经扫过了


                      if (_b.z <= z) {
                        continue;
                      }

                      var _seg2 = {
                        belong: _item2,
                        y1: _a3.y,
                        z1: _a3.z,
                        y2: _b.y,
                        z2: _b.z
                      }; // 最小值比当前z小，被访问过isVisited

                      if (_seg2.z1 <= z) {
                        _seg2.isVisited = true; // 等于才加入当前事件列表

                        if (_seg2.z1 === z) {
                          _list.push(_seg2);

                          _length++;
                        }
                      } // 最大值加入事件列表，=z忽略，注意判断可能z所属的扫描坐标不存在


                      if (_seg2.z2 > z) {
                        for (var _j10 = _i6 + 1; _j10 < elLen; _j10++) {
                          var _item3 = eventList[_j10];
                          var _z = _item3.z;

                          if (_seg2.z2 === _z) {
                            _item3.list.push(_seg2);

                            break;
                          } else if (_seg2.z2 > _z || _j10 === elLen - 1) {
                            eventList.splice(_j10, 0, {
                              z: _seg2.z2,
                              list: [_seg2]
                            });
                            elLen++;
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          _seg.isVisited = true;
          ael.push(_seg);
        }
      }
    }
  }

  function scan(eventList) {
    var ael = [],
        hash = {};

    for (var i = 0, len = eventList.length; i < len; i++) {
      var _eventList$i = eventList[i],
          k = _eventList$i.k,
          list = _eventList$i.list; // 先一遍循环，把刚进入的puzzle初始化放入ael，这样同时初始化的就不会有遗漏

      for (var _i9 = 0, _len12 = list.length; _i9 < _len12; _i9++) {
        var puzzle = list[_i9].puzzle; // 首次进入初始化数据

        if (!puzzle.isStart) {
          puzzle.isStart = true;
          puzzle.count = 2;
          ael.push(puzzle);
        }
      }

      var willEnd = []; // 再一遍循环，检查同区域点集合

      for (var _i10 = 0, _len13 = list.length; _i10 < _len13; _i10++) {
        var p = list[_i10],
            _puzzle = p.puzzle; // 遍历已存在的puzzle，和当前puzzle视为同区域集合，存数据

        for (var _i11 = 0, _len14 = ael.length; _i11 < _len14; _i11++) {
          var item = ael[_i11];

          if (_puzzle === item || _puzzle.plane === item.plane) {
            continue;
          }

          var key = _puzzle.uuid > item.uuid ? item.uuid + ',' + _puzzle.uuid : _puzzle.uuid + ',' + item.uuid; // 一定是第1次视为start

          var o = hash[key] = hash[key] || [];
          o.push(k);
        } // 归零时离开，延迟处理，依然是防止同时离开的puzzle不会有遗漏


        if (! --_puzzle.count) {
          willEnd.push(_puzzle);
        }
      }

      for (var j = 0, _len15 = willEnd.length; j < _len15; j++) {
        var _p3 = willEnd[j],
            uuid = _p3.uuid;
        _p3.isStart = false;

        var _i12 = ael.indexOf(_p3);

        ael.splice(_i12, 1); // 离开检查hash，如有则视为end

        for (var _k in hash) {
          if (hash.hasOwnProperty(_k)) {
            if (_k.indexOf(uuid + ',') === 0 || _k.indexOf(',' + uuid) > -1) {
              var _o4 = hash[_k];

              if (_o4.length < 2) {
                _o4.push(_k);
              }
            }
          }
        }
      }
    }

    return hash;
  }

  function splitPlaneByLine(puzzle, res) {
    if (checkIsec(puzzle.points.length, res)) {
      return;
    }

    var plane = puzzle.plane,
        points = puzzle.points,
        i1 = -1,
        i2 = -1;
    var p0 = plane.points[0],
        p1 = plane.points[1],
        p2 = plane.points[2],
        p3 = plane.points[3]; // 交点一定在边上，不在边上的不切割

    for (var i = 0, len = points.length; i < len; i++) {
      var _p4 = points[i],
          _p5 = points[(i + 1) % len];
      var r1 = pointOnLine3(res[0], _p4, _p5);
      var r2 = pointOnLine3(res[1], _p4, _p5);

      if (r1) {
        i1 = i;
      }

      if (r2) {
        i2 = i;
      }
    } // 看是否相邻以及是否是原有顶点，不同情况不同拆分，切割也不能在同一条边上


    if (i1 > -1 && i2 > -1 && i1 !== i2) {
      var onVertex1 = isZero3(points[i1], res[0]) ? i1 : -1;

      if (!onVertex1 && points[i1 + 1]) {
        onVertex1 = isZero3(points[i1 + 1], res[0]) ? i1 + 1 : -1;
      }

      var onVertex2 = isZero3(points[i2], res[1]) ? i2 : -1;

      if (!onVertex2 && points[i2 + 1]) {
        onVertex2 = isZero3(points[i2 + 1], res[1]) ? i2 + 1 : -1;
      } // 如果是相邻顶点，或者只有1个顶点但恰好2点在同边则失效


      if (Math.abs(i1 - i2) <= 1) {
        if (onVertex1 > -1 && onVertex2 > -1) {
          return;
        } else if (onVertex1 > -1) {
          if (onVertex1 === i2) {
            return;
          }
        } else if (onVertex2 > -1) {
          if (onVertex2 === i2) {
            return;
          }
        }
      } // 原本矩形经过任意matrix变换后一定还是个平行四边形（相对所在平面），4个顶点坐标已知
      // 然后交点坐标已知，也一定在这个平面上，求得相对于左上角顶点即原点的百分比坐标，分母为宽或高
      // 其实就是求拆分后的拼图，某个点对应于原本矩形纹理的百分比坐标
      // 先求得平行四边形的2个邻边的向量，然后求交点和向量所在直线与边的交点即可得出


      var va = plane.va,
          vb = plane.vb;

      if (!va) {
        va = plane.va = {
          x: p0.x - p1.x,
          y: p0.y - p1.y,
          z: p0.z - p1.z
        };
      }

      if (!vb) {
        vb = plane.vb = {
          x: p1.x - p2.x,
          y: p1.y - p2.y,
          z: p1.z - p2.z
        };
      }

      var hash = [],
          r0,
          _r2; // n边形（n一定>=3)，会被分为a、b两个多边形


      plane.puzzle = plane.puzzle || [];
      var _puzzle2 = [];
      var a = {
        plane: plane,
        node: plane.node,
        target: plane.target,
        isPuzzle: true,
        points: []
      };

      for (var _i13 = 0; _i13 <= i1; _i13++) {
        var r = hash[_i13] = getPercentXY(points[_i13], va, vb, p0, p1, p3);

        if (r) {
          a.points.push(r);
        }
      } // 第1个交点如果在顶点上忽略，前面循环考虑了


      if (onVertex1 === -1) {
        r0 = getPercentXY(res[0], va, vb, p0, p1, p3);

        if (r0) {
          a.points.push(r0);
        }
      } // 第2个即便在顶点上也包含，后面循环没考虑


      _r2 = getPercentXY(res[1], va, vb, p0, p1, p3);

      if (_r2) {
        a.points.push(_r2);
      }

      for (var _i14 = i2 + 1, _len16 = points.length; _i14 < _len16; _i14++) {
        var _r3 = hash[_i14] = getPercentXY(points[_i14], va, vb, p0, p1, p3);

        if (_r3) {
          a.points.push(_r3);
        }
      }

      if (a.points.length > 2) {
        _puzzle2.push(a);
      } // b部分同上


      var b = {
        plane: plane,
        node: plane.node,
        target: plane.target,
        isPuzzle: true,
        points: []
      }; // 复用数据但不能相同引用

      if (r0) {
        b.points.push(Object.assign({}, r0));
      } else {
        r0 = getPercentXY(res[0], va, vb, p0, p1, p3);

        if (r0) {
          b.points.push(r0);
        }
      }

      for (var _i15 = i1 + 1; _i15 <= i2; _i15++) {
        var _r4 = hash[_i15] = hash[_i15] || getPercentXY(points[_i15], va, vb, p0, p1, p3);

        if (_r4) {
          b.points.push(_r4);
        }
      }

      if (onVertex2 === -1) {
        if (_r2) {
          b.points.push(Object.assign({}, _r2));
        } else {
          _r2 = getPercentXY(res[1], va, vb, p0, p1, p3);

          if (_r2) {
            b.points.push(_r2);
          }
        }
      }

      if (b.points.length > 2) {
        _puzzle2.push(b);
      } // 只返回新增的


      return _puzzle2;
    }
  } // 已知空间平行四边形顶点和其面上一点，求相对于左上角顶点即原点的百分比坐标，四边形宽高即分母


  function getPercentXY(p, va, vb, p0, p1, p3) {
    var pa = {
      x: p.x + va.x,
      y: p.y + va.y,
      z: p.z + va.z
    },
        pb = {
      x: p.x + vb.x,
      y: p.y + vb.y,
      z: p.z + vb.z
    };
    var ipx = intersectLineLine3(p0, p1, p, pb, 3);
    var ipy = intersectLineLine3(p0, p3, p, pa, 3);

    if (ipx && ipy) {
      return {
        x: p.x,
        y: p.y,
        z: p.z,
        px: (ipx.x - p0.x) / (p1.x - p0.x),
        py: (ipy.y - p0.y) / (p3.y - p1.y)
      };
    }
  } // 检测相交线是否有效，不能和puzzle的边重合


  function checkIsec(len, res) {
    var a = res[0],
        b = res[1]; // 共边索引

    if (a.i === b.i) {
      return true;
    }

    if (a.i > b.i) {
      var t = a;
      a = b;
      b = t;
    } // 临边如果小的索引为1或大的索引为0


    if (b.i - a.i === 1) {
      if (Math.abs(a.pa - 1) < 1e-9 || b.pa < 1e-9) {
        return true;
      }
    } // 刚好隔边则必须同时索引为1和0


    if (b.i - a.i === 2) {
      if (Math.abs(a.pa - 1) < 1e-9 && b.pa < 1e-9) {
        return true;
      }
    } // 首尾临边


    if (b.i === len - 1 && a.i === 0) {
      if (Math.abs(b.pa - 1) < 1e-9 || a.pa < 1e-9) {
        return true;
      }
    } // 首尾隔边


    if (b.i === len - 1 && a.i === 1 || b.i === len - 2 && a.i === 0) {
      if (Math.abs(b.pa - 1) < 1e-9 && a.pa < 1e-9) {
        return true;
      }
    }

    return false;
  } // 将拼图按z顺序排好，渲染从z小的开始，拼图已经完全不相交（3d空间）


  function sortPuzzleZ(list) {
    if (list.length < 2) {
      return list;
    } // 用扫描线遍历一遍正视图，可以找到2个拼图在投影重合部分，有开始和结束，取x/y中间值，
    // 比较此点在2个平面上的z大小可以得出这2个拼图真正的z先后次序，如果相等则特殊处理，和不重合逻辑一样，
    // 不重合的话，取最大最小值z的平均比较即可，平均值可避免起点终点相同无法比较


    var eventHashX = {},
        eventHashY = {},
        puzzleHash = {};

    for (var i = 0, len = list.length; i < len; i++) {
      var puzzle = list[i],
          xBbox = puzzle.xBbox,
          yBbox = puzzle.yBbox;
      puzzleHash[puzzle.uuid] = puzzle;
      var start = xBbox[0],
          end = xBbox[2];
      var o = eventHashX[start] = eventHashX[start] || [];
      o.push(puzzle);
      o = eventHashX[end] = eventHashX[end] || [];
      o.push(puzzle);
      start = yBbox[0];
      end = yBbox[2];
      o = eventHashY[start] = eventHashY[start] || [];
      o.push(puzzle);
      o = eventHashY[end] = eventHashY[end] || [];
      o.push(puzzle);
      puzzle.cz = (xBbox[0] + xBbox[2]) * 0.5;
    }

    var eventListX = [],
        eventListY = [];

    for (var _i16 in eventHashX) {
      if (eventHashX.hasOwnProperty(_i16)) {
        var _o5 = eventHashX[_i16];
        eventListX.push({
          k: _i16,
          list: _o5
        });
      }
    }

    for (var _i17 in eventHashY) {
      if (eventHashY.hasOwnProperty(_i17)) {
        var _o6 = eventHashY[_i17];
        eventListY.push({
          k: _i17,
          list: _o6
        });
      }
    }

    eventListX.sort(function (a, b) {
      return a.k - b.k;
    });
    eventListY.sort(function (a, b) {
      return a.k - b.k;
    }); // 每个点作为事件，触发时所属拼图count--，首次拼图视为start，当count为0时拼图视为end
    // 这样2个（或多个）拼图同时都在start状态下（count > 0)的点就是重合区域点集合

    var hashX = scan(eventHashX),
        hashY = scan(eventHashY); // 取中值x/y，比较2个puzzle所在平面的值为x/y的点的z坐标大小

    var zHash = {};

    for (var _i18 in hashX) {
      if (hashX.hasOwnProperty(_i18)) {
        var listX = hashX[_i18],
            listY = hashY[_i18],
            k = _i18.splice(',');

        var pa = puzzleHash[k[0]],
            pb = puzzleHash[k[1]];
        var cx = (listX[0] + listX[1]) * 0.5,
            cy = (listY[0] + listY[1]) * 0.5;

        var _getPlainNormalEquati = getPlainNormalEquation(pa.points),
            a1 = _getPlainNormalEquati.a,
            b1 = _getPlainNormalEquati.b,
            c1 = _getPlainNormalEquati.c,
            d1 = _getPlainNormalEquati.d;

        var _getPlainNormalEquati2 = getPlainNormalEquation(pb.points),
            a2 = _getPlainNormalEquati2.a,
            b2 = _getPlainNormalEquati2.b,
            c2 = _getPlainNormalEquati2.c,
            d2 = _getPlainNormalEquati2.d;

        var z1 = c1 ? (-d1 - a1 * cx - b1 * cy) / c1 : 0;
        var z2 = c2 ? (-d2 - a2 * cx - b2 * cy) / c2 : 0;

        if (Math.abs(z1 - z2) > 1e-9) {
          zHash[_i18] = z1 - z2;
        }
      }
    }

    list.sort(function (a, b) {
      var key = a.uuid > b.uuid ? b.uuid + ',' + a.uuid : a.uuid + ',' + b.uuid; // 有重合的区域，除非相等，否则可以直接得出结果

      if (zHash.hasOwnProperty(key)) {
        return zHash[key];
      } // 无重合或者相等的，对比z中点


      return a.cz - b.cz;
    });
    return list;
  }

  var oit = {
    splitQuadrilateralPlane: splitQuadrilateralPlane,
    sortPuzzleZ: sortPuzzleZ
  };

  var TexturePage = /*#__PURE__*/function (_Page) {
    _inherits(TexturePage, _Page);

    function TexturePage(renderMode, gl, size, number) {
      var _this;

      _this = _Page.call(this, renderMode, gl, size, number) || this;
      _this.gl = gl;
      _this.texture = webgl.createTexture(gl, null, 0, size, size); // 默认0单元

      gl.bindTexture(gl.TEXTURE_2D, null);
      return _this;
    }

    _createClass(TexturePage, [{
      key: "add",
      value: function add(unitSize, pos) {
        _get(_getPrototypeOf(TexturePage.prototype), "add", this).call(this, unitSize, pos);

        if (!this.texture) {
          this.texture = webgl.createTexture(this.gl, null, 0, this.__size, this.__size);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        }
      }
    }, {
      key: "del",
      value: function del(pos) {
        _get(_getPrototypeOf(TexturePage.prototype), "del", this).call(this, pos);

        if (!this.__count) {
          var t = this.texture;

          if (t) {
            var gl = this.gl;
            gl.deleteTexture(t);
            this.texture = null;
          }
        }
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, gl, rootId, size, excludePage) {
        return _get(_getPrototypeOf(TexturePage), "getInstance", this).call(this, renderMode, gl, rootId, size, this, excludePage);
      }
    }]);

    return TexturePage;
  }(Page);

  /**
   * 一个fbo离屏纹理，mock成cache，当webgl需要局部根节点汇总时生成，即cacheTotal，
   * 基于此纹理进行filter、mask等后处理渲染
   */

  var TextureCache = /*#__PURE__*/function (_Cache) {
    _inherits(TextureCache, _Cache);

    function TextureCache(renderMode, gl, rootId, w, h, bbox, page, pos, x1, y1) {
      var _this;

      _this = _Cache.call(this, renderMode, gl, rootId, w, h, bbox, page, pos, x1, y1) || this;
      _this.gl = gl;
      return _this;
    }

    _createClass(TextureCache, [{
      key: "update",
      value: function update() {// 直接生成的texture不需要更新，覆盖掉不调用
      }
    }, {
      key: "clear",
      value: function clear() {
        if (_get(_getPrototypeOf(TextureCache.prototype), "clear", this).call(this)) {
          var page = this.__page,
              gl = page.gl,
              size = page.__size; // 尺寸必须对上才行

          var data = new Uint8Array(this.__width * this.__height * 4);
          gl.bindTexture(gl.TEXTURE_2D, page.texture); // 注意y镜像和原点左下

          gl.texSubImage2D(gl.TEXTURE_2D, 0, this.__x, size - this.__y - this.__height, this.__width, this.__height, gl.RGBA, gl.UNSIGNED_BYTE, data);
          gl.bindTexture(gl.TEXTURE_2D, null);
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1) {
        return _get(_getPrototypeOf(TextureCache.prototype), "reset", this).call(this, bbox, x1, y1, TexturePage);
      }
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, gl, rootId, bbox, x1, y1, excludePage) {
        return _get(_getPrototypeOf(TextureCache), "getInstance", this).call(this, renderMode, gl, rootId, bbox, x1, y1, this, TexturePage, excludePage);
      }
    }]);

    return TextureCache;
  }(Cache);

  var vertexBlur = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentBlur = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform vec2 u_direction;void main(){gl_FragColor=vec4(0.0);placeholder;}"; // eslint-disable-line

  var HASH = {};
  /**
   * 相同的图片且尺寸相同时，复用一个source，如果尺寸和原图相等直接用，否则生成一个离屏canvas
   */

  var ImgCanvasCache = /*#__PURE__*/function (_CanvasCache) {
    _inherits(ImgCanvasCache, _CanvasCache);

    function ImgCanvasCache(renderMode, ctx, rootId, w, h, bbox, page, x1, y1) {
      return _CanvasCache.call(this, renderMode, ctx, rootId, w, h, bbox, page, null, x1, y1) || this;
    }

    _createClass(ImgCanvasCache, [{
      key: "__init",
      value: function __init(w, h, bbox, page, pos, x1, y1) {
        this.__width = w;
        this.__height = h;
        this.__bbox = bbox;
        this.__page = page; // 相等就不生成新的离屏canvas，直接用原始资源比如<img>节点内容

        if (page.width === w && page.height === h) {
          this.__canvas = page.source;
        } // 不等则一个url只生成一份OffscreenCanvas
        else {
          var key = this.key = w + ' ' + h + ' ' + page.src;

          if (HASH.hasOwnProperty(key)) {
            var o = HASH[key];
            o.count++;
            this.__canvas = o.canvas;
          } else {
            var offscreenCanvas = inject.getOffscreenCanvas(w, h, null, null);
            var ctx = offscreenCanvas.ctx;
            ctx.globalAlpha = 1;
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(page.source, 0, 0, w, h);
            this.__canvas = offscreenCanvas.canvas;
            HASH[key] = {
              canvas: offscreenCanvas.canvas,
              count: 1
            };
          }
        }

        this.__x = 0;
        this.__y = 0;
        this.__enabled = true;
        this.__available = true;

        this.__appendData(x1, y1);
      }
    }, {
      key: "clear",
      value: function clear() {
        if (this.__available) {
          this.__available = false;
          return true;
        }
      }
    }, {
      key: "release",
      value: function release() {
        if (this.__enabled) {
          this.clear();
          var key = this.key;

          if (HASH.hasOwnProperty(key)) {
            var o = HASH[key];
            o.count--;

            if (!o.count) {
              delete HASH[key];
            }
          }

          this.__enabled = false;
          this.__page = null;
          return true;
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1) {
        this.release();
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var n = Math.max(w, h);

        if (n <= 0) {
          return;
        }

        this.__init(w, h, bbox, this.__page, null, x1, y1);
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.__canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__ctx;
      }
    }, {
      key: "size",
      get: function get() {}
    }], [{
      key: "getInstance",
      value: function getInstance(renderMode, ctx, rootId, bbox, loadImg, x1, y1) {
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var n = Math.max(w, h);

        if (n <= 0) {
          return;
        }

        return new ImgCanvasCache(renderMode, ctx, rootId, w, h, bbox, loadImg, x1, y1);
      }
    }]);

    return ImgCanvasCache;
  }(CanvasCache);

  var OFFSCREEN_OVERFLOW = offscreen.OFFSCREEN_OVERFLOW,
      OFFSCREEN_FILTER = offscreen.OFFSCREEN_FILTER,
      OFFSCREEN_MASK = offscreen.OFFSCREEN_MASK,
      OFFSCREEN_BLEND = offscreen.OFFSCREEN_BLEND,
      OFFSCREEN_MASK2 = offscreen.OFFSCREEN_MASK2,
      applyOffscreen = offscreen.applyOffscreen;
  var _enums$STYLE_KEY$1 = enums.STYLE_KEY,
      DISPLAY$1 = _enums$STYLE_KEY$1.DISPLAY,
      OPACITY$1 = _enums$STYLE_KEY$1.OPACITY,
      VISIBILITY$1 = _enums$STYLE_KEY$1.VISIBILITY,
      FILTER = _enums$STYLE_KEY$1.FILTER,
      OVERFLOW = _enums$STYLE_KEY$1.OVERFLOW,
      MIX_BLEND_MODE$1 = _enums$STYLE_KEY$1.MIX_BLEND_MODE,
      FILL = _enums$STYLE_KEY$1.FILL,
      TRANSFORM$1 = _enums$STYLE_KEY$1.TRANSFORM,
      TRANSFORM_ORIGIN = _enums$STYLE_KEY$1.TRANSFORM_ORIGIN,
      PERSPECTIVE = _enums$STYLE_KEY$1.PERSPECTIVE,
      PERSPECTIVE_ORIGIN = _enums$STYLE_KEY$1.PERSPECTIVE_ORIGIN,
      TRANSFORM_STYLE = _enums$STYLE_KEY$1.TRANSFORM_STYLE,
      BACKFACE_VISIBILITY = _enums$STYLE_KEY$1.BACKFACE_VISIBILITY;
  var NONE$1 = o$1.NONE,
      TRANSFORM_ALL$1 = o$1.TRANSFORM_ALL,
      OP$1 = o$1.OPACITY,
      FT$1 = o$1.FILTER,
      REPAINT$1 = o$1.REPAINT,
      MBM$1 = o$1.MIX_BLEND_MODE,
      PPT$1 = o$1.PERSPECTIVE,
      CACHE$1 = o$1.CACHE,
      MASK$1 = o$1.MASK;
  var isE = matrix.isE,
      inverse = matrix.inverse,
      multiply = matrix.multiply,
      calRectPoint = matrix.calRectPoint,
      assignMatrix = matrix.assignMatrix;
  var mbmName = mbm.mbmName;
  var transformBbox = util.transformBbox;
  var drawTextureCache = webgl.drawTextureCache,
      createTexture = webgl.createTexture,
      bindTexture = webgl.bindTexture,
      drawCache2Tex = webgl.drawCache2Tex,
      drawTex2Cache = webgl.drawTex2Cache;
  var DOM_RENDER = Dom.prototype.render;
  var IMG_RENDER = Img.prototype.render;
  var GEOM_RENDER = Geom.prototype.render;
  /**
   * 生成一个节点及其子节点所包含的矩形范围盒，canvas和webgl的最大尺寸限制不一样，由外部传入
   * 如果某个子节点超限，则视为整个超限，超限返回空
   * isPpt为webgl下有perspective的节点，需考虑透视
   */

  function genBboxTotal(node, __structs, index, total, lv, isPpt) {
    var __cache = node.__cache;
    assignMatrix(node.__matrixEvent, matrix.identity());
    node.__opacity = 1; // 先将局部根节点的bbox算好，可能没内容是空

    var bboxTotal;

    if (__cache && __cache.__available) {
      bboxTotal = __cache.bbox;
    } else {
      bboxTotal = node.bbox;
    }

    bboxTotal = bboxTotal.slice(0); // 局部根节点如有perspective，则计算pm，这里不会出现嵌套，因为每个出现都会生成局部根节点
    // 分2种情况，普通父ppt和自身有ppt情况，自身不能视为E，被绘入主画布时注意特殊处理
    // 自身ppt需将ppt提炼出来，然后node重新忽略ppt

    var pm;

    if (isPpt) {
      pm = node.__perspectiveMatrix || node.__selfPerspectiveMatrix;
    }

    if (node.__selfPerspective) {
      var bbox = transformBbox(bboxTotal, multiply(pm, node.matrix), 0, 0);
      mergeBbox(bboxTotal, bbox);
    }

    var top = node;

    for (var i = index + 1, len = index + total + 1; i < len; i++) {
      var _structs$i = __structs[i],
          _node = _structs$i.node,
          _total = _structs$i.total,
          hasMask = _structs$i.hasMask,
          isText = _structs$i.isText;

      if (isText) {
        if (_node.__limitCache) {
          inject.warn('Bbox of Text(' + index + ')' + ' is oversize' + _node.offsetWidth + ', ' + _node.offsetHeight);
          return;
        }

        var _bbox2 = _node.bbox,
            _p = _node.__domParent,
            matrix$1 = _p.__matrixEvent;

        if (_bbox2[2] - _bbox2[0] && _bbox2[3] - _bbox2[1]) {
          if (!isE(matrix$1)) {
            _bbox2 = transformBbox(_bbox2, matrix$1, 0, 0);
          }

          mergeBbox(bboxTotal, _bbox2);
        }

        continue;
      }

      if (_node.__limitCache) {
        inject.warn('Bbox of ' + _node.tagName + '(' + index + ')' + ' is oversize' + _node.offsetWidth + ', ' + _node.offsetHeight);
        return;
      }

      var __computedStyle2 = _node.__computedStyle,
          __mask = _node.__mask; // 跳过display:none元素和它的所有子节点和mask，本身是mask除外

      if (__computedStyle2[DISPLAY$1] === 'none' || i !== index && __mask) {
        i += _total || 0;

        if (hasMask) {
          i += countMaskNum(__structs, i + 1, hasMask);
        }

        continue;
      }

      var __cache2 = _node.__cache;
      var p = _node.__domParent;
      _node.__opacity = __computedStyle2[OPACITY$1] * p.__opacity; // 由于wasm的存在，使用getter取，没有wasm时不影响，有时获取到wasm计算的节点结果，因为私有__matrix为空

      var m = _node.matrix;

      if (p !== top) {
        m = multiply(p.__matrixEvent, m);
      } // 只有webgl且ppt情况才有pm，直接子节点才考虑预乘


      if (pm && p === top) {
        m = multiply(pm, m);
      }

      assignMatrix(_node.__matrixEvent, m); // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正

      if (__computedStyle2[BACKFACE_VISIBILITY] === 'hidden') {
        var x = m[5] < 0 && m[10] < 0,
            y = m[0] < 0 && m[10] < 0;

        if (x || y) {
          i += _total || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          continue;
        }
      }

      var _bbox = void 0; // 子元素有cacheTotal优先使用


      var target = _node.__cacheTarget;

      if (target) {
        if (target !== __cache2) {
          i += _total || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }
        }

        _bbox = target.bbox;
      } else {
        _bbox = _node.bbox; // 不能用filterBbox，子元素继承根节点的，如果有filter会是cacheFilter的bbox
      }

      if (_bbox[2] - _bbox[0] && _bbox[3] - _bbox[1]) {
        // 老的不变，新的会各自重新生成，根据matrixEvent合并bboxTotal
        _bbox = transformBbox(_bbox, m, 0, 0);
        mergeBbox(bboxTotal, _bbox);
      }
    }

    if (bboxTotal[2] - bboxTotal[0] <= 0 || bboxTotal[3] - bboxTotal[1] <= 0) {
      return;
    }

    return bboxTotal;
  }

  function mergeBbox(bbox, t) {
    bbox[0] = Math.min(bbox[0], t[0]);
    bbox[1] = Math.min(bbox[1], t[1]);
    bbox[2] = Math.max(bbox[2], t[2]);
    bbox[3] = Math.max(bbox[3], t[3]);
  }
  /**
   * 生成局部根节点离屏缓存，超限时除外
   * cache是每个节点自身的缓存，且共享离屏canvas
   * cacheTotal是基础
   * cacheFilter基于total
   * cacheMask基于filter
   * cacheBlend基于mask
   */


  function genTotal(renderMode, ctx, root, node, index, lv, total, __structs, width, height) {
    var __cacheTotal = node.__cacheTotal;

    if (__cacheTotal && __cacheTotal.__available) {
      return __cacheTotal;
    }

    var x1 = node.__x1,
        y1 = node.__y1,
        __offsetWidth = node.__offsetWidth,
        __offsetHeight = node.__offsetHeight;
    var bboxTotal = genBboxTotal(node, __structs, index, total, lv, false);

    if (!bboxTotal) {
      return;
    } // img节点特殊对待，如果只包含图片内容本身，多个相同引用可复用图片


    if (node instanceof Img && node.__loadImg.onlyImg) {
      __cacheTotal = node.__cacheTotal = ImgCanvasCache.getInstance(renderMode, ctx, root.__uuid, bboxTotal, node.__loadImg, x1, y1);
      return __cacheTotal;
    } // 生成cacheTotal，获取偏移dx/dy，连带考虑overflow:hidden的情况，当hidden尺寸一致无效时可忽略
    // 否则用一个单独临时的离屏获取包含hidden的结果，再绘入total


    var w, h, dx, dy, dbx, dby, tx, ty;
    var overflow = node.__computedStyle[OVERFLOW],
        isOverflow;

    if ((x1 !== bboxTotal[0] || y1 !== bboxTotal[1] || __offsetWidth !== bboxTotal[2] - bboxTotal[0] || __offsetHeight !== bboxTotal[3] - bboxTotal[1]) && overflow === 'hidden') {
      // geom可能超限，不能直接用bbox
      bboxTotal = [x1, y1, x1 + __offsetWidth, y1 + __offsetHeight];
      w = __offsetWidth;
      h = __offsetHeight;
      dx = -x1;
      dy = -y1;
      dbx = 0;
      dby = 0;
      tx = 0;
      ty = 0;
      isOverflow = true;
      __cacheTotal = inject.getOffscreenCanvas(w, h, 'overflow', null);
    } else {
      w = bboxTotal[2] - bboxTotal[0];
      h = bboxTotal[3] - bboxTotal[1];
      __cacheTotal = node.__cacheTotal = CanvasCache.getInstance(renderMode, ctx, root.__uuid, bboxTotal, x1, y1, null);

      if (!__cacheTotal || !__cacheTotal.__enabled) {
        if (w || h) {
          inject.warn('CanvasCache of ' + node.tagName + '(' + index + ')' + ' is oversize: ' + w + ', ' + h);
        }

        return;
      }

      __cacheTotal.__available = true;
      dx = __cacheTotal.dx;
      dy = __cacheTotal.dy;
      dbx = __cacheTotal.dbx;
      dby = __cacheTotal.dby;
      tx = __cacheTotal.x;
      ty = __cacheTotal.y; // 离屏画布的坐标和尺寸信息存储

      root.__env = {
        x: __cacheTotal.x,
        y: __cacheTotal.y,
        width: __cacheTotal.page.width,
        height: __cacheTotal.page.height
      };
    }

    var ctxTotal = __cacheTotal.ctx;
    /**
     * 再次遍历每个节点，以局部根节点左上角为基准原点，将所有节点绘制上去
     * 每个子节点的opacity有父继承计算在上面循环已经做好了，直接获取
     * 但matrixEvent可能需要重算，因为原点不一定是根节点的原点，影响tfo
     * 另外每个节点的refreshLevel需要设置REPAINT
     * 这样cacheTotal取消时子节点需确保重新计算一次matrix/opacity/filter，保证下次和父元素继承正确
     */

    var matrixList = [];
    var parentMatrix = null;
    var lastMatrix = null;
    var lastLv = lv; // 和外面没cache的类似，mask生成hash记录

    var maskStartHash = [];
    var offscreenHash = [];

    for (var i = index, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i2 = __structs[i],
          _node2 = _structs$i2.node,
          _lv = _structs$i2.lv,
          _total2 = _structs$i2.total,
          hasMask = _structs$i2.hasMask,
          isText = _structs$i2.isText; // 排除Text

      if (isText) {
        _node2.render(renderMode, ctxTotal, dx, dy);

        var oh = offscreenHash[i];

        if (oh) {
          ctxTotal = applyOffscreen(ctxTotal, oh, width, height, false);
        }
      } else {
        var __computedStyle = _node2.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

        if (__computedStyle[DISPLAY$1] === 'none') {
          i += _total2 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          var _oh = offscreenHash[i];

          if (_oh) {
            ctxTotal = applyOffscreen(ctxTotal, _oh, width, height, true);
          }

          continue;
        }

        var visibility = __computedStyle[VISIBILITY$1];
        var mh = maskStartHash[i];

        if (mh) {
          var idx = mh.idx,
              _hasMask = mh.hasMask,
              offscreenMask = mh.offscreenMask;

          var _target = inject.getOffscreenCanvas(width, height, null, 'mask2');

          offscreenMask.mask = _target; // 应用mask用到

          offscreenMask.isClip = _node2.__clip; // 定位到最后一个mask元素上的末尾

          var j = i + (_total2 || 0) + 1;

          while (--_hasMask) {
            var _total3 = __structs[j].total;
            j += (_total3 || 0) + 1;
          }

          j--;
          var list = offscreenHash[j] = offscreenHash[j] || [];
          list.push({
            idx: idx,
            lv: _lv,
            type: OFFSCREEN_MASK,
            offscreen: offscreenMask
          });
          list.push({
            idx: j,
            lv: _lv,
            type: OFFSCREEN_MASK2,
            offscreen: {
              ctx: ctxTotal,
              // 保存等待OFFSCREEN_MASK2时还原
              target: _target
            }
          });
          ctxTotal = _target.ctx;
        } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


        if (i === index) ; else if (_lv > lastLv) {
          parentMatrix = lastMatrix;

          if (isE(parentMatrix)) {
            parentMatrix = null;
          }

          matrixList.push(parentMatrix);
        } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
        else if (_lv < lastLv) {
          var diff = lastLv - _lv;
          matrixList.splice(-diff);
          parentMatrix = matrixList[_lv - 1];
        } // 不变是同级兄弟，无需特殊处理 else {}


        lastLv = _lv; // wasm取transform不同的方式

        var transform = void 0,
            tfo = void 0,
            wn = _node2.__wasmNode;

        if (wn) {
          transform = new Float64Array(wasm$1.instance.memory.buffer, wn.transform_ptr(), 16);
          var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
          tfo = [cs[16], cs[17]];
        } else {
          transform = __computedStyle[TRANSFORM$1];
          tfo = __computedStyle[TRANSFORM_ORIGIN];
        } // 特殊渲染的matrix，局部根节点为原点考虑，当需要计算时（不为E）再计算


        var m = void 0;

        if (i !== index && (!isE(parentMatrix) || !isE(transform))) {
          m = transform$1.calMatrixByOrigin(transform, tfo[0] + dbx + _node2.__x1 - x1 + tx, tfo[1] + dby + _node2.__y1 - y1 + ty);

          if (!isE(parentMatrix)) {
            m = multiply(parentMatrix, m);
          }
        }

        lastMatrix = m; // 子元素有cacheTotal优先使用

        var target = i > index && _node2.__cacheTarget;

        if (target === _node2.__cache) {
          target = null;
        }

        if (target) {
          i += _total2 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          var opacity = ctxTotal.globalAlpha = _node2.__opacity;

          if (opacity > 0) {
            if (m) {
              ctxTotal.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            } else {
              ctxTotal.setTransform(1, 0, 0, 1, 0, 0);
            }

            var mixBlendMode = __computedStyle[MIX_BLEND_MODE$1];

            if (mixBlendMode !== 'normal') {
              ctxTotal.globalCompositeOperation = mbmName(mixBlendMode);
            }

            CanvasCache.drawCache(target, __cacheTotal);
            ctxTotal.globalCompositeOperation = 'source-over';
          }

          var _oh2 = offscreenHash[i];

          if (_oh2) {
            ctxTotal = applyOffscreen(ctxTotal, _oh2, width, height, false);
          }
        } else {
          var offscreenBlend = void 0,
              _offscreenMask = void 0,
              offscreenFilter = void 0,
              offscreenOverflow = void 0;

          var _offscreen = i > index && _node2.__calOffscreen(ctxTotal, __computedStyle);

          if (_offscreen) {
            ctxTotal = _offscreen.ctx;
            offscreenBlend = _offscreen.offscreenBlend;
            _offscreenMask = _offscreen.offscreenMask;
            offscreenFilter = _offscreen.offscreenFilter;
            offscreenOverflow = _offscreen.offscreenOverflow;
          }

          if (visibility === 'visible') {
            var _opacity = ctxTotal.globalAlpha = _node2.__opacity;

            if (_opacity > 0) {
              if (m) {
                ctxTotal.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
              } else {
                ctxTotal.setTransform(1, 0, 0, 1, 0, 0);
              }

              _node2.render(renderMode, ctxTotal, dx, dy);
            }
          } // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


          if (offscreenBlend) {
            var _j = i + (_total2 || 0);

            if (hasMask) {
              _j += countMaskNum(__structs, _j + 1, hasMask);
            }

            var _list = offscreenHash[_j] = offscreenHash[_j] || [];

            _list.push({
              idx: i,
              lv: _lv,
              type: OFFSCREEN_BLEND,
              offscreen: offscreenBlend
            });
          } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
          // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


          if (_offscreenMask) {
            var _j2 = i + (_total2 || 0);

            maskStartHash[_j2 + 1] = {
              idx: i,
              hasMask: hasMask,
              offscreenMask: _offscreenMask
            };
          } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


          if (offscreenFilter) {
            var _j3 = i + (_total2 || 0);

            if (hasMask) {
              _j3 += countMaskNum(__structs, _j3 + 1, hasMask);
            }

            var _list2 = offscreenHash[_j3] = offscreenHash[_j3] || [];

            _list2.push({
              idx: i,
              lv: _lv,
              type: OFFSCREEN_FILTER,
              offscreen: offscreenFilter
            });
          } // overflow:hidden的离屏，最后孩子进行截取


          if (offscreenOverflow) {
            var _j4 = i + (_total2 || 0);

            if (hasMask) {
              _j4 += countMaskNum(__structs, _j4 + 1, hasMask);
            }

            var _list3 = offscreenHash[_j4] = offscreenHash[_j4] || [];

            _list3.push({
              idx: i,
              lv: _lv,
              type: OFFSCREEN_OVERFLOW,
              offscreen: offscreenOverflow
            });
          } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
          // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


          var _oh3 = offscreenHash[i];

          if (_oh3) {
            ctxTotal = applyOffscreen(ctxTotal, _oh3, width, height, false);
          }
        }
      }
    } // overflow写回整体离屏


    if (isOverflow) {
      var t = node.__cacheTotal = CanvasCache.getInstance(renderMode, ctx, root.__uuid, bboxTotal, x1, y1, null);
      t.__available = true;
      t.ctx.drawImage(__cacheTotal.canvas, t.x, t.y);

      __cacheTotal.release();

      __cacheTotal = t;
    }

    root.__env = null;
    return __cacheTotal;
  } // 从cacheTotal生成overflow、filter和mask，一定有cacheTotal才会进


  function genTotalOther(renderMode, __structs, __cacheTotal, node, hasMask, width, height) {
    var __computedStyle = node.__computedStyle,
        __cacheFilter = node.__cacheFilter,
        __cacheMask = node.__cacheMask;
    var filter = __computedStyle[FILTER];
    var target = __cacheTotal,
        needGen;

    if (filter && filter.length) {
      if (!__cacheFilter || !__cacheFilter.__available || needGen) {
        target = node.__cacheFilter = CanvasCache.genFilter(target, filter);
        needGen = true;
      }
    }

    if (hasMask && (!__cacheMask || !__cacheMask.__available || needGen)) {
      target = node.__cacheMask = CanvasCache.genMask(target, node, function (item, cacheMask, inverse) {
        // 和外面没cache的类似，mask生成hash记录，这里mask节点一定是个普通无cache的独立节点
        var maskStartHash = {};
        var offscreenHash = {};
        var dx = cacheMask.dx,
            dy = cacheMask.dy,
            dbx = cacheMask.dbx,
            dby = cacheMask.dby,
            tx = cacheMask.x,
            ty = cacheMask.y,
            ctx = cacheMask.ctx,
            x1 = cacheMask.x1,
            y1 = cacheMask.y1;
        var struct = item.__struct,
            root = item.__root,
            structs = root.__structs;
        var index = structs.indexOf(struct);
        var total = struct.total,
            lv = struct.lv;
        var matrixList = [];
        var parentMatrix = null;
        var lastMatrix = null;
        var opacityList = [];
        var parentOpacity = 1;
        var lastOpacity = 1;
        var lastLv = lv;

        for (var i = index, len = index + (total || 0) + 1; i < len; i++) {
          var _structs$i3 = __structs[i],
              _node3 = _structs$i3.node,
              _lv2 = _structs$i3.lv,
              _total4 = _structs$i3.total,
              _hasMask2 = _structs$i3.hasMask,
              isText = _structs$i3.isText; // 排除Text

          if (isText) {
            _node3.render(renderMode, ctx, dx, dy);

            if (offscreenHash.hasOwnProperty(i)) {
              ctx = applyOffscreen(ctx, offscreenHash[i], width, height, false);
            }
          } else {
            var _computedStyle = _node3.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

            if (_computedStyle[DISPLAY$1] === 'none') {
              i += _total4 || 0;

              if (_hasMask2) {
                i += countMaskNum(__structs, i + 1, _hasMask2);
              }

              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], width, height, true);
              }

              continue;
            }

            if (maskStartHash.hasOwnProperty(i)) {
              var _maskStartHash$i = maskStartHash[i],
                  idx = _maskStartHash$i.idx,
                  _hasMask3 = _maskStartHash$i.hasMask,
                  offscreenMask = _maskStartHash$i.offscreenMask;

              var _target3 = inject.getOffscreenCanvas(width, height, null, 'mask2');

              offscreenMask.mask = _target3; // 应用mask用到

              offscreenMask.isClip = _node3.__clip; // 定位到最后一个mask元素上的末尾

              var j = i + (_total4 || 0) + 1;

              while (--_hasMask3) {
                var _total5 = __structs[j].total;
                j += (_total5 || 0) + 1;
              }

              j--;
              var list = offscreenHash[j] = offscreenHash[j] || [];
              list.push({
                idx: idx,
                lv: _lv2,
                type: OFFSCREEN_MASK,
                offscreen: offscreenMask
              });
              list.push({
                idx: j,
                lv: _lv2,
                type: OFFSCREEN_MASK2,
                offscreen: {
                  ctx: ctx,
                  // 保存等待OFFSCREEN_MASK2时还原
                  target: _target3
                }
              });
              ctx = _target3.ctx;
            } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


            if (i === index) ; else if (_lv2 > lastLv) {
              parentMatrix = lastMatrix;

              if (isE(parentMatrix)) {
                parentMatrix = null;
              }

              matrixList.push(parentMatrix);
              parentOpacity = lastOpacity;
              opacityList.push(parentOpacity);
            } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
            else if (_lv2 < lastLv) {
              var diff = lastLv - _lv2;
              matrixList.splice(-diff);
              parentMatrix = matrixList[_lv2 - 1];
              opacityList.splice(-diff);
              parentOpacity = opacityList[_lv2 - 1];
            } // 不变是同级兄弟，无需特殊处理 else {}


            lastLv = _lv2; // 计算临时的matrix，先以此节点为局部根节点原点，后面考虑逆矩阵

            var opacity = _computedStyle[OPACITY$1];
            var transform = void 0,
                tfo = void 0,
                wn = _node3.__wasmNode;

            if (wn) {
              transform = new Float64Array(wasm$1.instance.memory.buffer, wn.transform_ptr(), 16);
              var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
              tfo = [cs[16], cs[17]];
            } else {
              transform = _node3.__computedStyle[TRANSFORM$1];
              tfo = _node3.__computedStyle[TRANSFORM_ORIGIN];
            }

            if (i !== index) {
              opacity *= parentOpacity;
            }

            _node3.__opacity = lastOpacity = opacity; // 特殊渲染的matrix，局部根节点为原点且考虑根节点自身的transform

            var m = void 0;

            if (!isE(transform)) {
              m = transform$1.calMatrixByOrigin(transform, tfo[0] + dbx + _node3.__x1 - x1 + tx, tfo[1] + dby + _node3.__y1 - y1 + ty);

              if (!isE(parentMatrix)) {
                m = multiply(parentMatrix, m);
              }
            }

            lastMatrix = m;

            if (m) {
              // 很多情况mask和target相同matrix，可简化计算
              if (util.equalArr(m, inverse)) {
                m = matrix.identity();
              } else if (inverse) {
                inverse = matrix.inverse(inverse);
                m = matrix.multiply(inverse, m);
              }
            } else if (!isE(inverse)) {
              m = matrix.inverse(inverse);
            }

            m = m || matrix.identity();
            assignMatrix(_node3.__matrixEvent, m); // 特殊渲染的matrix，局部根节点为原点考虑，本节点需inverse反向

            var _target2 = _node3.__cacheTarget;

            if (_target2 === _node3.__cache) {
              _target2 = null;
            }

            if (_target2) {
              i += _total4 || 0;

              if (_hasMask2) {
                i += countMaskNum(__structs, i + 1, _hasMask2);
              }

              ctx.globalAlpha = opacity;
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
              var mixBlendMode = _computedStyle[MIX_BLEND_MODE$1];

              if (mixBlendMode !== 'normal') {
                ctx.globalCompositeOperation = mbmName(mixBlendMode);
              } else {
                ctx.globalCompositeOperation = 'source-over';
              }

              var _target4 = _target2,
                  x = _target4.x,
                  y = _target4.y,
                  canvas = _target4.canvas,
                  _width = _target4.width,
                  _height = _target4.height,
                  x2 = _target4.x1,
                  y2 = _target4.y1,
                  dbx2 = _target4.dbx,
                  dby2 = _target4.dby;
              var ox = tx + x2 - x1 + dbx - dbx2;
              var oy = ty + y2 - y1 + dby - dby2;
              ctx.drawImage(canvas, x, y, _width, _height, ox, oy, _width, _height);
              ctx.globalCompositeOperation = 'source-over';

              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], _width, _height, false);
              }
            } // 等于将外面bbox计算和渲染合一的过程，但不需要bbox本身的内容
            else {
              var offscreenBlend = void 0,
                  _offscreenMask2 = void 0,
                  offscreenFilter = void 0,
                  offscreenOverflow = void 0;

              var _offscreen2 = _node3.__calOffscreen(ctx, _computedStyle);

              if (_offscreen2) {
                ctx = _offscreen2.ctx;
                offscreenBlend = _offscreen2.offscreenBlend;
                _offscreenMask2 = _offscreen2.offscreenMask;
                offscreenFilter = _offscreen2.offscreenFilter;
                offscreenOverflow = _offscreen2.offscreenOverflow;
              }

              ctx.globalAlpha = opacity;
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

              _node3.render(renderMode, ctx, dx, dy); // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


              if (offscreenBlend) {
                var _j5 = i + (_total4 || 0);

                if (_hasMask2) {
                  _j5 += countMaskNum(__structs, _j5 + 1, _hasMask2);
                }

                var _list4 = offscreenHash[_j5] = offscreenHash[_j5] || [];

                _list4.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_BLEND,
                  offscreen: offscreenBlend
                });
              } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
              // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


              if (_offscreenMask2) {
                var _j6 = i + (_total4 || 0);

                maskStartHash[_j6 + 1] = {
                  idx: i,
                  hasMask: _hasMask2,
                  offscreenMask: _offscreenMask2
                };
              } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


              if (offscreenFilter) {
                var _j7 = i + (_total4 || 0);

                if (_hasMask2) {
                  _j7 += countMaskNum(__structs, _j7 + 1, _hasMask2);
                }

                var _list5 = offscreenHash[_j7] = offscreenHash[_j7] || [];

                _list5.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_FILTER,
                  offscreen: offscreenFilter
                });
              } // overflow:hidden的离屏，最后孩子进行截取


              if (offscreenOverflow) {
                var _j8 = i + (_total4 || 0);

                if (_hasMask2) {
                  _j8 += countMaskNum(__structs, _j8 + 1, _hasMask2);
                }

                var _list6 = offscreenHash[_j8] = offscreenHash[_j8] || [];

                _list6.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_OVERFLOW,
                  offscreen: offscreenOverflow
                });
              } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
              // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], width, height);
              }
            }
          }
        }
      });
    }

    return target;
  }
  /**
   * canvas/webgl支持任意节点为mask，不像svg仅单节点
   * hasMask的num是指遮罩对象后面的兄弟节点数，需要换算成包含子节点的总数
   * @param __structs
   * @param start
   * @param hasMask
   */


  function countMaskNum(__structs, start, hasMask) {
    var count = 0;

    while (hasMask--) {
      var total = __structs[start].total;
      count += total || 0;
      start += total || 0; // total不算自身，所以还得+1

      count++;
      start++;
    }

    return count;
  } // webgl不太一样，使用fbo离屏绘制到一个纹理上进行汇总


  function genFrameBufferWithTexture(gl, texture, width, height) {
    var frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // let check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    // if(check !== gl.FRAMEBUFFER_COMPLETE) {
    //   inject.error('Framebuffer object is incomplete: ' + check.toString());
    // }
    // 离屏窗口0开始

    gl.viewport(0, 0, width, height); // gl.clearColor(0, 0, 0, 0);
    // gl.clear(gl.COLOR_BUFFER_BIT);

    return frameBuffer;
  }
  /**
   * 局部根节点复合图层生成，汇总所有子节点到一颗局部树上的位图缓存，包含超限特殊情况
   * 即便只有自己一个也要返回，因为webgl生成total的原因是有类似filter/mask等必须离屏处理的东西
   * 传入isPpt的时候，说明是有perspective的节点在前置分割处理完毕之后，进行的渲染，需预乘pm透视矩阵
   * 传入pptNode/oitHash的时候，说明是透视节点下某个preserve3d的子节点，其渲染需要考虑其子节点平面拆分，预处理
   */


  function genTotalWebgl(renderMode, __cacheTotal, gl, root, node, index, lv, total, __structs, W, H, isPpt, pptNode, oitHash) {
    if (__cacheTotal && __cacheTotal.__available) {
      return __cacheTotal;
    }

    var top = node;
    var x1 = node.__x1,
        y1 = node.__y1,
        __offsetWidth = node.__offsetWidth,
        __offsetHeight = node.__offsetHeight;
    var bboxTotal = genBboxTotal(node, __structs, index, total, lv, isPpt);

    if (!bboxTotal) {
      return;
    } // overflow:hidden和canvas一样特殊考虑


    var w, h, dx, dy, cx, cy, texture, frameBuffer;
    var overflow = node.__computedStyle[OVERFLOW];

    if (overflow === 'hidden' && (x1 !== bboxTotal[0] || y1 !== bboxTotal[1] || __offsetWidth !== bboxTotal[2] - bboxTotal[0] || __offsetHeight !== bboxTotal[3] - bboxTotal[1])) {
      // geom可能超限，不能直接用bbox
      bboxTotal = [x1, y1, x1 + __offsetWidth, y1 + __offsetHeight];
      w = __offsetWidth;
      h = __offsetHeight;
    } else {
      w = bboxTotal[2] - bboxTotal[0];
      h = bboxTotal[3] - bboxTotal[1];
    }

    if (__cacheTotal) {
      __cacheTotal.reset(bboxTotal, x1, y1);
    } else {
      __cacheTotal = TextureCache.getInstance(renderMode, gl, root.__uuid, bboxTotal, x1, y1, null);
    }

    if (!__cacheTotal || !__cacheTotal.__enabled) {
      if (w || h) {
        inject.warn('TextureCache of ' + node.tagName + '(' + index + ')' + ' is oversize: ' + w + ', ' + h);
      }

      return;
    }

    __cacheTotal.__available = true;
    node.__cacheTotal = __cacheTotal;
    cx = w * 0.5;
    cy = h * 0.5;
    dx = -bboxTotal[0];
    dy = -bboxTotal[1]; // 需要重新计算，因为bbox里是原本位置，这里是新的位置

    var pm, ppt;

    if (isPpt) {
      if (pptNode.__perspectiveMatrix) {
        var _pptNode$__computedSt = pptNode.__computedStyle,
            perspective = _pptNode$__computedSt[PERSPECTIVE],
            perspectiveOrigin = _pptNode$__computedSt[PERSPECTIVE_ORIGIN];
        pm = transform$1.calPerspectiveMatrix(perspective, x1 + dx + perspectiveOrigin[0], y1 + dy + perspectiveOrigin[1]);
      } else {
        var _perspectiveOrigin,
            wn = pptNode.__wasmNode;

        if (wn) {
          var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
          _perspectiveOrigin = [cs[16], cs[17]];
        } else {
          _perspectiveOrigin = pptNode.__computedStyle[TRANSFORM_ORIGIN];
        }

        pm = transform$1.calPerspectiveMatrix(pptNode.__selfPerspective, x1 + dx + _perspectiveOrigin[0], y1 + dy + _perspectiveOrigin[1]);
      }
    }

    if (oitHash) {
      if (pptNode.__perspectiveMatrix) {
        var _perspective = pptNode.__computedStyle[PERSPECTIVE];
        ppt = _perspective;
      } else {
        ppt = pptNode.__selfPerspective;
      }
    }

    var page = __cacheTotal.__page,
        size = page.__size; // 先绘制到一张单独的纹理，防止children中和cacheTotal重复texture不能绘制

    texture = createTexture(gl, null, 0, w, h);
    frameBuffer = genFrameBufferWithTexture(gl, texture, w, h);
    gl.viewport(0, 0, w, h); // 离屏画布的原点和尺寸信息存储

    root.__env = {
      x: dx,
      y: dy,
      width: w,
      height: h,
      node: node
    }; // fbo绘制对象纹理不用绑定单元，剩下的纹理绘制用0号

    var lastPage,
        list = [];
    var cacheTotal = __cacheTotal;

    for (var i = index, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i4 = __structs[i],
          _node4 = _structs$i4.node,
          _total6 = _structs$i4.total,
          hasMask = _structs$i4.hasMask,
          isText = _structs$i4.isText; // 先看text，visibility会在内部判断，display会被parent判断

      if (isText) {
        var __cache = _node4.__cache;

        if (__cache && __cache.__available) {
          var _node4$__domParent = _node4.__domParent,
              __opacity = _node4$__domParent.__opacity,
              matrixEvent = _node4$__domParent.matrixEvent;
          var p = __cache.__page;

          if (lastPage && lastPage !== p) {
            drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
          }

          lastPage = p;
          list.push({
            cache: __cache,
            opacity: __opacity,
            matrix: matrixEvent
          });
        }
      } // 再看total缓存/cache，都没有的是无内容的Xom节点
      else {
        var __computedStyle = _node4.__computedStyle;

        if (i > index) {
          if (__computedStyle[DISPLAY$1] === 'none' || _node4.__mask) {
            i += _total6 || 0;

            if (hasMask) {
              i += countMaskNum(__structs, i + 1, hasMask);
            }

            continue;
          }
        }

        var visibility = __computedStyle[VISIBILITY$1],
            mixBlendMode = __computedStyle[MIX_BLEND_MODE$1],
            backfaceVisibility = __computedStyle[BACKFACE_VISIBILITY];

        if (visibility === 'hidden' && !_total6) {
          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          continue;
        }

        var _p2 = _node4.__domParent,
            ppt2 = _node4.__selfPerspective,
            opacity = _node4.__opacity; // 特殊渲染的matrix，局部根节点为原点考虑，和bbox以节点自身主画布参考系不同

        var m = void 0;

        if (i > index) {
          // wasm取transform不同的方式
          var transform = void 0,
              tfo = void 0,
              _wn = _node4.__wasmNode;

          if (_wn) {
            transform = new Float64Array(wasm$1.instance.memory.buffer, _wn.transform_ptr(), 16);

            var _cs = new Float64Array(wasm$1.instance.memory.buffer, _wn.computed_style_ptr(), 18);

            tfo = [_cs[16], _cs[17]];
          } else {
            transform = __computedStyle[TRANSFORM$1];
            tfo = __computedStyle[TRANSFORM_ORIGIN];
          }

          if (!isE(transform)) {
            m = transform$1.calMatrixByOrigin(transform, tfo[0] + _node4.__x1 + dx, tfo[1] + _node4.__y1 + dy);
          }

          if (ppt2) {
            var t = transform$1.calPerspectiveMatrix(ppt2, tfo[0] + _node4.__x1 + dx, tfo[1] + _node4.__y1 + dy);
            m = multiply(t, m);
          }

          if (_p2 !== top) {
            m = multiply(_p2.__matrixEvent, m);
          } // 有透视还得预乘透视
          else if (pm) {
            m = multiply(pm, m);
          }

          assignMatrix(_node4.__matrixEvent, m); // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正

          if (backfaceVisibility === 'hidden') {
            var _m = _node4.matrix,
                x = _m[5] < 0 && _m[10] < 0,
                y = _m[0] < 0 && _m[10] < 0;

            if (x || y) {
              i += _total6 || 0;

              if (hasMask) {
                i += countMaskNum(__structs, i + 1, hasMask);
              }

              continue;
            }
          }
        } // 有oit平面拆分的优先考虑，其一定没有mbm；否则走普通渲染逻辑


        var _oit = oitHash && oitHash[i];

        if (_oit) {
          drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
          lastPage = null; // 只求子节点的matrix即可

          for (var j = i + 1, _len = i + (_total6 || 0) + 1; j < _len; j++) {
            var _structs$j = __structs[j],
                _node5 = _structs$j.node,
                _total7 = _structs$j.total,
                _hasMask4 = _structs$j.hasMask,
                _isText = _structs$j.isText;

            if (!_isText) {
              var _computedStyle2 = _node5.__computedStyle;

              if (_computedStyle2[DISPLAY$1] === 'none' || _node5.__mask) {
                j += _total7 || 0;

                if (_hasMask4) {
                  j += countMaskNum(__structs, j + 1, _hasMask4);
                }

                continue;
              }

              var _visibility = _computedStyle2[VISIBILITY$1],
                  _backfaceVisibility = _computedStyle2[BACKFACE_VISIBILITY];

              if (_visibility === 'hidden' && !_total7) {
                if (_hasMask4) {
                  j += countMaskNum(__structs, j + 1, _hasMask4);
                }

                continue;
              }

              var _p3 = _node5.__domParent;

              var _transform = void 0,
                  _tfo = void 0,
                  _wn2 = _node5.__wasmNode;

              if (_wn2) {
                _transform = new Float64Array(wasm$1.instance.memory.buffer, _wn2.transform_ptr(), 16);

                var _cs2 = new Float64Array(wasm$1.instance.memory.buffer, _wn2.computed_style_ptr(), 18);

                _tfo = [_cs2[16], _cs2[17]];
              } else {
                _transform = _computedStyle2[TRANSFORM$1];
                _tfo = _computedStyle2[TRANSFORM_ORIGIN];
              }

              var _m2 = void 0;

              if (!isE(_transform)) {
                _m2 = transform$1.calMatrixByOrigin(_transform, _tfo[0] + _node5.__x1 + dx, _tfo[1] + _node5.__y1 + dy);
              }

              if (_p3 !== top) {
                _m2 = multiply(_p3.__matrixEvent, _m2);
              } // 有透视还得预乘透视
              else if (pm) {
                _m2 = multiply(pm, _m2);
              }

              assignMatrix(_node5.__matrixEvent, _m2); // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正

              if (_backfaceVisibility === 'hidden') {
                var _m3 = _node5.matrix,
                    _x = _m3[5] < 0 && _m3[10] < 0,
                    _y = _m3[0] < 0 && _m3[10] < 0;

                if (_x || _y) {
                  i += _total7 || 0;

                  if (_hasMask4) {
                    i += countMaskNum(__structs, i + 1, _hasMask4);
                  }

                  continue;
                }
              }

              var target = _node5.__cacheTarget;

              if (target === _node5.__cache) {
                target = null;
              }

              if (target) {
                j += _total7 || 0;

                if (_hasMask4) {
                  j += countMaskNum(__structs, j + 1, _hasMask4);
                }
              }
            }
          }

          webgl.drawOitPlane(gl, __structs, _oit, ppt, cx, cy, dx, dy);
          i += _total6 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          var render = _node4.render;

          if (render !== DOM_RENDER && render !== IMG_RENDER && render !== GEOM_RENDER) {
            drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
            lastPage = null;

            _node4.render(renderMode, gl, dx, dy);

            gl.useProgram(gl.program);
          }
        } else {
          var _cache = _node4.__cache;

          var _target5 = i > index ? _node4.__cacheTarget : _cache;

          if (_target5) {
            if (opacity > 0) {
              // 局部的mbm和主画布一样，先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
              if (i > index && mixBlendMode !== 'normal') {
                if (list.length) {
                  drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
                }

                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                var res = genMbmWebgl(gl, texture, _target5, mixBlendMode, _node4.__opacity, m, dx, dy, cx, cy, size, size);

                if (res) {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
                  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                  gl.deleteFramebuffer(frameBuffer);
                  gl.deleteTexture(texture);
                  texture = res.texture;
                  frameBuffer = res.frameBuffer;
                  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                }

                lastPage = null;
              } else {
                var _p4 = _target5.__page;

                if (lastPage && lastPage !== _p4) {
                  drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
                }

                lastPage = _p4;
                list.push({
                  cache: _target5,
                  opacity: _node4.__opacity,
                  matrix: m
                });
              }
            }

            if (_target5 !== _cache) {
              i += _total6 || 0;

              if (hasMask) {
                i += countMaskNum(__structs, i + 1, hasMask);
              }
            }
          } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


          if ((!_target5 || _target5 === _cache) && opacity > 0) {
            var _render = _node4.render;

            if (_render !== DOM_RENDER && _render !== IMG_RENDER && _render !== GEOM_RENDER) {
              drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
              lastPage = null;

              _node4.render(renderMode, gl, dx, dy);

              gl.useProgram(gl.program);
            }
          }
        }
      }
    } // 删除fbo恢复


    drawTextureCache(gl, list, cx, cy, dx, dy, null, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); // 汇入集合

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, page.texture, 0);
    gl.viewport(0, 0, size, size);
    drawTex2Cache(gl, gl.program, cacheTotal, texture, w, h);
    gl.deleteTexture(texture);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.viewport(0, 0, W, H);
    root.__env = null;
    return __cacheTotal;
  }

  function genPptWebgl(renderMode, __cacheTotal, gl, root, node, index, lv, total, __structs, W, H) {
    if (__cacheTotal && __cacheTotal.__available) {
      return __cacheTotal;
    }

    var top = node;
    var mergeHash = [],
        mergeList = [];
    var isFlat = top.__computedStyle[TRANSFORM_STYLE] === 'flat',
        isTopFlat = isFlat; // 将产生transformStyle变化的节点记下来，直接子节点如果是flat也记下来，这样除了根节点下一直preserve3d的其它都被记录

    for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i5 = __structs[i],
          _lv3 = _structs$i5.lv,
          _node6 = _structs$i5.node,
          _total8 = _structs$i5.total,
          hasMask = _structs$i5.hasMask,
          isText = _structs$i5.isText;

      if (isText) {
        var mh = mergeHash[i];

        if (mh) {
          isFlat = mh.isFlat;
        }
      } else {
        var __computedStyle = _node6.__computedStyle;

        if (__computedStyle[DISPLAY$1] === 'none' || _node6.__mask) {
          i += _total8 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          var _mh2 = mergeHash[i];

          if (_mh2) {
            isFlat = _mh2.isFlat;
          }

          continue;
        }

        var visibility = __computedStyle[VISIBILITY$1],
            transformStyle = __computedStyle[TRANSFORM_STYLE];

        if (visibility === 'hidden' && !_total8) {
          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          var _mh3 = mergeHash[i];

          if (_mh3) {
            isFlat = _mh3.isFlat;
          }

          continue;
        }

        var p = _node6.__domParent;
        var target = _node6.__cacheTarget;

        if (target === _node6.__cache) {
          target = null;
        } // flat变化的局部子节点，或者flat根的直接子节点，生成局部根，已生成过的不用再生成


        if (_total8 && !target && (transformStyle !== p.__computedStyle[TRANSFORM_STYLE] || p === top && transformStyle === 'flat')) {
          var j = i + (_total8 || 0);

          if (hasMask) {
            j += countMaskNum(__structs, j + 1, hasMask);
          }

          mergeHash[j] = {
            isFlat: isFlat
          };
          isFlat = transformStyle === 'flat'; // 变化的则生成新的局部子节点汇总，记录flat情况

          mergeList.push({
            i: i,
            lv: _lv3,
            total: _total8,
            node: _node6,
            isFlat: isFlat
          });
        } // 子cache可以跳过，因为flat肯定先前执行


        if (target) {
          i += _total8 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }
        }

        var _mh = mergeHash[i];

        if (_mh) {
          isFlat = _mh.isFlat;
        }
      }
    } // 排序依旧是子节点先，但同层级不用倒序（没有mask影响）


    mergeList.sort(function (a, b) {
      if (a.lv === b.lv) {
        return a.i - b.i;
      }

      return b.lv - a.lv;
    }); // 根节点特殊处理，如果是flat就是flat但直接子节点后续渲染仍需要透视，如果是3d就要切分

    if (!isTopFlat) {
      mergeList.push({
        i: index,
        lv: lv,
        total: total,
        node: node,
        isFlat: isTopFlat
      });
    } // 变为preserve3d的子节点需要对其子节点进行平面拆分，记录这个子节点索引和拆分信息


    var oitHash = [];

    for (var _i = 0, _len2 = mergeList.length; _i < _len2; _i++) {
      var _mergeList$_i = mergeList[_i],
          _index = _mergeList$_i.i,
          _lv4 = _mergeList$_i.lv,
          _total9 = _mergeList$_i.total,
          _node7 = _mergeList$_i.node,
          _isFlat = _mergeList$_i.isFlat; // flat汇集临时cacheTotal

      if (_isFlat) {
        genTotalWebgl(renderMode, _node7.__cacheTotal, gl, root, _node7, _index, _lv4, _total9 || 0, __structs, W, H, null, top, oitHash);
      } // preserve3d需要以此节点为局部根E，所有子节点四边形面在3d空间下求交拆分，暂时不绘制，等上层flat调用绘制投影
      else {
        var _top = _node7,
            x0 = _node7.__x1,
            y0 = _node7.__y1,
            planeList = [];

        if (_node7.__hasContent) {
          var _target6 = _node7.__cacheTarget;
          var o = {
            index: _index,
            node: _node7,
            target: _target6,
            points: [{
              x: 0,
              y: 0,
              z: 0
            }, {
              x: _node7.__offsetWidth,
              y: 0,
              z: 0
            }, {
              x: _node7.__offsetWidth,
              y: _node7.__offsetHeight,
              z: 0
            }, {
              x: 0,
              y: _node7.__offsetHeight,
              z: 0
            }]
          };
          planeList.push(o);
        }

        for (var _i2 = _index + 1, _len3 = _index + (_total9 || 0) + 1; _i2 < _len3; _i2++) {
          var _structs$_i = __structs[_i2],
              _node8 = _structs$_i.node,
              _total10 = _structs$_i.total,
              _hasMask5 = _structs$_i.hasMask,
              _isText2 = _structs$_i.isText;

          if (_isText2) {
            var __cache = _node8.__cache;

            if (__cache && __cache.__available) {
              var __matrixEvent = _node8.__domParent.__matrixEvent;
              var x = __cache.x1,
                  y = __cache.y1,
                  width = __cache.__width,
                  height = __cache.__height;
              var xa = x - x0,
                  ya = y - y0;
              var xb = x + width - x0,
                  yb = y + height - y0;

              var _calRectPoint = calRectPoint(xa, ya, xb, yb, __matrixEvent),
                  x1 = _calRectPoint.x1,
                  y1 = _calRectPoint.y1,
                  z1 = _calRectPoint.z1,
                  x2 = _calRectPoint.x2,
                  y2 = _calRectPoint.y2,
                  z2 = _calRectPoint.z2,
                  x3 = _calRectPoint.x3,
                  y3 = _calRectPoint.y3,
                  z3 = _calRectPoint.z3,
                  x4 = _calRectPoint.x4,
                  y4 = _calRectPoint.y4,
                  z4 = _calRectPoint.z4;

              var _o = {
                index: _i2,
                node: _node8,
                target: __cache,
                points: [{
                  x: x1,
                  y: y1,
                  z: z1
                }, {
                  x: x2,
                  y: y2,
                  z: z2
                }, {
                  x: x3,
                  y: y3,
                  z: z3
                }, {
                  x: x4,
                  y: y4,
                  z: z4
                }]
              };
              planeList.push(_o);
            }
          } else {
            var _computedStyle3 = _node8.__computedStyle;

            if (_computedStyle3[DISPLAY$1] === 'none' || _node8.__mask) {
              _i2 += _total10 || 0;

              if (_hasMask5) {
                _i2 += countMaskNum(__structs, _i2 + 1, _hasMask5);
              }

              continue;
            }

            var _visibility2 = _computedStyle3[VISIBILITY$1],
                backfaceVisibility = _computedStyle3[BACKFACE_VISIBILITY];

            if (_visibility2 === 'hidden' && !_total10) {
              if (_hasMask5) {
                _i2 += countMaskNum(__structs, _i2 + 1, _hasMask5);
              }

              continue;
            } // wasm取transform不同的方式


            var transform = void 0,
                tfo = void 0,
                wn = _node8.__wasmNode;

            if (wn) {
              transform = new Float64Array(wasm$1.instance.memory.buffer, wn.transform_ptr(), 16);
              var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
              tfo = [cs[16], cs[17]];
            } else {
              transform = _computedStyle3[TRANSFORM$1];
              tfo = _computedStyle3[TRANSFORM_ORIGIN];
            }

            var _cache2 = _node8.__cache,
                _p5 = _node8.__domParent,
                ppt = _node8.__selfPerspective; // 当前局部根为原点坐标系下的matrix，只求交用

            var m = void 0;

            if (!isE(transform)) {
              m = transform$1.calMatrixByOrigin(transform, tfo[0] + _node8.__x1 - x0, tfo[1] + _node8.__y1 - y0);
            }

            if (ppt) {
              var t = transform$1.calPerspectiveMatrix(ppt, tfo[0] + _node8.__x1 - x0, tfo[1] + _node8.__y1 - y0);
              m = multiply(t, m);
            }

            if (_p5 !== _top) {
              m = multiply(_p5.__matrixEvent, m);
            }

            assignMatrix(_node8.__matrixEvent, m); // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正

            if (backfaceVisibility === 'hidden') {
              var _m4 = _node8.matrix,
                  _x2 = _m4[5] < 0 && _m4[10] < 0,
                  _y2 = _m4[0] < 0 && _m4[10] < 0;

              if (_x2 || _y2) {
                _i2 += _total10 || 0;

                if (_hasMask5) {
                  _i2 += countMaskNum(__structs, _i2 + 1, _hasMask5);
                }

                continue;
              }
            }

            var _target7 = _node8.__cacheTarget;

            if (_target7) {
              var _x3 = _target7.x1,
                  _y3 = _target7.y1,
                  _width2 = _target7.__width,
                  _height2 = _target7.__height; // 坐标计算还是以局部根为原点

              var _xa = _x3 - x0,
                  _ya = _y3 - y0;

              var _xb = _x3 + _width2 - x0,
                  _yb = _y3 + _height2 - y0;

              var _calRectPoint2 = calRectPoint(_xa, _ya, _xb, _yb, m),
                  _x4 = _calRectPoint2.x1,
                  _y4 = _calRectPoint2.y1,
                  _z = _calRectPoint2.z1,
                  _x5 = _calRectPoint2.x2,
                  _y5 = _calRectPoint2.y2,
                  _z2 = _calRectPoint2.z2,
                  _x6 = _calRectPoint2.x3,
                  _y6 = _calRectPoint2.y3,
                  _z3 = _calRectPoint2.z3,
                  _x7 = _calRectPoint2.x4,
                  _y7 = _calRectPoint2.y4,
                  _z4 = _calRectPoint2.z4;

              var _o2 = {
                index: _i2,
                node: _node8,
                target: _target7,
                points: [{
                  x: _x4,
                  y: _y4,
                  z: _z
                }, {
                  x: _x5,
                  y: _y5,
                  z: _z2
                }, {
                  x: _x6,
                  y: _y6,
                  z: _z3
                }, {
                  x: _x7,
                  y: _y7,
                  z: _z4
                }]
              };
              planeList.push(_o2);

              if (_target7 !== _cache2) {
                _i2 += _total10 || 0;

                if (_hasMask5) {
                  _i2 += countMaskNum(__structs, _i2 + 1, _hasMask5);
                }
              }
            }
          }
        } // 有2个以上面才会求相交


        if (planeList.length > 1) {
          oit.splitQuadrilateralPlane(planeList);
        } // 没拆分的直接存入，拆分的存有效拼图


        var list = [];

        for (var _i3 = 0, _len4 = planeList.length; _i3 < _len4; _i3++) {
          var plane = planeList[_i3];
          var puzzle = plane.puzzle;

          if (puzzle && puzzle.length) {
            for (var _i4 = 0, _len5 = puzzle.length; _i4 < _len5; _i4++) {
              var _p6 = puzzle[_i4];

              if (!_p6.isDeleted) {
                list.push(_p6);
              }
            }
          } else {
            list.push(plane);
          }
        } // 按z排序，远的先绘制


        oitHash[_index] = oit.sortPuzzleZ(list);
      }

      _node7.__updateCache();
    } // 最后一次循环绘制到局部根节点上，类似genTotalWebgl()逻辑，但要考虑ppt透视


    return genTotalWebgl(renderMode, __cacheTotal, gl, root, node, index, lv, total, __structs, W, H, true, node, oitHash);
  }

  function genFilterWebgl(renderMode, gl, node, cache, filter, W, H) {
    cache.x1;
        cache.y1;
        cache.width;
        cache.height;
        cache.bbox;
    var target = cache;
    filter.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (k === 'blur' && v > 0) {
        var res = genBlurWebgl(renderMode, gl, target, v);

        if (res) {
          if (target !== cache) {
            target.release();
          }

          target = res;
        }
      } else if (k === 'dropShadow') {
        var _res = genDropShadowWebgl(renderMode, gl, target, v);

        if (_res) {
          if (target !== cache) {
            target.release();
          }

          target = _res;
        }
      } else if (k === 'hueRotate') {
        var rotation = geom.d2r(v % 360);
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);

        var _res2 = genColorMatrixWebgl(renderMode, gl, target, [0.213 + cosR * 0.787 - sinR * 0.213, 0.715 - cosR * 0.715 - sinR * 0.715, 0.072 - cosR * 0.072 + sinR * 0.928, 0, 0, 0.213 - cosR * 0.213 + sinR * 0.143, 0.715 + cosR * 0.285 + sinR * 0.140, 0.072 - cosR * 0.072 - sinR * 0.283, 0, 0, 0.213 - cosR * 0.213 - sinR * 0.787, 0.715 - cosR * 0.715 + sinR * 0.715, 0.072 + cosR * 0.928 + sinR * 0.072, 0, 0, 0, 0, 0, 1, 0]);

        if (_res2) {
          if (target !== cache) {
            target.release();
          }

          target = _res2;
        }
      } else if (k === 'saturate' && v !== 100) {
        var amount = v * 0.01;

        var _res3 = genColorMatrixWebgl(renderMode, gl, target, [0.213 + 0.787 * amount, 0.715 - 0.715 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 + 0.285 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 - 0.715 * amount, 0.072 + 0.928 * amount, 0, 0, 0, 0, 0, 1, 0]);

        if (_res3) {
          if (target !== cache) {
            target.release();
          }

          target = _res3;
        }
      } else if (k === 'brightness' && v !== 100) {
        var b = v * 0.01;

        var _res4 = genColorMatrixWebgl(renderMode, gl, target, [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0]);

        if (_res4) {
          if (target !== cache) {
            target.release();
          }

          target = _res4;
        }
      } else if (k === 'grayscale' && v > 0) {
        v = Math.min(v, 100);
        var oneMinusAmount = 1 - v * 0.01;

        if (oneMinusAmount < 0) {
          oneMinusAmount = 0;
        } else if (oneMinusAmount > 1) {
          oneMinusAmount = 1;
        }

        var _res5 = genColorMatrixWebgl(renderMode, gl, target, [0.2126 + 0.7874 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 + 0.2848 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 + 0.9278 * oneMinusAmount, 0, 0, 0, 0, 0, 1, 0]);

        if (_res5) {
          if (target !== cache) {
            target.release();
          }

          target = _res5;
        }
      } else if (k === 'contrast' && v !== 100) {
        var _amount = v * 0.01;

        var o = -0.5 * _amount + 0.5;

        var _res6 = genColorMatrixWebgl(renderMode, gl, target, [_amount, 0, 0, 0, o, 0, _amount, 0, 0, o, 0, 0, _amount, 0, o, 0, 0, 0, 1, 0]);

        if (_res6) {
          if (target !== cache) {
            target.release();
          }

          target = _res6;
        }
      } else if (k === 'sepia' && v > 0) {
        v = Math.min(v, 100);

        var _oneMinusAmount = 1 - v * 0.01;

        if (_oneMinusAmount < 0) {
          _oneMinusAmount = 0;
        } else if (_oneMinusAmount > 1) {
          _oneMinusAmount = 1;
        }

        var _res7 = genColorMatrixWebgl(renderMode, gl, target, [0.393 + 0.607 * _oneMinusAmount, 0.769 - 0.769 * _oneMinusAmount, 0.189 - 0.189 * _oneMinusAmount, 0, 0, 0.349 - 0.349 * _oneMinusAmount, 0.686 + 0.314 * _oneMinusAmount, 0.168 - 0.168 * _oneMinusAmount, 0, 0, 0.272 - 0.272 * _oneMinusAmount, 0.534 - 0.534 * _oneMinusAmount, 0.131 + 0.869 * _oneMinusAmount, 0, 0, 0, 0, 0, 1, 0]);

        if (_res7) {
          if (target !== cache) {
            target.release();
          }

          target = _res7;
        }
      } else if (k === 'invert' && v > 0) {
        v = Math.min(v, 100);

        var _o3 = v * 0.01;

        var _amount2 = 1 - 2 * _o3;

        var _res8 = genColorMatrixWebgl(renderMode, gl, target, [_amount2, 0, 0, 0, _o3, 0, _amount2, 0, 0, _o3, 0, 0, _amount2, 0, _o3, 0, 0, 0, 1, 0]);

        if (_res8) {
          if (target !== cache) {
            target.release();
          }

          target = _res8;
        }
      }
    }); // 切换回主程序

    gl.useProgram(gl.program);
    gl.viewport(0, 0, W, H);
    return node.__cacheFilter = target;
  }

  function genBlurShader(gl, sigma, d) {
    var key = 'programBlur,' + sigma + ',' + d;

    if (gl.hasOwnProperty(key)) {
      return gl[key];
    }

    var weights = blur.gaussianWeight(sigma, d);
    var frag = '';
    var r = Math.floor(d * 0.5);

    for (var i = 0; i < r; i++) {
      var c = (r - i) * 0.01;
      frag += "gl_FragColor += texture2D(u_texture, v_texCoords + vec2(-".concat(c, ", -").concat(c, ") * u_direction) * ").concat(weights[i], ";\n      gl_FragColor += texture2D(u_texture, v_texCoords + vec2(").concat(c, ", ").concat(c, ") * u_direction) * ").concat(weights[i], ";\n");
    }

    frag += "gl_FragColor += texture2D(u_texture, v_texCoords) * ".concat(weights[r], ";");
    frag = fragmentBlur.replace('placeholder', frag);
    return gl[key] = webgl.initShaders(gl, vertexBlur, frag);
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核d扩大3倍性能慢
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * 先动态生成gl程序，默认3核源码示例已注释，根据sigma获得d（一定奇数），再计算权重
   * 然后将d尺寸和权重拼接成真正程序并编译成program，再开始绘制
   */


  function genBlurWebgl(renderMode, gl, cache, sigma) {
    var x1 = cache.x1,
        y1 = cache.y1,
        bbox = cache.bbox,
        width = cache.width,
        height = cache.height;
    var d = blur.kernelSize(sigma);
    var spread = blur.outerSizeByD(d); // 防止超限，webgl最大纹理尺寸限制

    if (width > Page.MAX + spread || height > Page.MAX + spread) {
      inject.warn('Filter blur is oversize');
      return;
    }

    var bboxNew = bbox.slice(0);
    bboxNew[0] -= spread;
    bboxNew[1] -= spread;
    bboxNew[2] += spread;
    bboxNew[3] += spread; // 写到一个tex中方便后续处理

    var w = width + spread * 2,
        h = height + spread * 2;
    var tex = createTexture(gl, null, 0, w, h);
    var frameBuffer = genFrameBufferWithTexture(gl, tex, w, h);
    drawCache2Tex(gl, gl.program, cache, w, h, spread); // 生成blur，同尺寸复用fbo

    var program = genBlurShader(gl, sigma, d);
    tex = webgl.drawBlur(gl, program, tex, w, h);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // 写回一个cache中

    var target = TextureCache.getInstance(renderMode, gl, cache.__rootId, bboxNew, x1, y1, null);
    target.__available = true;
    var page = target.__page,
        size = page.__size,
        texture = page.texture;
    frameBuffer = genFrameBufferWithTexture(gl, texture, size, size);
    drawTex2Cache(gl, gl.program, target, tex, w, h);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    return target;
  }

  function genColorMatrixWebgl(renderMode, gl, cache, m) {
    var x1 = cache.x1,
        y1 = cache.y1,
        bbox = cache.bbox;
    var target = TextureCache.getInstance(renderMode, gl, cache.__rootId, bbox.slice(0), x1, y1, cache.__page);
    target.__available = true;
    var page = target.__page,
        size = page.__size;
    var frameBuffer = genFrameBufferWithTexture(gl, target.__page.texture, size, size);
    webgl.drawCm(gl, gl.programCm, target, cache, m, size * 0.5, size); // 切回

    gl.useProgram(gl.program);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    return target;
  }

  function genMaskWebgl(renderMode, gl, root, node, cache, W, H, i, lv, __structs) {
    var x1 = cache.x1,
        y1 = cache.y1,
        width = cache.width,
        height = cache.height,
        bbox = cache.bbox,
        dbx = cache.dbx,
        dby = cache.dby;
    var bboxNew = bbox.slice(0); // 结果不能和源同page纹理，一定符合尺寸要求，不会比源大

    var __cacheMask = TextureCache.getInstance(renderMode, gl, root.__uuid, bboxNew, x1, y1, cache.__page);

    __cacheMask.__available = true;
    node.__cacheMask = __cacheMask; // 先求得被遮罩的matrix，用作inverse给mask计算，以被遮罩左上角为原点

    var transform,
        tfo,
        wn = node.__wasmNode;

    if (wn) {
      transform = new Float64Array(wasm$1.instance.memory.buffer, wn.transform_ptr(), 16);
      var cs = new Float64Array(wasm$1.instance.memory.buffer, wn.computed_style_ptr(), 18);
      tfo = [cs[16], cs[17]];
    } else {
      transform = node.__computedStyle[TRANSFORM$1];
      tfo = node.__computedStyle[TRANSFORM_ORIGIN];
    }

    var inverse;

    if (isE(transform)) {
      inverse = matrix.identity();
    } else {
      inverse = transform$1.calMatrixByOrigin(transform, tfo[0], tfo[1]);
    }

    inverse = matrix.inverse(inverse); // 将所有mask绘入一个单独纹理中，尺寸和原点与被遮罩相同

    gl.viewport(0, 0, width, height);
    var texture = createTexture(gl, null, 0, width, height);
    var cx = width * 0.5,
        cy = height * 0.5;
    var frameBuffer = genFrameBufferWithTexture(gl, texture, width, height);
    var next = node.next;
    var isClip = next.__clip;
    var lastPage,
        list = [];
    var dx = -x1 + dbx,
        dy = -y1 + dby;

    while (next && next.__mask && next.__clip === isClip) {
      var total = __structs[i].total || 0;
      var matrixList = [];
      var parentMatrix = void 0;
      var lastMatrix = void 0;
      var opacityList = [];
      var parentOpacity = 1;
      var lastOpacity = void 0;
      var lastLv = lv;
      var index = i;

      for (var len = i + (total || 0) + 1; i < len; i++) {
        var _structs$i6 = __structs[i],
            _node9 = _structs$i6.node,
            _lv5 = _structs$i6.lv,
            _total11 = _structs$i6.total,
            hasMask = _structs$i6.hasMask,
            isText = _structs$i6.isText;

        if (isText) {
          var __cache = _node9.__cache;

          if (__cache && __cache.__available) {
            var _node9$__domParent = _node9.__domParent,
                __matrixEvent = _node9$__domParent.__matrixEvent,
                __opacity = _node9$__domParent.__opacity;
            var p = __cache.__page;

            if (lastPage && lastPage !== p) {
              drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
            }

            lastPage = p;
            list.push({
              cache: __cache,
              opacity: __opacity,
              matrix: __matrixEvent
            });
          }
        } else {
          var __limitCache = _node9.__limitCache;
          var computedStyle = _node9.__computedStyle; // 跳过display:none元素和它的所有子节点和mask

          if (computedStyle[DISPLAY$1] === 'none' || __limitCache) {
            i += _total11 || 0;

            if (hasMask) {
              i += countMaskNum(__structs, i + 1, hasMask);
            }

            continue;
          }

          var opacity = computedStyle[OPACITY$1],
              visibility = computedStyle[VISIBILITY$1],
              backfaceVisibility = computedStyle[BACKFACE_VISIBILITY];

          if (visibility === 'hidden' && !_total11) {
            if (hasMask) {
              i += countMaskNum(__structs, i + 1, hasMask);
            }

            continue;
          }

          var _cache3 = _node9.__cache; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理

          if (i === index) ; else if (_lv5 > lastLv) {
            parentMatrix = lastMatrix;

            if (isE(parentMatrix)) {
              parentMatrix = null;
            }

            matrixList.push(parentMatrix);
            parentOpacity = lastOpacity;
            opacityList.push(parentOpacity);
          } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
          else if (_lv5 < lastLv) {
            var diff = lastLv - _lv5;
            matrixList.splice(-diff);
            parentMatrix = matrixList[_lv5 - 1];
            opacityList.splice(-diff);
            parentOpacity = opacityList[_lv5 - 1];
          } // 不变是同级兄弟，无需特殊处理 else {}


          lastLv = _lv5;

          var _transform2 = void 0,
              _tfo2 = void 0,
              _wn3 = _node9.__wasmNode;

          if (_wn3) {
            _transform2 = new Float64Array(wasm$1.instance.memory.buffer, _wn3.transform_ptr(), 16);

            var _cs3 = new Float64Array(wasm$1.instance.memory.buffer, _wn3.computed_style_ptr(), 18);

            _tfo2 = [_cs3[16], _cs3[17]];
          } else {
            _transform2 = computedStyle[TRANSFORM$1];
            _tfo2 = computedStyle[TRANSFORM_ORIGIN];
          } // 不考虑mbm


          var m = void 0;

          if (isE(_transform2)) {
            m = matrix.identity();
          } else {
            m = transform$1.calMatrixByOrigin(_transform2, _tfo2[0] + dbx + _node9.__x1 - x1, _tfo2[1] + dby + _node9.__y1 - y1);
          }

          if (!isE(parentMatrix)) {
            m = multiply(parentMatrix, m);
          }

          lastMatrix = m;
          lastOpacity = parentOpacity * opacity;
          var target = _node9.__cacheTarget;

          if (target && (target !== _cache3 || visibility === 'visible')) {
            m = matrix.multiply(inverse, m); // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正

            if (backfaceVisibility === 'hidden') {
              var _m5 = _node9.matrix,
                  x = _m5[5] < 0 && _m5[10] < 0,
                  y = _m5[0] < 0 && _m5[10] < 0;

              if (x || y) {
                i += _total11 || 0;

                if (hasMask) {
                  i += countMaskNum(__structs, i + 1, hasMask);
                }

                continue;
              }
            }

            var _p7 = target.__page;

            if (lastPage && lastPage !== _p7) {
              drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
            }

            lastPage = _p7;
            list.push({
              cache: target,
              opacity: lastOpacity,
              matrix: m
            });

            if (target !== _cache3) {
              i += _total11 || 0;

              if (hasMask) {
                i += countMaskNum(__structs, i + 1, hasMask);
              }
            }
          } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


          if (!target || target === _cache3) {
            var render = _node9.render;

            if (render !== DOM_RENDER && render !== IMG_RENDER && render !== GEOM_RENDER) {
              drawTextureCache(gl, list.splice(0), cx, cy, dx, dy, null, null);
              lastPage = null;

              _node9.render(renderMode, gl, dx, dy);

              gl.useProgram(gl.program);
            }
          }
        }
      }

      next = next.__next;
    } // 绘制到fbo的纹理对象上并删除fbo恢复


    drawTextureCache(gl, list, cx, cy, dx, dy, null, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    gl.bindTexture(gl.TEXTURE_2D, null);
    var program;

    if (isClip) {
      program = gl.programClip;
    } else {
      program = gl.programMask;
    }

    var page = __cacheMask.__page,
        size = page.size,
        tex = page.texture;
    frameBuffer = genFrameBufferWithTexture(gl, tex, size, size);
    webgl.drawMask(gl, program, __cacheMask, cache, texture, size * 0.5, size); // 切换回主程序

    gl.useProgram(gl.program);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    gl.viewport(0, 0, W, H);
    return __cacheMask;
  }
  /**
   * webgl的dropShadow只生成阴影部分，模糊复用blur，然后进行拼合
   * 复用blur时生成的模糊是临时的，和主程序模糊不一样，需区分
   */


  function genDropShadowWebgl(renderMode, gl, cache, v) {
    var x1 = cache.x1,
        y1 = cache.y1,
        bbox = cache.bbox,
        width = cache.width,
        height = cache.height; // 先根据x/y/color生成单色阴影

    var _v = _slicedToArray(v, 5),
        x = _v[0],
        y = _v[1],
        sigma = _v[2],
        color = _v[4];

    var d = blur.kernelSize(sigma);
    var spread = blur.outerSizeByD(d); // 防止超限，webgl最大纹理尺寸限制

    if (width > Page.MAX + spread || height > Page.MAX + spread) {
      inject.warn('Filter dropShadow is oversize');
      return;
    }

    var w = width + spread * 2,
        h = height + spread * 2;
    var tex1 = createTexture(gl, null, 0, w, h);
    var frameBuffer = genFrameBufferWithTexture(gl, tex1, w, h);
    gl.useProgram(gl.programDs);
    webgl.drawDropShadow(gl, gl.programDs, frameBuffer, cache, color, width, w, height, h); // 生成模糊的阴影

    if (sigma) {
      var program = genBlurShader(gl, sigma, d);
      tex1 = webgl.drawBlur(gl, program, tex1, w, h);
    }

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // cache绘制到一个单独的tex上

    var tex2 = createTexture(gl, null, 0, width, height);
    frameBuffer = genFrameBufferWithTexture(gl, tex2, width, height);
    drawCache2Tex(gl, gl.program, cache, width, height, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // 原图tex2和模糊阴影tex1合成

    var bboxNew = bbox.slice(0);
    bboxNew[0] += x;
    bboxNew[1] += y;
    bboxNew[2] += x;
    bboxNew[3] += y;
    bboxNew[0] -= spread;
    bboxNew[1] -= spread;
    bboxNew[2] += spread;
    bboxNew[3] += spread;
    var bboxMerge = bbox.slice(0);
    mergeBbox(bboxMerge, bboxNew);
    var target = TextureCache.getInstance(renderMode, gl, cache.__rootId, bboxMerge, x1, y1, null);
    target.__available = true;
    var page = target.__page,
        size = page.__size;
    frameBuffer = genFrameBufferWithTexture(gl, page.texture, size, size);
    var dx1 = bboxNew[0] - bboxMerge[0],
        dy1 = bboxNew[1] - bboxMerge[1];
    var dx2 = bbox[0] - bboxMerge[0],
        dy2 = bbox[1] - bboxMerge[1];
    webgl.drawDropShadowMerge(gl, target, size, tex1, dx1, dy1, w, h, tex2, dx2, dy2, width, height);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    bindTexture(gl, null, 0);
    gl.deleteTexture(tex1);
    gl.deleteTexture(tex2);
    return target;
  }
  /**
   * 生成blendMode混合fbo纹理结果，原本是所有元素向画布或一个fbo记A进行绘制，当出现mbm时，进入到这里，
   * 先生成一个新的fbo记B，之前的绘制都先到B上，再把后续元素绘制到一个同尺寸的fbo纹理上，
   * 两者进行mbm混合，返回到A上
   */


  function genMbmWebgl(gl, texture, cache, mbm, opacity, matrix, dx, dy, cx, cy, width, height) {
    // 后续绘制到同尺寸纹理上
    var tex = createTexture(gl, null, 0, width, height);
    var frameBuffer = genFrameBufferWithTexture(gl, tex, width, height);
    drawTextureCache(gl, [{
      cache: cache,
      opacity: opacity,
      matrix: matrix
    }], cx, cy, dx, dy, null, null);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // 获取对应的mbm程序

    var program;
    mbm = mbmName(mbm);

    if (mbm === 'multiply') {
      program = gl.programMbmMp;
    } else if (mbm === 'screen') {
      program = gl.programMbmSr;
    } else if (mbm === 'overlay') {
      program = gl.programMbmOl;
    } else if (mbm === 'darken') {
      program = gl.programMbmDk;
    } else if (mbm === 'lighten') {
      program = gl.programMbmLt;
    } else if (mbm === 'color-dodge') {
      program = gl.programMbmCd;
    } else if (mbm === 'color-burn') {
      program = gl.programMbmCb;
    } else if (mbm === 'hard-light') {
      program = gl.programMbmHl;
    } else if (mbm === 'soft-light') {
      program = gl.programMbmSl;
    } else if (mbm === 'difference') {
      program = gl.programMbmDf;
    } else if (mbm === 'exclusion') {
      program = gl.programMbmEx;
    } else if (mbm === 'hue') {
      program = gl.programMbmHue;
    } else if (mbm === 'saturation') {
      program = gl.programMbmSt;
    } else if (mbm === 'color') {
      program = gl.programMbmCl;
    } else if (mbm === 'luminosity') {
      program = gl.programMbmLm;
    }

    gl.useProgram(program); // 生成新的fbo，将混合结果绘入

    var resTex = createTexture(gl, null, 0, width, height);
    var resFrameBuffer = genFrameBufferWithTexture(gl, resTex, width, height);
    webgl.drawMbm(gl, program, texture, tex);
    gl.useProgram(gl.program);
    return {
      texture: resTex,
      frameBuffer: resFrameBuffer
    };
  }

  function renderSvg$1(renderMode, ctx, root, isFirst, rlv) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height; // mask节点很特殊，本身有matrix会影响，本身没改变但对象节点有改变也需要计算逆矩阵应用顶点

    var maskEffectHash = [];

    if (!isFirst) {
      // 先遍历一遍收集完全不变的defs，缓存起来id，随后再执行遍历渲染生成新的，避免掉重复的id
      for (var i = 0, len = __structs.length; i < len; i++) {
        var _structs$i7 = __structs[i],
            node = _structs$i7.node,
            total = _structs$i7.total,
            hasMask = _structs$i7.hasMask,
            isText = _structs$i7.isText;
        var __cacheDefs = node.__cacheDefs;
        var __refreshLevel = node.__refreshLevel; // 只要涉及到matrix和opacity就影响mask

        var hasEffectMask = hasMask && (__refreshLevel >= REPAINT$1 || __refreshLevel & (TRANSFORM_ALL$1 | OP$1));

        if (hasEffectMask) {
          var start = i + (total || 0) + 1;
          var end = start + hasMask; // mask索引遍历时处理，暂存遮罩对象的刷新lv

          maskEffectHash[end - 1] = __refreshLevel;
        } // >=REPAINT重绘生成走render()跳过这里


        if (__refreshLevel < REPAINT$1) {
          // 特殊的mask判断，遮罩对象影响这个mask了，除去filter、遮罩对象无TRANSFORM变化外都可缓存
          var mh = maskEffectHash[i];

          if (mh) {
            if (!(__refreshLevel & TRANSFORM_ALL$1) && mh < REPAINT$1 && !(mh & TRANSFORM_ALL$1)) {
              __cacheDefs.forEach(function (item) {
                ctx.addCache(item);
              });
            }
          } // 去除特殊的filter，普通节点或不影响的mask在<REPAINT下defs的其它都可缓存
          else if (!isText) {
            __cacheDefs.forEach(function (item) {
              ctx.addCache(item);
            });
          }
        }
      }
    }

    var maskHash = []; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var matrixList = [];
    var parentMatrix;
    var vdList = [];
    var parentVd;
    var lastLv = 0;
    var lastRefreshLv = 0;
    var lastNode;

    var _loop = function _loop(_i6, _len6) {
      var _structs$_i2 = __structs[_i6],
          node = _structs$_i2.node,
          lv = _structs$_i2.lv,
          total = _structs$_i2.total,
          hasMask = _structs$_i2.hasMask,
          isText = _structs$_i2.isText;

      var computedStyle = void 0,
          __refreshLevel = void 0,
          __cacheDefs = void 0,
          __cacheTotal = void 0;

      if (isText) {
        computedStyle = node.computedStyle;
        __refreshLevel = lastRefreshLv;
      } else {
        computedStyle = node.__computedStyle;
        __cacheDefs = node.__cacheDefs;
        __refreshLevel = node.__refreshLevel;
        __cacheTotal = node.__cacheTotal;
      }

      lastRefreshLv = __refreshLevel;
      node.__refreshLevel = NONE$1;
      var display = computedStyle[DISPLAY$1]; // 将随后的若干个mask节点范围存下来

      if (hasMask && display !== 'none') {
        var _start = _i6 + (total || 0) + 1;

        var _end = _start + hasMask; // svg限制了只能Geom单节点，不可能是Dom，所以end只有唯一


        maskHash[_end - 1] = {
          index: _i6,
          start: _start,
          end: _end,
          isClip: __structs[_start].node.__clip // 第一个节点是clip为准

        };
      } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点第一个特殊处理


      if (lv < lastLv) {
        var diff = lastLv - lv;
        matrixList.splice(-diff);
        parentMatrix = matrixList[lv - 1];
        vdList.splice(-diff);
        parentVd = vdList[lv - 1];
      } else if (lv > lastLv) {
        matrixList.push(parentMatrix = lastNode.__matrix);
        var vd = lastNode.__virtualDom;
        vdList.push(vd);
        parentVd = vd;
      }

      lastNode = node;
      lastLv = lv;
      var virtualDom = void 0; // svg小刷新等级时直接修改vd，这样Geom不再感知

      if (__refreshLevel < REPAINT$1 && !isText) {
        virtualDom = node.__virtualDom; // total可以跳过所有孩子节点省略循环

        if (__cacheTotal && __cacheTotal.__available) {
          _i6 += total || 0;
          virtualDom.cache = true;
        } else {
          __cacheTotal && (__cacheTotal.__available = true);
          virtualDom = node.__virtualDom = util.extend({}, virtualDom); // dom要清除children缓存，geom和img无需

          if (node instanceof Dom && !(node instanceof Img)) {
            virtualDom.children = [];
          } // 还得判断，和img加载混在一起时，触发刷新如果display:none，则还有cacheTotal


          if (display === 'none') {
            _i6 += total || 0;

            if (hasMask) {
              _i6 += hasMask;
            }
          } else {
            delete virtualDom.cache;
          }
        }

        if (__refreshLevel & TRANSFORM_ALL$1) {
          var matrix$1 = node.__matrix;

          if (!matrix$1 || isE(matrix$1)) {
            delete virtualDom.transform;
          } else {
            virtualDom.transform = 'matrix(' + util.joinArr(matrix.m2m6(matrix$1), ',') + ')';
          }

          if (parentMatrix && matrix$1) {
            matrix$1 = multiply(parentMatrix, matrix$1);
          }

          assignMatrix(node.__matrixEvent, matrix$1);
        }

        if (__refreshLevel & OP$1) {
          var opacity = computedStyle[OPACITY$1];

          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        }

        if (__refreshLevel & FT$1) {
          var filter = computedStyle[FILTER];
          var s = painter.svgFilter(filter);

          if (s) {
            virtualDom.filter = s;
          } else {
            delete virtualDom.filter;
          }
        }

        if (__refreshLevel & MBM$1) {
          var mixBlendMode = computedStyle[MIX_BLEND_MODE$1];

          if (mixBlendMode !== 'normal') {
            virtualDom.mixBlendMode = mbmName(mixBlendMode);
          } else {
            delete virtualDom.mixBlendMode;
          }
        }

        virtualDom.lv = __refreshLevel;
      } else {
        // >=REPAINT会调用render，重新生成defsCache，text没有这个东西
        if (!isText) {
          node.__cacheDefs.splice(0);

          var _matrix = node.__matrix;

          if (parentMatrix) {
            _matrix = multiply(parentMatrix, _matrix);
          }

          assignMatrix(node.__matrixEvent, _matrix);
        }

        node.render(renderMode, ctx, 0, 0);
        virtualDom = node.__virtualDom; // svg mock，每次都生成，每个节点都是局部根，更新时自底向上清除

        if (!isText) {
          var o = node.__cacheTotal = node.__cacheTotal || {
            __available: true,

            get available() {
              _i5 = _i6;
              return this.__available;
            },

            release: function release() {
              this.__available = false;
              delete virtualDom.cache;
            },
            __offsetY: function __offsetY() {}
          };
          o.__available = true;
        } // 渲染后更新取值


        display = computedStyle[DISPLAY$1];

        if (display === 'none') {
          _i6 += total || 0;
          _i6 += hasMask || 0;
        }
      }
      /**
       * mask会在join时过滤掉，这里将假设正常渲染的vd的内容获取出来组成defs的mask内容
       * 另外最初遍历时记录了会影响的mask，在<REPAINT时比较，>=REPAINT始终重新设置
       * 本身有matrix也需要重设
       */


      var mh = maskHash[_i6];

      if (mh && (maskEffectHash[_i6] || __refreshLevel >= REPAINT$1 || __refreshLevel & (TRANSFORM_ALL$1 | OP$1))) {
        var index = mh.index,
            _start2 = mh.start,
            _end2 = mh.end,
            isClip = mh.isClip;
        var target = __structs[index];
        var dom = target.node;
        var mChildren = []; // clip模式时，先添加兜底整个白色使得全部都可见，mask本身变反色（黑色）

        if (isClip) {
          mChildren.push({
            type: 'item',
            tagName: 'path',
            props: [['d', "M0,0L".concat(width, ",0L").concat(width, ",").concat(height, "L0,").concat(height, "L0,0")], ['fill', 'rgba(255,255,255,1)'], ['stroke-width', 0]]
          });
        }

        for (var j = _start2; j < _end2; j++) {
          var _node10 = __structs[j].node;
          var _node10$computedStyle = _node10.computedStyle,
              _display = _node10$computedStyle[DISPLAY$1],
              visibility = _node10$computedStyle[VISIBILITY$1],
              fill = _node10$computedStyle[FILL],
              _node10$virtualDom = _node10.virtualDom,
              children = _node10$virtualDom.children,
              _opacity2 = _node10$virtualDom.opacity;

          if (_display !== 'none' && visibility !== 'hidden') {
            // 引用相同无法diff，需要clone
            children = util.clone(children);
            mChildren = mChildren.concat(children);

            for (var k = 0, _len7 = children.length; k < _len7; k++) {
              var _children$k = children[k],
                  tagName = _children$k.tagName,
                  props = _children$k.props;

              if (tagName === 'path') {
                if (isClip) {
                  for (var _j9 = 0, _len8 = props.length; _j9 < _len8; _j9++) {
                    var item = props[_j9];

                    if (item[0] === 'fill') {
                      item[1] = util.int2invert(fill[0]);
                    }
                  }
                }

                var _matrix2 = _node10.matrix;
                var ivs = inverse(dom.matrix);
                _matrix2 = multiply(ivs, _matrix2); // path没有transform属性，在vd上，需要弥补

                props.push(['transform', "matrix(".concat(util.joinArr(matrix.m2m6(_matrix2), ','), ")")]); // path没有opacity属性，在vd上，需要弥补

                if (!util.isNil(_opacity2) && _opacity2 !== 1) {
                  props.push(['opacity', _opacity2]);
                }
              } // img可能有matrix属性，需判断
              else if (tagName === 'image') {
                var hasTransform = -1;

                for (var m = 0, _len9 = props.length; m < _len9; m++) {
                  if (props[m][0] === 'transform') {
                    hasTransform = m;
                    break;
                  }
                }

                if (hasTransform === -1) {
                  var _ivs = inverse(dom.matrix);

                  if (!isE(_ivs)) {
                    props.push(['transform', "matrix(".concat(util.joinArr(matrix.m2m6(_ivs), ','), ")")]);
                  }
                } else {
                  var _matrix3 = props[hasTransform][1].match(/[\d.]+/g).map(function (i) {
                    return parseFloat(i);
                  });

                  var _ivs2 = inverse(dom.matrix);

                  _matrix3 = multiply(_ivs2, _matrix3);
                  props[hasTransform][1] = "matrix(".concat(util.joinArr(matrix.m2m6(_matrix3), ','), ")");
                }
              }
            }
          }
        } // 清掉上次的


        for (var _i7 = __cacheDefs.length - 1; _i7 >= 0; _i7--) {
          var _item = __cacheDefs[_i7];

          if (_item.tagName === 'mask') {
            __cacheDefs.splice(_i7, 1);

            ctx.removeCache(_item);
          }
        }

        var _o4 = {
          tagName: 'mask',
          props: [],
          children: mChildren
        };
        var id = ctx.add(_o4);

        __cacheDefs.push(_o4);

        id = 'url(#' + id + ')';
        dom.virtualDom.mask = id;
      } // mask不入children


      if (parentVd && !node.__mask) {
        parentVd.children.push(virtualDom);
      }

      if (_i6 === 0) {
        parentMatrix = node.__matrix;
        parentVd = virtualDom;
      }

      _i5 = _i6;
    };

    for (var _i5 = 0, _len6 = __structs.length; _i5 < _len6; _i5++) {
      _loop(_i5);
    }
  }

  var lastList = [];

  function renderWebgl$1(renderMode, gl, root, isFirst, rlv) {
    if (isFirst) {
      Page.init(gl.getParameter(gl.MAX_TEXTURE_SIZE), true);
    }

    var __structs = root.__structs,
        width = root.width,
        height = root.height,
        __wasmRoot = root.__wasmRoot;
    var wasmOp, wasmMe;

    if (__wasmRoot) {
      var len = __structs.length;
      wasmOp = new Float64Array(wasm$1.instance.memory.buffer, __wasmRoot.op_ptr(), len);
      wasmMe = new Float64Array(wasm$1.instance.memory.buffer, __wasmRoot.me_ptr(), len * 16);
    }

    var cx = width * 0.5,
        cy = height * 0.5; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var lastRefreshLevel = NONE$1;
    var mergeList = [];
    var hasMbm; // 是否有混合模式出现

    /**
     * 先一遍先序遍历每个节点绘制到自己__cache上，排除Text和已有的缓存以及局部根缓存，
     * 根据refreshLevel进行等级区分，可能是<REPAINT或>=REPAINT，REFLOW布局已前置处理完。
     * 首次绘制没有catchTotal等，后续则可能会有，在<REPAINT可据此跳过所有子节点加快循环，布局过程会提前删除它们。
     * lv的变化根据大小相等进行出入栈parent操作，实现获取节点parent数据的方式，
     * 同时过程中计算出哪些节点要生成局部根，存下来
     * 第一次强制进入，后续不包含cache变更且<REPAINT的时候不进入省略循环
     */

    if (isFirst || rlv >= REPAINT$1 || rlv & (CACHE$1 | FT$1 | PPT$1 | MASK$1)) {
      // 记录transformStyle，出现ppt时有用，同时ts为flat后同一ppt上下文影响继承显示
      var flatList = [],
          flatExtendList = [];
      var pptNodeList = [];
      var parentPptNode = null;
      var lastPptNode = null;
      var lastLv = 0; // 节点开始有ppt得记录，后续孩子中如果有flat的，得强制生成cacheTotal

      for (var i = 0, _len10 = __structs.length; i < _len10; i++) {
        var _structs$i8 = __structs[i],
            node = _structs$i8.node,
            lv = _structs$i8.lv,
            total = _structs$i8.total,
            hasMask = _structs$i8.hasMask,
            isText = _structs$i8.isText;
        node.__index = i; // 生成total需要
        // Text特殊处理，webgl中先渲染为bitmap，再作为贴图绘制，缓存交由text内部判断，直接调用渲染纹理方法

        if (isText) {
          if (lastRefreshLevel >= REPAINT$1) {
            var bbox = node.bbox,
                x = node.__x,
                y = node.__y;
            var __cache = node.__cache;

            if (__cache) {
              __cache.reset(bbox, x, y);
            } else {
              __cache = CanvasCache.getInstance(mode.CANVAS, gl, root.__uuid, bbox, x, y, null);
            }

            if (__cache && __cache.enabled) {
              __cache.__bbox = bbox;
              __cache.__available = true;
              node.__cache = __cache;
              node.render(mode.CANVAS, __cache.ctx, __cache.dx, __cache.dy);

              __cache.update();

              node.__cacheTarget = __cache;
            } else {
              __cache && __cache.release();
              node.__limitCache = true;
              node.__cacheTarget = null;
            }
          }

          continue;
        }

        var __computedStyle = node.__computedStyle; // 跳过display:none元素和它的所有子节点

        if (__computedStyle[DISPLAY$1] === 'none') {
          i += total || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          continue;
        }

        var perspective = __computedStyle[PERSPECTIVE];
        var isFlat = __computedStyle[TRANSFORM_STYLE] === 'flat'; // 特殊，新的ppt上下文节点启用新值，否则还是老的
        var pptNode = perspective ? node : null; // root第一个特殊处理

        if (lv === 0) {

          if (perspective) {
            parentPptNode = node;
          }
        } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树
        else if (lv > lastLv) {
          flatList.push(isFlat);
          flatExtendList.push(isFlat);
          parentPptNode = lastPptNode || parentPptNode;
          pptNodeList.push(pptNode || parentPptNode);
        } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
        else if (lv < lastLv) {
          var diff = lastLv - lv;
          flatList.splice(-diff);
          flatList[lv - 1];
          flatExtendList.splice(-diff);
          flatExtendList[lv - 1];
          pptNodeList.splice(-diff);
          parentPptNode = pptNodeList[lv - 1];
        } // 不变是同级兄弟，无需特殊处理 else {}


        lastLv = lv; // 根据refreshLevel优化计算

        var __refreshLevel = node.__refreshLevel,
            __currentStyle = node.__currentStyle,
            __cacheTotal = node.__cacheTotal;
        node.__refreshLevel = NONE$1;
        /**
         * lv<REPAINT，一般会有__cache，跳过渲染过程，快速运算，没有cache则是自身超限或无内容，目前不感知
         * 可能有cacheTotal，为之前生成的局部根，清除逻辑在更新检查是否>=REPAINT那里，小变化不动
         * 当有遮罩时，如果被遮罩节点本身无变更，需要检查其next的遮罩节点有无变更，
         * 但其实不用检查，因为next变更一定会清空cacheMask，只要检查cacheMask即可
         * 如果没有或无效，直接添加，无视节点本身变化，后面防重即可
         */

        if (!__refreshLevel) ; else if (__refreshLevel < REPAINT$1) {
          var hasContent = node.__hasContent;
          var mixBlendMode = __computedStyle[MIX_BLEND_MODE$1];
          var isMbm = __refreshLevel & MBM$1 && mixBlendMode !== 'normal';
          var need = node.__cacheAsBitmap || hasMask;

          if (!need && __refreshLevel & (FT$1 | CACHE$1)) {
            var filter = __computedStyle[FILTER];

            if (filter && filter.length) {
              need = true;
            }
          }

          var isPpt = void 0;

          if (!need && __refreshLevel & (PPT$1 | CACHE$1)) {
            var __domParent = node.__domParent;
            isPpt = total && perspective && (!isE(__domParent && __domParent.__perspectiveMatrix) || !isE(node.__selfPerspectiveMatrix));

            if (isPpt) {
              need = true;
            }
          }

          if (isMbm) {
            hasMbm = true;
          } // 这里和canvas不一样，前置cacheAsBitmap条件变成或条件之一，新的ppt层级且画中画需要新的fbo


          if (need && (hasContent || total)) {
            mergeList.push({
              i: i,
              lv: lv,
              total: total,
              node: node,
              hasMask: hasMask,
              isPpt: isPpt
            });
          } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


          if (__cacheTotal && __cacheTotal.__available) {
            i += total || 0;

            if (__refreshLevel === NONE$1 && hasMask) {
              i += countMaskNum(__structs, i + 1, hasMask);
            }
          }
        }
        /**
         * >=REPAINT重新渲染，并根据结果判断是否离屏限制错误
         * Geom没有子节点无需汇总局部根，Dom中Img也是，它们的局部根等于自身的cache，其它符合条件的Dom需要生成
         */
        else {
          var _hasContent = node.calContent(__currentStyle, __computedStyle),
              onlyImg = void 0; // 有内容先以canvas模式绘制到离屏画布上，自定义渲染设置无内容不实现即可跳过


          if (_hasContent) {
            var _bbox3 = node.bbox,
                _cache4 = node.__cache,
                x1 = node.__x1,
                y1 = node.__y1; // 单图特殊对待缓存

            if (node instanceof Img) {
              var loadImg = node.__loadImg;

              if (loadImg.onlyImg && !loadImg.error && loadImg.source) {
                onlyImg = true;
                _cache4 = node.__cache = ImgWebglCache.getInstance(mode.CANVAS, gl, root.__uuid, _bbox3, loadImg, x1, y1); // 纯img按原尺寸绘制

                if (_cache4 && _cache4.enabled && _cache4.count === 1) {
                  _cache4.ctx.drawImage(loadImg.source, x1 + _cache4.dx, y1 + _cache4.dy);

                  _cache4.update();
                }
              }
            }

            if (!onlyImg) {
              if (_cache4) {
                _cache4.reset(_bbox3, x1, y1); // 特殊的单独img变为非纯img，需重新生成cache


                if (!(_cache4 instanceof CanvasCache)) {
                  _cache4 = node.__cache = CanvasCache.getInstance(mode.CANVAS, gl, root.__uuid, _bbox3, x1, y1, null);
                }
              } else {
                _cache4 = node.__cache = CanvasCache.getInstance(mode.CANVAS, gl, root.__uuid, _bbox3, x1, y1, null);
              }
            }

            if (_cache4 && _cache4.enabled) {
              _cache4.__bbox = _bbox3;
              _cache4.__available = true;
              node.__cache = _cache4;

              if (!onlyImg) {
                node.render(mode.CANVAS, _cache4.ctx, _cache4.dx, _cache4.dy);

                _cache4.update();
              }
            } else {
              _cache4 && _cache4.release();
              node.__limitCache = true;
              node.__cacheTarget = null;
              return;
            }

            node.__updateCache();
          } else {
            node.__limitCache = false;
            node.__cacheTarget = null;
          }

          if (_hasContent || total) {
            var overflow = __computedStyle[OVERFLOW],
                _filter = __computedStyle[FILTER],
                _mixBlendMode = __computedStyle[MIX_BLEND_MODE$1],
                _perspective2 = __computedStyle[PERSPECTIVE];

            var _isMbm = _mixBlendMode !== 'normal';

            var _isPpt = total && _perspective2 || !isE(node.__selfPerspectiveMatrix);

            var isOverflow = overflow === 'hidden' && total;
            var isFilter = _filter && _filter.length;

            if (_isMbm) {
              hasMbm = true;
            }

            if (node.__cacheAsBitmap || hasMask || isFilter || isOverflow || _isPpt) {
              mergeList.push({
                i: i,
                lv: lv,
                total: total,
                node: node,
                hasMask: hasMask,
                isPpt: _isPpt
              });
            }
          }
        }

        lastRefreshLevel = __refreshLevel;
        lastPptNode = pptNode;
      }
    } // 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
    // 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩


    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a.lv === b.lv) {
          return b.i - a.i;
        }

        return b.lv - a.lv;
      }); // ppt只有嵌套才需要生成，最下面的孩子节点的ppt无需，因此记录一个hash存index，
      // 同时因为是后序遍历，孩子先存所有父亲的index即可保证父亲才能生成cacheTotal

      for (var ii = 0, _len11 = mergeList.length; ii < _len11; ii++) {
        var _mergeList$ii = mergeList[ii],
            _i8 = _mergeList$ii.i,
            _lv6 = _mergeList$ii.lv,
            _total12 = _mergeList$ii.total,
            _node11 = _mergeList$ii.node,
            _hasMask6 = _mergeList$ii.hasMask,
            _isPpt2 = _mergeList$ii.isPpt;
        var _computedStyle4 = _node11.__computedStyle;
        var _filter2 = _computedStyle4[FILTER]; // 有ppt的，向上查找所有父亲index记录，可能出现重复记得提前跳出

        var __limitCache = _node11.__limitCache,
            _cacheTotal = _node11.__cacheTotal,
            __cacheFilter = _node11.__cacheFilter,
            __cacheMask = _node11.__cacheMask;

        if (__limitCache) {
          return;
        }

        var needGen = void 0; // 可能没变化，比如被遮罩节点、filter变更等

        if (!_cacheTotal || !_cacheTotal.__available) {
          var res = void 0;

          if (_isPpt2) {
            res = genPptWebgl(renderMode, _cacheTotal, gl, root, _node11, _i8, _lv6, _total12 || 0, __structs, width, height);
          } else {
            res = genTotalWebgl(renderMode, _cacheTotal, gl, root, _node11, _i8, _lv6, _total12 || 0, __structs, width, height, null, null, null);
          }

          if (!res) {
            return;
          }

          _cacheTotal = res;
          needGen = true;
        } // 即使超限，也有total结果


        var target = _cacheTotal;

        if (_filter2.length) {
          if (!__cacheFilter || !__cacheFilter.__available || needGen) {
            var _res9 = genFilterWebgl(renderMode, gl, _node11, target, _filter2, width, height);

            if (_res9) {
              target = _res9;
              needGen = true;
            }
          }
        }

        if (_hasMask6 && (!__cacheMask || !__cacheMask.__available || needGen)) {
          genMaskWebgl(renderMode, gl, root, _node11, target, width, height, _i8 + (_total12 || 0) + 1, _lv6, __structs);
        }

        _node11.__updateCache();
      }
    } // 非首次，没有cache变更重新生成的，可以直接用上次的缓存渲染列表
    else if (wasmOp && !isFirst && rlv < REPAINT$1 && !(rlv & (CACHE$1 | FT$1 | PPT$1 | MASK$1))) {
      for (var _i9 = 0, _len12 = lastList.length; _i9 < _len12; _i9++) {
        drawTextureCache(gl, lastList[_i9], cx, cy, 0, 0, wasmOp, wasmMe);
      }

      return;
    }

    lastList.splice(0);
    /**
     * 最后先序遍历一次应用__cacheTotal即可，没有的用__cache，以及剩下的超尺寸的和Text
     * 由于mixBlendMode的存在，需先申请个fbo纹理，所有绘制默认向该纹理绘制，最后fbo纹理再进入主画布
     * 前面循环时有记录是否出现mbm，只有出现才申请，否则不浪费直接输出到主画布
     * 超尺寸的不绘制并给出警告，实现会扰乱逻辑且很少会出现这种情况
     */

    var frameBuffer, texture;

    if (hasMbm) {
      texture = createTexture(gl, null, 0, width, height);
      bindTexture(gl, null, 0);
      frameBuffer = genFrameBufferWithTexture(gl, texture, width, height);
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    }

    var lastPage,
        list = [];

    for (var _i10 = 0, _len13 = __structs.length; _i10 < _len13; _i10++) {
      var _structs$_i3 = __structs[_i10],
          _node12 = _structs$_i3.node,
          _total13 = _structs$_i3.total,
          _hasMask7 = _structs$_i3.hasMask,
          _isText3 = _structs$_i3.isText; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_isText3) {
        // text特殊之处，__config部分是复用parent的
        var _cache5 = _node12.__cache;

        if (_cache5 && _cache5.__available) {
          var _node12$__domParent = _node12.__domParent,
              __matrixEvent = _node12$__domParent.__matrixEvent,
              __opacity = _node12$__domParent.__opacity;
          var p = _cache5.__page;

          if (lastPage && lastPage !== p) {
            var o = list.splice(0);
            lastList.push(o);
            drawTextureCache(gl, o, cx, cy, 0, 0, wasmOp, wasmMe);
          }

          lastPage = p;

          if (wasmOp) {
            list.push({
              cache: _cache5,
              index: _i10,
              wasm: true
            });
          } else {
            list.push({
              cache: _cache5,
              opacity: __opacity,
              matrix: __matrixEvent
            });
          }
        }
      } else {
        var _computedStyle5 = _node12.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

        if (_computedStyle5[DISPLAY$1] === 'none') {
          _i10 += _total13 || 0;

          if (_hasMask7) {
            _i10 += countMaskNum(__structs, _i10 + 1, _hasMask7);
          }

          continue;
        }

        var _mixBlendMode2 = _computedStyle5[MIX_BLEND_MODE$1],
            visibility = _computedStyle5[VISIBILITY$1],
            backfaceVisibility = _computedStyle5[BACKFACE_VISIBILITY];
        var opacity = wasmOp ? wasmOp[_i10] : _computedStyle5[OPACITY$1];
        var _cache6 = _node12.__cache;
        var m = void 0;

        if (!wasmOp) {
          m = _node12.__matrix;
          var __selfPerspectiveMatrix = _node12.__selfPerspectiveMatrix;

          if (!isE(__selfPerspectiveMatrix)) {
            m = multiply(__selfPerspectiveMatrix, m);
          }

          var _domParent = _node12.__domParent;

          if (_domParent) {
            var op = _domParent.__opacity;

            if (op !== 1) {
              opacity *= _domParent.__opacity;
            }

            var pm = _domParent.__perspectiveMatrix,
                me = _domParent.__matrixEvent;

            if (pm && pm.length) {
              m = multiply(pm, m);
            }

            if (me && me.length) {
              m = multiply(me, m);
            }
          }

          _node12.__opacity = opacity;
          assignMatrix(_node12.__matrixEvent, m);
        }

        if (visibility === 'hidden' && !_total13) {
          if (_hasMask7) {
            _i10 += countMaskNum(__structs, _i10 + 1, _hasMask7);
          }

          continue;
        } // 后面不可见，只有rotateX和rotateY翻转导致的0/5/10位的cos值为负，同时转2次抵消10位是正


        if (backfaceVisibility === 'hidden') {
          var _m6 = _node12.matrix,
              _x8 = _m6[5] < 0 && _m6[10] < 0,
              _y8 = _m6[0] < 0 && _m6[10] < 0;

          if (_x8 || _y8) {
            _i10 += _total13 || 0;

            if (_hasMask7) {
              _i10 += countMaskNum(__structs, _i10 + 1, _hasMask7);
            }

            continue;
          }
        } // total和自身cache的尝试，visibility不可见时没有cache


        var _target8 = _node12.__cacheTarget;

        if (_target8) {
          if (opacity > 0) {
            // 有mbm则需要混合之前的纹理和新纹理到fbo上面，连续的mbm则依次交替绘制到画布或离屏fbo上
            if (_mixBlendMode2 !== 'normal') {
              if (list.length) {
                var _o5 = list.splice(0);

                lastList.push(_o5);
                drawTextureCache(gl, _o5, cx, cy, 0, 0, wasmOp, wasmMe);
                lastPage = null;
              }

              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
              gl.bindFramebuffer(gl.FRAMEBUFFER, null);
              gl.deleteFramebuffer(frameBuffer);

              var _res10 = genMbmWebgl(gl, texture, _target8, _mixBlendMode2, opacity, m, 0, 0, cx, cy, width, height);

              if (_res10) {
                gl.deleteTexture(texture);
                texture = _res10.texture;
                frameBuffer = _res10.frameBuffer;
              }
            } else {
              var _p8 = _target8.__page;

              if (lastPage && lastPage !== _p8) {
                var _o6 = list.splice(0);

                lastList.push(_o6);
                drawTextureCache(gl, _o6, cx, cy, 0, 0, wasmOp, wasmMe);
              }

              lastPage = _p8;

              if (wasmOp) {
                list.push({
                  cache: _target8,
                  index: _i10,
                  wasm: true
                });
              } else {
                list.push({
                  cache: _target8,
                  opacity: opacity,
                  matrix: m
                });
              }
            }
          }

          if (_target8 !== _cache6) {
            _i10 += _total13 || 0;

            if (_hasMask7) {
              _i10 += countMaskNum(__structs, _i10 + 1, _hasMask7);
            }
          }
        } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


        if ((!_target8 || _target8 === _cache6) && opacity > 0) {
          var render = _node12.render;

          if (render !== DOM_RENDER && render !== IMG_RENDER && render !== GEOM_RENDER) {
            var _o7 = list.splice(0);

            lastList.push(_o7);
            drawTextureCache(gl, _o7, cx, cy, 0, 0, wasmOp, wasmMe);
            lastPage = null;

            _node12.render(renderMode, gl, 0, 0);

            gl.useProgram(gl.program);
          }
        }
      }
    }

    lastList.push(list);
    drawTextureCache(gl, list, cx, cy, 0, 0, wasmOp, wasmMe); // 有mbm时将汇总的fbo绘入主画布，否则本身就是到主画布无需多余操作

    if (hasMbm) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.deleteFramebuffer(frameBuffer); // 顶点buffer

      var pointBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
      var a_position = gl.getAttribLocation(gl.program, 'a_position');
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position); // 纹理buffer

      var texBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
      var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
      gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_texCoords); // opacity buffer

      var opacityBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
      var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
      gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_opacity); // 纹理单元

      bindTexture(gl, texture, 0);
      var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
      gl.uniform1i(u_texture, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.deleteBuffer(pointBuffer);
      gl.deleteBuffer(texBuffer);
      gl.deleteBuffer(opacityBuffer);
      gl.disableVertexAttribArray(a_position);
      gl.disableVertexAttribArray(a_texCoords);
      gl.deleteTexture(texture);
    }
  }

  function renderCanvas$1(renderMode, ctx, root, isFirst, rlv) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height,
        __wasmRoot = root.__wasmRoot;
    var wasmOp, wasmMe;

    if (__wasmRoot) {
      var len = __structs.length;
      wasmOp = new Float64Array(wasm$1.instance.memory.buffer, __wasmRoot.op_ptr(), len);
      wasmMe = new Float64Array(wasm$1.instance.memory.buffer, __wasmRoot.me_ptr(), len * 16);
    }

    var mergeList = [];
    /**
     * 先一遍先序遍历收集cacheAsBitmap的节点，说明这棵子树需要缓存，可能出现嵌套，深层级优先、后面优先
     * 可能遇到已有缓存没变化的，这时候不要收集忽略掉，没有缓存的走后面遍历普通渲染
     * 第一次强制进入，后续不包含cache变更且<REPAINT的时候不进入省略循环
     */

    if (isFirst || rlv >= REPAINT$1 || rlv & (CACHE$1 | FT$1 | MASK$1)) {
      for (var i = 0, _len14 = __structs.length; i < _len14; i++) {
        var _structs$i9 = __structs[i],
            node = _structs$i9.node,
            lv = _structs$i9.lv,
            total = _structs$i9.total,
            hasMask = _structs$i9.hasMask,
            isText = _structs$i9.isText; // 排除Text，要么根节点直接绘制，要么被局部根节点汇总，自身并不缓存（fillText比位图更快）

        if (isText) {
          continue;
        }

        var __computedStyle = node.__computedStyle; // 跳过display:none元素和它的所有子节点

        if (__computedStyle[DISPLAY$1] === 'none') {
          i += total || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          continue;
        } // 根据refreshLevel优化计算，处理其样式


        var __refreshLevel = node.__refreshLevel,
            __cacheTotal = node.__cacheTotal;
        node.__refreshLevel = NONE$1; // filter变化需重新生成，cacheTotal本身就存在要判断下；CACHE取消重新生成则无需判断
        // img在只有自身的情况下自动生成并特殊对待，cache是<img>标签，多个相同引用的img使用同一份资源

        var need = node.__cacheAsBitmap && (__refreshLevel & (CACHE$1 | FT$1) || __refreshLevel >= REPAINT$1);

        if (!need && node instanceof Img) {
          var hasContent = node.calContent(node.__currentStyle, node.__computedStyle);
          var loadImg = node.__loadImg;

          if (loadImg.onlyImg && hasContent) {
            need = true;
          }
        }

        if (need) {
          mergeList.push({
            i: i,
            lv: lv,
            total: total,
            node: node,
            hasMask: hasMask
          });
        } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


        if (__cacheTotal && __cacheTotal.__available) {
          i += total || 0;

          if (__refreshLevel === NONE$1 && hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }
        }
      }
    }
    /**
     * 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
     * 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩
     */


    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a.lv === b.lv) {
          return b.i - a.i;
        }

        return b.lv - a.lv;
      });
      mergeList.forEach(function (item) {
        var i = item.i,
            lv = item.lv,
            total = item.total,
            node = item.node,
            hasMask = item.hasMask;

        var __cacheTotal = genTotal(renderMode, ctx, root, node, i, lv, total || 0, __structs, width, height);

        if (__cacheTotal) {
          genTotalOther(renderMode, __structs, __cacheTotal, node, hasMask, width, height);

          node.__updateCache();
        }
      });
    }
    /**
     * 最后先序遍历一次并应用__cacheTotal即可，没有的普通绘制，以及剩下的超尺寸的和Text
     * 特殊离屏和cacheAsBitmap的离屏都已经产生了cacheTotal，除非超限
     * 离屏功能的数据结构和算法逻辑非常复杂，需用到下面2个hash，来完成一些filter、mask等离屏才能完成的绘制
     * 其中overflow、filter、mix-blend-mode是对自身及子节点，mask则是对自身和后续next遮罩节点
     * 一个节点在Xom渲染中申请离屏canvas，是按照一定顺序来的，且多个离屏后面的有前面的ctx引用，第一个则引用最初非离屏的ctx
     * 这个顺序在应用离屏时以反向顺序开始，这样最后ctx被还原到最初的ctx
     * mask是个十分特殊的离屏，因为除了自身外，next节点也需要汇总到另外一个离屏上，为了逻辑一致性
     * 所有离屏应用的索引都以最后一个节点的索引为准，即有mask时以最后一个mask，无mask则以自身节点的最后一个（+total)为索引
     * 由于存在普通非cache绘制，所以依然要用到栈代替递归计算matrix
     */


    var maskStartHash = [];
    var offscreenHash = [];
    var lastOpacity = -1;

    for (var _i11 = 0, _len15 = __structs.length; _i11 < _len15; _i11++) {
      var _structs$_i4 = __structs[_i11],
          _node13 = _structs$_i4.node,
          _lv7 = _structs$_i4.lv,
          _total14 = _structs$_i4.total,
          _hasMask8 = _structs$_i4.hasMask,
          _isText4 = _structs$_i4.isText; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_isText4) {
        _node13.render(renderMode, ctx, 0, 0);

        var oh = offscreenHash[_i11];

        if (oh) {
          ctx = applyOffscreen(ctx, oh, width, height, false);
          lastOpacity = -1;
        }
      } else {
        var _computedStyle6 = _node13.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

        if (_computedStyle6[DISPLAY$1] === 'none') {
          _i11 += _total14 || 0;

          if (_hasMask8) {
            _i11 += countMaskNum(__structs, _i11 + 1, _hasMask8);
          }

          var _oh4 = offscreenHash[_i11];

          if (_oh4) {
            ctx = applyOffscreen(ctx, _oh4, width, height, true);
            lastOpacity = -1;
          }

          continue;
        } // 遮罩对象申请了个离屏，其第一个mask申请另外一个离屏mask2，开始聚集所有mask元素的绘制，
        // 这是一个十分特殊的逻辑，保存的index是最后一个节点的索引，OFFSCREEN_MASK2是最低优先级，
        // 这样当mask本身有filter时优先自身，然后才是OFFSCREEN_MASK2


        var msh = maskStartHash[_i11];

        if (msh) {
          var idx = msh.idx,
              _hasMask9 = msh.hasMask,
              offscreenMask = msh.offscreenMask;

          var _target9 = inject.getOffscreenCanvas(width, height, null, 'mask2');

          offscreenMask.mask = _target9; // 应用mask用到

          offscreenMask.isClip = _node13.__clip; // 定位到最后一个mask元素上的末尾

          var j = _i11 + (_total14 || 0) + 1;

          while (--_hasMask9) {
            var _total15 = __structs[j].total;
            j += (_total15 || 0) + 1;
          }

          j--;
          var list = offscreenHash[j] = offscreenHash[j] || [];
          list.push({
            idx: idx,
            lv: _lv7,
            type: OFFSCREEN_MASK,
            offscreen: offscreenMask
          });
          list.push({
            idx: j,
            lv: _lv7,
            type: OFFSCREEN_MASK2,
            offscreen: {
              ctx: ctx,
              // 保存等待OFFSCREEN_MASK2时还原
              target: _target9
            }
          });
          ctx = _target9.ctx;
        } // 设置opacity/matrix，根节点是没有父节点的不计算继承值


        var opacity = wasmOp ? wasmOp[_i11] : _computedStyle6[OPACITY$1];
        var m = void 0;

        if (!wasmOp) {
          m = _node13.__matrix;
          var __domParent = _node13.__domParent;

          if (__domParent) {
            var op = __domParent.__opacity;

            if (op !== 1) {
              opacity *= __domParent.__opacity;
            }

            var me = __domParent.__matrixEvent;

            if (me && me.length) {
              m = multiply(me, m);
            }
          }

          _node13.__opacity = opacity;
          assignMatrix(_node13.__matrixEvent, m);
        } // 有cache声明从而有total的可以直接绘制并跳过子节点索，total生成可能会因超限而失败


        var target = _node13.__cacheTarget;

        if (target === _node13.__cache) {
          target = null;
        }

        if (target) {
          if (lastOpacity !== opacity) {
            ctx.globalAlpha = opacity;
            lastOpacity = opacity;
          }

          if (opacity > 0) {
            if (wasmOp) {
              var _idx = _i11 * 16;

              ctx.setTransform(wasmMe[_idx], wasmMe[_idx + 1], wasmMe[_idx + 4], wasmMe[_idx + 5], wasmMe[_idx + 12], wasmMe[_idx + 13]);
            } else {
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            }

            var mixBlendMode = _computedStyle6[MIX_BLEND_MODE$1];

            if (mixBlendMode !== 'normal') {
              ctx.globalCompositeOperation = mbmName(mixBlendMode);
            }

            var _target10 = target,
                x = _target10.x,
                y = _target10.y,
                canvas = _target10.canvas,
                x1 = _target10.x1,
                y1 = _target10.y1,
                dbx = _target10.dbx,
                dby = _target10.dby,
                w = _target10.width,
                h = _target10.height;
            ctx.drawImage(canvas, x, y, w, h, x1 - dbx, y1 - dby, w, h); // total应用后记得设置回来

            ctx.globalCompositeOperation = 'source-over';
          }

          _i11 += _total14 || 0;

          if (_hasMask8) {
            _i11 += countMaskNum(__structs, _i11 + 1, _hasMask8);
          } // 父超限但子有total的时候，i此时已经增加到了末尾，也需要检查


          var _oh5 = offscreenHash[_i11];

          if (_oh5) {
            ctx = applyOffscreen(ctx, _oh5, width, height, false);
            lastOpacity = -1;
          }
        } // 没有cacheTotal是普通节点绘制
        else {
          // 如果有离屏则先申请替换ctx
          var offscreenBlend = void 0,
              _offscreenMask3 = void 0,
              offscreenFilter = void 0,
              offscreenOverflow = void 0;

          var _offscreen3 = _node13.__calOffscreen(ctx, _computedStyle6);

          if (_offscreen3) {
            ctx = _offscreen3.ctx;
            offscreenBlend = _offscreen3.offscreenBlend;
            _offscreenMask3 = _offscreen3.offscreenMask;
            offscreenFilter = _offscreen3.offscreenFilter;
            offscreenOverflow = _offscreen3.offscreenOverflow;
          } // 节点自身渲染


          if (lastOpacity !== opacity) {
            ctx.globalAlpha = opacity;
            lastOpacity = opacity;
          }

          if (opacity > 0) {
            if (wasmOp) {
              var _idx2 = _i11 * 16;

              ctx.setTransform(wasmMe[_idx2], wasmMe[_idx2 + 1], wasmMe[_idx2 + 4], wasmMe[_idx2 + 5], wasmMe[_idx2 + 12], wasmMe[_idx2 + 13]);
            } else {
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            }

            _node13.render(renderMode, ctx, 0, 0);
          } // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


          if (offscreenBlend) {
            var _j10 = _i11 + (_total14 || 0);

            if (_hasMask8) {
              _j10 += countMaskNum(__structs, _j10 + 1, _hasMask8);
            }

            var _list7 = offscreenHash[_j10] = offscreenHash[_j10] || [];

            _list7.push({
              idx: _i11,
              lv: _lv7,
              type: OFFSCREEN_BLEND,
              offscreen: offscreenBlend
            });
          } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
          // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


          if (_offscreenMask3) {
            var _j11 = _i11 + (_total14 || 0);

            maskStartHash[_j11 + 1] = {
              idx: _i11,
              hasMask: _hasMask8,
              offscreenMask: _offscreenMask3
            };
          } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


          if (offscreenFilter) {
            var _j12 = _i11 + (_total14 || 0);

            if (_hasMask8) {
              _j12 += countMaskNum(__structs, _j12 + 1, _hasMask8);
            }

            var _list8 = offscreenHash[_j12] = offscreenHash[_j12] || [];

            _list8.push({
              idx: _i11,
              lv: _lv7,
              type: OFFSCREEN_FILTER,
              offscreen: offscreenFilter
            });
          } // overflow:hidden的离屏，最后孩子进行截取


          if (offscreenOverflow) {
            var _j13 = _i11 + (_total14 || 0);

            if (_hasMask8) {
              _j13 += countMaskNum(__structs, _j13 + 1, _hasMask8);
            }

            var _list9 = offscreenHash[_j13] = offscreenHash[_j13] || [];

            _list9.push({
              idx: _i11,
              lv: _lv7,
              type: OFFSCREEN_OVERFLOW,
              offscreen: offscreenOverflow
            });
          } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
          // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


          var _oh6 = offscreenHash[_i11];

          if (_oh6) {
            ctx = applyOffscreen(ctx, _oh6, width, height, false);
            lastOpacity = -1;
          }
        }
      }
    }
  }

  var struct = {
    renderCanvas: renderCanvas$1,
    renderSvg: renderSvg$1,
    renderWebgl: renderWebgl$1
  };

  var ca = {
    alpha: true,
    antialias: true,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    depth: true,
    stencil: true
  };

  var vertex = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;attribute float a_opacity;varying float v_opacity;void main(){gl_Position=a_position;v_texCoords=a_texCoords;v_opacity=a_opacity;}"; // eslint-disable-line

  var fragment = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;varying float v_opacity;uniform sampler2D u_texture;void main(){float opacity=v_opacity;if(opacity<=0.0){discard;}opacity=clamp(opacity,0.0,1.0);vec4 color=texture2D(u_texture,v_texCoords);gl_FragColor=color*opacity;}"; // eslint-disable-line

  var vertexMask = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords1;attribute vec2 a_texCoords2;varying vec2 v_texCoords1;varying vec2 v_texCoords2;void main(){gl_Position=a_position;v_texCoords1=a_texCoords1;v_texCoords2=a_texCoords2;}"; // eslint-disable-line

  var fragmentMask = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords1;varying vec2 v_texCoords2;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords1);vec4 color2=texture2D(u_texture2,v_texCoords2);gl_FragColor=color1*color2.a;}"; // eslint-disable-line

  var fragmentClip = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords1;varying vec2 v_texCoords2;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords1);vec4 color2=texture2D(u_texture2,v_texCoords2);float a=color1.a*(1.0-color2.a);gl_FragColor=vec4(color1.rgb*(1.0-color2.a),a);}"; // eslint-disable-line

  var vertexOverflow = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentOverflow = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_texCoords);}"; // eslint-disable-line

  var vertexCm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentCm = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_m[20];void main(){vec4 c=texture2D(u_texture,v_texCoords);if(c.a>0.0){c.rgb/=c.a;}vec4 result;result.r=(u_m[0]*c.r);result.r+=(u_m[1]*c.g);result.r+=(u_m[2]*c.b);result.r+=(u_m[3]*c.a);result.r+=u_m[4];result.g=(u_m[5]*c.r);result.g+=(u_m[6]*c.g);result.g+=(u_m[7]*c.b);result.g+=(u_m[8]*c.a);result.g+=u_m[9];result.b=(u_m[10]*c.r);result.b+=(u_m[11]*c.g);result.b+=(u_m[12]*c.b);result.b+=(u_m[13]*c.a);result.b+=u_m[14];result.a=(u_m[15]*c.r);result.a+=(u_m[16]*c.g);result.a+=(u_m[17]*c.b);result.a+=(u_m[18]*c.a);result.a+=u_m[19];gl_FragColor=vec4(result.rgb*result.a,result.a);}"; // eslint-disable-line

  var vertexDs = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentDs = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_color[4];void main(){vec4 c=texture2D(u_texture,v_texCoords);gl_FragColor=vec4(u_color[0]*c.a,u_color[1]*c.a,u_color[2]*c.a,u_color[3]*c.a);}"; // eslint-disable-line

  var vertexMbm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentMultiply = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return((1.0-a2/a3)*c1*255.0+a2/a3*((1.0-a1)*c2*255.0+a1*c3*255.0))/255.0;}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=bottom*top;float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentScreen = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentOverlay = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(top.r,bottom.r),op(top.g,bottom.g),op(top.b,bottom.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDarken = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return min(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLighten = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return max(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorDodge = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==1.0){return a==0.0 ? a : 1.0;}return min(1.0,a/(1.0-b));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorBurn = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==0.0){return a==1.0 ? a : 0.0;}return 1.0-min(1.0,(1.0-a)/b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHardLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSoftLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5? a-(1.0-2.0*b)*a*(1.0-a): a+(2.0*b-1.0)*(a<=0.25?((16.0*a-12.0)*a+4.0)*a: sqrt(a)-a);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDifference = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return abs(a-b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentExclusion = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-2.0*a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHue = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(a);float l=getLuminosity(a);return setLuminosity(setSaturation(b,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSaturation = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(b);float l=getLuminosity(a);return setLuminosity(setSaturation(a,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColor = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(a);return setLuminosity(b,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLuminosity = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(b);return setLuminosity(a,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var vertexSs = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentSs = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_opacity;void main(){gl_FragColor=texture2D(u_texture,v_texCoords)*u_opacity;}"; // eslint-disable-line

  var _enums$STYLE_KEY = enums.STYLE_KEY,
      TOP = _enums$STYLE_KEY.TOP,
      RIGHT = _enums$STYLE_KEY.RIGHT,
      BOTTOM = _enums$STYLE_KEY.BOTTOM,
      LEFT = _enums$STYLE_KEY.LEFT,
      POSITION = _enums$STYLE_KEY.POSITION,
      DISPLAY = _enums$STYLE_KEY.DISPLAY,
      VISIBILITY = _enums$STYLE_KEY.VISIBILITY,
      COLOR = _enums$STYLE_KEY.COLOR,
      WIDTH = _enums$STYLE_KEY.WIDTH,
      HEIGHT = _enums$STYLE_KEY.HEIGHT,
      Z_INDEX = _enums$STYLE_KEY.Z_INDEX,
      POINTER_EVENTS = _enums$STYLE_KEY.POINTER_EVENTS,
      WRITING_MODE = _enums$STYLE_KEY.WRITING_MODE,
      TEXT_STROKE_COLOR = _enums$STYLE_KEY.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH = _enums$STYLE_KEY.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER = _enums$STYLE_KEY.TEXT_STROKE_OVER,
      MATRIX = _enums$STYLE_KEY.MATRIX,
      TRANSFORM = _enums$STYLE_KEY.TRANSFORM,
      OPACITY = _enums$STYLE_KEY.OPACITY,
      MIX_BLEND_MODE = _enums$STYLE_KEY.MIX_BLEND_MODE,
      FONT_SIZE = _enums$STYLE_KEY.FONT_SIZE;
  var isNil$8 = util.isNil,
      isFunction$1 = util.isFunction;
  var PX = o$4.PX,
      INHERIT = o$4.INHERIT;
  var getLevel = o$1.getLevel,
      isReflow = o$1.isReflow,
      NONE = o$1.NONE,
      FT = o$1.FILTER,
      PPT = o$1.PERSPECTIVE,
      REPAINT = o$1.REPAINT,
      REFLOW = o$1.REFLOW,
      REBUILD = o$1.REBUILD,
      CACHE = o$1.CACHE,
      TF = o$1.TRANSFORM,
      TRANSFORM_ALL = o$1.TRANSFORM_ALL,
      OP = o$1.OPACITY,
      MBM = o$1.MIX_BLEND_MODE,
      MASK = o$1.MASK;
  var isGeom = o$2.isGeom;
  var renderCanvas = struct.renderCanvas,
      renderSvg = struct.renderSvg,
      renderWebgl = struct.renderWebgl;
  var ROOT_DOM_NAME = {
    canvas: 'canvas',
    svg: 'svg',
    webgl: 'canvas'
  };

  function getDom(dom) {
    if (util.isString(dom) && dom) {
      var o = document.querySelector(dom);

      if (!o) {
        throw new Error('Can not find dom of selector: ' + dom);
      }

      return o;
    }

    if (!dom) {
      throw new Error('Can not find dom: ' + dom);
    }

    return dom;
  }

  function renderProp(k, v) {
    var s = Array.isArray(v) ? util.joinSourceArray(v) : util.stringify(v);

    if (k === 'className') {
      k = 'class';
    } else if (k === 'style') {
      return '';
    }

    return ' ' + k + '="' + util.encodeHtml(s, true) + '"';
  }

  var EVENT_LIST = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];

  function initEvent(dom, Root) {
    var list = [];
    EVENT_LIST.forEach(function (type) {
      function cb(e) {
        var root = dom.__root;

        if (root && root instanceof Root) {
          if (['touchend', 'touchcancel', 'touchmove'].indexOf(type) > -1) {
            var target = root.__touchstartTarget;

            var event = root.__wrapEvent(e);

            event.target = target;

            while (target) {
              target.__emitEvent(event, null, true);

              target = target.__domParent;
            }
          } else {
            root.__cb(e);
          }
        }
      }

      dom.addEventListener(type, cb);
      list.push({
        type: type,
        cb: cb
      });
    });
    return list;
  }

  function removeEvent(dom, list) {
    list.forEach(function (item) {
      dom.removeEventListener(item.type, item.cb);
    });
  }

  var uuid = 0;

  var Root = /*#__PURE__*/function (_Dom) {
    _inherits(Root, _Dom);

    function Root(tagName, props, children) {
      var _this;

      _this = _Dom.call(this, tagName, props, children) || this;
      _this.__dom = null; // 真实DOM引用

      _this.__mw = 0; // 记录最大宽高，防止尺寸变化清除不完全

      _this.__mh = 0; // this.__scx = 1; // 默认缩放，css改变canvas/svg缩放后影响事件坐标，有值手动指定，否则自动计算
      // this.__scy = 1;

      _this.__task = []; // 更新样式异步刷新&回调

      _this.__taskClone = []; // 动画执行时可能会修改task，每帧执行前先clone出来防止被篡改

      _this.__frameTask = []; // 帧动画回调汇总

      _this.__ani = []; // 动画异步刷新&回调

      _this.__isAsyncDraw = false;
      _this.__pause = false;
      _this.__arList = []; // parse中dom的动画解析预存到Root上，layout后执行

      _this.__ref = {};
      _this.__freeze = false; // 冻住只计算不渲染

      _this.__animateController = new Controller();
      Event.mix(_assertThisInitialized(_this));
      _this.__uuid = uuid++;
      _this.__rlv = REBUILD; // 每次刷新最大lv

      _this.__lastUpdateP = null; // 每帧addUpdate都会向上检查，很多时候同级无需继续，第一次检查暂存parent对象
      // 开启wasm后，默认使用，除非显示取消

      if (wasm$1.instance && (props.wasm === undefined || props.wasm)) {
        _this.__wasmRoot = wasm$1.Root["new"]();
        _this.__wasmNode = wasm$1.Node["new"](false);
      } else {
        _this.__wasmRoot = null;
      }

      builder.buildRoot(_assertThisInitialized(_this), _this.__children);
      _this.__env = null; // 生成cacheTotal时会覆盖这个信息，得知当前离屏画布信息

      return _this;
    }

    _createClass(Root, [{
      key: "__initProps",
      value: function __initProps() {
        var w = this.props.width;

        if (!isNil$8(w)) {
          var value = parseFloat(w) || 0;

          if (value > 0) {
            this.__width = value;
          }
        }

        var h = this.props.height;

        if (!isNil$8(h)) {
          var _value = parseFloat(h) || 0;

          if (_value > 0) {
            this.__height = _value;
          }
        }
      }
    }, {
      key: "__genHtml",
      value: function __genHtml(domName) {
        var _this2 = this;

        var res = "<".concat(domName); // 拼接处理属性

        Object.keys(this.props).forEach(function (k) {
          var v = _this2.props[k]; // 忽略事件

          if (!/^on[a-zA-Z]/.test(k)) {
            res += renderProp(k, v);
          }
        });
        res += "></".concat(domName, ">");
        return res;
      }
    }, {
      key: "__wrapEvent",
      value: function __wrapEvent(e) {
        var x, y; // 触摸结束取消特殊没有touches

        if (['touchend', 'touchcancel'].indexOf(e.type) === -1) {
          var dom = this.dom,
              __scx = this.__scx,
              __scy = this.__scy;

          var _dom$getBoundingClien = dom.getBoundingClientRect(),
              x2 = _dom$getBoundingClien.x,
              y2 = _dom$getBoundingClien.y,
              left = _dom$getBoundingClien.left,
              top = _dom$getBoundingClien.top,
              width = _dom$getBoundingClien.width,
              height = _dom$getBoundingClien.height;

          x = x2 || left || 0;
          y = y2 || top || 0;

          var _ref = e.touches ? e.touches[0] : e,
              clientX = _ref.clientX,
              clientY = _ref.clientY;

          x = clientX - x;
          y = clientY - y; // 外边的scale影响元素事件响应，根据倍数计算真实的坐标，优先手动指定，否则自动计算

          if (!isNil$8(__scx)) {
            x /= __scx;
          } else {
            x *= this.__width / width;
          }

          if (!isNil$8(__scy)) {
            y /= __scy;
          } else {
            y *= this.__height / height;
          }
        }

        return {
          event: e,
          stopPropagation: function stopPropagation() {
            this.__stopPropagation = true;
            e.stopPropagation();
          },
          stopImmediatePropagation: function stopImmediatePropagation() {
            this.__stopPropagation = true;
            this.__stopImmediatePropagation = true;
            e.stopImmediatePropagation();
          },
          preventDefault: function preventDefault() {
            e.preventDefault();
          },
          x: x,
          y: y,
          __hasEmitted: false
        };
      } // 类似touchend/touchcancel/touchmove这种无需判断是否发生于元素上，直接响应

    }, {
      key: "__cb",
      value: function __cb(e) {
        if (e.type === 'touchmove' && !this.__touchstartTarget) {
          return;
        }

        var data = this.__wrapEvent(e);

        this.__emitEvent(data, null, false);

        return data;
      }
      /**
       * 添加到真实Dom上，优先已存在的同名canvas/svg节点，没有则dom下生成新的
       * @param dom
       */

    }, {
      key: "appendTo",
      value: function appendTo(dom) {
        dom = getDom(dom);
        this.__isDestroyed = false;

        this.__initProps();

        var tagName = this.__tagName;
        var domName = ROOT_DOM_NAME[tagName]; // OffscreenCanvas兼容，包含worker的

        if (typeof window !== 'undefined' && window.OffscreenCanvas && dom instanceof window.OffscreenCanvas || typeof self !== 'undefined' && self.OffscreenCanvas && dom instanceof self.OffscreenCanvas) {
          this.__dom = dom;
          this.__width = dom.width;
          this.__height = dom.height;
        } // 已有root节点
        else if (dom.nodeName.toLowerCase() === domName) {
          this.__dom = dom;

          if (this.__width) {
            dom.setAttribute('width', this.__width);
          }

          if (this.__height) {
            dom.setAttribute('height', this.__height);
          }
        } // 没有canvas/svg节点则生成一个新的
        else {
          this.__dom = dom.querySelector(domName);

          if (!this.__dom) {
            dom.innerHTML = this.__genHtml(domName);
            this.__dom = dom.querySelector(domName);
          } // 老的销毁
          else {
            var old = this.__dom.__root;

            if (old && old instanceof Root) {
              old.destroy();
            }
          }
        } // 没有设置width/height则采用css计算形式


        if (!this.__width || !this.__height) {
          var domCss = window.getComputedStyle(dom, null);

          if (!this.__width) {
            this.__width = parseFloat(domCss.getPropertyValue('width')) || 0;
            dom.setAttribute('width', this.width);
          }

          if (!this.__height) {
            this.__height = parseFloat(domCss.getPropertyValue('height')) || 0;
            dom.setAttribute('height', this.height);
          }
        } // 最终无宽高给出警告


        if (!this.__width || !this.__height) {
          inject.warn('karas render target with a width or height of 0.');
        }

        var params = Object.assign({}, ca, this.props.contextAttributes); // 只有canvas有ctx，svg用真实dom

        if (tagName === 'canvas') {
          this.__ctx = this.__dom.getContext('2d', params);
          this.__renderMode = mode.CANVAS;
        } else if (tagName === 'svg') {
          this.__defs = this.dom.__defs || Defs.getInstance(this.__uuid);
          this.__renderMode = mode.SVG;
        } else if (tagName === 'webgl') {
          // 优先手动指定，再自动判断，最后兜底
          var gl,
              webgl2 = this.props.webgl2;

          if (!isNil$8(webgl2)) {
            if (webgl2) {
              gl = this.__dom.getContext('webgl2', params);
            }

            if (!gl) {
              gl = this.__dom.getContext('webgl', params);
            }

            this.__ctx = gl;
          } else {
            gl = this.__ctx = this.__dom.getContext('webgl2', params) || this.__dom.getContext('webgl', params);
          }

          this.__initShader(gl);

          this.__renderMode = mode.WEBGL;
        }

        var wr = this.__wasmRoot;

        if (wr) {
          wr.mode = this.__renderMode;
        }

        this.draw(true);
        this.__eventCbList = initEvent(this.__dom, Root);
        this.__dom.__root = this;
        frame.addRoot(this);
      }
    }, {
      key: "__initShader",
      value: function __initShader(gl) {
        gl.program = webgl.initShaders(gl, vertex, fragment);
        gl.programMask = webgl.initShaders(gl, vertexMask, fragmentMask);
        gl.programClip = webgl.initShaders(gl, vertexMask, fragmentClip);
        gl.programOverflow = webgl.initShaders(gl, vertexOverflow, fragmentOverflow);
        gl.programCm = webgl.initShaders(gl, vertexCm, fragmentCm);
        gl.programDs = webgl.initShaders(gl, vertexDs, fragmentDs);
        gl.programMbmMp = webgl.initShaders(gl, vertexMbm, fragmentMultiply);
        gl.programMbmSr = webgl.initShaders(gl, vertexMbm, fragmentScreen);
        gl.programMbmOl = webgl.initShaders(gl, vertexMbm, fragmentOverlay);
        gl.programMbmDk = webgl.initShaders(gl, vertexMbm, fragmentDarken);
        gl.programMbmLt = webgl.initShaders(gl, vertexMbm, fragmentLighten);
        gl.programMbmCd = webgl.initShaders(gl, vertexMbm, fragmentColorDodge);
        gl.programMbmCb = webgl.initShaders(gl, vertexMbm, fragmentColorBurn);
        gl.programMbmHl = webgl.initShaders(gl, vertexMbm, fragmentHardLight);
        gl.programMbmSl = webgl.initShaders(gl, vertexMbm, fragmentSoftLight);
        gl.programMbmDf = webgl.initShaders(gl, vertexMbm, fragmentDifference);
        gl.programMbmEx = webgl.initShaders(gl, vertexMbm, fragmentExclusion);
        gl.programMbmHue = webgl.initShaders(gl, vertexMbm, fragmentHue);
        gl.programMbmSt = webgl.initShaders(gl, vertexMbm, fragmentSaturation);
        gl.programMbmCl = webgl.initShaders(gl, vertexMbm, fragmentColor);
        gl.programMbmLm = webgl.initShaders(gl, vertexMbm, fragmentLuminosity);
        gl.programSs = webgl.initShaders(gl, vertexSs, fragmentSs);
        gl.useProgram(gl.program);
      }
    }, {
      key: "__reLayout",
      value: function __reLayout() {
        var renderMode = this.renderMode,
            width = this.width,
            height = this.height;

        if (this.__renderMode === mode.WEBGL) {
          this.ctx.viewport(0, 0, width, height);
        }

        this.__checkRoot(renderMode, width, height);

        var wm = this.__currentStyle[WRITING_MODE];
        var isUpright = wm.v && wm.v.indexOf('vertical') === 0; // 布局分为两步，普通流和定位流，互相递归

        this.__layout({
          x: 0,
          y: 0,
          w: width,
          h: height,
          isUpright: isUpright
        }, false, false, false); // 绝对布局需要从根开始保存相对坐标系的容器引用，并根据relative/absolute情况变更


        this.__layoutAbs(this, {
          x: 0,
          y: 0,
          w: width,
          h: height,
          isUpright: isUpright
        }, null);

        var s = this.__structs = this.__structure(0, 0);

        var wr = this.__wasmRoot;

        if (wr) {
          wr.font_size = this.__computedStyle[FONT_SIZE];
          wr.clear();

          for (var i = 0, len = s.length; i < len; i++) {
            var node = s[i].node;

            if (node instanceof Component) {
              node = node.shadowRoot;
            }

            var wn = node.__wasmNode; // 一定有

            wr.add_node(wn.ptr);
          }
        }

        this.__checkAr();
      }
    }, {
      key: "draw",
      value: function draw(isFirst) {
        var isDestroyed = this.isDestroyed,
            renderMode = this.renderMode,
            ctx = this.ctx,
            defs = this.defs;

        if (isDestroyed) {
          return;
        }

        this.__lastUpdateP = null; // 首次递归测量整树的继承，后续更改各自更新机制做，防止每次整树遍历；root检查首次直接做，后续在checkUpdate()中插入

        if (isFirst) {
          this.__reLayout();
        }

        var wr = this.__wasmRoot;

        if (wr) {
          wr.refresh();
        }

        var rlv = this.__rlv;
        this.__rlv = NONE; // freeze()冻住不渲染

        if (this.props.noRender || this.__freeze) {
          this.emit(Event.REFRESH, rlv, true);
          return;
        }

        if (renderMode === mode.CANVAS) {
          this.__clearCanvas(ctx);

          renderCanvas(renderMode, ctx, this, isFirst, rlv);
        } // svg的特殊diff需要
        else if (renderMode === mode.SVG) {
          defs.clear();
          renderSvg(renderMode, defs, this, isFirst, rlv);
          var nvd = this.virtualDom;
          nvd.defs = defs.value;
          var dom = this.__dom;

          if (dom.__vd) {
            // console.log(this.dom.__vd);
            // console.log(nvd);
            diff(dom, dom.__vd, nvd);
          } else {
            dom.innerHTML = util.joinVirtualDom(nvd);
          }

          dom.__vd = nvd;
          dom.__defs = defs;
        } else if (renderMode === mode.WEBGL) {
          this.__clearWebgl(ctx);

          renderWebgl(renderMode, ctx, this, isFirst, rlv);
        }

        this.emit(Event.REFRESH, rlv, false);
      }
    }, {
      key: "remove",
      value: function remove() {
        _get(_getPrototypeOf(Root.prototype), "remove", this).call(this);

        this.destroy();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.children.forEach(function (item) {
          item.remove();
        });

        this.__destroy();

        frame.removeRoot(this);

        this.__animateController.__destroy();

        var n = this.dom;

        if (n) {
          removeEvent(n, this.__eventCbList || []);
          delete n.__root;
        }

        this.__dom = null;
        var gl = this.__ctx;

        if (this.renderMode === mode.CANVAS) {
          this.__clearCanvas(gl);
        } else if (this.renderMode === mode.WEBGL) {
          this.__clearWebgl(gl);

          ['program', 'programMask', 'programClip', 'programOverflow', 'programCm', 'programDs', 'programMbmMp', 'programMbmSr', 'programMbmOl', 'programMbmDk', 'programMbmLt', 'programMbmCd', 'programMbmCb', 'programMbmHl', 'programMbmSl', 'programMbmDf', 'programMbmEx', 'programMbmHue', 'programMbmSt', 'programMbmCl', 'programMbmLm', 'programSs'].forEach(function (k) {
            var p = gl[k];
            gl.deleteShader(p.vertexShader);
            gl.deleteShader(p.fragmentShader);
            gl.deleteProgram(p);
            delete gl[k];
          });

          for (var i in gl) {
            if (i.indexOf('programBlur,') === 0) {
              var p = gl[i];
              gl.deleteShader(p.vertexShader);
              gl.deleteShader(p.fragmentShader);
              gl.deleteProgram(p);
              delete gl[i];
            }
          }

          gl.bindTexture(gl.TEXTURE_2D, null); // gl.getExtension('WEBGL_lose_context').loseContext();
        }

        this.__ctx = gl = null;
        var wr = this.__wasmRoot;

        if (wr) {
          wr.clear();
          wr.free();
          this.__wasmRoot = null;
        }
      }
    }, {
      key: "scale",
      value: function scale() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
        this.__scx = x;
        this.__scy = y;
      }
    }, {
      key: "resize",
      value: function resize(w, h, cb) {
        var self = this;

        if (w !== self.width || h !== self.height) {
          self.__width = w;
          self.__height = h;
          self.updateStyle({
            width: w,
            height: h
          }, cb);
        } else if (isFunction$1(cb)) {
          cb(-1);
        }

        var wr = this.__wasmRoot;

        if (wr) {
          wr.resize(w, h);
        }
      }
    }, {
      key: "getTargetAtPoint",
      value: function getTargetAtPoint(x, y, includeIgnore) {
        function scan(vd, x, y, path, zPath) {
          var __x1 = vd.__x1,
              __y1 = vd.__y1,
              offsetWidth = vd.offsetWidth,
              offsetHeight = vd.offsetHeight,
              matrixEvent = vd.matrixEvent,
              children = vd.children,
              zIndexChildren = vd.zIndexChildren,
              _vd$computedStyle = vd.computedStyle,
              display = _vd$computedStyle[DISPLAY],
              pointerEvents = _vd$computedStyle[POINTER_EVENTS];

          if (!includeIgnore && display === 'none') {
            return;
          }

          if (Array.isArray(zIndexChildren)) {
            for (var i = 0, len = children.length; i < len; i++) {
              children[i].__index__ = i;
            }

            for (var _i = zIndexChildren.length - 1; _i >= 0; _i--) {
              var item = zIndexChildren[_i];

              if (item instanceof karas.Text) {
                continue;
              }

              var path2 = path.slice();
              path2.push(item.__index__);
              var zPath2 = zPath.slice();
              zPath2.push(_i);
              var res = scan(item, x, y, path2, zPath2);

              if (res) {
                return res;
              }
            }
          }

          if (!includeIgnore && pointerEvents === 'none') {
            return;
          }

          var inThis = geom.pointInQuadrilateral(x, y, __x1, __y1, __x1 + offsetWidth, __y1, __x1 + offsetWidth, __y1 + offsetHeight, __x1, __y1 + offsetHeight, matrixEvent);

          if (inThis) {
            return {
              target: vd,
              path: path,
              zPath: zPath
            };
          }
        }

        return scan(this, x, y, [], []);
      }
      /**
       * 每次刷新前检查root节点的样式，有些固定的修改无效，有些继承的作为根初始化
       * @param renderMode
       * @param width
       * @param height
       * @private
       */

    }, {
      key: "__checkRoot",
      value: function __checkRoot(renderMode, width, height) {
        var dom = this.dom,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __wasmRoot = this.__wasmRoot; // canvas/svg作为根节点一定是block或flex，不会是inline

        if (['flex', 'block'].indexOf(currentStyle[DISPLAY]) === -1) {
          computedStyle[DISPLAY] = currentStyle[DISPLAY] = 'block';
        } // 同理position不能为absolute


        if (currentStyle[POSITION] === 'absolute') {
          computedStyle[POSITION] = currentStyle[POSITION] = 'static';
        } // 根节点满宽高


        currentStyle[WIDTH] = {
          v: width,
          u: PX
        };
        currentStyle[HEIGHT] = {
          v: height,
          u: PX
        };
        computedStyle[WIDTH] = width;
        computedStyle[HEIGHT] = height; // 可能调用resize()导致变更，要重设，canvas无论离屏与否都可使用直接赋值，svg则按dom属性api

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          if (dom.width !== width) {
            dom.width = width;
          }

          if (dom.height !== height) {
            dom.height = height;
          }
        } else if (renderMode === mode.SVG) {
          dom.setAttribute('width', width);
          dom.setAttribute('height', height);
        }

        if (__wasmRoot) {
          __wasmRoot.resize(width, height);
        }
      }
      /**
       * 添加更新，分析repaint/reflow和上下影响，异步刷新
       * sync是动画在gotoAndStop的时候，下一帧刷新由于一帧内同步执行计算标识true
       * wasmChange比较特殊，仅在gotoAndStop的时候用到，可能变化完全在wasm中js没有keys和lv，需强制刷新
       */

    }, {
      key: "__addUpdate",
      value: function __addUpdate(node, keys, focus, addDom, removeDom, sync, wasmChange, cb) {
        if (this.__isDestroyed) {
          return;
        }

        if (node instanceof Component) {
          node = node.shadowRoot;
        }

        var _node = node,
            computedStyle = _node.__computedStyle,
            cacheStyle = _node.__cacheStyle,
            __cacheProps = _node.__cacheProps;
        var hasZ, hasVisibility, hasColor, hasDisplay, hasTsColor, hasTsWidth, hasTsOver; // 可能无keys但有aniParams，多防御一下，比如steps动画

        var lv = focus || NONE; // 清空对应改变的cacheStyle

        if (keys) {
          for (var i = 0, len = keys.length; i < len; i++) {
            var k = keys[i];

            if (node instanceof Geom && isGeom(node.__tagName, k)) {
              lv |= REPAINT;
              __cacheProps[k] = undefined;
            } else {
              // repaint置空，如果reflow会重新生成空的
              cacheStyle[k] = undefined; // TRBL变化只对relative/absolute起作用，其它忽视

              if ((k === TOP || k === RIGHT || k === BOTTOM || k === LEFT) && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) === -1) {
                continue;
              } // 细化等级


              lv |= getLevel(k);

              if (k === DISPLAY) {
                hasDisplay = true;
              } else if (k === Z_INDEX) {
                hasZ = node !== this && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) > -1;
              } else if (k === VISIBILITY) {
                hasVisibility = true;
              } else if (k === COLOR) {
                hasColor = true;
              } else if (k === TEXT_STROKE_COLOR) {
                hasTsColor = true;
              } else if (k === TEXT_STROKE_WIDTH) {
                hasTsWidth = true;
              } else if (k === TEXT_STROKE_OVER) {
                hasTsOver = true;
              }
            }
          }
        }

        var res = this.__calUpdate(node, computedStyle, cacheStyle, lv, hasDisplay, hasVisibility, hasZ, hasColor, hasTsColor, hasTsWidth, hasTsOver, addDom, removeDom); // 动画在最后一帧要finish或者cancel时，特殊调用同步计算无需刷新，不会有cb


        if (sync) {
          if (res) {
            this.__aniChange = true;
          }

          return;
        } // wasm动画变更可能会无keys和lv，需要强制刷新


        if (res || wasmChange) {
          this.__asyncDraw(cb);
        } else {
          cb && cb(true);
        }
      }
    }, {
      key: "__addAniUpdate",
      value: function __addAniUpdate(node, trans, fixed, frame) {
        // diff为0或者极端跳帧情况相同时无变化
        if (this.__isDestroyed) {
          return;
        }

        var computedStyle = node.__computedStyle,
            cacheStyle = node.__cacheStyle,
            cacheProps = node.__cacheProps;
        var hasZ, hasVisibility, hasColor, hasDisplay, hasTsColor, hasTsWidth, hasTsOver;
        hasColor = frame.hasColor;
        hasTsColor = frame.hasTsColor;
        hasTsWidth = frame.hasTsWidth;
        hasTsOver = frame.hasTsOver;
        var ignoreTRBL = false;
        var lv = frame.lv || NONE;
        var len = trans.length;

        for (var i = 0; i < len; i++) {
          var k = trans[i];

          if (frame.isGeom && node instanceof Geom && isGeom(node.__tagName, k)) {
            cacheProps[k] = undefined;
          } else {
            // repaint置空，如果reflow会重新生成空的
            cacheStyle[k] = undefined; // TRBL变化只对relative/absolute起作用，其它忽视，如果position也变化会重新布局生效

            if ((k === TOP || k === RIGHT || k === BOTTOM || k === LEFT) && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) === -1) {
              ignoreTRBL = true;
            } // 特殊处理，z变化也只对非flow生效
            else if (k === Z_INDEX) {
              hasZ = node !== this && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) > -1;
            }
          }
        }

        var fLen = fixed.length;

        for (var _i2 = 0, _len = fLen; _i2 < _len; _i2++) {
          var _k = fixed[_i2];
          lv |= getLevel(_k);
          cacheStyle[_k] = undefined; // 特殊的2个，影响是否需要刷新生效

          if (_k === DISPLAY) {
            hasDisplay = true;
          } else if (_k === VISIBILITY) {
            hasVisibility = true;
          }
        } // 无效的变化


        if (ignoreTRBL && len === 1 && !fLen) {
          return;
        } // 设置有动画造成了更新


        this.__aniChange = true;

        this.__calUpdate(node, computedStyle, cacheStyle, lv, hasDisplay, hasVisibility, hasZ, hasColor, hasTsColor, hasTsWidth, hasTsOver, false, false);
      } // wasm的动画更新外部不知道改了啥（性能），其内部倒是知道，这里检查mask和向上清空cache影响

    }, {
      key: "__addWasmAniUpdate",
      value: function __addWasmAniUpdate(node) {
        var computedStyle = node.__computedStyle,
            __mask = node.__mask,
            __hasMask = node.__hasMask,
            __domParent = node.__domParent; // 没有变化或none无需刷新

        if (computedStyle[DISPLAY] === 'none') {
          return false;
        } // mask需清除遮罩对象的缓存


        var hasRelease;

        if (__mask) {
          var prev = node.__prev;

          while (prev && prev.__mask) {
            prev = prev.__prev;
          }

          if (prev && (prev instanceof Xom || prev instanceof Component && prev.shadowRoot instanceof Xom)) {
            prev.__refreshLevel |= CACHE | MASK;
            prev.__struct.hasMask = prev.__hasMask = __mask;

            if (prev.__cacheMask) {
              hasRelease = prev.__cacheMask.release() || hasRelease;
            }
          }
        } // mask无论如何都要清除，除非是opacity/ppt，这里因为wasm只考虑opacity


        if (__hasMask) {
          var lv = node.__wasmNode.refresh_level;

          if (lv ^ OP) {
            if (node.__cacheMask) {
              hasRelease = node.__cacheMask.release() || hasRelease;
            }

            if (node.__cacheFilter) {
              hasRelease = node.__cacheFilter.release() || hasRelease;
            }
          }
        } // 除了清空cache，Root的rlv需要标识向上情况，这样webgl的渲染不会使用老的队列缓存


        if (hasRelease) {
          node.__updateCache();
        }

        if (__domParent !== this.__lastUpdateP) {
          var p = __domParent;
          this.__lastUpdateP = p; // 同层级避免重复进入查找，每次draw()重设

          while (p) {
            if (p.__refreshLevel & (CACHE | REPAINT | REFLOW)) {
              break;
            }

            p.__refreshLevel |= CACHE;

            if (p.__cacheTotal) {
              hasRelease = p.__cacheTotal.release() || hasRelease;
            }

            if (p.__cacheFilter) {
              hasRelease = p.__cacheFilter.release() || hasRelease;
            }

            if (p.__cacheMask) {
              hasRelease = p.__cacheMask.release() || hasRelease;
            }

            if (hasRelease) {
              p.__updateCache();
            }

            p = p.__domParent;
          }
        }

        if (hasRelease) {
          this.__rlv |= CACHE;
        }
      }
    }, {
      key: "__calUpdate",
      value: function __calUpdate(node, computedStyle, cacheStyle, lv, hasDisplay, hasVisibility, hasZ, hasColor, hasTsColor, hasTsWidth, hasTsOver, addDom, removeDom) {
        var currentStyle = node.__currentStyle,
            __mask = node.__mask,
            __domParent = node.__domParent; // 防御一下

        if (addDom || removeDom) {
          lv |= REFLOW;
        } // 没有变化或none无需刷新


        if (lv === NONE || computedStyle[DISPLAY] === 'none' && !hasDisplay) {
          return false;
        } // transform变化清空重算，比较特殊，MATRIX的cache需手动清理


        if (lv & TF) {
          cacheStyle[MATRIX] = computedStyle[TRANSFORM] = undefined;
        } // mask需清除遮罩对象的缓存


        var hasRelease,
            hasMask = lv & MASK;

        if (__mask || hasMask) {
          var prev = node.__prev;

          while (prev && prev.__mask) {
            prev = prev.__prev;
          }

          if (prev && (prev instanceof Xom || prev instanceof Component && prev.shadowRoot instanceof Xom)) {
            prev.__refreshLevel |= CACHE | MASK;
            prev.__struct.hasMask = prev.__hasMask = __mask;

            if (prev.__cacheMask) {
              hasRelease = prev.__cacheMask.release() || hasRelease;
            }
          }
        } // wasm的特殊更新，不管lv多少只要有transform和op都得计算


        if (lv & TRANSFORM_ALL) {
          var wn = node.__wasmNode;

          if (wn) {
            wn.cal_matrix(lv & TRANSFORM_ALL);
          }
        } // 大部分动画都是repaint初始化已经知道


        var isRf = isReflow(lv);

        if (isRf) {
          var top = reflow.checkTop(this, node, addDom, removeDom);

          if (top === this) {
            this.__reLayout();
          } // 布局影响next的所有节点，重新layout的w/h数据使用之前parent暂存的，x使用parent，y使用prev或者parent的
          else {
            reflow.checkNext(this, top, node, hasZ, addDom, removeDom);

            this.__checkAr();
          }

          if (removeDom) {
            var temp = node;

            while (temp.isShadowRoot) {
              temp = temp.__host;

              temp.__destroy();
            }

            node.__destroy();
          }
        } else {
          // dom在>=REPAINT时total失效，svg的Geom比较特殊
          var need = lv >= REPAINT;

          if (need) {
            if (node.__cache) {
              hasRelease = node.__cache.release() || hasRelease;
            }

            node.__calStyle(lv, currentStyle, computedStyle, cacheStyle);

            node.__calPerspective(currentStyle, computedStyle, cacheStyle);
          } // < REPAINT特殊的优化computedStyle计算
          else {
            if (lv & PPT) {
              node.__calPerspective(currentStyle, computedStyle, cacheStyle);
            }

            if (lv & TRANSFORM_ALL || lv & OP) {
              var _wn = node.__wasmNode;

              if (_wn) ; else {
                if (lv & TRANSFORM_ALL) {
                  var o = node.__selfPerspectiveMatrix;

                  node.__calMatrix(lv, currentStyle, computedStyle, cacheStyle);

                  var n = node.__selfPerspectiveMatrix;

                  if (!need && !util.equalArr(o, n)) {
                    need = true;
                  }
                }

                if (lv & OP) {
                  computedStyle[OPACITY] = currentStyle[OPACITY];
                }
              }
            }

            if (lv & FT) {
              node.__calFilter(currentStyle, computedStyle, cacheStyle);
            }

            if (lv & MBM) {
              computedStyle[MIX_BLEND_MODE] = currentStyle[MIX_BLEND_MODE];
            } // 暂时这样，缺少lv


            if (hasZ) {
              computedStyle[Z_INDEX] = currentStyle[Z_INDEX];
            }
          } // 影响子继承REPAINT的变化，如果被cache住需要清除


          if (hasVisibility || hasColor || hasTsColor || hasTsWidth || hasTsOver) {
            for (var __structs = this.__structs, __struct = node.__struct, i = __structs.indexOf(__struct) + 1, len = i + (__struct.total || 0); i < len; i++) {
              var _structs$i = __structs[i],
                  _node2 = _structs$i.node,
                  total = _structs$i.total,
                  isText = _structs$i.isText; // text的style指向parent，不用管

              if (isText) {
                continue;
              }

              var _currentStyle = _node2.__currentStyle,
                  _cacheStyle = _node2.__cacheStyle;

              var _need = void 0;

              if (hasVisibility && _currentStyle[VISIBILITY].u === INHERIT) {
                _need = true;
                _cacheStyle[VISIBILITY] = undefined;
              } else if (hasColor && _currentStyle[COLOR].u === INHERIT) {
                _need = true;
                _cacheStyle[COLOR] = undefined;
              } else if (hasTsColor && _currentStyle[TEXT_STROKE_COLOR].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_COLOR] = undefined;
              } else if (hasTsWidth && _currentStyle[TEXT_STROKE_WIDTH].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_WIDTH] = undefined;
              } else if (hasTsOver && _currentStyle[TEXT_STROKE_OVER].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_OVER] = undefined;
              }

              if (_need) {
                _node2.__refreshLevel |= REPAINT;

                _node2.clearCache();

                _node2.__calStyle(REPAINT, _currentStyle, _node2.__computedStyle, _cacheStyle);
              } // 不为inherit此子树可跳过，因为不影响
              else {
                i += total || 0;
              }
            }
          } // perspective也特殊只清空total的cache，和>=REPAINT清空total共用


          if (need || lv & PPT) {
            if (node.__cacheTotal) {
              hasRelease = node.__cacheTotal.release() || hasRelease;
            }
          } // mask无论如何都要清除，除非是opacity/ppt，其它变化需要重新生成


          if (node.__hasMask) {
            if (need || lv ^ OP || lv & PPT) {
              if (node.__cacheMask) {
                hasRelease = node.__cacheMask.release() || hasRelease;
              }

              if (node.__cacheFilter) {
                hasRelease = node.__cacheFilter.release() || hasRelease;
              }
            }
          } // 特殊的filter清除cache
          else if ((need || lv & (FT | PPT)) && node.__cacheFilter) {
            hasRelease = node.__cacheFilter.release() || hasRelease;
          } // 更新cacheTarget有效指向


          if (hasRelease) {
            node.__updateCache();
          } // 向上清除cache汇总缓存信息，过程中可能会出现重复，根据refreshLevel判断，reflow已经自己清过了


          if (__domParent !== this.__lastUpdateP) {
            var p = __domParent;
            this.__lastUpdateP = p; // 同层级避免重复进入查找，每次draw()重设

            while (p) {
              if (p.__refreshLevel & (CACHE | REPAINT | REFLOW)) {
                break;
              }

              p.__refreshLevel |= CACHE;

              if (p.__cacheTotal) {
                hasRelease = p.__cacheTotal.release() || hasRelease;
              }

              if (p.__cacheFilter) {
                hasRelease = p.__cacheFilter.release() || hasRelease;
              }

              if (p.__cacheMask) {
                hasRelease = p.__cacheMask.release() || hasRelease;
              }

              if (hasRelease) {
                p.__updateCache();
              }

              p = p.__domParent;
            }
          } // 清除parent的zIndexChildren缓存，强制所有孩子重新渲染，父节点下可能多个子节点重复调用


          if (hasZ && __domParent) {
            __domParent.__zIndexChildren = null;

            __domParent.__updateStruct();

            if (this.__renderMode === mode.SVG) {
              hasRelease = node.__cacheTotal.release() || hasRelease;
              reflow.clearSvgCache(__domParent);
            }
          }
        }

        node.__refreshLevel |= lv; // 有被清除的cache则设置到Root上

        if (hasRelease) {
          lv |= CACHE;
        }

        this.__rlv |= lv;

        if (addDom || removeDom) {
          this.__rlv |= REBUILD;
        }

        return true;
      } // 所有动画由Root代理，方便控制pause，主动更新时参数传null复用，
      // 注意逻辑耦合，任意动画/主动更新第一次触发时，需把ani和task的队列填充，以防重复onFrame调用

    }, {
      key: "__asyncDraw",
      value: function __asyncDraw(cb) {
        if (!this.__isAsyncDraw) {
          frame.onFrame(this);
          this.__isAsyncDraw = true;
        }

        this.__task.push(cb);
      }
    }, {
      key: "__cancelAsyncDraw",
      value: function __cancelAsyncDraw(cb) {
        if (!cb) {
          return;
        }

        var task = this.__task;
        var i = task.indexOf(cb);

        if (i > -1) {
          task.splice(i, 1);

          if (!task.length && !this.__frameTask.length && !this.__ani.length) {
            frame.offFrame(this);
            this.__isAsyncDraw = false;
          }
        }
      }
    }, {
      key: "__onFrame",
      value: function __onFrame(cb) {
        if (!this.__isAsyncDraw) {
          frame.onFrame(this);
          this.__isAsyncDraw = true;
        }

        this.__frameTask.push(cb);
      }
    }, {
      key: "__offFrame",
      value: function __offFrame(cb) {
        if (!cb) {
          return;
        }

        var frameTask = this.__frameTask;
        var i = frameTask.indexOf(cb);

        if (i > -1) {
          frameTask.splice(i, 1);

          if (!frameTask.length && !this.__task.length && !this.__ani.length) {
            frame.offFrame(this);
            this.__isAsyncDraw = false;
          }
        }
      }
    }, {
      key: "__onAniFrame",
      value: function __onAniFrame(animation) {
        if (!this.__isAsyncDraw) {
          frame.onFrame(this);
          this.__isAsyncDraw = true;
        }

        this.__ani.push(animation);
      }
    }, {
      key: "__offAniFrame",
      value: function __offAniFrame(animation) {
        var ani = this.__ani;
        var i = ani.indexOf(animation);

        if (i > -1) {
          ani.splice(i, 1);

          if (!ani.length && !this.__task.length && !this.__frameTask.length) {
            frame.offFrame(this);
            this.__isAsyncDraw = false;
          }
        }
      }
      /**
       * 每帧调用Root的before回调，先将存储的动画before执行，触发数据先变更完，然后若有变化或主动更新则刷新
       * wasm的执行也放在和动画__before一起，先后顺序无要求
       */

    }, {
      key: "__before",
      value: function __before(diff) {
        var ani = this.__ani,
            len = ani.length,
            task = this.__taskClone = this.__task.splice(0),
            len2 = task.length,
            frameTask = this.__frameTask,
            len3 = frameTask.length; // 先重置标识，动画没有触发更新，在每个__before执行，如果调用了更新则更改标识


        this.__aniChange = false;

        if (!this.__pause) {
          var wr = this.__wasmRoot; // wasm的动画计算顺序要放在前面，因为其他动画可能包含REPAINT/REFLOW之类的变更，涵盖wasm的transform/opacity

          if (wr) {
            var n = wr.before(diff); // 有动画执行了需刷新

            if (n) {
              this.__aniChange = true;
            }
          }

          for (var i = 0; i < len; i++) {
            var a = ani[i];

            var r = a.__before(diff); // 返回true说明完全被wasm动画代理，非true则是其它，更新逻辑会包含wasm的


            if (r) {
              this.__addWasmAniUpdate(a.__target);
            }
          }
        }

        if (this.__aniChange || len2 || len3) {
          this.draw(false);
        }
      }
      /**
       * 每帧调用的Root的after回调，将所有动画的after执行，以及主动更新的回调执行
       * 当都清空的时候，取消raf对本Root的侦听
       */

    }, {
      key: "__after",
      value: function __after(diff) {
        var ani = this.__ani.slice(0),
            len = ani.length,
            task = this.__taskClone.splice(0),
            len2 = task.length,
            frameTask = this.__frameTask.slice(0),
            len3 = frameTask.length; // 动画用同一帧内的pause判断，ani的after可能会改变队列（比如结束），需要先制作副本


        var pause = this.__pause;

        if (!pause) {
          var wr = this.__wasmRoot;
          /**
           * 有wasm需要特殊对待，首先要保证动画的执行顺序，主体仍然是每个动画依次执行after，和before的顺序对应，
           * 但wasm存在的话不可能一个个去执行，通信消耗过大，所以是先执行所有的wasm动画，计算transform和opacity，
           * 然后是每个普通js动画执行after。
           * 普通的动画中如果完全被wasm替代计算了，会有ignore标识，before不再执行，
           * 但after需要执行且需要wasm那边的数据，比如是否begin、end、finish的状态。
           * 多个动画可能会出现混合状态，即有的有wasm有的没有，有的被wasm完全替代有的没有，
           * 这时候wasm动画数量和顺序和普通js动画对应不上，获取数据需注意，在普通js动画中有变量可以识别是否有wasm动画，
           * 以此为手段，在遍历普通js动画中，可以增加偏移量来解决获取对应wasm动画索引的问题。
           */

          if (wr) {
            var n = wr.after();
            var states; // 有n个长度的动画，取共享内存的状态，数量一定和before对得上

            if (n) {
              states = new Uint8Array(wasm$1.instance.memory.buffer, wr.am_states_ptr(), n);
            }

            var offset = 0; // 偏移计数器

            for (var i = 0; i < len; i++) {
              var a = ani[i];

              if (a.__wasmAnimation) {
                var s = states[i - offset]; // 0是fps中忽略，1是普通frame事件，2是begin，4是end，8是finish

                if (s & 2) {
                  a.__begin = true;
                }

                if (s & 4) {
                  a.__end = true;
                }

                if (s & 8) {
                  a.__finished = true;
                }
              } // 普通js动画无wasm也就是共享数据中不占队列，除了执行外要标识偏移++，如果下一个动画有wasm的话，索引要保持正确
              else {
                offset++;
              }

              a.__after();
            }
          } // 没有wasm普通遍历执行动画列表
          else {
            for (var _i3 = 0; _i3 < len; _i3++) {
              ani[_i3].__after();
            }
          }

          for (var _i4 = 0; _i4 < len3; _i4++) {
            var item = frameTask[_i4];
            item && item(diff);
          }
        } // frameDraw不受pause影响，即主动更新样式之类非动画/帧动画


        for (var _i5 = 0; _i5 < len2; _i5++) {
          var _item = task[_i5];
          _item && _item();
        }

        len = this.__ani.length; // 动画和渲染任务可能会改变自己的任务队列

        len2 = this.__task.length;
        len3 = this.__frameTask.length;

        if (!len && !len2 && !len3) {
          frame.offFrame(this);
          this.__isAsyncDraw = false;
        }
      }
    }, {
      key: "__clearCanvas",
      value: function __clearCanvas(ctx) {
        // 可能会调整宽高，所以每次清除用最大值
        this.__mw = Math.max(this.__mw, this.width);
        this.__mh = Math.max(this.__mh, this.height); // 清除前得恢复默认matrix，防止每次布局改变了属性

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.__mw, this.__mh);
      }
    }, {
      key: "__clearWebgl",
      value: function __clearWebgl(ctx) {
        ctx.clearColor(0, 0, 0, 0);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
      }
    }, {
      key: "freeze",
      value: function freeze() {
        if (!this.__freeze) {
          this.__freeze = true;
          this.emit(Event.FREEZE);
        }
      }
    }, {
      key: "unFreeze",
      value: function unFreeze() {
        if (this.__freeze) {
          this.__freeze = false;
          this.emit(Event.UN_FREEZE);
        }
      }
    }, {
      key: "pause",
      value: function pause() {
        this.__pause = true;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.__pause = false;
      }
    }, {
      key: "__addAr",
      value: function __addAr(node) {
        this.__arList.push(node);
      }
    }, {
      key: "__checkAr",
      value: function __checkAr() {
        var list = this.__arList.splice(0);

        for (var i = 0, len = list.length; i < len; i++) {
          list[i].__execAr();
        }
      }
    }, {
      key: "dom",
      get: function get() {
        return this.__dom;
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "renderMode",
      get: function get() {
        return this.__renderMode;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__ctx;
      }
    }, {
      key: "defs",
      get: function get() {
        return this.__defs;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "animateController",
      get: function get() {
        return this.__animateController;
      }
    }]);

    return Root;
  }(Dom);

  /**
   * 二阶贝塞尔曲线范围框
   * @param x0
   * @param y0
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @returns {number[]}
   * https://www.iquilezles.org/www/articles/bezierbbox/bezierbbox.htm
   */

  function bboxBezier2(x0, y0, x1, y1, x2, y2) {
    var minX = Math.min(x0, x2);
    var minY = Math.min(y0, y2);
    var maxX = Math.max(x0, x2);
    var maxY = Math.max(y0, y2); // 控制点位于边界内部时，边界就是范围框，否则计算导数获取极值

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY) {
      var tx = (x0 - x1) / (x0 - 2 * x1 + x2);

      if (isNaN(tx) || tx < 0) {
        tx = 0;
      } else if (tx > 1) {
        tx = 1;
      }

      var ty = (y0 - y1) / (y0 - 2 * y1 + y2);

      if (isNaN(ty) || ty < 0) {
        ty = 0;
      } else if (ty > 1) {
        ty = 1;
      }

      var sx = 1 - tx;
      var sy = 1 - ty;
      var qx = sx * sx * x0 + 2 * sx * tx * x1 + tx * tx * x2;
      var qy = sy * sy * y0 + 2 * sy * ty * y1 + ty * ty * y2;
      minX = Math.min(minX, qx);
      minY = Math.min(minY, qy);
      maxX = Math.max(maxX, qx);
      maxY = Math.max(maxY, qy);
    }

    return [minX, minY, maxX, maxY];
  }
  /**
   * 同上三阶的
   */


  function bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3) {
    var minX = Math.min(x0, x3);
    var minY = Math.min(y0, y3);
    var maxX = Math.max(x0, x3);
    var maxY = Math.max(y0, y3);

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY || x2 < minX || y2 < minY || x2 > maxX || y2 > maxY) {
      var cx = -x0 + x1;
      var cy = -y0 + y1;
      var bx = x0 - 2 * x1 + x2;
      var by = y0 - 2 * y1 + y2;
      var ax = -x0 + 3 * x1 - 3 * x2 + x3;
      var ay = -y0 + 3 * y1 - 3 * y2 + y3;
      var hx = bx * bx - ax * cx;
      var hy = by * by - ay * cy;

      if (hx > 0) {
        hx = Math.sqrt(hx);
        var t = (-bx - hx) / ax; // 2次项系数为0注意降级为一元一次方程

        if (ax && t > 0 && t < 1) {
          var s = 1 - t;
          var q = s * s * s * x0 + 3 * s * s * t * x1 + 3 * s * t * t * x2 + t * t * t * x3;
          minX = Math.min(minX, q);
          maxX = Math.max(maxX, q);
        }

        t = ax ? (-bx + hx) / ax : -cx * 0.5 / bx;

        if (t > 0 && t < 1) {
          var _s = 1 - t;

          var _q = _s * _s * _s * x0 + 3 * _s * _s * t * x1 + 3 * _s * t * t * x2 + t * t * t * x3;

          minX = Math.min(minX, _q);
          maxX = Math.max(maxX, _q);
        }
      }

      if (hy > 0) {
        hy = Math.sqrt(hy);

        var _t = (-by - hy) / ay;

        if (ay && _t > 0 && _t < 1) {
          var _s2 = 1 - _t;

          var _q2 = _s2 * _s2 * _s2 * y0 + 3 * _s2 * _s2 * _t * y1 + 3 * _s2 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q2);
          maxY = Math.max(maxY, _q2);
        }

        _t = ay ? (-by + hy) / ay : -cy * 0.5 / by;

        if (_t > 0 && _t < 1) {
          var _s3 = 1 - _t;

          var _q3 = _s3 * _s3 * _s3 * y0 + 3 * _s3 * _s3 * _t * y1 + 3 * _s3 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q3);
          maxY = Math.max(maxY, _q3);
        }
      }
    }

    return [minX, minY, maxX, maxY];
  }

  function bboxBezier(x0, y0, x1, y1, x2, y2, x3, y3) {
    var len = arguments.length;

    if (Array.isArray(x0)) {
      var l = x0.length;
      var arr = x0;

      var _arr$ = _slicedToArray(arr[0], 2);

      x0 = _arr$[0];
      y0 = _arr$[1];

      var _arr$2 = _slicedToArray(arr[1], 2);

      x1 = _arr$2[0];
      y1 = _arr$2[1];
      len = 4;

      if (l >= 3) {
        var _arr$3 = _slicedToArray(arr[2], 2);

        x2 = _arr$3[0];
        y2 = _arr$3[1];
        len = 6;
      }

      if (l >= 4) {
        var _arr$4 = _slicedToArray(arr[3], 2);

        x3 = _arr$4[0];
        y3 = _arr$4[1];
        len = 8;
      }
    }

    if (len === 4) {
      var a = Math.min(x0, x1);
      var b = Math.min(y0, y1);
      var c = Math.max(x0, x1);
      var d = Math.max(y0, y1);
      return [a, b, c, d];
    }

    if (len === 6) {
      return bboxBezier2(x0, y0, x1, y1, x2, y2);
    }

    if (len === 8) {
      return bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3);
    }
  }
  /**
   * 范数 or 模
   */


  function norm(v) {
    var order = v.length;
    var sum = v.reduce(function (a, b) {
      return Math.pow(a, order) + Math.pow(b, order);
    });
    return Math.pow(sum, 1 / order);
  } // https://zhuanlan.zhihu.com/p/130247362


  function simpson38(derivativeFunc, l, r) {
    var f = derivativeFunc;
    var middleL = (2 * l + r) / 3;
    var middleR = (l + 2 * r) / 3;
    return (f(l) + 3 * f(middleL) + 3 * f(middleR) + f(r)) * (r - l) / 8;
  }
  /**
   * bezier 曲线的长度
   * @param derivativeFunc 微分函数
   * @param l 左点
   * @param r 右点
   * @param eps 精度
   * @return {*} number
   */


  function adaptiveSimpson38(derivativeFunc, l, r) {
    var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
    var f = derivativeFunc;
    var mid = (l + r) / 2;
    var st = simpson38(f, l, r);
    var sl = simpson38(f, l, mid);
    var sr = simpson38(f, mid, r);
    var ans = sl + sr - st;

    if (Math.abs(ans) <= 15 * eps) {
      return sl + sr + ans / 15;
    }

    return adaptiveSimpson38(f, l, mid, eps / 2) + adaptiveSimpson38(f, mid, r, eps / 2);
  }
  /**
   * bezier 曲线的长度
   * @param points 曲线的起止点 和 控制点
   * @param startT 计算长度的起点，满足 0 <= startT <= endT <= 1
   * @param endT 计算长度的终点
   * @return {*} number
   */


  function bezierLength(points) {
    var startT = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var endT = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (points.length === 6) {
      points = [[points[0], points[1]], [points[2], points[3]], [points[4], points[5]]];
    } else if (points.length === 8) {
      points = [[points[0], points[1]], [points[2], points[3]], [points[4], points[5]], [points[6], points[7]]];
    }

    if (points.length === 2) {
      var _points$ = _slicedToArray(points[0], 2),
          x1 = _points$[0],
          y1 = _points$[1],
          _points$2 = _slicedToArray(points[1], 2),
          x2 = _points$2[0],
          y2 = _points$2[1];

      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points));
    };

    return adaptiveSimpson38(derivativeFunc, startT, endT);
  }
  /**
   * 3 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at3(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points = _slicedToArray(points, 4),
        p0 = _points[0],
        p1 = _points[1],
        p2 = _points[2],
        p3 = _points[3];

    var _p = _slicedToArray(p0, 2),
        x0 = _p[0],
        y0 = _p[1];

    var _p2 = _slicedToArray(p1, 2),
        x1 = _p2[0],
        y1 = _p2[1];

    var _p3 = _slicedToArray(p2, 2),
        x2 = _p3[0],
        y2 = _p3[1];

    var _p4 = _slicedToArray(p3, 2),
        x3 = _p4[0],
        y3 = _p4[1];

    var x = 0;
    var y = 0; // 3阶导数就是常数了，大于3阶的都是0

    if (order === 0) {
      x = Math.pow(1 - t, 3) * x0 + 3 * t * Math.pow(1 - t, 2) * x1 + 3 * (1 - t) * Math.pow(t, 2) * x2 + Math.pow(t, 3) * x3;
      y = Math.pow(1 - t, 3) * y0 + 3 * t * Math.pow(1 - t, 2) * y1 + 3 * (1 - t) * Math.pow(t, 2) * y2 + Math.pow(t, 3) * y3;
    } else if (order === 1) {
      x = 3 * ((1 - t) * (1 - t) * (x1 - x0) + 2 * (1 - t) * t * (x2 - x1) + t * t * (x3 - x2));
      y = 3 * ((1 - t) * (1 - t) * (y1 - y0) + 2 * (1 - t) * t * (y2 - y1) + t * t * (y3 - y2));
    } else if (order === 2) {
      x = 6 * (x2 - 2 * x1 + x0) * (1 - t) + 6 * (x3 - 2 * x2 + x1) * t;
      y = 6 * (y2 - 2 * y1 + y0) * (1 - t) + 6 * (y3 - 2 * y2 + y1) * t;
    } else if (order === 3) {
      x = 6 * (x3 - 3 * x2 + 3 * x1 - x0);
      y = 6 * (y3 - 3 * y2 + 3 * y1 - y0);
    }

    return [x, y];
  }
  /**
   * 2 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at2(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points2 = _slicedToArray(points, 3),
        p0 = _points2[0],
        p1 = _points2[1],
        p2 = _points2[2];

    var _p5 = _slicedToArray(p0, 2),
        x0 = _p5[0],
        y0 = _p5[1];

    var _p6 = _slicedToArray(p1, 2),
        x1 = _p6[0],
        y1 = _p6[1];

    var _p7 = _slicedToArray(p2, 2),
        x2 = _p7[0],
        y2 = _p7[1];

    var x = 0;
    var y = 0;

    if (order === 0) {
      x = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
      y = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
    } else if (order === 1) {
      x = 2 * (1 - t) * (x1 - x0) + 2 * t * (x2 - x1);
      y = 2 * (1 - t) * (y1 - y0) + 2 * t * (y2 - y1);
    } else if (order === 2) {
      x = 2 * (x2 - 2 * x1 + x0);
      y = 2 * (y2 - 2 * y1 + y0);
    }

    return [x, y];
  }

  function at(t, points) {
    var derivativeOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (points.length === 4) {
      return at3(t, points, derivativeOrder);
    } else if (points.length === 3) {
      return at2(t, points, derivativeOrder);
    }
  }

  function pointAtBezier(points, percent, maxIteration, eps) {
    var length = bezierLength(points, 0, 1);
    return pointAtBezierWithLength(points, length, percent, maxIteration, eps);
  }

  function pointAtBezierWithLength(points, length) {
    var percent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var maxIteration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;
    var eps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.001;

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points));
    };

    var targetLen = length * percent;
    var approachLen = length;
    var approachT = percent;
    var preApproachT = approachT;

    for (var i = 0; i < maxIteration; i++) {
      approachLen = simpson38(derivativeFunc, 0, approachT);
      var d = approachLen - targetLen;

      if (Math.abs(d) < eps) {
        break;
      } // Newton 法


      var derivative1 = norm(at(approachT, points, 1)); // 1 阶导数

      var derivative2 = norm(at(approachT, points, 2)); // 2 阶导数

      var numerator = d * derivative1;
      var denominator = d * derivative2 + derivative1 * derivative1;
      approachT = approachT - numerator / denominator;

      if (Math.abs(approachT - preApproachT) < eps) {
        break;
      } else {
        preApproachT = approachT;
      }
    }

    return at(approachT, points, 0);
  }

  function sliceBezier(points, t) {
    if (!Array.isArray(points) || points.length < 3) {
      return points;
    }

    var x1, y1, x2, y2, x3, y3, x4, y4;
    var pts0 = points[0],
        pts1 = points[1],
        pts2 = points[2],
        pts3 = points[3];

    if (!pts0 || !pts1 || !pts2) {
      return points;
    }

    if (Array.isArray(pts0)) {
      x1 = pts0[0];
      y1 = pts0[1];
    } else {
      x1 = pts0.x;
      y1 = pts0.y;
    }

    if (Array.isArray(pts1)) {
      x2 = pts1[0];
      y2 = pts1[1];
    } else {
      x2 = pts1.x;
      y2 = pts1.y;
    }

    if (Array.isArray(pts2)) {
      x3 = pts2[0];
      y3 = pts2[1];
    } else {
      x3 = pts2.x;
      y3 = pts2.y;
    }

    var x12 = (x2 - x1) * t + x1;
    var y12 = (y2 - y1) * t + y1;
    var x23 = (x3 - x2) * t + x2;
    var y23 = (y3 - y2) * t + y2;
    var x123 = (x23 - x12) * t + x12;
    var y123 = (y23 - y12) * t + y12;

    if (points.length === 4) {
      if (Array.isArray(pts3)) {
        x4 = pts3[0];
        y4 = pts3[1];
      } else {
        x4 = pts3.x;
        y4 = pts3.y;
      }

      var x34 = (x4 - x3) * t + x3;
      var y34 = (y4 - y3) * t + y3;
      var x234 = (x34 - x23) * t + x23;
      var y234 = (y34 - y23) * t + y23;
      var x1234 = (x234 - x123) * t + x123;
      var y1234 = (y234 - y123) * t + y123;
      return [[x1, y1], [x12, y12], [x123, y123], [x1234, y1234]];
    } else if (points.length === 3) {
      return [[x1, y1], [x12, y12], [x123, y123]];
    }
  }

  function sliceBezier2Both(points) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (!Array.isArray(points) || points.length < 3) {
      return points;
    }

    start = Math.max(start, 0);
    end = Math.min(end, 1);

    if (start === 0 && end === 1) {
      return points;
    }

    if (end < 1) {
      points = sliceBezier(points, end);
    }

    if (start > 0) {
      if (end < 1) {
        start = start / end;
      }

      points = sliceBezier(points.slice(0).reverse(), 1 - start).reverse();
    }

    return points;
  }

  function pointAtByT(points) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (points.length === 4) {
      return pointAtByT3(points, t);
    } else if (points.length === 3) {
      return pointAtByT2(points, t);
    }
  }

  function pointAtByT2(points, t) {
    var x = points[0][0] * (1 - t) * (1 - t) + 2 * points[1][0] * t * (1 - t) + points[2][0] * t * t;
    var y = points[0][1] * (1 - t) * (1 - t) + 2 * points[1][1] * t * (1 - t) + points[2][1] * t * t;
    return [x, y];
  }

  function pointAtByT3(points, t) {
    var x = points[0][0] * (1 - t) * (1 - t) * (1 - t) + 3 * points[1][0] * t * (1 - t) * (1 - t) + 3 * points[2][0] * t * t * (1 - t) + points[3][0] * t * t * t;
    var y = points[0][1] * (1 - t) * (1 - t) * (1 - t) + 3 * points[1][1] * t * (1 - t) * (1 - t) + 3 * points[2][1] * t * t * (1 - t) + points[3][1] * t * t * t;
    return [x, y];
  } // 已知曲线和上面一点获得t


  function getPointT(points, x, y) {
    if (points.length === 4) {
      return getPointT3(points, x, y);
    } else if (points.length === 3) {
      return getPointT2(points, x, y);
    }
  }

  function getPointT2(points, x, y) {
    // x/y都需要求，以免其中一个无解，过滤掉[0, 1]之外的
    var tx = equation.getRoots([points[0][0] - x, 2 * (points[1][0] - points[0][0]), points[2][0] + points[0][0] - 2 * points[1][0]]).filter(function (i) {
      return i >= 0 && i <= 1;
    });
    var ty = equation.getRoots([points[0][1] - y, 2 * (points[1][1] - points[0][1]), points[2][1] + points[0][1] - 2 * points[1][1]]).filter(function (i) {
      return i >= 0 && i <= 1;
    }); // 可能有多个解，x和y要匹配上，这里最多x和y各2个总共4个解

    var t = [];

    for (var i = 0, len = tx.length; i < len; i++) {
      var _x = tx[i];

      for (var j = 0, _len = ty.length; j < _len; j++) {
        var _y = ty[j];
        var diff = Math.abs(_x - _y); // 必须小于一定误差

        if (diff < 1e-10) {
          t.push({
            x: _x,
            y: _y,
            diff: diff
          });
        }
      }
    }

    t.sort(function (a, b) {
      return a.diff - b.diff;
    });

    if (t.length > 2) {
      t.splice(2);
    } // 取均数


    t = t.map(function (item) {
      return (item.x + item.y) * 0.5;
    });
    var res = [];
    t.forEach(function (t) {
      var xt = points[0][0] * Math.pow(1 - t, 2) + 2 * points[1][0] * t * (1 - t) + points[2][0] * t * t;
      var yt = points[0][1] * Math.pow(1 - t, 2) + 2 * points[1][1] * t * (1 - t) + points[2][1] * t * t; // 计算误差忽略

      if (Math.abs(xt - x) < 1e-10 && Math.abs(yt - y) < 1e-10) {
        res.push(t);
      }
    });
    return res;
  }

  function getPointT3(points, x, y) {
    var tx = equation.getRoots([points[0][0] - x, 3 * (points[1][0] - points[0][0]), 3 * (points[2][0] + points[0][0] - 2 * points[1][0]), points[3][0] - points[0][0] + 3 * points[1][0] - 3 * points[2][0]]).filter(function (i) {
      return i >= 0 && i <= 1;
    });
    var ty = equation.getRoots([points[0][1] - y, 3 * (points[1][1] - points[0][1]), 3 * (points[2][1] + points[0][1] - 2 * points[1][1]), points[3][1] - points[0][1] + 3 * points[1][1] - 3 * points[2][1]]).filter(function (i) {
      return i >= 0 && i <= 1;
    }); // 可能有多个解，x和y要匹配上，这里最多x和y各3个总共9个解

    var t = [];

    for (var i = 0, len = tx.length; i < len; i++) {
      var _x2 = tx[i];

      for (var j = 0, _len2 = ty.length; j < _len2; j++) {
        var _y2 = ty[j];
        var diff = Math.abs(_x2 - _y2); // 必须小于一定误差

        if (diff < 1e-10) {
          t.push({
            x: _x2,
            y: _y2,
            diff: diff
          });
        }
      }
    }

    t.sort(function (a, b) {
      return a.diff - b.diff;
    });

    if (t.length > 3) {
      t.splice(3);
    } // 取均数


    t = t.map(function (item) {
      return (item.x + item.y) * 0.5;
    });
    var res = [];
    t.forEach(function (t) {
      var xt = points[0][0] * Math.pow(1 - t, 3) + 3 * points[1][0] * t * Math.pow(1 - t, 2) + 3 * points[2][0] * t * t * (1 - t) + points[3][0] * Math.pow(t, 3);
      var yt = points[0][1] * Math.pow(1 - t, 3) + 3 * points[1][1] * t * Math.pow(1 - t, 2) + 3 * points[2][1] * t * t * (1 - t) + points[3][1] * Math.pow(t, 3); // 计算误差忽略

      if (Math.abs(xt - x) < 1e-10 && Math.abs(yt - y) < 1e-10) {
        res.push(t);
      }
    });
    return res;
  }

  function bezierSlope(points, t) {
    if (points.length === 2) {
      var _points$3 = _slicedToArray(points[0], 2),
          x1 = _points$3[0],
          y1 = _points$3[1];

      var _points$4 = _slicedToArray(points[1], 2),
          x2 = _points$4[0],
          y2 = _points$4[1];

      if (x1 === x2) {
        return Infinity;
      }

      return (y2 - y1) / (x2 - x1);
    }

    if (points.length === 3) {
      return bezier2Slope(points, t);
    }

    if (points.length === 4) {
      return bezier3Slope(points, t);
    }
  }

  function bezier2Slope(points, t) {
    var _points3 = _slicedToArray(points, 3),
        _points3$ = _slicedToArray(_points3[0], 2),
        x0 = _points3$[0],
        y0 = _points3$[1],
        _points3$2 = _slicedToArray(_points3[1], 2),
        x1 = _points3$2[0],
        y1 = _points3$2[1],
        _points3$3 = _slicedToArray(_points3[2], 2),
        x2 = _points3$3[0],
        y2 = _points3$3[1];

    var x = 2 * (x0 - 2 * x1 + x2) * t + 2 * x1 - 2 * x0;

    if (x === 0) {
      return Infinity;
    }

    return (2 * (y0 - 2 * y1 + y2) * t + 2 * y1 - 2 * y0) / x;
  }

  function bezier3Slope(points, t) {
    var _points4 = _slicedToArray(points, 4),
        _points4$ = _slicedToArray(_points4[0], 2),
        x0 = _points4$[0],
        y0 = _points4$[1],
        _points4$2 = _slicedToArray(_points4[1], 2),
        x1 = _points4$2[0],
        y1 = _points4$2[1],
        _points4$3 = _slicedToArray(_points4[2], 2),
        x2 = _points4$3[0],
        y2 = _points4$3[1],
        _points4$4 = _slicedToArray(_points4[3], 2),
        x3 = _points4$4[0],
        y3 = _points4$4[1];

    var x = 3 * (-x0 + 3 * x1 - 3 * x2 + x3) * t * t + 2 * (3 * x0 - 6 * x1 + 3 * x2) * t + 3 * x1 - 3 * x0;

    if (x === 0) {
      return Infinity;
    }

    return (3 * (-y0 + 3 * y1 - 3 * y2 + y3) * t * t + 2 * (3 * y0 - 6 * y1 + 3 * y2) * t + 3 * y1 - 3 * y0) / x;
  }

  var bezier = {
    bboxBezier: bboxBezier,
    bezierLength: bezierLength,
    pointAtBezier: pointAtBezier,
    pointAtBezierWithLength: pointAtBezierWithLength,
    sliceBezier: sliceBezier,
    sliceBezier2Both: sliceBezier2Both,
    pointAtByT: pointAtByT,
    getPointT: getPointT,
    bezierSlope: bezierSlope
  };

  var STROKE_WIDTH$5 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$7 = util.isNil;

  function reBuild(target, origin, base, isMulti) {
    if (isMulti) {
      return target.map(function (item) {
        return origin + item * base;
      });
    } else {
      return origin + target * base;
    }
  }

  function reBuildC(target, originX, originY, width, height, isMulti) {
    if (isMulti) {
      if (target) {
        return target.map(function (item) {
          return reBuildC(item, originX, originY, width, height);
        });
      }
    } else {
      if (target && target.length >= 2) {
        return [originX + target[0] * width, originY + target[1] * height];
      }
    }

    return [];
  }

  function curveNum(controlA, controlB) {
    var num = 0;

    if (controlA && controlA.length >= 2) {
      num++;
    }

    if (controlB && controlB.length >= 2) {
      num += 2;
    }

    return num;
  }

  function getNewPoint(xa, ya, xb, yb, controlA, controlB, num) {
    var start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

    if (start === 0 && end === 1) {
      return [xa, ya, xb, yb, controlA, controlB];
    }

    if (start === end) {
      return [];
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    }

    start = Math.max(0, start);
    end = Math.min(1, end);

    if (num === 3) {
      var _bezier$sliceBezier2B = bezier.sliceBezier2Both([[xa, ya], controlA, controlB, [xb, yb]], start, end);

      var _bezier$sliceBezier2B2 = _slicedToArray(_bezier$sliceBezier2B, 4);

      var _bezier$sliceBezier2B3 = _slicedToArray(_bezier$sliceBezier2B2[0], 2);

      xa = _bezier$sliceBezier2B3[0];
      ya = _bezier$sliceBezier2B3[1];
      controlA = _bezier$sliceBezier2B2[1];
      controlB = _bezier$sliceBezier2B2[2];

      var _bezier$sliceBezier2B4 = _slicedToArray(_bezier$sliceBezier2B2[3], 2);

      xb = _bezier$sliceBezier2B4[0];
      yb = _bezier$sliceBezier2B4[1];
    } else if (num === 2) {
      var _bezier$sliceBezier2B5 = bezier.sliceBezier2Both([[xa, ya], controlB, [xb, yb]], start, end);

      var _bezier$sliceBezier2B6 = _slicedToArray(_bezier$sliceBezier2B5, 3);

      var _bezier$sliceBezier2B7 = _slicedToArray(_bezier$sliceBezier2B6[0], 2);

      xa = _bezier$sliceBezier2B7[0];
      ya = _bezier$sliceBezier2B7[1];
      controlB = _bezier$sliceBezier2B6[1];

      var _bezier$sliceBezier2B8 = _slicedToArray(_bezier$sliceBezier2B6[2], 2);

      xb = _bezier$sliceBezier2B8[0];
      yb = _bezier$sliceBezier2B8[1];
    } else if (num === 1) {
      var _bezier$sliceBezier2B9 = bezier.sliceBezier2Both([[xa, ya], controlA, [xb, yb]], start, end);

      var _bezier$sliceBezier2B10 = _slicedToArray(_bezier$sliceBezier2B9, 3);

      var _bezier$sliceBezier2B11 = _slicedToArray(_bezier$sliceBezier2B10[0], 2);

      xa = _bezier$sliceBezier2B11[0];
      ya = _bezier$sliceBezier2B11[1];
      controlA = _bezier$sliceBezier2B10[1];

      var _bezier$sliceBezier2B12 = _slicedToArray(_bezier$sliceBezier2B10[2], 2);

      xb = _bezier$sliceBezier2B12[0];
      yb = _bezier$sliceBezier2B12[1];
    } else {
      var a = xb - xa;
      var b = yb - ya;
      xa += a * start;
      ya += b * start;
      xb += a * (1 - end);
      yb += b * (1 - end);
    }

    return [xa, ya, xb, yb, controlA, controlB];
  }

  var Line = /*#__PURE__*/function (_Geom) {
    _inherits(Line, _Geom);

    function Line(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // xa,ya和xb,yb表明线段的首尾坐标，control表明控制点坐标

      if (_this.isMulti) {
        _this.__xa = [0];
        _this.__ya = [0];
        _this.__xb = [1];
        _this.__yb = [1];
        _this.__controlA = [[]];
        _this.__controlB = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.xa)) {
          _this.__xa = props.xa.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$7(props.xa)) {
          _this.__xa = [parseFloat(props.xa) || 0];
        }

        if (Array.isArray(props.ya)) {
          _this.__ya = props.ya.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$7(props.ya)) {
          _this.__ya = [parseFloat(props.ya) || 0];
        }

        if (Array.isArray(props.xb)) {
          _this.__xb = props.xb.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$7(props.xb)) {
          _this.__xb = [parseFloat(props.xb) || 0];
        }

        if (Array.isArray(props.yb)) {
          _this.__yb = props.yb.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$7(props.yb)) {
          _this.__yb = [parseFloat(props.yb) || 0];
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__xa.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$7(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__xa.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i = _this.__end.length; _i < _this.__xa.length; _i++) {
            _this.__end.push(1);
          }
        } else if (!isNil$7(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__xa.map(function () {
            return _v;
          });
        }
      } else {
        _this.__xa = _this.__ya = _this.__start = 0;
        _this.__xb = _this.__yb = _this.__end = 1;
        _this.__controlA = [];
        _this.__controlB = [];

        if (!isNil$7(props.xa)) {
          _this.__xa = parseFloat(props.xa) || 0;
        }

        if (!isNil$7(props.ya)) {
          _this.__ya = parseFloat(props.ya) || 0;
        }

        if (!isNil$7(props.xb)) {
          _this.__xb = parseFloat(props.xb) || 0;
        }

        if (!isNil$7(props.yb)) {
          _this.__yb = parseFloat(props.yb) || 0;
        }

        if (!isNil$7(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$7(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA;
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB;
        }
      }

      return _this;
    }

    _createClass(Line, [{
      key: "__buildCache",
      value: function __buildCache(originX, originY, focus) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;
        ['xa', 'xb'].forEach(function (k) {
          if (isNil$7(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originX, width, isMulti);
          }
        });
        ['ya', 'yb'].forEach(function (k) {
          if (isNil$7(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originY, height, isMulti);
          }
        });
        ['controlA', 'controlB'].forEach(function (k) {
          if (isNil$7(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuildC(_this2[k], originX, originY, width, height, isMulti);
          }
        });
        ['start', 'end'].forEach(function (k) {
          if (isNil$7(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = _this2[k];
          }
        });
        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx2, dy2) {
        var _this3 = this;

        var res = _get(_getPrototypeOf(Line.prototype), "render", this).call(this, renderMode, ctx, dx2, dy2);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        var x3 = res.x3,
            y3 = res.y3,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;

        var rebuild = this.__buildCache(x3, y3);

        if (rebuild && renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            __cacheProps.xa.forEach(function (xa, i) {
              var xb = __cacheProps.xb[i];
              var ya = __cacheProps.ya[i];
              var yb = __cacheProps.yb[i];
              var ca = __cacheProps.controlA[i];
              var cb = __cacheProps.controlB[i];
              var start = __cacheProps.start[i];
              var end = __cacheProps.end[i];
              var curve = curveNum(ca, cb);

              if (start !== 0 || end !== 1) {
                var _getNewPoint = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                var _getNewPoint2 = _slicedToArray(_getNewPoint, 6);

                xa = _getNewPoint2[0];
                ya = _getNewPoint2[1];
                xb = _getNewPoint2[2];
                ya = _getNewPoint2[3];
                ca = _getNewPoint2[4];
                cb = _getNewPoint2[5];
              }

              d += painter.svgLine(xa, ya, xb, yb, ca, cb, curve);
            });
          } else {
            var curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);
            var xa = __cacheProps.xa,
                ya = __cacheProps.ya,
                xb = __cacheProps.xb,
                yb = __cacheProps.yb,
                controlA = __cacheProps.controlA,
                controlB = __cacheProps.controlB,
                start = __cacheProps.start,
                end = __cacheProps.end;

            if (start !== 0 || end !== 1) {
              var _getNewPoint3 = getNewPoint(xa, ya, xb, yb, controlA, controlB, curve, start, end, __cacheProps.len);

              var _getNewPoint4 = _slicedToArray(_getNewPoint3, 6);

              xa = _getNewPoint4[0];
              ya = _getNewPoint4[1];
              xb = _getNewPoint4[2];
              yb = _getNewPoint4[3];
              controlA = _getNewPoint4[4];
              controlB = _getNewPoint4[5];
            }

            d = painter.svgLine(xa, ya, xb, yb, controlA, controlB, curve);
          }

          __cacheProps.d = d;
        }

        if (renderMode === mode.CANVAS) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

            if (strokeWidth > 0 && stroke !== 'none') {
              _this3.__preSetCanvas(renderMode, ctx, {
                stroke: stroke,
                strokeWidth: strokeWidth,
                strokeDasharray: strokeDasharrays[i],
                strokeLinecap: strokeLinecaps[i],
                strokeLinejoin: strokeLinejoins[i],
                strokeMiterlimit: strokeMiterlimits[i]
              });

              if (isStrokeRE) {
                ctx.strokeStyle = stroke.v[0];
              }

              ctx.beginPath();

              if (isMulti) {
                __cacheProps.xa.forEach(function (xa, i) {
                  var xb = __cacheProps.xb[i];
                  var ya = __cacheProps.ya[i];
                  var yb = __cacheProps.yb[i];
                  var ca = __cacheProps.controlA[i];
                  var cb = __cacheProps.controlB[i];
                  var start = __cacheProps.start[i];
                  var end = __cacheProps.end[i];
                  var curve = curveNum(ca, cb);

                  if (start !== 0 || end !== 1) {
                    var _getNewPoint5 = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                    var _getNewPoint6 = _slicedToArray(_getNewPoint5, 6);

                    xa = _getNewPoint6[0];
                    ya = _getNewPoint6[1];
                    xb = _getNewPoint6[2];
                    ya = _getNewPoint6[3];
                    ca = _getNewPoint6[4];
                    cb = _getNewPoint6[5];
                  }

                  painter.canvasLine(ctx, xa, ya, xb, yb, ca, cb, curve, dx, dy);
                });
              } else {
                var _curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);

                var _xa = __cacheProps.xa,
                    _ya = __cacheProps.ya,
                    _xb = __cacheProps.xb,
                    _yb = __cacheProps.yb,
                    _controlA = __cacheProps.controlA,
                    _controlB = __cacheProps.controlB,
                    _start = __cacheProps.start,
                    _end = __cacheProps.end;

                if (_start !== 0 || _end !== 1) {
                  var _getNewPoint7 = getNewPoint(_xa, _ya, _xb, _yb, _controlA, _controlB, _curve, _start, _end, __cacheProps.len);

                  var _getNewPoint8 = _slicedToArray(_getNewPoint7, 6);

                  _xa = _getNewPoint8[0];
                  _ya = _getNewPoint8[1];
                  _xb = _getNewPoint8[2];
                  _yb = _getNewPoint8[3];
                  _controlA = _getNewPoint8[4];
                  _controlB = _getNewPoint8[5];
                }

                painter.canvasLine(ctx, _xa, _ya, _xb, _yb, _controlA, _controlB, _curve, dx, dy);
              }

              ctx.stroke();
              ctx.closePath();
            }
          });
        } else if (renderMode === mode.SVG) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);
            var props = [['d', __cacheProps.d], ['fill', 'none'], ['stroke', isStrokeRE ? stroke.v[0] : stroke.v || stroke], ['stroke-width', strokeWidth]];

            _this3.__propsStrokeStyle(props, strokeDasharrayStrs[i], strokeLinecaps[i], strokeLinejoins[i], strokeMiterlimits[i]);

            _this3.addGeom('path', props);
          });
        }

        return res;
      }
    }, {
      key: "xa",
      get: function get() {
        return this.getProps('xa');
      }
    }, {
      key: "ya",
      get: function get() {
        return this.getProps('ya');
      }
    }, {
      key: "xb",
      get: function get() {
        return this.getProps('xb');
      }
    }, {
      key: "yb",
      get: function get() {
        return this.getProps('yb');
      }
    }, {
      key: "controlA",
      get: function get() {
        return this.getProps('controlA');
      }
    }, {
      key: "controlB",
      get: function get() {
        return this.getProps('controlB');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            originX = this.__x3,
            originY = this.__y3,
            strokeWidth = this.computedStyle[STROKE_WIDTH$5];

        this.__buildCache(originX, originY);

        var xa = __cacheProps.xa,
            ya = __cacheProps.ya,
            xb = __cacheProps.xb,
            yb = __cacheProps.yb,
            controlA = __cacheProps.controlA,
            controlB = __cacheProps.controlB;

        var bbox = _get(_getPrototypeOf(Line.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          half = Math.max(half, item);
        });
        half = Math.ceil(half * 0.5) + 1;

        if (!isMulti) {
          xa = [xa];
          xb = [xb];
          ya = [ya];
          yb = [yb];
          controlA = [controlA];
          controlB = [controlB];
        }

        xa.forEach(function (xa, i) {
          var y1 = ya[i];
          var x2 = xb[i];
          var y2 = yb[i];
          var ca = controlA[i];
          var cb = controlB[i];

          if ((isNil$7(ca) || ca.length < 2) && (isNil$7(cb) || cb.length < 2)) {
            bbox[0] = Math.min(bbox[0], xa - half);
            bbox[0] = Math.min(bbox[0], x2 - half);
            bbox[1] = Math.min(bbox[1], y1 - half);
            bbox[1] = Math.min(bbox[1], y2 - half);
            bbox[2] = Math.max(bbox[2], xa + half);
            bbox[2] = Math.max(bbox[2], x2 + half);
            bbox[3] = Math.max(bbox[3], y1 + half);
            bbox[3] = Math.max(bbox[3], y2 + half);
          } else if (isNil$7(ca) || ca.length < 2) {
            var bezierBox = bezier.bboxBezier(xa, y1, cb[0], cb[1], x2, y2);
            bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
          } else if (isNil$7(cb) || cb.length < 2) {
            var _bezierBox = bezier.bboxBezier(xa, y1, ca[0], ca[1], x2, y2);

            bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
          } else {
            var _bezierBox2 = bezier.bboxBezier(xa, y1, ca[0], ca[1], cb[0], cb[1], x2, y2);

            bbox[0] = Math.min(bbox[0], _bezierBox2[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox2[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[3] + half);
          }
        });
        return bbox;
      }
    }]);

    return Line;
  }(Geom);

  var Point = /*#__PURE__*/function () {
    function Point(x, y) {
      if (Array.isArray(x)) {
        var _x = x;

        var _x2 = _slicedToArray(_x, 2);

        x = _x2[0];
        y = _x2[1];
      }

      this.x = x;
      this.y = y;
    }

    _createClass(Point, [{
      key: "toString",
      value: function toString() {
        // return this.x.toFixed(1).replace('.0', '') + ',' + this.y.toFixed(1).replace('.0', '');
        return this.x + ',' + this.y;
      }
    }, {
      key: "equal",
      value: function equal(o) {
        return this === o || this.x === o.x && this.y === o.y;
      } // 排序，要求a在b左即x更小，x相等a在b下，符合返回false，不符合则true

    }], [{
      key: "compare",
      value: function compare(a, b) {
        if (a.x > b.x) {
          return true;
        }

        return a.x === b.x && a.y > b.y;
      }
    }]);

    return Point;
  }();

  var Segment = /*#__PURE__*/function () {
    function Segment(coords, belong) {
      this.coords = coords;
      this.belong = belong; // 属于source多边形还是clip多边形，0和1区别

      this.calBbox();
      this.myFill = [false, false]; // 自己的上下内外性

      this.otherFill = [false, false]; // 对方的上下内外性

      this.myCoincide = 0; // 自己重合次数

      this.otherCoincide = 0; // 对方重合次数

      this.isVisited = false; // 扫描求交时用到

      this.isDeleted = false; // 相交裁剪老的线段会被删除
    }

    _createClass(Segment, [{
      key: "calBbox",
      value: function calBbox() {
        var coords = this.coords,
            l = coords.length;

        if (l === 2) {
          var a = coords[0],
              b = coords[1];
          var x1 = Math.min(a.x, b.x);
          var y1 = Math.min(a.y, b.y);
          var x2 = Math.max(a.x, b.x);
          var y2 = Math.max(a.y, b.y);
          this.bbox = [x1, y1, x2, y2];
        } else {
          var arr = coords.map(function (item) {
            return [item.x, item.y];
          });
          this.bbox = bezier.bboxBezier(arr);
        }
      } // 线段边逆序

    }, {
      key: "reverse",
      value: function reverse() {
        this.coords.reverse();
      }
    }, {
      key: "equal",
      value: function equal(o) {
        var ca = this.coords,
            cb = o.coords;

        if (ca.length !== cb.length) {
          return false;
        }

        for (var i = 0, len = ca.length; i < len; i++) {
          if (!ca[i].equal(cb[i])) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "toHash",
      value: function toHash() {
        return this.coords.map(function (item) {
          return item.toString();
        }).join(' ');
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.toHash() + ' ' + this.belong + ' ' + this.myCoincide + '' + this.otherCoincide + ' ' + this.myFill.map(function (i) {
          return i ? 1 : 0;
        }).join('') + this.otherFill.map(function (i) {
          return i ? 1 : 0;
        }).join('');
      }
    }]);

    return Segment;
  }();

  var EPS$1 = 1e-9;
  var EPS2$1 = 1 - 1e-9;

  function isParallel(k1, k2) {
    if (k1 === Infinity && k2 === Infinity) {
      return true;
    } else if (k1 === Infinity && k2 === -Infinity) {
      return true;
    } else if (k1 === -Infinity && k2 === -Infinity) {
      return true;
    } else if (k1 === -Infinity && k2 === Infinity) {
      return true;
    } else {
      return Math.abs(k1 - k2) < EPS$1;
    }
  }

  function getIntersectionLineLine$1(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, d) {
    var toSource = ((bx2 - bx1) * (ay1 - by1) - (by2 - by1) * (ax1 - bx1)) / d;
    var toClip = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d; // 非顶点相交才是真相交

    if (toSource >= 0 && toSource <= 1 && toClip >= 0 && toClip <= 1 && (toSource > EPS$1 && toSource < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1)) {
      var ox = ax1 + toSource * (ax2 - ax1);
      var oy = ay1 + toSource * (ay2 - ay1);
      return [{
        point: new Point(ox, oy),
        toSource: toSource,
        toClip: toClip
      }];
    }
  }

  function getIntersectionBezier2Line$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2) {
    var res = isec.intersectBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2);

    if (res.length) {
      res = res.map(function (item) {
        var toClip; // toClip是直线上的距离，可以简化为只看x或y，选择差值比较大的防止精度问题

        if (Math.abs(bx2 - bx1) >= Math.abs(by2 - by1)) {
          toClip = Math.abs((item.x - bx1) / (bx2 - bx1));
        } else {
          toClip = Math.abs((item.y - by1) / (by2 - by1));
        } // 相交于双方端点忽略，一方非端点要记录，防止多区域情况


        if (item.t > EPS$1 && item.t < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1) {
          // 还要判断斜率，相等也忽略（小于一定误差）
          var k1 = bezier.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
          var k2 = bezier.bezierSlope([[bx1, by1], [bx2, by2]]); // 忽略方向，180°也是平行，Infinity相减为NaN

          if (isParallel(k1, k2)) {
            return;
          }

          return {
            point: new Point(item.x, item.y),
            toSource: item.t,
            // source是曲线直接用t
            toClip: toClip
          };
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier2Bezier2$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3) {
    var res = isec.intersectBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier.getPointT([[bx1, by1], [bx2, by2], [bx3, by3]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS$1 && item.t < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
            var k2 = bezier.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (isParallel(k1, k2)) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier2Bezier3$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var res = isec.intersectBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier.getPointT([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS$1 && item.t < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
            var k2 = bezier.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (isParallel(k1, k2)) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier3Line$1(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2) {
    var res = isec.intersectBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是直线上的距离，可以简化为只看x或y，选择差值比较大的防止精度问题
        var toClip;

        if (Math.abs(bx2 - bx1) >= Math.abs(by2 - by1)) {
          toClip = Math.abs((item.x - bx1) / (bx2 - bx1));
        } else {
          toClip = Math.abs((item.y - by1) / (by2 - by1));
        } // 相交于双方端点忽略，一方非端点要记录，防止多区域情况


        if (item.t > EPS$1 && item.t < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1) {
          // 还要判断斜率，相等也忽略（小于一定误差）
          var k1 = bezier.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3], [ax4, ay4]], item.t);
          var k2 = bezier.bezierSlope([[bx1, by1], [bx2, by2]]); // 忽略方向，180°也是平行，Infinity相减为NaN

          if (isParallel(k1, k2)) {
            return;
          }

          return {
            point: new Point(item.x, item.y),
            toSource: item.t,
            // source是曲线直接用t
            toClip: toClip
          };
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier3Bezier3$1(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var res = isec.intersectBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier.getPointT([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS$1 && item.t < EPS2$1 || toClip > EPS$1 && toClip < EPS2$1) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3], [ax4, ay4]], item.t);
            var k2 = bezier.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (isParallel(k1, k2)) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  } // 两条线可能多个交点，将交点按原本线段的方向顺序排序


  function sortIntersection$1(res, isSource) {
    return res.sort(function (a, b) {
      if (isSource) {
        return a.toSource - b.toSource;
      }

      return a.toClip - b.toClip;
    }).map(function (item) {
      return {
        point: item.point,
        t: isSource ? item.toSource : item.toClip
      };
    }).filter(function (item) {
      return item.t > EPS$1 && item.t < EPS2$1;
    });
  }

  var intersect$1 = {
    getIntersectionLineLine: getIntersectionLineLine$1,
    getIntersectionBezier2Line: getIntersectionBezier2Line$1,
    getIntersectionBezier2Bezier2: getIntersectionBezier2Bezier2$1,
    getIntersectionBezier2Bezier3: getIntersectionBezier2Bezier3$1,
    getIntersectionBezier3Line: getIntersectionBezier3Line$1,
    getIntersectionBezier3Bezier3: getIntersectionBezier3Bezier3$1,
    sortIntersection: sortIntersection$1,
    EPS: EPS$1,
    EPS2: EPS2$1
  };

  var getIntersectionLineLine = intersect$1.getIntersectionLineLine,
      getIntersectionBezier2Line = intersect$1.getIntersectionBezier2Line,
      getIntersectionBezier2Bezier2 = intersect$1.getIntersectionBezier2Bezier2,
      getIntersectionBezier2Bezier3 = intersect$1.getIntersectionBezier2Bezier3,
      getIntersectionBezier3Line = intersect$1.getIntersectionBezier3Line,
      getIntersectionBezier3Bezier3 = intersect$1.getIntersectionBezier3Bezier3,
      sortIntersection = intersect$1.sortIntersection,
      EPS = intersect$1.EPS,
      EPS2 = intersect$1.EPS2;

  var Polygon$1 = /*#__PURE__*/function () {
    function Polygon(regions, index) {
      this.index = index; // 属于source多边形还是clip多边形，0和1区别

      var segments = []; // 多边形有>=1个区域，一般是1个

      if (!Array.isArray(regions)) {
        return;
      }

      regions.forEach(function (vertices) {
        // 每个区域有>=2条线段，组成封闭区域，1条肯定不行，2条必须是曲线
        if (!Array.isArray(vertices) || vertices.length < 2) {
          return;
        }

        if (vertices.length === 2 && vertices[1].length <= 2) {
          return;
        }

        var startPoint = new Point(vertices[0]),
            firstPoint = startPoint; // 根据多边形有向边，生成线段，不保持原有向，统一左下作为线段起点，如果翻转则记录个值标明

        for (var i = 1, len = vertices.length; i < len; i++) {
          var curr = vertices[i],
              l = curr.length; // 闭合区域，首尾顶点重复统一

          var endPoint = new Point(curr[l - 2], curr[l - 1]);
          var seg = void 0;

          if (l === 2) {
            // 长度为0的直线忽略
            if (startPoint.equal(endPoint)) {
              continue;
            }

            var coords = Point.compare(startPoint, endPoint) ? [endPoint, startPoint] : [startPoint, endPoint];
            seg = new Segment(coords, index);
          } // 曲线需确保x单调性，如果非单调，则切割为单调的多条
          else if (l === 4) {
            // 长度为0的曲线忽略
            if (startPoint.equal(endPoint) && startPoint.x === curr[0] && startPoint.y === curr[1]) {
              continue;
            }

            var cPoint = new Point(curr[0], curr[1]);
            var t = getBezierMonotonicity([startPoint, cPoint, endPoint], true);

            if (t) {
              var points = [[startPoint.x, startPoint.y], [curr[0], curr[1]], [endPoint.x, endPoint.y]];
              var curve1 = bezier.sliceBezier(points, t[0]);
              var curve2 = bezier.sliceBezier2Both(points, t[0], 1);
              var p1 = new Point(curve1[1]),
                  p2 = new Point(curve1[2]),
                  p3 = new Point(curve2[1]);

              var _coords = Point.compare(startPoint, p2) ? [p2, p1, startPoint] : [startPoint, p1, p2];

              segments.push(new Segment(_coords, index));
              _coords = Point.compare(p2, endPoint) ? [endPoint, p3, p2] : [p2, p3, endPoint];
              seg = new Segment(_coords, index);
            } else {
              var _coords2 = Point.compare(startPoint, endPoint) ? [endPoint, cPoint, startPoint] : [startPoint, cPoint, endPoint];

              seg = new Segment(_coords2, index);
            }
          } // 3阶可能有2个单调改变t点
          else if (l === 6) {
            // 降级为2阶曲线
            if (curr[0] === curr[2] && curr[1] === curr[3]) {
              curr.splice(2, 2);
              i--;
              continue;
            } // 长度为0的曲线忽略


            if (startPoint.equal(endPoint) && startPoint.x === curr[0] && startPoint.y === curr[1] && startPoint.x === curr[2] && startPoint.y === curr[3]) {
              continue;
            }

            var cPoint1 = new Point(curr[0], curr[1]),
                cPoint2 = new Point(curr[2], curr[3]);

            var _t = getBezierMonotonicity([startPoint, cPoint1, cPoint2, endPoint], true);

            if (_t) {
              (function () {
                var points = [[startPoint.x, startPoint.y], [curr[0], curr[1]], [curr[2], curr[3]], [endPoint.x, endPoint.y]];
                var lastPoint = startPoint,
                    lastT = 0;

                _t.forEach(function (t) {
                  var curve = bezier.sliceBezier2Both(points, lastT, t);
                  var p1 = new Point(curve[1]),
                      p2 = new Point(curve[2]),
                      p3 = new Point(curve[3]);
                  var coords = Point.compare(lastPoint, p3) ? [p3, p2, p1, lastPoint] : [lastPoint, p1, p2, p3];
                  segments.push(new Segment(coords, index));
                  lastT = t;
                  lastPoint = p3;
                });

                var curve = bezier.sliceBezier2Both(points, lastT, 1);
                var p1 = new Point(curve[1]),
                    p2 = new Point(curve[2]);
                var coords = Point.compare(lastPoint, endPoint) ? [endPoint, p2, p1, lastPoint] : [lastPoint, p1, p2, endPoint];
                seg = new Segment(coords, index);
              })();
            } else {
              var _coords3 = Point.compare(startPoint, endPoint) ? [endPoint, cPoint2, cPoint1, startPoint] : [startPoint, cPoint1, cPoint2, endPoint];

              seg = new Segment(_coords3, index);
            }
          }

          segments.push(seg); // 终点是下条边的起点

          startPoint = endPoint;
        } // 强制要求闭合，非闭合自动连直线到开始点闭合


        if (!startPoint.equal(firstPoint)) {
          var _coords4 = Point.compare(startPoint, firstPoint) ? [firstPoint, startPoint] : [startPoint, firstPoint];

          segments.push(new Segment(_coords4, index));
        }
      });
      this.segments = segments;
    } // 根据y坐标排序，生成有序线段列表，再扫描求交


    _createClass(Polygon, [{
      key: "selfIntersect",
      value: function selfIntersect() {
        var list = genHashXList(this.segments);
        this.segments = findIntersection(list, false, false, false);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.segments.map(function (item) {
          return item.toString();
        });
      }
    }, {
      key: "reset",
      value: function reset(index) {
        this.index = index;
        this.segments.forEach(function (seg) {
          seg.belong = index;
          seg.otherCoincide = 0;
          seg.otherFill[0] = seg.otherFill[1] = false;
        });
        return this;
      } // 2个非自交的多边形互相判断相交，依旧是扫描线算法，2个多边形统一y排序，但要分别出属于哪个多边形，因为只和对方测试相交

    }], [{
      key: "intersect2",
      value: function intersect2(polyA, polyB, isIntermediateA, isIntermediateB) {
        if (!polyA.segments.length || !polyB.segments.length) {
          return;
        }

        var list = genHashXList(polyA.segments.concat(polyB.segments));
        var segments = findIntersection(list, true, isIntermediateA, isIntermediateB);
        polyA.segments = segments.filter(function (item) {
          return item.belong === 0;
        });
        polyB.segments = segments.filter(function (item) {
          return item.belong === 1;
        });
      }
      /**
       * 以Bentley-Ottmann算法为原理，为每个顶点设计事件，按x升序、y升序遍历所有顶点的事件
       * 每条线段边有2个顶点即2个事件，左下为start，右上为end
       * 同顶点优先end，start相同则对比线段谁后面的y更小（向量法），其实就是对比非共点部分的y大小
       * 维护一个活跃边列表ael，同样保证x升序、y升序，start事件线段进入ael，end离开
       * ael中相邻的线段说明上下相互接壤，接壤一侧则内外填充性一致
       * 最下面的边（含第一条）可直接得知下方填充性（下面没有了一定是多边形外部），再推测出上方
       * 其余的边根据自己下方相邻即可确定填充性
       */

    }, {
      key: "annotate2",
      value: function annotate2(polyA, polyB, isIntermediateA, isIntermediateB) {
        var list = genHashXYList(polyA.segments.concat(polyB.segments));
        var aelA = [],
            aelB = [],
            hashA = {},
            hashB = {}; // 算法3遍循环，先注释a多边形的边自己内外性，再b的边自己内外性，最后一起注释对方的内外性
        // 因数据结构合在一起，所以2遍循环可以完成，先注释a和b的自己，再一遍对方

        list.forEach(function (item) {
          var isStart = item.isStart,
              seg = item.seg;
          var belong = seg.belong; // 连续操作时，已有的中间结果可以跳过

          if (belong === 0 && isIntermediateA || belong === 1 && isIntermediateB) {
            return;
          }

          var ael = belong === 0 ? aelA : aelB,
              hash = belong === 0 ? hashA : hashB;

          if (isStart) {
            // 自己重合的线段只考虑第一条，其它剔除
            if (seg.myCoincide) {
              var hc = seg.toHash();

              if (hash.hasOwnProperty(hc)) {
                return;
              }

              hash[hc] = true;
            } // console.error(seg.toString(), ael.length)
            // 下面没有线段了，底部边，上方填充下方空白（除非是偶次重复段，上下都空白，奇次和单线相同）


            if (!ael.length) {
              if (seg.myCoincide) {
                seg.myFill[0] = seg.myCoincide % 2 === 0;
              } else {
                seg.myFill[0] = true;
              }

              ael.push(seg);
            } else {
              // 插入到ael正确的位置，按照x升序、y升序
              var len = ael.length,
                  top = ael[len - 1];
              var isAboveLast = segAboveCompare(seg, top); // 比ael栈顶还高在最上方

              if (isAboveLast) {
                seg.myFill[1] = top.myFill[0];

                if (seg.myCoincide) {
                  seg.myFill[0] = seg.myCoincide % 2 === 0 ? !seg.myFill[1] : seg.myFill[1];
                } else {
                  seg.myFill[0] = !seg.myFill[1];
                }

                ael.push(seg);
              } // 不高且只有1个则在最下方
              else if (len === 1) {
                if (seg.myCoincide) {
                  seg.myFill[0] = seg.myCoincide % 2 === 0;
                } else {
                  seg.myFill[0] = true;
                }

                ael.unshift(seg);
              } else {
                // 遍历，尝试对比是否在ael栈中相邻2条线段之间
                for (var i = len - 2; i >= 0; i--) {
                  var curr = ael[i];
                  var isAbove = segAboveCompare(seg, curr);

                  if (isAbove) {
                    seg.myFill[1] = curr.myFill[0];

                    if (seg.myCoincide) {
                      seg.myFill[0] = seg.myCoincide % 2 === 0 ? !seg.myFill[1] : seg.myFill[1];
                    } else {
                      seg.myFill[0] = !seg.myFill[1];
                    }

                    ael.splice(i + 1, 0, seg);
                    break;
                  } else if (i === 0) {
                    if (seg.myCoincide) {
                      seg.myFill[0] = seg.myCoincide % 2 === 0;
                    } else {
                      seg.myFill[0] = true;
                    }

                    ael.unshift(seg);
                  }
                }
              }
            } // console.warn(seg.toString())

          } else {
            var _i = ael.indexOf(seg); // 一般肯定有，重合线段会剔除不进ael


            if (_i > -1) {
              ael.splice(_i, 1);
            }
          }
        }); // 注释对方，除了重合线直接使用双方各自的注释拼接，普通线两边的对方内外性相同，根据是否在里面inside确定结果
        // inside依旧看自己下方的线段上方情况，不同的是要看下方的线和自己belong是否相同，再确定取下方above的值

        var ael = [],
            hash = {};
        list.forEach(function (item) {
          var isStart = item.isStart,
              seg = item.seg;
          var belong = seg.belong;

          if (isStart) {
            // 自重合或者它重合统一只保留第一条线
            if (seg.myCoincide || seg.otherCoincide) {
              var hc = seg.toHash();

              if (hash.hasOwnProperty(hc)) {
                return;
              }

              hash[hc] = true;
            } // console.error(seg.toString(), ael.length)


            var inside = false;

            if (!ael.length) {
              inside = false;
              ael.push(seg);
            } else {
              var len = ael.length,
                  top = ael[len - 1];
              var isAboveLast = segAboveCompare(seg, top);

              if (isAboveLast) {
                if (top.belong === belong) {
                  inside = top.otherFill[0];
                } else {
                  inside = top.myFill[0];
                }

                ael.push(seg);
              } else if (len === 1) {
                // inside = false;
                ael.unshift(seg);
              } else {
                for (var i = len - 2; i >= 0; i--) {
                  var curr = ael[i];
                  var isAbove = segAboveCompare(seg, curr);

                  if (isAbove) {
                    // 如果在自己的下方线和自己同色，则取下方线的另外色上填充
                    if (curr.belong === belong) {
                      inside = curr.otherFill[0];
                    } // 否则取下方线的下方色上填充
                    else {
                      inside = curr.myFill[0];
                    }

                    ael.splice(i + 1, 0, seg);
                    break;
                  } else if (i === 0) {
                    // inside = false;
                    ael.unshift(seg);
                  }
                }
              }
            } // 重合线的otherFill直接引用指向对方myFill，不能普通计算


            if (!seg.otherCoincide) {
              seg.otherFill[0] = inside;
              seg.otherFill[1] = inside;
            } // console.warn(seg.toString(), inside)

          } else {
            var _i2 = ael.indexOf(seg);

            if (_i2 > -1) {
              ael.splice(_i2, 1);
            }
          }
        });
      }
    }]);

    return Polygon;
  }();

  function findIntersection(list, compareBelong, isIntermediateA, isIntermediateB) {
    // 从左到右扫描，按x坐标排序，相等按y，边会进入和离开扫描线各1次，在扫描线中的边为活跃边，维护1个活跃边列表，新添加的和老的求交
    var ael = [],
        delList = [],
        segments = [];

    while (list.length) {
      if (delList.length) {
        delList.splice(0).forEach(function (seg) {
          var i = ael.indexOf(seg);
          ael.splice(i, 1);

          if (!seg.isDeleted) {
            segments.push(seg);
          }
        });
      }

      var _list$ = list[0],
          x = _list$.x,
          arr = _list$.arr;

      while (arr.length) {
        var seg = arr.shift(); // 被切割的老线段无效

        if (seg.isDeleted) {
          continue;
        }

        var belong = seg.belong,
            bboxA = seg.bbox; // 第2次访问边是离开活动，考虑删除

        if (seg.isVisited) {
          // console.warn(x, seg.toString());
          // console.log(ael.map(item => item.toString()));
          // 可能是垂线不能立刻删除，所以等到下次活动x再删除，因为会出现极端情况刚进来就出去，和后面同y的重合
          if (bboxA[0] !== bboxA[2] || seg.coords.length !== 2) {
            var i = ael.indexOf(seg);
            ael.splice(i, 1);

            if (!seg.isDeleted) {
              segments.push(seg);
            }
          } else {
            delList.push(seg);
          }

          seg.isVisited = false; // 还原以备后面逻辑重复利用
          // console.log(ael.map(item => item.toString()));
        } // 第1次访问边一定是进入活动，求交
        else {
          // console.error(x, seg.toString(), ael.length);
          // console.log(ael.map(item => item.toString()));
          // 和asl里的边求交，如果被分割，新生成的存入asl和hash，老的线段无需再进入asl
          if (ael.length) {
            var coordsA = seg.coords,
                lenA = coordsA.length;
            var _coordsA$ = coordsA[0],
                ax1 = _coordsA$.x,
                ay1 = _coordsA$.y;
            var _coordsA$2 = coordsA[1],
                ax2 = _coordsA$2.x,
                ay2 = _coordsA$2.y;

            for (var _i3 = 0; _i3 < ael.length; _i3++) {
              var item = ael[_i3]; // 被切割的老线段无效，注意seg切割过程中可能变成删除

              if (item.isDeleted || seg.isDeleted) {
                continue;
              } // 互交所属belong不同才进行检测，自交则不检查belong


              if (compareBelong && item.belong === belong) {
                continue;
              } // bbox相交才考虑真正计算，加速


              var bboxB = item.bbox,
                  coordsB = item.coords,
                  lenB = coordsB.length;
              var isSourceReverted = false; // 求交可能a、b线主从互换

              if (isRectsOverlap(bboxA, bboxB, lenA, lenB)) {
                // 完全重合简化，同矩形的线myFill共享，对方矩形互换otherFill
                if (lenA === lenB && seg.equal(item)) {
                  if (compareBelong) {
                    // 因为一定不自交，所以重合线不会被分割
                    seg.otherCoincide++;
                    item.otherCoincide++;
                    seg.otherFill = item.myFill;
                    item.otherFill = seg.myFill;
                  } else {
                    seg.myCoincide++;
                    item.myCoincide++;
                    seg.myFill = item.myFill;
                  }

                  continue;
                }

                var _coordsB$ = coordsB[0],
                    bx1 = _coordsB$.x,
                    by1 = _coordsB$.y;
                var _coordsB$2 = coordsB[1],
                    bx2 = _coordsB$2.x,
                    by2 = _coordsB$2.y;
                var inters = void 0,
                    overs = void 0; // a是直线

                if (lenA === 2) {
                  // b是直线
                  if (lenB === 2) {
                    var d = (by2 - by1) * (ax2 - ax1) - (bx2 - bx1) * (ay2 - ay1); // 平行检查是否重合，否则求交

                    if (d === 0) {
                      // 垂线特殊，y=kx+b没法求
                      if (ax1 === ax2) {
                        if (ax1 === bx1 && ax2 === bx2) {
                          overs = checkOverlapLine(ax1, ay1, ax2, ay2, seg, bx1, by1, bx2, by2, item, true);
                        }
                      } else {
                        // 水平线默认k是0
                        var k1 = 0;
                        var k2 = 0;

                        if (ay2 !== ay1) {
                          k1 = (ax2 - ax1) / (ay2 - ay1);
                        }

                        if (by2 !== by1) {
                          k2 = (bx2 - bx1) / (by2 - by1);
                        }

                        var b1 = ay1 - k1 * ax1;
                        var b2 = by1 - k2 * bx1;

                        if (b1 === b2) {
                          overs = checkOverlapLine(ax1, ay1, ax2, ay2, seg, bx1, by1, bx2, by2, item, false);
                        }
                      }
                    } else {
                      inters = getIntersectionLineLine(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, d);
                    }
                  } // b是曲线
                  else {
                    var _coordsB$3 = coordsB[2],
                        bx3 = _coordsB$3.x,
                        by3 = _coordsB$3.y; // b是2阶曲线

                    if (lenB === 3) {
                      inters = getIntersectionBezier2Line(bx1, by1, bx2, by2, bx3, by3, ax1, ay1, ax2, ay2);
                      isSourceReverted = true;
                    } // b是3阶曲线
                    else {
                      var _coordsB$4 = coordsB[3],
                          bx4 = _coordsB$4.x,
                          by4 = _coordsB$4.y;
                      inters = getIntersectionBezier3Line(bx1, by1, bx2, by2, bx3, by3, bx4, by4, ax1, ay1, ax2, ay2);
                      isSourceReverted = true;
                    }
                  }
                } // a是曲线
                else {
                  var _coordsA$3 = coordsA[2],
                      ax3 = _coordsA$3.x,
                      ay3 = _coordsA$3.y; // a是2阶曲线

                  if (lenA === 3) {
                    // b是直线
                    if (lenB === 2) {
                      inters = getIntersectionBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2);
                    } // b是曲线
                    else {
                      var _coordsB$5 = coordsB[2],
                          _bx = _coordsB$5.x,
                          _by = _coordsB$5.y; // b是2阶曲线

                      if (lenB === 3) {
                        inters = getIntersectionBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, _bx, _by);

                        if (!inters) {
                          overs = checkOverlapBezier(seg, item);
                        }
                      } // b是3阶曲线
                      else {
                        var _coordsB$6 = coordsB[3],
                            _bx2 = _coordsB$6.x,
                            _by2 = _coordsB$6.y;
                        inters = getIntersectionBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, _bx, _by, _bx2, _by2);
                      }
                    }
                  } // a是3阶曲线
                  else {
                    var _coordsA$4 = coordsA[3],
                        ax4 = _coordsA$4.x,
                        ay4 = _coordsA$4.y; // b是直线

                    if (lenB === 2) {
                      inters = getIntersectionBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2);
                    } // b是曲线
                    else {
                      var _coordsB$7 = coordsB[2],
                          _bx3 = _coordsB$7.x,
                          _by3 = _coordsB$7.y; // b是2阶曲线

                      if (lenB === 3) {
                        inters = getIntersectionBezier2Bezier3(bx1, by1, bx2, by2, _bx3, _by3, ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4);
                        isSourceReverted = true;
                      } // b是3阶曲线
                      else {
                        var _coordsB$8 = coordsB[3],
                            _bx4 = _coordsB$8.x,
                            _by4 = _coordsB$8.y;
                        inters = getIntersectionBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, _bx3, _by3, _bx4, _by4);

                        if (!inters) {
                          overs = checkOverlapBezier(seg, item);
                        }
                      }
                    }
                  }
                } // 有重合的，重合线段已经求好，直接使用


                if (overs) {
                  activeNewSeg(segments, list, ael, x, overs.ra);
                  activeNewSeg(segments, list, ael, x, overs.rb);
                  seg.isDeleted = item.isDeleted = true;
                  ael.splice(_i3, 1);
                  break;
                } // 有交点，确保原先线段方向顺序（x升序、y升序），各自依次切割，x右侧新线段也要存入list
                else if (inters && inters.length) {
                  // 特殊检查，当只有一方需要切割时，说明交点在另一方端点上，但是由于精度问题，导致这个点坐标不和那个端点数据一致，
                  // 且进一步为了让点的引用一致，也应该直接使用这个已存在的端点易用
                  for (var _i4 = 0, len = inters.length; _i4 < len; _i4++) {
                    var pt = inters[_i4]; // 只会有一种可能，如果交点对2条线都是误差忽略，求交时已经被屏蔽

                    if (pt.toSource <= EPS) {
                      pt.point = isSourceReverted ? coordsB[0] : coordsA[0];
                    } else if (pt.toSource >= EPS2) {
                      pt.point = isSourceReverted ? coordsB[coordsB.length - 1] : coordsA[coordsA.length - 1];
                    } else if (pt.toClip <= EPS) {
                      pt.point = isSourceReverted ? coordsA[0] : coordsB[0];
                    } else if (pt.toClip >= EPS2) {
                      pt.point = isSourceReverted ? coordsA[coordsA.length - 1] : coordsB[coordsB.length - 1];
                    }
                  } // console.log('inters', i, inters);


                  var pa = sortIntersection(inters, !isSourceReverted); // console.log(pa);

                  var ra = sliceSegment(seg, pa, isIntermediateA && belong === 0); // console.log(ra.map(item => item.toString()));

                  var pb = sortIntersection(inters, isSourceReverted); // console.log(pb);

                  var rb = sliceSegment(item, pb, isIntermediateB && belong === 1); // console.log(rb.map(item => item.toString()));
                  // 新切割的线段继续按照坐标存入列表以及ael，为后续求交

                  activeNewSeg(segments, list, ael, x, ra);
                  activeNewSeg(segments, list, ael, x, rb); // 老的线段被删除无效了，踢出ael，防止seg没被分割

                  if (rb.length) {
                    ael.splice(_i3, 1);
                  }

                  break;
                }
              }
            }
          } // 不相交切割才进入ael


          if (!seg.isDeleted) {
            ael.push(seg);
            seg.isVisited = true;
          } // console.log(ael.map(item => item.toString()));

        }
      }

      list.shift();
    } // 最后面的线


    delList.forEach(function (seg) {
      if (!seg.isDeleted) {
        segments.push(seg);
      }
    }); // 最后再过滤一遍，因为新生成的切割线可能会被再次切割变成删除的无效线段

    return segments.filter(function (item) {
      return !item.isDeleted;
    });
  } // 给定交点列表分割线段，ps需排好顺序从头到尾，isSelf标明是否自相交阶段，false是和对方交点切割


  function sliceSegment(seg, ps, isIntermediate) {
    var res = [];

    if (!ps.length) {
      return res;
    }

    var belong = seg.belong,
        coords = seg.coords,
        len = coords.length;
    var startPoint = coords[0];
    var lastT = 0; // 多个点可能截取多条，最后一条保留只修改数据，其它新生成

    ps.forEach(function (item) {
      var point = item.point,
          t = item.t;
      var ns;

      if (len === 2) {
        ns = new Segment([startPoint, point], belong);
      } else if (len === 3) {
        var c = bezier.sliceBezier2Both(coords.map(function (item) {
          return [item.x, item.y];
        }), lastT, t);
        ns = new Segment([startPoint, new Point(c[1][0], c[1][1]), point], belong);
      } else if (len === 4) {
        var _c = bezier.sliceBezier2Both(coords.map(function (item) {
          return [item.x, item.y];
        }), lastT, t);

        ns = new Segment([startPoint, new Point(_c[1][0], _c[1][1]), new Point(_c[2][0], _c[2][1]), point], belong);
      } // 连续操作的中间结果已有自己内外性，截取时需继承


      if (isIntermediate) {
        ns.myFill[0] = seg.myFill[0];
        ns.myFill[1] = seg.myFill[1];
      }

      startPoint = point;
      res.push(ns);
      lastT = t;
    }); // 最后一条

    var ns;

    if (len === 2) {
      ns = new Segment([startPoint, coords[1]], belong);
    } else if (len === 3) {
      var c = bezier.sliceBezier2Both(coords.map(function (item) {
        return [item.x, item.y];
      }), lastT, 1);
      ns = new Segment([startPoint, new Point(c[1][0], c[1][1]), coords[2]], belong);
    } else if (len === 4) {
      var _c2 = bezier.sliceBezier2Both(coords.map(function (item) {
        return [item.x, item.y];
      }), lastT, 1);

      ns = new Segment([startPoint, new Point(_c2[1][0], _c2[1][1]), new Point(_c2[2][0], _c2[2][1]), coords[3]], belong);
    }

    if (isIntermediate) {
      ns.myFill[0] = seg.myFill[0];
      ns.myFill[1] = seg.myFill[1];
    }

    res.push(ns); // 老的打标失效删除

    seg.isDeleted = true;
    return res;
  } // 相交的线段slice成多条后，老的删除，新的考虑添加进扫描列表和活动边列表，根据新的是否在范围内


  function activeNewSeg(segments, list, ael, x, ns) {
    ns.forEach(function (seg) {
      var bbox = seg.bbox,
          x1 = bbox[0],
          x2 = bbox[2]; // console.log(seg.toString(), x1, x2, x);
      // 活跃x之前无相交判断意义，除了竖线，出现活跃前只可能一方为竖线截断另一方的左边部分

      if (x2 <= x && x1 !== x2 && seg.coords.length !== 2) {
        segments.push(seg);
        return;
      } // 按顺序放在list的正确位置，可能x1已经过去不需要加入了，但要考虑ael


      var i = 0;

      if (x1 < x) {
        seg.isVisited = true;
        ael.push(seg);
      } else {
        for (var len = list.length; i < len; i++) {
          var item = list[i];
          var lx = item.x;

          if (x1 === lx) {
            item.arr.push(seg);
            break;
          } // 新的插入


          if (x1 < lx) {
            var temp = {
              x: x1,
              arr: [seg]
            };
            list.splice(i, 0, temp);
            break;
          }
        }
      } // x2一定会加入


      for (var _len = list.length; i < _len; i++) {
        var _item = list[i];
        var _lx = _item.x;

        if (x2 === _lx) {
          // 访问过的尽可能排在前面早出栈，减少对比次数
          _item.arr.unshift(seg);

          break;
        }

        if (x2 < _lx) {
          var _temp = {
            x: x2,
            arr: [seg]
          };
          list.splice(i, 0, _temp);
          break;
        }
      }
    });
  } // 按x升序将所有线段组成一个垂直扫描线列表，求交用，y方向不用管


  function genHashXList(segments) {
    var hashX = {};
    segments.forEach(function (seg) {
      var bbox = seg.bbox,
          min = bbox[0],
          max = bbox[2];
      putHashX(hashX, min, seg);
      putHashX(hashX, max, seg);
    });
    var list = [];
    Object.keys(hashX).forEach(function (x) {
      return list.push({
        x: parseFloat(x),
        arr: hashX[x]
      });
    });
    return list.sort(function (a, b) {
      return a.x - b.x;
    });
  } // 每个线段会放2次，开始点和结束点，哪怕x相同，第1次是开始用push，第2次结束unshift，这样离开时排在前面


  function putHashX(hashX, x, seg) {
    var list = hashX[x] = hashX[x] || [];

    if (seg.isVisited) {
      list.unshift(seg);
      seg.isVisited = false;
    } else {
      list.push(seg);
      seg.isVisited = true;
    }
  } // 按x升序将所有线段组成一个垂直扫描线列表，y方向也需要判断


  function genHashXYList(segments) {
    var hashXY = {};
    segments.forEach(function (seg) {
      var coords = seg.coords,
          l = coords.length;
      var start = coords[0],
          end = coords[l - 1];
      putHashXY(hashXY, start.x, start.y, seg, true);
      putHashXY(hashXY, end.x, end.y, seg, false);
    });
    var listX = [];
    Object.keys(hashXY).forEach(function (x) {
      var hashY = hashXY[x];
      var listY = [];
      Object.keys(hashY).forEach(function (y) {
        var arr = hashY[y].sort(function (a, b) {
          // end优先于start先触发
          if (a.isStart !== b.isStart) {
            return a.isStart ? 1 : -1;
          } // start点相同看谁在上谁在下，下方在前，比y极大值，因为start相同又不相交，所以上方的y极值更大


          if (a.isStart) {
            return segAboveCompare(a.seg, b.seg) ? 1 : -1;
          } // end点相同无所谓，其不参与运算，因为每次end线段先出栈ael

        }); // console.log(x, y, arr.map(item => item.isStart + ', ' + item.seg.toString()));

        listY.push({
          y: parseFloat(y),
          arr: arr
        });
      });
      listX.push({
        x: parseFloat(x),
        arr: listY.sort(function (a, b) {
          return a.y - b.y;
        })
      });
    });
    listX.sort(function (a, b) {
      return a.x - b.x;
    });
    var list = [];
    listX.forEach(function (item) {
      item.arr.forEach(function (item) {
        list = list.concat(item.arr);
      });
    });
    return list;
  }

  function putHashXY(hashXY, x, y, seg, isStart) {
    var hash = hashXY[x] = hashXY[x] || {};
    var list = hash[y] = hash[y] || [];
    list.push({
      isStart: isStart,
      seg: seg
    });
  } // pt在线段left -> right的上方或线上


  function pointAboveOrOnLine(pt, left, right) {
    var x = pt.x,
        y = pt.y;
    var x1 = left.x,
        y1 = left.y;
    var x2 = right.x,
        y2 = right.y;
    return vector.crossProduct(x1 - x, y1 - y, x2 - x, y2 - y) >= 0;
  } // a是否在b的上边，取x相同部分看y大小，只有start点事件时才判断


  function segAboveCompare(segA, segB) {
    var ca = segA.coords,
        cb = segB.coords;
    var la = ca.length,
        lb = cb.length;
    var a1 = ca[0],
        b1 = cb[0]; // 两条直线用向量积判断，注意开始点是否相同即可

    if (la === 2 && lb === 2) {
      var a2 = ca[1],
          b2 = cb[1];

      if (a1.equal(b1)) {
        return pointAboveOrOnLine(a2, b1, b2);
      } else {
        return pointAboveOrOnLine(a1, b1, b2);
      }
    } // a是竖线的话看另一条在左还是右，左的话a在下，否则在上，因为此时只可能是左和a尾相连或右和a首相连


    if (la === 2 && a1.x === ca[1].x) {
      return b1.x >= a1.x;
    } // 如果有曲线，取二者x共同的区域部分[x1, x3]，以及区域中点x2，这3个点不可能都重合，一定会有某点的y比较大小


    var x1 = Math.max(a1.x, b1.x),
        x3 = Math.min(ca[la - 1].x, cb[lb - 1].x),
        x2 = x1 + (x3 - x1) * 0.5;

    if (a1 !== b1) {
      var _y = getYByX(ca, x1),
          _y2 = getYByX(cb, x1);

      if (_y !== _y2) {
        return _y > _y2;
      }
    }

    if (ca[la - 1] !== cb[lb - 1]) {
      var _y3 = getYByX(ca, x3),
          _y4 = getYByX(cb, x3);

      if (_y3 !== _y4) {
        return _y3 > _y4;
      }
    }

    var y1 = getYByX(ca, x2),
        y2 = getYByX(cb, x2);

    if (y1 !== y2) {
      return y1 > y2;
    }
  } // 获取曲线单调性t值，有结果才返回


  function getBezierMonotonicity(coords, isX) {
    if (coords.length === 3) {
      var t = isX ? (coords[0].x - coords[1].x) / (coords[0].x - 2 * coords[1].x + coords[2].x) : (coords[0].y - coords[1].y) / (coords[0].y - 2 * coords[1].y + coords[2].y);

      if (t > 1e-9 && t < 1 - 1e-9) {
        return [t];
      }
    } else if (coords.length === 4) {
      var _t2 = equation.getRoots([isX ? 3 * (coords[1].x - coords[0].x) : 3 * (coords[1].y - coords[0].y), isX ? 6 * (coords[2].x + coords[0].x - 2 * coords[1].x) : 6 * (coords[2].y + coords[0].y - 2 * coords[1].y), isX ? 3 * (coords[3].x + 3 * coords[1].x - coords[0].x - 3 * coords[2].x) : 3 * (coords[3].y + 3 * coords[1].y - coords[0].y - 3 * coords[2].y)]).filter(function (i) {
        return i > 1e-9 && i < 1 - 1e-9;
      });

      if (_t2.length) {
        return _t2.sort(function (a, b) {
          return a - b;
        });
      }
    }
  } // 根据x的值解得t后获取y，由于线段已经x单调，所以解只会有1个而非多个


  function getYByX(coords, x) {
    var len = coords.length;

    if (x === coords[0].x) {
      return coords[0].y;
    }

    if (x === coords[len - 1].x) {
      return coords[len - 1].y;
    }

    if (len === 2) {
      if (coords[0].y === coords[1].y) {
        return coords[0].y;
      }

      var p = (x - coords[0].x) / (coords[1].x - coords[0].x);
      return coords[0].y + p * (coords[1].y - coords[0].y);
    } else if (len === 3) {
      var t = equation.getRoots([coords[0].x - x, 2 * (coords[1].x - coords[0].x), coords[2].x + coords[0].x - 2 * coords[1].x]).filter(function (i) {
        return i >= 0 && i <= 1;
      });
      var pts = coords.map(function (item) {
        return [item.x, item.y];
      });
      return bezier.pointAtByT(pts, t[0])[1];
    } else if (len === 4) {
      var _t3 = equation.getRoots([coords[0].x - x, 3 * (coords[1].x - coords[0].x), 3 * (coords[2].x + coords[0].x - 2 * coords[1].x), coords[3].x + 3 * coords[1].x - coords[0].x - 3 * coords[2].x]).filter(function (i) {
        return i >= 0 && i <= 1;
      });

      var _pts = coords.map(function (item) {
        return [item.x, item.y];
      });

      return bezier.pointAtByT(_pts, _t3[0])[1];
    }
  }

  function isRectsOverlap(bboxA, bboxB, lenA, lenB) {
    if (lenA === 2 && lenB === 2) {
      // 2条垂线特殊考虑，此时x范围都是0，只能比较y
      if (bboxA[0] === bboxA[2] && bboxB[0] === bboxB[2] && bboxA[0] === bboxA[2]) {
        if (bboxA[1] >= bboxB[3] || bboxB[1] >= bboxA[3]) {
          return false;
        }

        return true;
      } // 2条水平线也是


      if (bboxA[1] === bboxA[3] && bboxB[1] === bboxB[3] && bboxA[1] === bboxA[3]) {
        if (bboxA[0] >= bboxB[2] || bboxB[0] >= bboxA[2]) {
          return false;
        }

        return true;
      }
    }

    return geom.isRectsOverlap(bboxA, bboxB);
  }

  function checkOverlapLine(ax1, ay1, ax2, ay2, segA, bx1, by1, bx2, by2, segB, isY) {
    var ra = [],
        rb = [];
    var coordsA = segA.coords,
        coordsB = segB.coords;

    if (ax1 < bx1 && !isY || ay1 < by1 && isY) {
      ra.push(new Segment([coordsA[0], coordsB[0]], segA.belong));

      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsB[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else if (ax2 === bx2 && !isY || ay2 === by2 && isY) {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
      }
    } // 不会出现完全重合即ax2 == bx2
    else if (ax1 === bx1 && !isY || ay1 === by1 && isY) {
      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
      }
    } // ax1 > bx1
    else {
      rb.push(new Segment([coordsB[0], coordsA[0]], segB.belong));

      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else if (ax2 === bx2 && !isY || ay2 === by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsA[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsB[1]], segB.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
      }
    }

    return {
      ra: ra,
      rb: rb
    };
  }

  function checkOverlapBezier(segA, segB) {
    var ca = segA.coords.map(function (item) {
      return [item.x, item.y];
    }),
        la = ca.length;
    var cb = segB.coords.map(function (item) {
      return [item.x, item.y];
    }),
        lb = cb.length;
    var firstA = ca[0],
        firstB = cb[0],
        lastA = ca[la - 1],
        lastB = cb[lb - 1];
    var t1 = bezier.getPointT(ca, firstB[0], firstB[1]);
    var t2 = bezier.getPointT(ca, lastB[0], lastB[1]);
    var t3 = bezier.getPointT(cb, firstA[0], firstA[1]);
    var t4 = bezier.getPointT(cb, lastA[0], lastA[1]); // console.warn(segA.toString());console.warn(segB.toString());
    // console.log(t1, t2, t3, t4);

    var l1 = t1.length,
        l2 = t2.length,
        l3 = t3.length,
        l4 = t4.length;
    /**
     * 重合有3种情况，对应4个t（每方各2个）的情况不同：
     * a. 一个包含另外一个，这样其中一方t为空，另一方t为2个即两个端点各1
     * b. 一对端点重合另外一侧包含，比上面的t多1个即空的那方t多1
     * c. 普通部分重合，每方各有1个t
     */

    var conditionA = l1 === 1 && l2 === 1 && l3 === 0 && l4 === 0 || l1 === 0 && l2 === 0 && l3 === 1 && l4 === 1;
    var conditionB = l1 === 1 && l2 === 1 && l3 + l4 === 1 || l1 + l2 === 1 && l3 === 1 && l4 === 1;
    var conditionC = l1 + l2 === 1 && l3 + l4 === 1;

    if (conditionA || conditionB || conditionC) {
      var startA = l1 ? t1[0] : 0;
      var endA = l2 ? t2[0] : 1;
      var a = bezier.sliceBezier2Both(ca, startA, endA);
      var startB = l3 ? t3[0] : 0;
      var endB = l4 ? t4[0] : 1;
      var b = bezier.sliceBezier2Both(cb, startB, endB); // console.log(startA, endA, startB, endB);
      // 确定重合之后就是截取，重合一定出现在左右的中间部分，这样只要分别判断左右两端是否需要各自裁剪即可

      if (equalBezier(a, b)) {
        var over = a.map(function (item) {
          return new Point(item);
        }); // console.log(over);

        var ra = [],
            rb = [];

        if (startA > 0) {
          var s = bezier.sliceBezier2Both(ca, 0, startA);
          var arr = [segA.coords[0], new Point(s[1]), segB.coords[0]];

          if (la === 4) {
            arr.splice(2, 0, new Point(s[2]));
          }

          ra.push(new Segment(arr, segA.belong));
        }

        ra.push(new Segment(over, segA.belong)); // 重合的部分

        if (endA < 1) {
          var _s = bezier.sliceBezier2Both(ca, endA, 1);

          var _arr = [segB.coords[lb - 1], new Point(_s[1]), segA.coords[la - 1]];

          if (la === 4) {
            _arr.splice(2, 0, new Point(_s[2]));
          }

          ra.push(new Segment(_arr, segA.belong));
        }

        if (startB > 0) {
          var _s2 = bezier.sliceBezier2Both(cb, 0, startB);

          var _arr2 = [segB.coords[0], new Point(_s2[1]), segA.coords[0]];

          if (lb === 4) {
            _arr2.splice(2, 0, new Point(_s2[2]));
          }

          rb.push(new Segment(_arr2, segB.belong));
        }

        rb.push(new Segment(over, segB.belong)); // 重合的部分

        if (endB < 1) {
          var _s3 = bezier.sliceBezier2Both(cb, endB, 1);

          var _arr3 = [segA.coords[la - 1], new Point(_s3[1]), segB.coords[lb - 1]];

          if (lb === 4) {
            _arr3.splice(2, 0, new Point(_s3[2]));
          }

          rb.push(new Segment(_arr3, segB.belong));
        } // console.log(ra.map(item => item.toString()));
        // console.log(rb.map(item => item.toString()));


        return {
          ra: ra,
          rb: rb
        };
      }
    }
  }

  function equalBezier(a, b) {
    for (var i = 0, len = a.length; i < len; i++) {
      var ai = a[i],
          bi = b[i];

      if (Math.abs(ai[0] - bi[0]) > 1e-9 || Math.abs(ai[1] - bi[1]) > 1e-9) {
        return false;
      }
    }

    return true;
  }

  function join(res, chains, chain, index, pt, isHead) {
    for (var i = 0, len = chains.length; i < len; i++) {
      var item = chains[i];

      if (item !== chain) {
        var l = item.length;
        var head = item[0],
            tail = item[l - 1];
        var ptHead = head.coords[0];
        var coords = tail.coords,
            l2 = coords.length;
        var ptTail = coords[l2 - 1];

        if (pt.equal(ptHead)) {
          if (isHead) {
            item = reverse(chain).concat(item);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          } else {
            item = chain.concat(item);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          }
        } else if (pt.equal(ptTail)) {
          if (isHead) {
            item = item.concat(chain);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          } else {
            item = item.concat(reverse(chain));
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          }
        }
      }
    } // 无法和别的链接，也要检查自身闭合


    close(res, chains, chain, index);
  }

  function close(res, chains, chain, index) {
    var l = chain.length;
    var head = chain[0],
        tail = chain[l - 1];
    var ptHead = head.coords[0];
    var coords2 = tail.coords,
        l2 = coords2.length;
    var ptTail = coords2[l2 - 1];

    if (ptHead.equal(ptTail)) {
      chains.splice(index, 1);
      res.push(chain);
    }
  } // 整条链颠倒，包含每个线段自身颠倒


  function reverse(chain) {
    chain.forEach(function (item) {
      return item.reverse();
    });
    return chain.reverse();
  }

  function chains (list) {
    var chains = [],
        res = []; // 在对方内部的排在前面，这样会优先形成包含情况而不是交叉

    list.sort(function (a, b) {
      if (b.otherFill[0] && b.otherFill[1]) {
        return 1;
      }

      return -1;
    });

    outer: while (list.length) {
      var seg = list.shift(),
          coords = seg.coords,
          len = coords.length;
      var start = coords[0],
          end = coords[len - 1];
      var temp = void 0; // 尝试追加到某条链中，互相头尾链接可能有4种情况，其中2种会reverse线段首尾

      for (var i = 0, _len = chains.length; i < _len; i++) {
        var chain = chains[i],
            l = chain.length;
        var head = chain[0],
            tail = chain[l - 1];
        var ptHead = head.coords[0];
        var coords2 = tail.coords,
            l2 = coords2.length;
        var ptTail = coords2[l2 - 1];

        if (start.equal(ptTail)) {
          if (seg.belong !== tail.belong) {
            chain.push(seg);
            join(res, chains, chain, i, end, false);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 0
            };
          }
        } else if (start.equal(ptHead)) {
          if (seg.belong !== tail.belong) {
            seg.reverse();
            chain.unshift(seg);
            join(res, chains, chain, i, end, true);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 1
            };
          }
        } else if (end.equal(ptTail)) {
          if (seg.belong !== tail.belong) {
            seg.reverse();
            chain.push(seg);
            join(res, chains, chain, i, start, false);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 2
            };
          }
        } else if (end.equal(ptHead)) {
          if (seg.belong !== tail.belong) {
            chain.unshift(seg);
            join(res, chains, chain, i, start, true);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 3
            };
          }
        }
      } // 如果没有优先添加对方的线段形成包含，则到这里检查是否有己方的进行链接


      if (temp) {
        if (temp.t === 0) {
          chains[temp.i].push(seg);
          join(res, chains, chains[temp.i], temp.i, end, false);
        } else if (temp.t === 1) {
          seg.reverse();
          chains[temp.i].unshift(seg);
          join(res, chains, chains[temp.i], temp.i, end, true);
        } else if (temp.t === 2) {
          seg.reverse();
          chains[temp.i].push(seg);
          join(res, chains, chains[temp.i], temp.i, start, false);
        } else if (temp.t === 3) {
          chains[temp.i].unshift(seg);
          join(res, chains, chains[temp.i], temp.i, start, true);
        }
      } // 找不到则生成新链
      else {
        chains.push([seg]);
      }
    } // 鞋带公式求得每个多边形的时钟序  https://zhuanlan.zhihu.com/p/401010594


    var v = res.map(function (item) {
      // let isInner = true, isOuter = true;
      var clockwise = true;
      var s = 0,
          lastX,
          lastY,
          minX,
          minY,
          maxX,
          maxY;
      item.forEach(function (seg, i) {
        // 内部是指边的两侧都是对方填充说明在内部
        // if(!seg.otherFill[0] || !seg.otherFill[1]) {
        //   isInner = false;
        // }
        // // 外部是指边的一侧为空
        // if(!seg.myFill[0] && !seg.otherFill[0] || !seg.myFill[1] && !seg.otherFill[1]) {}
        // else {
        //   isOuter = false;
        // }
        var coords = seg.coords,
            len = coords.length,
            bbox = seg.bbox;

        if (i) {
          minX = Math.min(minX, bbox[0]);
          minY = Math.min(minY, bbox[1]);
          maxX = Math.max(maxX, bbox[2]);
          maxY = Math.max(maxY, bbox[3]);
        } else {
          minX = bbox[0];
          minY = bbox[1];
          maxX = bbox[2];
          maxY = bbox[3];
        }

        if (len === 2) {
          if (i) {
            s += lastX * coords[1].y - lastY * coords[1].x;
          } else {
            s += coords[0].x * coords[1].y - coords[0].y * coords[1].x;
          }

          lastX = coords[1].x;
          lastY = coords[1].y;
        } else if (len === 3) {
          if (i) {
            s += lastX * coords[2].y - lastY * coords[2].x;
          } else {
            s += coords[0].x * coords[1].y - coords[0].y * coords[2].x;
          }

          lastX = coords[2].x;
          lastY = coords[2].y;
        } else if (len === 4) {
          if (i) {
            s += lastX * coords[3].y - lastY * coords[3].x;
          } else {
            s += coords[0].x * coords[3].y - coords[0].y * coords[3].x;
          }

          lastX = coords[3].x;
          lastY = coords[3].y;
        }
      }); // 首个顶点重合

      var first = item[0],
          coords = first.coords;
      s += lastX * coords[0].y - lastY * coords[0].x;

      if (s < 0) {
        clockwise = false;
      }

      return {
        // isInner,
        // isOuter,
        list: item,
        clockwise: clockwise,
        bbox: [minX, minY, maxX, maxY],
        area: (maxX - minX) * (maxY - minY)
      };
    });
    v.forEach(function (item) {
      if (item.checked) {
        return;
      }

      var bbox = item.bbox;
      var list = [item];

      for (var _i = 0, _len2 = v.length; _i < _len2; _i++) {
        var item2 = v[_i];

        if (item2 !== item) {
          // 互相包含则存入列表
          if (geom.isRectsInside(bbox, item2.bbox, true) || geom.isRectsInside(item2.bbox, bbox, true)) {
            list.push(item2);
          }
        }
      } // 按面积排序，最小的即最里面的在前面


      if (list.length > 1) {
        list.sort(function (a, b) {
          return a.area - b.area;
        }); // 可能存在已经排过序的，例如外围a包含了内部的b和c，b和c互不相交，a和b已经调整过排序了，a和c再调整则a已经checked

        for (var _i2 = 1, _len3 = list.length; _i2 < _len3; _i2++) {
          var _item = list[_i2];

          if (_item.checked) {
            var _clockwise = _item.clockwise;

            for (var j = _i2 - 1; j >= 0; j--) {
              var _item2 = list[j];
              _item2.checked = true;

              if (_item2.clockwise === _clockwise) {
                reverse(_item2.list);
                _item2.clockwise = !_clockwise;
              }

              _clockwise = !_clockwise;
            }

            _clockwise = _item.clockwise;

            for (var _j = _i2 + 1; _j < _len3; _j++) {
              var _item3 = list[_j];
              _item3.checked = true;

              if (_item3.clockwise === _clockwise) {
                reverse(_item3.list);
                _item3.clockwise = !_clockwise;
              }

              _clockwise = !_clockwise;
            }

            return;
          }
        } // 新的依次时钟序互相颠倒


        var clockwise = list[0].clockwise;
        list[0].checked = true;

        for (var _i3 = 1, _len4 = list.length; _i3 < _len4; _i3++) {
          var _item4 = list[_i3];
          _item4.checked = true;

          if (_item4.clockwise === clockwise) {
            reverse(_item4.list);
            _item4.clockwise = !clockwise;
          }

          clockwise = !clockwise;
        }
      }
    });
    return v.map(function (item) {
      var list = item.list.map(function (seg) {
        var coords = seg.coords,
            len = coords.length;

        if (len === 2) {
          return [coords[1].x, coords[1].y];
        } else if (len === 3) {
          return [coords[1].x, coords[1].y, coords[2].x, coords[2].y];
        } else if (len === 4) {
          return [coords[1].x, coords[1].y, coords[2].x, coords[2].y, coords[3].x, coords[3].y];
        }
      }); // 首个顶点重合

      var first = item.list[0],
          coords = first.coords;
      list.unshift([coords[0].x, coords[0].y]);
      return list;
    });
  }

  function prefix(polygon) {
    if (!polygon || !Array.isArray(polygon) || !Array.isArray(polygon[0])) {
      return [];
    }

    if (Array.isArray(polygon[0][0])) {
      return polygon;
    }

    return [polygon];
  }

  function trivial(polygonA, polygonB) {
    var isIntermediateA = polygonA instanceof Polygon$1;
    var isIntermediateB = polygonB instanceof Polygon$1; // 生成多边形对象，相交线段拆分开来，曲线x单调性裁剪，重合线段标记

    var source;

    if (isIntermediateA) {
      source = polygonA.reset(0);
    } else {
      source = new Polygon$1(prefix(polygonA), 0);
      source.selfIntersect();
    } // console.log(source.toString());


    var clip;

    if (isIntermediateB) {
      clip = polygonB.reset(1);
    } else {
      clip = new Polygon$1(prefix(polygonB), 1);
      clip.selfIntersect();
    } // console.log(clip.toString());
    // console.log('----');
    // 两个多边形之间再次互相判断相交


    Polygon$1.intersect2(source, clip, isIntermediateA, isIntermediateB); // console.log(source.toString());
    // console.log(clip.toString());
    // console.log('====');

    Polygon$1.annotate2(source, clip, isIntermediateA, isIntermediateB); // console.log(source.toString());
    // console.log(clip.toString());

    return [source, clip];
  }

  var INTERSECT = [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0],
      UNION = [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
      SUBTRACT = [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0],
      SUBTRACT_REV = [0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0],
      XOR = [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0];

  function filter(segments, matrix) {
    var res = [],
        hash = {};
    segments.forEach(function (seg) {
      var belong = seg.belong,
          myFill = seg.myFill,
          otherFill = seg.otherFill,
          otherCoincide = seg.otherCoincide;

      if (otherCoincide) {
        // 对方重合线只出现一次
        var hc = seg.toHash();

        if (hash.hasOwnProperty(hc)) {
          return;
        }

        hash[hc] = true;
      }

      var i;

      if (belong) {
        i = (otherFill[0] ? 8 : 0) + (myFill[0] ? 4 : 0) + (otherFill[1] ? 2 : 0) + (myFill[1] ? 1 : 0);
      } else {
        i = (myFill[0] ? 8 : 0) + (otherFill[0] ? 4 : 0) + (myFill[1] ? 2 : 0) + (otherFill[1] ? 1 : 0);
      }

      if (matrix[i]) {
        res.push(seg);
      }
    }); // console.log(res.map(item => item.toString()));

    return res;
  }

  var bo = {
    intersect: function intersect(polygonA, polygonB, intermediate) {
      var _trivial = trivial(polygonA, polygonB),
          _trivial2 = _slicedToArray(_trivial, 2),
          source = _trivial2[0],
          clip = _trivial2[1];

      var list = filter(source.segments.concat(clip.segments), INTERSECT);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return chains(list);
    },
    union: function union(polygonA, polygonB, intermediate) {
      var _trivial3 = trivial(polygonA, polygonB),
          _trivial4 = _slicedToArray(_trivial3, 2),
          source = _trivial4[0],
          clip = _trivial4[1];

      var list = filter(source.segments.concat(clip.segments), UNION);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return chains(list);
    },
    subtract: function subtract(polygonA, polygonB, intermediate) {
      var _trivial5 = trivial(polygonA, polygonB),
          _trivial6 = _slicedToArray(_trivial5, 2),
          source = _trivial6[0],
          clip = _trivial6[1];

      var list = filter(source.segments.concat(clip.segments), SUBTRACT); // 暂时这样解决反向的问题

      if (!list.length) {
        list = filter(source.segments.concat(clip.segments), SUBTRACT_REV);
      }

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return chains(list);
    },
    subtractRev: function subtractRev(polygonA, polygonB, intermediate) {
      var _trivial7 = trivial(polygonA, polygonB),
          _trivial8 = _slicedToArray(_trivial7, 2),
          source = _trivial8[0],
          clip = _trivial8[1];

      var list = filter(source.segments.concat(clip.segments), SUBTRACT_REV);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return chains(list);
    },
    xor: function xor(polygonA, polygonB, intermediate) {
      var _trivial9 = trivial(polygonA, polygonB),
          _trivial10 = _slicedToArray(_trivial9, 2),
          source = _trivial10[0],
          clip = _trivial10[1];

      var list = filter(source.segments.concat(clip.segments), XOR);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return chains(list);
    },
    chain: function chain(polygon) {
      if (polygon instanceof Polygon$1) {
        return chains(polygon.segments);
      }

      return prefix(polygon);
    },
    chains: chains
  };

  var intersect = bo.intersect,
      union = bo.union,
      subtract = bo.subtract,
      subtractRev = bo.subtractRev,
      xor = bo.xor,
      chain = bo.chain;
  var STROKE_WIDTH$4 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$6 = util.isNil;

  var Polyline = /*#__PURE__*/function (_Geom) {
    _inherits(Polyline, _Geom);

    function Polyline(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 所有点的列表

      if (_this.isMulti) {
        _this.__points = [[]];
        _this.__controls = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__points.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$6(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__points.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i = _this.__end.length; _i < _this.__points.length; _i++) {
            _this.__end.push(1);
          }
        } else if (!isNil$6(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__points.map(function () {
            return _v;
          });
        }
      } else {
        _this.__points = []; // 控制点

        _this.__controls = [];
        _this.__start = 0;
        _this.__end = 1;

        if (!isNil$6(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$6(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }
      }

      if (Array.isArray(props.controls)) {
        _this.__controls = props.controls;
      }

      if (Array.isArray(props.points)) {
        _this.__points = props.points;
      }

      if (props.booleanOperations) {
        _this.__booleanOperations = props.booleanOperations;
      }

      return _this;
    }

    _createClass(Polyline, [{
      key: "calContent",
      value: function calContent(currentStyle, computedStyle) {
        var res = _get(_getPrototypeOf(Polyline.prototype), "calContent", this).call(this, currentStyle, computedStyle); // 查看是否有顶点


        if (res && !this.__hasXomContent) {
          var points = this.currentProps.points,
              isMulti = this.isMulti;

          if (isMulti) {
            for (var i = 0, len = points.length; i < len; i++) {
              if (points.length) {
                return true;
              }
            }
          } else {
            if (points.length) {
              return true;
            }
          }
        }

        return res;
      }
    }, {
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        return points.map(function (item) {
          if (!Array.isArray(item)) {
            return;
          }

          var len = item.length;

          if (isControl) {
            if (len !== 0 && len !== 2 && len !== 4) {
              return;
            }
          } else {
            if (len !== 0 && len !== 2) {
              return;
            }
          }

          var res = [];

          for (var i = 0; i < len; i++) {
            if (i % 2 === 0) {
              res.push(originX + item[i] * width);
            } else {
              res.push(originY + item[i] * height);
            }
          }

          return res;
        });
      } // 供polygon覆盖，后处理booleanOperations

    }, {
      key: "__reprocessing",
      value: function __reprocessing(list, isMulti) {
        if (!isMulti || list.length < 2) {
          return list;
        }

        var bo = this.booleanOperations,
            len = list.length;

        if (!bo) {
          return list;
        }

        if (!Array.isArray(bo)) {
          var old = bo;
          bo = [bo];

          for (var i = 1; i < len - 1; i++) {
            bo.push(old);
          }
        }

        if (Array.isArray(bo) && bo.length) {
          var res = [],
              temp = list[0];

          for (var _i2 = 1; _i2 < len; _i2++) {
            var op = (bo[_i2 - 1] || '').toString().toLowerCase();
            var cur = list[_i2];

            if (['intersect', 'intersection', 'union', 'subtract', 'subtractrev', 'diff', 'difference', 'xor'].indexOf(op) === -1) {
              res = res.concat(chain(temp));
              temp = cur || [];
              continue;
            }

            switch (op) {
              case 'intersect':
              case 'intersection':
                temp = intersect(temp, cur, true);
                break;

              case 'union':
                temp = union(temp, cur, true);
                break;

              case 'subtract':
              case 'diff':
              case 'difference':
                temp = subtract(temp, cur, true);
                break;

              case 'subtractrev':
                temp = subtractRev(temp, cur, true);
                break;

              case 'xor':
                temp = xor(temp, cur, true);
                break;
            }
          }

          return res.concat(chain(temp));
        }

        return list;
      } // 同polygon覆盖，booleanOperations改变时需刷新缓冲顶点坐标

    }, {
      key: "__needRebuildSE",
      value: function __needRebuildSE(__cacheProps) {
        if (util.isNil(__cacheProps.booleanOperations)) {
          __cacheProps.booleanOperations = true;
          return true;
        }
      }
    }, {
      key: "__buildCache",
      value: function __buildCache(originX, originY) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            points = this.points,
            controls = this.controls,
            start = this.start,
            end = this.end,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild, rebuildSE;

        if (isNil$6(__cacheProps.points)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.points = points.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item);
              }
            });
          } else {
            __cacheProps.points = this.__getPoints(originX, originY, width, height, points);
          }
        }

        if (isNil$6(__cacheProps.controls)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.controls = controls.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item, true);
              }

              return item;
            });
          } else {
            __cacheProps.controls = this.__getPoints(originX, originY, width, height, controls, true);
          }
        }

        if (isNil$6(__cacheProps.start)) {
          rebuildSE = true;
          __cacheProps.start = start;
        }

        if (isNil$6(__cacheProps.end)) {
          rebuildSE = true;
          __cacheProps.end = end;
        } // polygon会覆盖检查booleanOperations缓存


        if (this.__needRebuildSE(__cacheProps)) {
          rebuildSE = true;
        } // points/controls有变化就需要重建顶点


        if (rebuild) {
          var _points = __cacheProps.points,
              _controls = __cacheProps.controls;

          if (isMulti) {
            __cacheProps.list2 = _points.map(function (item, i) {
              var cl = _controls[i];

              if (Array.isArray(item)) {
                return item.map(function (point, j) {
                  if (j) {
                    return _this2.__concatPointAndControl(point, cl && cl[j - 1]);
                  }

                  return point;
                });
              }
            });
            __cacheProps.len = this.__getLength(__cacheProps.list2, isMulti);
          } else {
            __cacheProps.list2 = _points.map(function (point, i) {
              if (i) {
                return _this2.__concatPointAndControl(point, _controls[i - 1]);
              }

              return point;
            });
            __cacheProps.len = this.__getLength(__cacheProps.list2, isMulti);
          }
        }

        if (rebuild || rebuildSE) {
          if (isMulti) {
            __cacheProps.list = __cacheProps.list2.map(function (item, i) {
              if (Array.isArray(item)) {
                var len = __cacheProps.len;
                return _this2.__getNewList(item, {
                  list: len.list[i],
                  total: len.total[i],
                  increase: len.increase[i]
                }, __cacheProps.start[i], __cacheProps.end[i]);
              }
            });
          } else {
            __cacheProps.list = this.__getNewList(__cacheProps.list2, __cacheProps.len, __cacheProps.start, __cacheProps.end);
          } // 后处理一次，让polygon支持布尔运算


          __cacheProps.list = this.__reprocessing(__cacheProps.list, isMulti);
        }

        return rebuild || rebuildSE;
      }
    }, {
      key: "__getNewList",
      value: function __getNewList(list, len) {
        var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        if (start === 0 && end === 1) {
          return list;
        }

        if (start === end) {
          return [];
        }

        if (start > end) {
          var _ref = [end, start];
          start = _ref[0];
          end = _ref[1];
        } // start和end只能相差<=1，如果>1则校正


        while (end - start > 1) {
          end--;
        } // 将start和end统一至最接近0的正值


        while (end < 0 || start < 0) {
          end++;
          start++;
        }

        while (end >= 1 && start >= 1) {
          end--;
          start--;
        } // clone出原本顶点列表，防止干扰


        var length = list.length;
        list = util.clone(list);
        var res = [];
        var start2 = start > 1 ? start - 1 : start;
        var end2 = end > 1 ? end - 1 : end;

        var i = this.__getIndex(len.increase, start2 * len.total, 0, length - 1);

        var j = this.__getIndex(len.increase, end2 * len.total, 0, length - 1); // start<0或者end>1或者普通情况，一共3种，start和end不可能同时超限


        var isStartLt0 = start < 0;
        var isEndGt1 = end > 1;
        end2 *= len.total;
        var prePercent = 1;
        var endPoint;

        if (end2 > len.increase[j]) {
          var prev = list[j].slice(list[j].length - 2); // 最后2个点是x,y，前面是control

          var current = list[j + 1];
          var l = len.list[j];
          var diff = end2 - len.increase[j];
          var t = diff / l;
          prePercent = t;

          if (current.length === 2) {
            var a = current[0] - prev[0];
            var b = current[1] - prev[1];

            if (isEndGt1) {
              endPoint = [prev[0] + t * a, prev[1] + t * b];
            } else {
              t = 1 - t;
              endPoint = [current[0] - t * a, current[1] - t * b];
            }
          } else if (current.length === 4) {
            var r = bezier.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]]], t);
            endPoint = [r[1][0], r[1][1], r[2][0], r[2][1]];
          } else if (current.length === 6) {
            var _r = bezier.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]], [current[4], current[5]]], t);

            endPoint = [_r[1][0], _r[1][1], _r[2][0], _r[2][1], _r[3][0], _r[3][1]];
          }
        }

        start2 *= len.total;

        if (start2 > len.increase[i]) {
          var _current;

          var _prev = list[i].slice(list[i].length - 2);

          var _l = len.list[i]; // 同一条线段时如果有end裁剪，会影响start长度，这里还要防止头尾绕了一圈的情况

          if (i === j && !isStartLt0 && !isEndGt1 && prePercent !== 1) {
            _l *= prePercent;

            if (endPoint) {
              _current = endPoint;
            }
          }

          if (!_current) {
            _current = list[i + 1];
          }

          var _diff = start2 - len.increase[i];

          var _t = _diff / _l;

          if (_current.length === 2) {
            var _a = _current[0] - _prev[0];

            var _b = _current[1] - _prev[1];

            if (isStartLt0) {
              _t = 1 - _t;
              res.push([_current[0] - _t * _a, _current[1] - _t * _b]);
            } else {
              res.push([_prev[0] + _t * _a, _prev[1] + _t * _b]);
            }

            res.push(_current);
          } else if (_current.length === 4) {
            var _r2 = bezier.sliceBezier([[_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

            res.push(_r2[0]);
            res.push([_r2[1][0], _r2[1][1], _r2[2][0], _r2[2][1]]); // 同一条线段上去除end冲突

            if (i === j && !isStartLt0 && !isEndGt1) {
              endPoint = null;
            }
          } else if (_current.length === 6) {
            var _r3 = bezier.sliceBezier([[_current[4], _current[5]], [_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

            res.push(_r3[0]);
            res.push([_r3[1][0], _r3[1][1], _r3[2][0], _r3[2][1], _current[4], _current[5]]);

            if (i === j && !isStartLt0 && !isEndGt1) {
              endPoint = null;
            }
          }
        } // start和end之间的线段，注意头尾饶了一圈的情况，以及起始点被上方考虑过了


        for (var k = i + 2; k <= j + (!isStartLt0 && !isEndGt1 ? 0 : length); k++) {
          res.push(list[k % length]);
        }

        if (endPoint) {
          res.push(endPoint);
        }

        return res;
      }
    }, {
      key: "__getIndex",
      value: function __getIndex(list, t, i, j) {
        if (i === j) {
          if (list[i] > t) {
            return i - 1;
          }

          return i;
        }

        var middle = i + (j - i >> 1);

        if (list[middle] === t) {
          return middle;
        } else if (list[middle] > t) {
          return this.__getIndex(list, t, i, Math.max(middle - 1, i));
        } else {
          return this.__getIndex(list, t, Math.min(middle + 1, j), j);
        }
      }
    }, {
      key: "__getLength",
      value: function __getLength(list, isMulti) {
        var _this3 = this;

        var res = [];
        var total = 0;
        var increase = [];

        if (isMulti) {
          total = [];
          list.forEach(function (list) {
            var temp = _this3.__getLength(list);

            res.push(temp.list);
            total.push(temp.total);
            increase.push([0].concat(temp.increase));
          });
        } else if (Array.isArray(list)) {
          total = 0;
          increase.push(0);
          var start = 0;

          for (var i = 0, len = list.length; i < len; i++) {
            var item = list[i];

            if (Array.isArray(item)) {
              start = i;
              break;
            }
          }

          var prev = list[start];

          for (var _i3 = start + 1, _len = list.length; _i3 < _len; _i3++) {
            var _item = list[_i3];

            if (!Array.isArray(_item)) {
              continue;
            }

            if (_item.length === 2) {
              var a = Math.abs(_item[0] - prev[0]);
              var b = Math.abs(_item[1] - prev[1]);
              var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
              res.push(c);
              total += c;
              increase.push(total);
              prev = _item;
            } else if (_item.length === 4) {
              var _c = bezier.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]]]);

              res.push(_c);
              total += _c;
              increase.push(total);
              prev = [_item[2], _item[3]];
            } else if (_item.length === 6) {
              var _c2 = bezier.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]], [_item[4], _item[5]]]);

              res.push(_c2);
              total += _c2;
              increase.push(total);
              prev = [_item[4], _item[5]];
            }
          }
        }

        return {
          list: res,
          total: total,
          increase: increase
        };
      }
    }, {
      key: "__concatPointAndControl",
      value: function __concatPointAndControl(point, control) {
        if (Array.isArray(control) && (control.length === 2 || control.length === 4) && Array.isArray(point) && point.length === 2) {
          return control.concat(point);
        }

        return point;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Polyline.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.__buildCache(res.x3, res.y3);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "points",
      get: function get() {
        return this.getProps('points');
      }
    }, {
      key: "controls",
      get: function get() {
        return this.getProps('controls');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__x3,
              originY = this.__y3,
              strokeWidth = this.computedStyle[STROKE_WIDTH$4];

          this.__buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Polyline.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var points = __cacheProps.points,
              controls = __cacheProps.controls;

          if (!isMulti) {
            points = [points];
            controls = [controls];
          }

          points.forEach(function (pointList, i) {
            if (!pointList || pointList.length < 2 || !pointList[0] || !pointList[1] || pointList[0].length < 2 || pointList[1].length < 2) {
              return;
            }

            var controlList = controls[i] || [];

            var _pointList$ = _slicedToArray(pointList[0], 2),
                xa = _pointList$[0],
                ya = _pointList$[1];

            for (var _i4 = 1, len = pointList.length; _i4 < len; _i4++) {
              var item = pointList[_i4];

              if (!item || item.length < 2) {
                continue;
              }

              var _pointList$_i = _slicedToArray(pointList[_i4], 2),
                  xb = _pointList$_i[0],
                  yb = _pointList$_i[1];

              var c = controlList[_i4 - 1];

              if (c && c.length === 4) {
                var bezierBox = bezier.bboxBezier(xa, ya, c[0], c[1], c[2], c[3], xb, yb);
                bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
              } else if (c && c.length === 2) {
                var _bezierBox = bezier.bboxBezier(xa, ya, c[0], c[1], xb, yb);

                bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
              } else {
                bbox[0] = Math.min(bbox[0], xa - half);
                bbox[1] = Math.min(bbox[1], ya - half);
                bbox[2] = Math.max(bbox[2], xa + half);
                bbox[3] = Math.max(bbox[3], ya + half);
              }

              xa = xb;
              ya = yb;
            }
          });
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }, {
      key: "booleanOperations",
      get: function get() {
        return this.getProps('booleanOperations');
      }
    }]);

    return Polyline;
  }(Geom);

  var Polygon = /*#__PURE__*/function (_Polyline) {
    _inherits(Polygon, _Polyline);

    function Polygon(tagName, props) {
      return _Polyline.call(this, tagName, props) || this;
    }

    _createClass(Polygon, [{
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        var res = _get(_getPrototypeOf(Polygon.prototype), "__getPoints", this).call(this, originX, originY, width, height, points, isControl);

        if (!isControl) {
          res.push(res[0]);
        }

        return res;
      }
    }]);

    return Polygon;
  }(Polyline);

  var STROKE_WIDTH$3 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$5 = util.isNil;
  var sectorPoints = geom.sectorPoints;

  function getR$3(v, dft) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = dft;
    }

    return v;
  }

  var Sector = /*#__PURE__*/function (_Geom) {
    _inherits(Sector, _Geom);

    function Sector(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 角度

      if (_this.isMulti) {
        _this.__begin = [0];
        _this.__end = [0];
        _this.__r = [1];

        if (Array.isArray(props.begin)) {
          _this.__begin = props.begin.map(function (i) {
            return getR$3(i, 0);
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            return getR$3(i, 0);
          });
        }

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR$3(i, 1);
          });
        }

        if (Array.isArray(props.edge)) {
          _this.__edge = props.edge.map(function (i) {
            return !!i;
          });
        }

        if (Array.isArray(props.closure)) {
          _this.__closure = props.closure.map(function (i) {
            return !!i;
          });
        }
      } else {
        _this.__begin = _this.__end = 0; // 半径[0, ∞)，默认1

        _this.__r = 1; // 扇形两侧是否有边

        _this.__edge = false; // 扇形大于180°时，是否闭合两端

        _this.__closure = false;

        if (!isNil$5(props.begin)) {
          _this.__begin = getR$3(props.begin, 0);
        }

        if (!isNil$5(props.end)) {
          _this.__end = getR$3(props.end, 0);
        }

        if (!isNil$5(props.r)) {
          _this.__r = getR$3(props.r, 1);
        }

        if (!isNil$5(props.edge)) {
          _this.__edge = !!props.edge;
        }

        if (!isNil$5(props.closure)) {
          _this.__closure = !!props.closure;
        }
      }

      return _this;
    }

    _createClass(Sector, [{
      key: "__buildCache",
      value: function __buildCache(cx, cy, focus) {
        var width = this.width,
            begin = this.begin,
            end = this.end,
            r = this.r,
            edge = this.edge,
            closure = this.closure,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$5(__cacheProps.begin) || focus) {
          rebuild = true;
          __cacheProps.begin = (begin || 0) % 360;
        }

        if (isNil$5(__cacheProps.end) || focus) {
          rebuild = true;
          __cacheProps.end = (end || 0) % 360;
        }

        if (isNil$5(__cacheProps.r) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.r = r.map(function (r) {
              return r * width * 0.5;
            });
          } else {
            __cacheProps.r = r * width * 0.5;
          }
        }

        r = __cacheProps.r;

        if (isNil$5(__cacheProps.edge) || focus) {
          rebuild = true;
          __cacheProps.edge = edge;
        }

        if (isNil$5(__cacheProps.closure) || focus) {
          rebuild = true;
          __cacheProps.closure = closure;
        }

        if (rebuild) {
          if (isMulti) {
            __cacheProps.list = [];
            __cacheProps.sList = [];
            begin.forEach(function (begin, i) {
              var r2 = isNil$5(r[i]) ? width * 0.5 : r[i];
              var list = sectorPoints(cx, cy, r2, parseFloat(begin || 0) % 360, parseFloat(end[i] || 0) % 360);
              var sList = list.slice(0);

              if (closure[i]) {
                list.push(list[0].slice(0));

                if (edge) {
                  sList.push(sList[0].slice(0));
                }
              } else {
                list.unshift([cx, cy]);
                list.push([cx, cy]);

                if (edge) {
                  sList.unshift([cx, cy]);
                  sList.push([cx, cy]);
                }
              }

              __cacheProps.list.push(list);

              __cacheProps.sList.push(sList);
            });
          } else {
            var list = sectorPoints(cx, cy, r, parseFloat(begin || 0), parseFloat(end || 0));
            var sList = list.slice(0);

            if (closure) {
              list.push(list[0].slice(0));

              if (edge) {
                sList.push(sList[0].slice(0));
              }
            } else {
              list.unshift([cx, cy]);
              list.push([cx, cy]);

              if (edge) {
                sList.unshift([cx, cy]);
                sList.push([cx, cy]);
              }
            }

            __cacheProps.list = list;
            __cacheProps.sList = sList;
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx2, dy2) {
        var res = _get(_getPrototypeOf(Sector.prototype), "render", this).call(this, renderMode, ctx, dx2, dy2);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.__buildCache(res.cx, res.cy);

        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var _this$__cacheProps = this.__cacheProps,
            list = _this$__cacheProps.list,
            sList = _this$__cacheProps.sList,
            isMulti = this.isMulti; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy
          };

          this.__renderOneSector(renderMode, ctx, isMulti, list, sList, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy
              };

              this.__renderOneSector(renderMode, ctx, isMulti, list, sList, _o);
            }
          }

          for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
            var stroke = strokes[_i];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i],
                strokeDasharray: strokeDasharrays[_i],
                strokeDasharrayStr: strokeDasharrayStrs[_i],
                strokeLinecap: strokeLinecaps[_i],
                strokeLinejoin: strokeLinejoins[_i],
                strokeMiterlimit: strokeMiterlimits[_i],
                dx: dx,
                dy: dy
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, sList, _o2);
            }
          }
        }

        return res;
      }
    }, {
      key: "__renderOneSector",
      value: function __renderOneSector(renderMode, ctx, isMulti, list, sList, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill.k === 'conic';
        var isStrokeCE = stroke.k === 'conic';
        var isFillRE = fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else {
          if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, false);
          }

          if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        }
      }
    }, {
      key: "__genSector",
      value: function __genSector(edge, d, fill, stroke, strokeWidth, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (edge) {
          var props = [['d', d[0]], ['fill', fill.v || fill], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

          this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

          this.addGeom('path', props);
        } else {
          this.addGeom('path', [['d', d[0]], ['fill', fill.v || fill]]);

          if (strokeWidth > 0) {
            var _props = [['d', d[1]], ['fill', 'none'], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

            this.__propsStrokeStyle(_props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

            this.addGeom('path', _props);
          }
        }
      }
    }, {
      key: "begin",
      get: function get() {
        return this.getProps('begin');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "edge",
      get: function get() {
        return this.getProps('edge');
      } // >180°时是否链接端点

    }, {
      key: "closure",
      get: function get() {
        return this.getProps('closure');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__x3,
              originY = this.__y3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$3];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;

          this.__buildCache(cx, cy);

          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Sector.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var xb = cx + r - half;
          var ya = cy - r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Sector;
  }(Geom);

  var STROKE_WIDTH$2 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$4 = util.isNil;

  function genVertex(x, y, width, height) {
    var rx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var ry = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (rx === 0 || ry === 0) {
      return [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]];
    }

    var ox = rx * geom.H;
    var oy = ry * geom.H;
    return [[x + rx, y], [x + width - rx, y], [x + width + ox - rx, y, x + width, y + ry - oy, x + width, y + ry], [x + width, y + height - ry], [x + width, y + height + oy - ry, x + width + ox - rx, y + height, x + width - rx, y + height], [x + rx, y + height], [x + rx - ox, y + height, x, y + height + oy - ry, x, y + height - ry], [x, y + ry], [x, y + ry - oy, x + rx - ox, y, x + rx, y]];
  }

  function getR$2(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 0;
    }

    return v;
  }

  var Rect = /*#__PURE__*/function (_Geom) {
    _inherits(Rect, _Geom);

    function Rect(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 圆角

      if (_this.isMulti) {
        _this.__rx = [0];
        _this.__ry = [0];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR$2(i);
          });
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR$2(i);
          });
        }
      } else {
        _this.__rx = _this.__ry = 0;

        if (!isNil$4(props.rx)) {
          _this.__rx = getR$2(props.rx);
        }

        if (!isNil$4(props.ry)) {
          _this.__ry = getR$2(props.ry);
        }
      }

      return _this;
    }

    _createClass(Rect, [{
      key: "__buildCache",
      value: function __buildCache(originX, originY, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$4(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (rx) {
              return Math.min(rx, 0.5) * width;
            });
          } else {
            __cacheProps.rx = Math.min(rx, 0.5) * width;
          }
        }

        if (isNil$4(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = rx.map(function (ry) {
              return Math.min(ry, 0.5) * height;
            });
          } else {
            __cacheProps.ry = Math.min(ry, 0.5) * height;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return genVertex(originX, originY, width, height, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = genVertex(originX, originY, width, height, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Rect.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.__buildCache(res.x3, res.y3);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var originX = this.__x3,
              originY = this.__y3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$2];

          this.__buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Rect.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          bbox[0] = Math.min(bbox[0], originX - half);
          bbox[1] = Math.min(bbox[1], originY - half);
          bbox[2] = Math.max(bbox[2], originX + width + half);
          bbox[3] = Math.max(bbox[3], originY + height + half);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Rect;
  }(Geom);

  var STROKE_WIDTH$1 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$3 = util.isNil;

  function getR$1(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Circle = /*#__PURE__*/function (_Geom) {
    _inherits(Circle, _Geom);

    function Circle(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__r = [1];

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR$1(i);
          });
        } else if (!isNil$3(props.r)) {
          _this.__r = getR$1(props.r);
        }
      } else {
        _this.__r = 1;

        if (!isNil$3(props.r)) {
          _this.__r = getR$1(props.r);
        }
      }

      return _this;
    }

    _createClass(Circle, [{
      key: "__buildCache",
      value: function __buildCache(cx, cy, focus) {
        var width = this.width,
            r = this.r,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;

        if (isNil$3(__cacheProps.r) || focus) {
          if (isMulti) {
            __cacheProps.r = r.map(function (i) {
              return i * width * 0.5;
            });
            __cacheProps.list = __cacheProps.r.map(function (r) {
              return geom.ellipsePoints(cx, cy, r, r);
            });
          } else {
            __cacheProps.r = r * width * 0.5;
            __cacheProps.list = geom.ellipsePoints(cx, cy, __cacheProps.r, __cacheProps.r);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Circle.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.__buildCache(res.cx, res.cy);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__x3,
              originY = this.__y3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$1];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;

          this.__buildCache(cx, cy);

          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Circle.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var ya = cy - r - half;
          var xb = cx + r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Circle;
  }(Geom);

  var STROKE_WIDTH = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$2 = util.isNil;

  function getR(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Ellipse = /*#__PURE__*/function (_Geom) {
    _inherits(Ellipse, _Geom);

    function Ellipse(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__rx = [1];
        _this.__ry = [1];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR(i);
          });
        } else if (!isNil$2(props.rx)) {
          _this.__rx = [getR(props.rx)];
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR(i);
          });
        } else if (!isNil$2(props.ry)) {
          _this.__ry = [getR(props.ry)];
        }
      } else {
        _this.__rx = 1;

        if (!isNil$2(props.rx)) {
          _this.__rx = getR(props.rx);
        }

        _this.__ry = 1;

        if (!isNil$2(props.ry)) {
          _this.__ry = getR(props.ry);
        }
      }

      return _this;
    }

    _createClass(Ellipse, [{
      key: "__buildCache",
      value: function __buildCache(cx, cy, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$2(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (i) {
              return i * width * 0.5;
            });
          } else {
            __cacheProps.rx = rx * width * 0.5;
          }
        }

        if (isNil$2(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = ry.map(function (i) {
              return i * height * 0.5;
            });
          } else {
            __cacheProps.ry = ry * height * 0.5;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return geom.ellipsePoints(cx, cy, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = geom.ellipsePoints(cx, cy, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Ellipse.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.__buildCache(res.cx, res.cy);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__x3,
              originY = this.__y3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;

          this.__buildCache(cx, cy);

          var rx = 0,
              ry = 0;

          if (isMulti) {
            var mx = 0,
                my = 0;

            __cacheProps.rx.forEach(function (rx, i) {
              mx = Math.max(rx, mx);
              my = Math.max(ry, __cacheProps.ry[i]);
            });

            rx = mx;
            ry = my;
          } else {
            rx = __cacheProps.rx;
            ry = __cacheProps.ry;
          }

          var bbox = _get(_getPrototypeOf(Ellipse.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - rx - half;
          var xb = cx + rx + half;
          var ya = cy - ry - half;
          var yb = cy + ry + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Ellipse;
  }(Geom);

  var isPrimitive$1 = util.isPrimitive,
      isNil$1 = util.isNil,
      isString$1 = util.isString;
  /**
   * 入口方法，animateRecords记录所有的动画结果等初始化后分配开始动画
   * offsetTime默认0，递归传下去为右libraryId引用的元素增加偏移时间，为了库元素动画复用而开始时间不同
   * @param karas
   * @param json
   * @param animateRecords
   * @param areaStart 为了和AE功能对应，播放一段动画，特增加这2个参数，递归相加起效
   * @param areaDuration 最外层优先
   * @returns {Node|Component|*}
   */

  function parse(karas, json, animateRecords, areaStart, areaDuration) {
    if (isPrimitive$1(json) || json instanceof Node$1 || json instanceof Component) {
      return json;
    }

    if (Array.isArray(json)) {
      return json.map(function (item) {
        return parse(karas, item, animateRecords, areaStart, areaDuration);
      });
    }

    areaStart += parseInt(json.areaStart) || 0;

    if (areaDuration === null) {
      if (!isNil$1(json.areaDuration)) {
        var n = parseInt(json.areaDuration);

        if (!isNaN(n) && n > 0) {
          areaDuration = n;
        }
      }
    }

    var tagName = json.tagName,
        _json$props = json.props,
        props = _json$props === void 0 ? {} : _json$props,
        _json$children = json.children,
        children = _json$children === void 0 ? [] : _json$children,
        _json$animate = json.animate,
        animate = _json$animate === void 0 ? [] : _json$animate;

    if (!tagName) {
      throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
    }

    if (!Array.isArray(children)) {
      throw new Error('children must be an array');
    }

    var vd;

    if (isString$1(tagName)) {
      if (tagName.charAt(0) === '$') {
        vd = karas.createGm(tagName, props);
      } else if (/^[A-Z]/.test(tagName)) {
        var cp = Component.getRegister(tagName);
        props.tagName = props.tagName || tagName;
        vd = karas.createCp(cp, props, children.map(function (item) {
          return parse(karas, item, animateRecords, areaStart, areaDuration);
        }));
      } else {
        vd = karas.createVd(tagName, props, children.map(function (item) {
          return parse(karas, item, animateRecords, areaStart, areaDuration);
        }));
      }
    } // 扩展支持非标准json，tagName是个类引用
    else {
      // 特殊的$匿名类
      if (tagName instanceof Geom || tagName.prototype && tagName.prototype instanceof Geom) {
        vd = karas.createGm(tagName, props);
      } else {
        var _cp = Component.getRegister(tagName);

        props.tagName = props.tagName || tagName;
        vd = karas.createCp(_cp, props, children.map(function (item) {
          return parse(karas, item, animateRecords, areaStart, areaDuration);
        }));
      }
    }

    if (animate) {
      if (!Array.isArray(animate)) {
        animate = [animate];
      }

      var has;
      animate.forEach(function (item) {
        var value = item.value; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          has = true;
        }
      }); // 产生实际动画运行才存入列表供root调用执行

      if (has) {
        animateRecords.push({
          animate: animate,
          target: vd,
          areaStart: areaStart,
          areaDuration: areaDuration
        });
      }
    }

    return vd;
  }

  var isNil = util.isNil,
      isFunction = util.isFunction,
      isPrimitive = util.isPrimitive,
      clone = util.clone,
      extend = util.extend;
  /**
   * 链接json中的某个child到library文件，
   * props需要是clone的，因为防止多个child使用同一个库文件
   * children则直接引用，无需担心多个使用同一个
   * library也需要带上，在library直接子元素还包含library时会用到
   * @param child
   * @param libraryItem
   */

  function linkLibrary(child, libraryItem) {
    // 规定图层child只有init和动画，属性和子图层来自库
    child.tagName = libraryItem.tagName;
    child.props = clone(libraryItem.props) || {};
    child.children = libraryItem.children || [];

    if (libraryItem.vars && !child.vars) {
      child.vars = libraryItem.vars;
    }

    if (libraryItem.library) {
      child.library = libraryItem.library;
    } // 删除以免二次解析


    delete child.libraryId;
    var init = child.init;

    if (init) {
      var props = child.props;
      var style = props.style;
      extend(props, init); // style特殊处理，防止被上面覆盖丢失原始值

      if (style) {
        extend(style, init.style);
        props.style = style;
      } // 删除以免二次解析


      delete child.init;
    }
  }
  /**
   * 遍历一遍library的一级，将一级的id存到hash上，无需递归二级，
   * 因为顺序前提要求排好且无循环依赖，所以被用到的一定在前面出现，
   * 一般是无children的元件在前，包含children的div在后
   * 即便library中的元素有children或library，在linkChild时将其link过去，parse递归会继续处理
   * @param item：library的一级孩子
   * @param hash：存放library的key/value引用
   */


  function initLibrary(item, hash) {
    var id = item.id; // library中一定有id，因为是一级，二级+特殊需求才会出现放开

    if (isNil(id)) {
      throw new Error('Library item miss id: ' + JSON.stringify(item));
    } else {
      hash[id] = item;
    }
  } // 有library的json一级初始化library供链接前，可以替换library里的内容


  function replaceLibraryVars(json, hash, vars) {
    // 新版同级vars语法，增加可以修改library子元素中递归子属性
    if (json && json.hasOwnProperty('vars')) {
      var slot = json.vars;

      if (!Array.isArray(slot)) {
        slot = [slot];
      }

      var hasChanged;

      for (var i = 0, len = slot.length; i < len; i++) {
        var _slot$i = slot[i],
            id = _slot$i.id,
            member = _slot$i.member;

        if (!Array.isArray(member)) {
          member = [member];
        } // library.xxx，需要>=2的长度，开头必须是library


        if (Array.isArray(member) && member[0] === 'library') {
          slot.splice(i--, 1);
          len--;
          hasChanged = true;

          if (vars && vars.hasOwnProperty(id)) {
            var target = hash;

            outer: for (var _i = 1, _len = member.length; _i < _len; _i++) {
              var k = member[_i]; // 最后一个属性可以为空

              if (target.hasOwnProperty(k) || _i === _len - 1) {
                // 最后一个member表达式替换
                if (_i === _len - 1) {
                  var v = vars[id];
                  var old = target[k]; // 支持函数模式和值模式

                  if (isFunction(v)) {
                    v = v(old);
                  } // 直接替换library的子对象，需补充id和tagName


                  if (_i === 1) {
                    target[k] = Object.assign({
                      id: old.id,
                      tagName: old.tagName
                    }, v);
                  } // 替换library中子对象的一个属性直接赋值
                  else {
                    target[k] = v;
                  }
                } // 子属性继续下去
                else {
                  target = target[k];
                }
              } else {
                inject.error('Library slot miss ' + k);
                break outer;
              }
            }
          }
        }
      }

      if (!slot.length) {
        delete json.vars;
      } else if (hasChanged) {
        json.vars = slot;
      }
    }
  }

  function replaceVars(json, vars) {
    // 新版vars语法
    if (json && json.hasOwnProperty('vars')) {
      var slot = json.vars;
      delete json.vars;

      if (!Array.isArray(slot)) {
        slot = [slot];
      }

      if (Array.isArray(slot)) {
        slot.forEach(function (item) {
          var id = item.id,
              member = item.member;

          if (!Array.isArray(member)) {
            member = [member];
          } // 排除特殊的library


          if (Array.isArray(member) && member.length && member[0] !== 'library' && vars && vars.hasOwnProperty(id)) {
            var target = json;

            for (var i = 0, len = member.length; i < len; i++) {
              var k = member[i]; // 最后一个属性可以为空

              if (target.hasOwnProperty(k) || i === len - 1) {
                // 最后一个member表达式替换
                if (i === len - 1) {
                  var v = vars[id]; // undefined和null意义不同

                  if (v === undefined) {
                    return;
                  } // 支持函数模式和值模式


                  if (isFunction(v)) {
                    v = v(target[k]);
                  }

                  target[k] = v;
                } else {
                  target = target[k];
                }
              } else {
                inject.error('Slot miss ' + k);
                return;
              }
            }
          }
        });
      }
    }
  } // parse的options可以传总的duration等


  function replaceAnimateOptions(options, opt) {
    ['iterations', 'fill', 'duration', 'direction', 'easing', 'fps', 'delay', 'endDelay', 'playbackRate', 'spfLimit'].forEach(function (k) {
      if (opt.hasOwnProperty(k)) {
        options[k] = opt[k];
      }
    });
  }

  function apply(json, opt, hash) {
    if (isPrimitive(json) || json instanceof Node$1 || json instanceof Component) {
      return json;
    }

    if (Array.isArray(json)) {
      return json.map(function (item) {
        return apply(item, opt, hash);
      });
    } // 先判断是否是个链接到库的节点，是则进行链接操作


    var libraryId = json.libraryId;

    if (!isNil(libraryId)) {
      var libraryItem = hash[libraryId]; // 规定图层child只有init和动画，tagName和属性和子图层来自库

      if (libraryItem) {
        linkLibrary(json, libraryItem);
      } else {
        throw new Error('Link library miss id: ' + libraryId);
      }
    } // 再判断是否有library形成一个新的作用域，会出现library下的library使得一个链接节点链接后出现library的情况


    var library = json.library;

    if (Array.isArray(library)) {
      hash = {};
      library.forEach(function (item) {
        return initLibrary(item, hash);
      }); // 替换library插槽

      replaceLibraryVars(json, hash, opt.vars);
      delete json.library;
    }

    var tagName = json.tagName,
        _json$props = json.props,
        props = _json$props === void 0 ? {} : _json$props,
        _json$children = json.children,
        children = _json$children === void 0 ? [] : _json$children,
        _json$animate = json.animate,
        animate = _json$animate === void 0 ? [] : _json$animate;

    if (!tagName) {
      throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
    } // 缩写src和font


    var src = props.src;

    if (/^#\d+$/.test(src)) {
      var imgs = opt.imgs,
          i = parseInt(src.slice(1));

      if (Array.isArray(imgs)) {
        props.src = imgs[i];
      }
    }

    var style = props.style;

    if (style) {
      var fontFamily = style.fontFamily;

      if (/^#\d+$/.test(fontFamily)) {
        var fonts = opt.fonts,
            _i2 = parseInt(fontFamily.slice(1));

        if (Array.isArray(fonts)) {
          style.fontFamily = fonts[_i2];
        }
      } // 先替换style的


      replaceVars(style, opt.vars);
    } // 再替换静态属性，style也作为属性的一种


    replaceVars(props, opt.vars); // 替换children里的内容，如文字，无法直接替换tagName/props/children/animate本身，因为下方用的还是原引用

    replaceVars(json, opt.vars);
    json.children = apply(children, opt, hash);

    if (animate) {
      if (!Array.isArray(animate)) {
        animate = [animate];
      }

      animate.forEach(function (item) {
        var value = item.value,
            options = item.options; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          value.forEach(function (item) {
            replaceVars(item, opt.vars);
          });
        }

        if (options) {
          replaceVars(options, opt.vars);
          replaceAnimateOptions(options, opt);
        }
      });
    }

    return json;
  } // 将library、vars应用于json，转换json为一个普通的原始json数据


  function apply$1 (json) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // 特殊单例声明无需clone加速解析
    if (!options.singleton && !json.singleton) {
      json = util.clone(json);
    }

    return apply(json, options, {});
  }

  var o = {
    apply: apply$1,
    parse: function parse$1(karas, json, dom, options) {
      if (!json) {
        return;
      } // 根节点的fonts字段定义字体信息


      var fonts = json.fonts;

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var fontFamily = item.fontFamily,
              url = item.url,
              data = item.data;

          if (fontFamily && (url || data)) {
            o$3.register(fontFamily, url, data);
          }
        });
      } // 重载，在确定dom传入选择器字符串或html节点对象时作为渲染功能，否则仅创建vd返回


      if (!inject.isDom(dom)) {
        options = options || dom || {};
        dom = null;
      } else {
        options = options || {};
      }

      json = apply$1(json, options); // 暂存所有动画声明，等root的生成后开始执行

      var animateRecords = [];

      var vd = parse(karas, json, animateRecords, 0, null); // 有dom时parse作为根方法渲染


      if (dom) {
        var _json = json,
            tagName = _json.tagName;

        if (['canvas', 'svg', 'webgl'].indexOf(tagName) === -1) {
          throw new Error('Parse dom must be canvas/svg/webgl');
        } // parse直接（非递归）的动画记录


        var ac = options.controller instanceof Controller ? options.controller : vd.animateController; // 第一次render，收集递归json里面的animateRecords，它在xom的__layout最后生成

        karas.render(vd, dom); // 直接的json里的animateRecords，再加上递归的parse的json的（第一次render布局时处理）动画一并播放

        if (options.autoPlay !== false) {
          ac.__records = ac.__records.concat(animateRecords);

          ac.__playAuto();
        } // 不自动播放进入记录列表，初始化并等待手动调用
        else {
          ac.__records2 = ac.__records2.concat(animateRecords);
          ac.init(ac.__records2, ac.list2);
        }
      } // 递归的parse，如果有动画，此时还没root，先暂存下来，等上面的root的render第一次布局时收集
      else {
        if (animateRecords.length) {
          vd.__animateRecords = {
            options: options,
            list: animateRecords,
            controller: options.controller instanceof Controller ? options.controller : null
          };
        }
      }

      return vd;
    },
    loadAndParse: function loadAndParse(karas, json, dom, options) {
      var fonts = json.fonts,
          components = json.components,
          imgs = json.imgs;
      var list1 = [];
      var list2 = [];
      var list3 = [];

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var url = item.url;

          if (url) {
            list1.push(item);
          }
        });
      }

      if (components) {
        if (!Array.isArray(components)) {
          components = [components];
        }

        components.forEach(function (item) {
          var tagName = item.tagName,
              url = item.url,
              reload = item.reload; // 如果没申明reload且已经被注册，则无需重复加载

          if (tagName && karas.Component.hasRegister(tagName) && !reload) {
            return;
          } // 即便没有tagName也要加载，可能组件内部执行了注册逻辑


          if (url) {
            list2.push(item);
          }
        });
      }

      if (imgs) {
        if (!Array.isArray(imgs)) {
          imgs = [imgs];
        }

        imgs.forEach(function (item) {
          var url = item.url;

          if (url) {
            list3.push(url);
          }
        });
      }

      var a = list1.length,
          b = list2.length,
          c = list3.length;
      var count = 0;

      var cb = function cb() {
        if (count === a + b + c) {
          var res = o.parse(karas, json, dom, options);

          if (options && util.isFunction(options.callback)) {
            options.callback(res);
          }
        }
      };

      if (a || b || c) {
        karas.inject.loadFont(list1, function () {
          count += a;
          cb();
        });
        karas.inject.loadComponent(list2.map(function (item) {
          return item.url;
        }), function () {
          count += b; // 默认约定加载的js组件会在全局变量申明同名tagName，已有不覆盖，防止组件代码内部本身有register

          list2.forEach(function (item) {
            var tagName = item.tagName;

            if (tagName && window[tagName] && !karas.Component.hasRegister(tagName)) {
              karas.Component.register(tagName, window[tagName]);
            }
          });
          cb();
        });
        karas.inject.measureImg(list3, function () {
          count += c;
          cb();
        });
      } else {
        cb();
      }
    }
  };

  var style = {
    css: css,
    reset: reset,
    unit: o$4,
    font: o$3,
    abbr: abbr,
    transform: transform$1
  };

  var animate = {
    Animation: Animation,
    Controller: Controller,
    easing: easing,
    frame: frame
  };

  function calDeg(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    var atan = Math.atan(Math.abs(dy) / Math.abs(dx)); // 2象限

    if (dx < 0 && dy >= 0) {
      return Math.PI - atan;
    } // 3象限


    if (dx < 0 && dy < 0) {
      return atan - Math.PI;
    } // 1象限


    if (dx >= 0 && dy >= 0) {
      return atan;
    } // 4象限，顺时针正好


    return -atan;
  }

  function rotate(theta) {
    var sin = Math.sin(theta);
    var cos = Math.cos(theta);
    var t = matrix.identity();
    t[0] = t[5] = cos;
    t[1] = sin;
    t[4] = -sin;
    return t;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param points
   */


  function pointIndex(points) {
    var _points = _slicedToArray(points, 6),
        x1 = _points[0],
        y1 = _points[1],
        x2 = _points[2],
        y2 = _points[3],
        x3 = _points[4],
        y3 = _points[5];

    var index = [0, 1, 2]; // 将a点放入最左

    if (x2 < x1 && x2 < x3) {
      var _ref = [x2, y2, x1, y1];
      x1 = _ref[0];
      y1 = _ref[1];
      x2 = _ref[2];
      y2 = _ref[3];
      index[0] = 1;
      index[1] = 0;
    } else if (x3 < x2 && x3 < x1) {
      var _ref2 = [x3, y3, x1, y1];
      x1 = _ref2[0];
      y1 = _ref2[1];
      x3 = _ref2[2];
      y3 = _ref2[3];
      index[0] = 2;
      index[2] = 0;
    } // 有可能出现2个并列的情况，判断取上面那个


    if (x1 === x2) {
      if (y1 > y2) {
        var _ref3 = [x2, y2, x1, y1];
        x1 = _ref3[0];
        y1 = _ref3[1];
        x2 = _ref3[2];
        y2 = _ref3[3];
        var t = index[0];
        index[0] = index[1];
        index[1] = t;
      }
    } else if (x1 === x3) {
      if (y1 > y3) {
        var _ref4 = [x3, y3, x1, y1];
        x1 = _ref4[0];
        y1 = _ref4[1];
        x3 = _ref4[2];
        y3 = _ref4[3];
        var _t = index[0];
        index[0] = index[2];
        index[2] = _t;
      }
    } // ab到ac要顺时针旋转，即2个向量夹角为正，用向量叉乘判断正负


    var cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);

    if (cross < 0) {
      var _ref5 = [x3, y3, x2, y2];
      x2 = _ref5[0];
      y2 = _ref5[1];
      x3 = _ref5[2];
      y3 = _ref5[3];
      var _t2 = index[1];
      index[1] = index[2];
      index[2] = _t2;
    }

    return [x1, y1, x2, y2, x3, y3, index];
  }
  /**
   * 第2个点根据第一个点的交换顺序交换
   * @param points
   * @param index
   * @returns {[]}
   */


  function pointByIndex(points, index) {
    var res = [];

    for (var i = 0, len = index.length; i < len; i++) {
      var j = index[i];
      res.push(points[j * 2]);
      res.push(points[j * 2 + 1]);
    }

    return res;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param source 源3个点
   * @param target 目标3个点
   * @returns 交换顺序后的点坐标
   */


  function exchangeOrder(source, target) {
    var _pointIndex = pointIndex(source),
        _pointIndex2 = _slicedToArray(_pointIndex, 7),
        sx1 = _pointIndex2[0],
        sy1 = _pointIndex2[1],
        sx2 = _pointIndex2[2],
        sy2 = _pointIndex2[3],
        sx3 = _pointIndex2[4],
        sy3 = _pointIndex2[5],
        index = _pointIndex2[6];

    var _pointByIndex = pointByIndex(target, index),
        _pointByIndex2 = _slicedToArray(_pointByIndex, 6),
        tx1 = _pointByIndex2[0],
        ty1 = _pointByIndex2[1],
        tx2 = _pointByIndex2[2],
        ty2 = _pointByIndex2[3],
        tx3 = _pointByIndex2[4],
        ty3 = _pointByIndex2[5];

    return [[sx1, sy1, sx2, sy2, sx3, sy3], [tx1, ty1, tx2, ty2, tx3, ty3]];
  }
  /**
   * 存在一种情况，变换结果使得三角形镜像相反了，即顶点a越过bc线，判断是否溢出
   * @param source
   * @param target
   * @returns {boolean}是否溢出
   */


  function isOverflow(source, target) {
    var _source = _slicedToArray(source, 6),
        sx1 = _source[0],
        sy1 = _source[1],
        sx2 = _source[2],
        sy2 = _source[3],
        sx3 = _source[4],
        sy3 = _source[5];

    var _target = _slicedToArray(target, 6),
        tx1 = _target[0],
        ty1 = _target[1],
        tx2 = _target[2],
        ty2 = _target[3],
        tx3 = _target[4],
        ty3 = _target[5];

    var cross1 = (sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1);
    var cross2 = (tx2 - tx1) * (ty3 - ty1) - (tx3 - tx1) * (ty2 - ty1);
    return cross1 > 0 && cross2 < 0 || cross1 < 0 && cross2 > 0;
  }

  function transform(source, target) {
    var _source2 = _slicedToArray(source, 6),
        sx1 = _source2[0],
        sy1 = _source2[1],
        sx2 = _source2[2],
        sy2 = _source2[3],
        sx3 = _source2[4],
        sy3 = _source2[5];

    var _target2 = _slicedToArray(target, 6),
        tx1 = _target2[0],
        ty1 = _target2[1],
        tx2 = _target2[2],
        ty2 = _target2[3],
        tx3 = _target2[4],
        ty3 = _target2[5]; // 记录翻转


    var overflow = isOverflow(source, target); // 第0步，将源三角第1个a点移到原点

    var m = matrix.identity();
    m[12] = -sx1;
    m[13] = -sy1;
    var t; // 第1步，以第1条边ab为基准，将其贴合x轴上，为后续倾斜不干扰做准备

    var theta = calDeg(sx1, sy1, sx2, sy2);

    if (theta !== 0) {
      t = rotate(-theta);
      m = matrix.multiply(t, m);
    } // 第2步，以第1条边AB为基准，缩放x轴ab至目标相同长度，可与4步合并


    var ls = geom.pointsDistance(sx1, sy1, sx2, sy2);
    var lt = geom.pointsDistance(tx1, ty1, tx2, ty2); // if(ls !== lt) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[0] = scale;
    // m = matrix.multiply(t, m);
    // }
    // 第3步，缩放y，先将目标三角形旋转到x轴平行，再变换坐标计算

    var n = matrix.identity();
    n[12] = -tx1;
    n[13] = -ty1;
    theta = calDeg(tx1, ty1, tx2, ty2); // 记录下这个旋转角度，后面源三角形要反向旋转

    var alpha = theta;

    if (theta !== 0) {
      t = rotate(-theta);
      n = matrix.multiply(t, n);
    } // 目标三角反向旋转至x轴后的坐标
    // 源三角目前的第3点坐标y值即为长度，因为a点在原点0无需减去


    var ls2 = Math.abs(matrix.calPoint({
      x: sx3,
      y: sy3
    }, m).y);
    var lt2 = Math.abs(matrix.calPoint({
      x: tx3,
      y: ty3
    }, n).y); // 缩放y
    // if(ls2 !== lt2) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[3] = scale;
    // m = matrix.multiply(t, m);
    // }

    if (ls !== lt || ls2 !== lt2) {
      t = matrix.identity();

      if (ls !== lt) {
        t[0] = lt / ls;
      }

      if (ls2 !== lt2) {
        t[5] = lt2 / ls2;
      }

      m = matrix.multiply(t, m);
    } // 第4步，x轴倾斜，用余弦定理求目前a和A的夹角


    n = m;

    var _matrix$calPoint = matrix.calPoint({
      x: sx1,
      y: sy1
    }, n),
        ax1 = _matrix$calPoint.x,
        ay1 = _matrix$calPoint.y;

    var _matrix$calPoint2 = matrix.calPoint({
      x: sx2,
      y: sy2
    }, n),
        ax2 = _matrix$calPoint2.x,
        ay2 = _matrix$calPoint2.y;

    var _matrix$calPoint3 = matrix.calPoint({
      x: sx3,
      y: sy3
    }, n),
        ax3 = _matrix$calPoint3.x,
        ay3 = _matrix$calPoint3.y;

    var ab = geom.pointsDistance(ax1, ay1, ax2, ay2);
    var ac = geom.pointsDistance(ax1, ay1, ax3, ay3);
    var bc = geom.pointsDistance(ax3, ay3, ax2, ay2);
    var AB = geom.pointsDistance(tx1, ty1, tx2, ty2);
    var AC = geom.pointsDistance(tx1, ty1, tx3, ty3);
    var BC = geom.pointsDistance(tx3, ty3, tx2, ty2);
    var a = geom.angleBySide(bc, ab, ac);
    var A = geom.angleBySide(BC, AB, AC); // 先至90°，再旋转至目标角，可以合并成tan相加，不知道为什么不能直接tan倾斜差值角度

    if (a !== A) {
      t = matrix.identity();
      t[4] = Math.tan(a - Math.PI * 0.5) + Math.tan(Math.PI * 0.5 - A);
      m = matrix.multiply(t, m);
    } // 发生翻转时特殊处理按x轴垂直翻转


    if (overflow) {
      m[1] = -m[1];
      m[5] = -m[5];
      m[13] = -m[13];
    } // 第5步，再次旋转，角度为目标旋转到x轴的负值，可与下步合并


    if (alpha !== 0) {
      t = rotate(alpha); // m = matrix.multiply(t, m);
    } else {
      t = matrix.identity();
    } // 第6步，移动第一个点的差值
    // t = matrix.identity();


    t[12] = tx1;
    t[13] = ty1;
    return matrix.multiply(t, m);
  }

  var tar = {
    exchangeOrder: exchangeOrder,
    isOverflow: isOverflow,
    transform: transform
  };

  var math = {
    matrix: matrix,
    tar: tar,
    vector: vector,
    equation: equation,
    geom: geom,
    bezier: bezier,
    isec: isec,
    booleanOperations: bo
  };

  var refresh = {
    level: o$1,
    change: o$2,
    Page: Page,
    Cache: Cache,
    CanvasPage: CanvasPage,
    CanvasCache: CanvasCache,
    webgl: webgl,
    ImgWebglCache: ImgWebglCache
  };

  var version = "0.86.22";

  var isString = util.isString;
  Geom.register('$line', Line);
  Geom.register('$polyline', Polyline);
  Geom.register('$polygon', Polygon);
  Geom.register('$sector', Sector);
  Geom.register('$rect', Rect);
  Geom.register('$circle', Circle);
  Geom.register('$ellipse', Ellipse);
  var karas$1 = {
    version: version,
    wasm: wasm$1,
    render: function render(root, dom) {
      if (!(root instanceof Root)) {
        throw new Error('Render dom must be canvas/svg/webgl');
      }

      if (dom) {
        root.appendTo(dom);
      }

      return root;
    },
    createElement: function createElement(tagName, props) {
      props = props || {};
      var children = [];

      for (var i = 2, len = arguments.length; i < len; i++) {
        children.push(arguments[i]);
      }

      if (isString(tagName)) {
        if (tagName.charAt(0) === '$') {
          return this.createGm(tagName, props);
        } else if (/^[A-Z]/.test(tagName)) {
          return this.createCp(tagName, props, children);
        } else {
          return this.createVd(tagName, props, children);
        }
      } else if (tagName) {
        // 特殊的$匿名类
        if (tagName instanceof Geom || tagName.prototype && tagName.prototype instanceof Geom) {
          return this.createGm(tagName, props);
        }

        return this.createCp(tagName, props, children);
      }
    },
    createVd: function createVd(tagName, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      if (['canvas', 'svg', 'webgl'].indexOf(tagName) > -1) {
        return new Root(tagName, props, children);
      }

      if (tag.TAG_NAME.hasOwnProperty(tagName)) {
        if (tagName === 'img') {
          return new Img(tagName, props);
        } else {
          return new Dom(tagName, props, children);
        }
      }

      throw new Error("Can not use <".concat(tagName, ">"));
    },
    createGm: function createGm(tagName, props) {
      var klass = Geom.getRegister(tagName);

      if (!isString(tagName)) {
        var s = /^function ([\w$]+)/.exec(tagName.toString());

        if (s && s.length > 1) {
          tagName = s[1];
        }
      }

      return new klass(tagName, props);
    },
    createCp: function createCp(tagName, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var klass = Component.getRegister(tagName);

      if (isString(tagName)) {
        props.tagName = tagName; // 特例，tagName如果是string需要记录下来
      }

      props.children = children; // 特例，children通过props传入

      return new klass(props);
    },
    parse: function parse(json, dom, options) {
      return o.parse(this, json, dom, options);
    },
    loadAndParse: function loadAndParse(json, dom, options) {
      return o.loadAndParse(this, json, dom, options);
    },
    mode: mode,
    Component: Component,
    Node: Node$1,
    Text: Text,
    Geom: Geom,
    Xom: Xom,
    Dom: Dom,
    Img: Img,
    Root: Root,
    Event: Event,
    util: util,
    inject: inject,
    style: style,
    parser: o,
    animate: animate,
    math: math,
    refresh: refresh,
    enums: enums,
    ca: ca,
    config: config
  };

  if (typeof window !== 'undefined') {
    window.karas = karas$1;
  } else if (typeof self !== 'undefined') {
    self.karas = karas$1;
  }

  return karas$1;

}));
//# sourceMappingURL=index.js.map
